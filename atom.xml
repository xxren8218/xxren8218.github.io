<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-06-15T10:36:18.918Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分查找算法详解</title>
    <link href="https://xxren8218.github.io/20210615/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://xxren8218.github.io/20210615/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html</id>
    <published>2021-06-15T10:34:40.000Z</published>
    <updated>2021-06-15T10:36:18.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二分查找算法详解"><a href="#二分查找算法详解" class="headerlink" title="二分查找算法详解"></a>二分查找算法详解</h3><p>先给大家讲个笑话乐呵一下：</p><p>有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。</p><p>从此，图书馆丢了 N - 1 本书。</p><p><strong>Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky..</strong></p><p>.这句话可以这样理解：<strong>思路很简单，细节是魔鬼。</strong></p><p>本文就来探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。</p><p>而且，我们就是要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。</p><h4 id="零、二分查找框架"><a href="#零、二分查找框架" class="headerlink" title="零、二分查找框架"></a>零、二分查找框架</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    left, right = <span class="number">0</span>, ...</span><br><span class="line">    <span class="keyword">while</span> ...:</span><br><span class="line">        mid = (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            ...</span><br><span class="line"><span class="keyword">elif</span> nums[mid] &lt; right:</span><br><span class="line">            left = ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; right:</span><br><span class="line">            right = ...</span><br><span class="line">     <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure><p><strong>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节</strong>。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。</p><p>其中…标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p><p>另外声明一下，计算 mid 时需要技巧防止溢出，本文暂时忽略这个问题。</p><h4 id="一、寻找一个数（基本的二分搜索）"><a href="#一、寻找一个数（基本的二分搜索）" class="headerlink" title="一、寻找一个数（基本的二分搜索）"></a>一、寻找一个数（基本的二分搜索）</h4><p>这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums) - <span class="number">1</span> <span class="comment"># 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right: <span class="comment"># 注意</span></span><br><span class="line">        mid = (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; right:</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; right:</span><br><span class="line">            right = mid - <span class="number">1</span> <span class="comment"># 注意</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>       </span><br></pre></td></tr></table></figure><p><em>$\color{red}{1.}$</em> 为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？</p><p>答：因为初始化 right 的赋值是 len(nums) - 1，即最后一个元素的索引，而不是 len(nums)。</p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 len(nums) 是越界的。</p><p>我们这个算法中使用的是 [left, right] 两端都闭的区间。<strong>这个区间就是每次进行搜索的区间，我们不妨称为「搜索区间」</strong></p><p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:</span><br><span class="line"><span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure><p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？<strong>搜索区间为空的时候应该终止</strong>，意味着你没得找了，就等于没找到嘛。</p><p><em>$\color{red}{while (left &lt;= right)}$</em> 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见<strong>这时候搜索区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p><p><em>$\color{red}{while (left &lt; right)}$</em> 的终止条件是 left == right，写成区间的形式就是 [right, right]，或者带个具体的数字进去 [2, 2]，<strong>这时候搜索区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就可能出现错误。</p><p>当然，如果你非要用 while(left &lt; right) 也可以，我们已经知道了出错的原因，就打个补丁好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">return</span> left <span class="keyword">if</span> nums[mid] == target <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><em>$\color{red}{2.}$</em>为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？</p><p>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</p><p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，如何确定下一步的搜索区间呢？</p><p>当然是去搜索 [left, mid - 1] 或者 [mid + 1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。</p><p><em>$\color{red}{3.}$</em> 此算法有什么缺陷？</p><p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p><p>比如说给你有序数组 nums = [1,2,2,2,3]，target = 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p><p>这样的需求很常见。你也许会说，找到一个 target 索引，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</p><p>我们后续的算法就来讨论这两种二分查找的算法。</p><h4 id="二、寻找左侧边界的二分搜索"><a href="#二、寻找左侧边界的二分搜索" class="headerlink" title="二、寻找左侧边界的二分搜索"></a>二、寻找左侧边界的二分搜索</h4><p>直接看代码，其中的标记是需要注意的细节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_bound</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span>, n <span class="comment"># 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt; right: <span class="comment"># 注意</span></span><br><span class="line">        mid = (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid <span class="comment"># 注意</span></span><br><span class="line">     </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    # target比所有数都大</span></span><br><span class="line"><span class="string">if left == len(nums) return -1</span></span><br><span class="line"><span class="string"># 类似之前算法的处理方式</span></span><br><span class="line"><span class="string">return left if nums[left] == target else -1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><em>$\color{red}{1.}$</em> 为什么 while 循环的条件中是 &lt;，而不是 &lt;= ？</p><p>答：用相同的方法分析，因为初始化 right = len(nums) 而不是 len(nums) - 1 。因此每次循环的「搜索区间」是 [left, right) 左闭右开。</p><p>while(left &lt; right) 终止的条件是 left == right，此时搜索区间 [left, left) 恰巧为空，所以可以正确终止。</p><p><em>$\color{red}{2.}$</em>为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？</p><p>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183536.PNG" alt=""></p><p>对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 2 的元素有 1 个。</p><p>比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1 的元素有 0 个。如果 target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个。</p><p>综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, len(nums)]，所以我们简单添加两行代码就能在正确的时候 return -1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="comment"># target比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> left == <span class="built_in">len</span>(nums) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="comment"># 类似之前算法的处理方式</span></span><br><span class="line"><span class="keyword">return</span> left <span class="keyword">if</span> nums[left] == target <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><em>$\color{red}{3.}$</em>为什么 left = mid + 1，right = mid ？和之前的算法不一样？</p><p>答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。</p><p><em>$\color{red}{4.}$</em>为什么该算法能够搜索左侧边界？</p><p>答：关键在于对于 nums[mid] == target 这种情况的处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">    right = mid</span><br></pre></td></tr></table></figure><p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p><p><em>$\color{red}{5.}$</em> 为什么返回 left 而不是 right？</p><p>答：都是一样的，因为 while 终止的条件是 left == right。</p><h4 id="三、寻找右侧边界的二分查找"><a href="#三、寻找右侧边界的二分查找" class="headerlink" title="三、寻找右侧边界的二分查找"></a>三、寻找右侧边界的二分查找</h4><p>寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_bound</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span>, n </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt; right: </span><br><span class="line">        mid = (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line">            </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    if left == 0: return -1</span></span><br><span class="line"><span class="string">return left - 1 if nums[left - 1] == target else -1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> left - <span class="number">1</span> <span class="comment"># 注意</span></span><br></pre></td></tr></table></figure><p><em>$\color{red}{1.}$</em> 为什么这个算法能够找到右侧边界？</p><p>答：类似地，关键点还是这里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">    left = mid + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>当 nums[mid] == target 时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。</p><p><em>$\color{red}{2.}$</em>  为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。</p><p>答：首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。</p><p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">    left = mid + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 这样想：mid = left -1</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183556.PNG" alt=""></p><p>因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left - 1] 可能是 target。</p><p>至于为什么 left 的更新必须是 left = mid + 1，同左侧边界搜索，就不再赘述。</p><p><em>$\color{red}{3.}$</em>  为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？</p><p>答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 [0, len(nums)]，所以可以添加两行代码，正确地返回 -1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">if</span> left == <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> left - <span class="number">1</span> <span class="keyword">if</span> nums[left - <span class="number">1</span>] == target <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h4><p>先来梳理一下这些细节差异的因果逻辑:</p><p>第一个，最基本的二分查找算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right]</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br></pre></td></tr></table></figure><p>第二个，寻找左侧边界的二分查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = <span class="built_in">len</span>(nums)</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure><p>第三个，寻找右侧边界的二分查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = <span class="built_in">len</span>(nums)</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 left = mid + <span class="number">1</span></span><br><span class="line">所以最后无论返回 left 还是 right，必须减一</span><br></pre></td></tr></table></figure><p>如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。</p><p>通过本文，你学会了：</p><p><em>$\color{blue}{1.}$</em>分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。</p><p><em>$\color{blue}{2.}$</em>注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。</p><p><em>$\color{blue}{3.}$</em>如需要搜索左右边界，只要在 nums[mid] == target 时做修改即可。搜索右侧时需要减一。</p><p>就算遇到其他的二分查找变形，运用这几点技巧，也能保证你写出正确的代码。LeetCode Explore 中有二分查找的专项练习，其中提供了三种不同的代码模板，现在你再去看看，很容易就知道这几个模板的实现原理了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二分查找算法详解&quot;&gt;&lt;a href=&quot;#二分查找算法详解&quot; class=&quot;headerlink&quot; title=&quot;二分查找算法详解&quot;&gt;&lt;/a&gt;二分查找算法详解&lt;/h3&gt;&lt;p&gt;先给大家讲个笑话乐呵一下：&lt;/p&gt;
&lt;p&gt;有一天阿东到图书馆借了 N 本书，出图书馆的时候，</summary>
      
    
    
    
    <category term="二分查找" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>02-动态规划设计之最长递增子序列</title>
    <link href="https://xxren8218.github.io/20210615/02-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210615/02-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2021-06-15T10:28:49.000Z</published>
    <updated>2021-06-15T10:36:34.228Z</updated>
    
    <content type="html"><![CDATA[<p>很多人了解了动态规划，但还是不会写状态转移方程，没有思路，怎么办？本文就借助「最长递增子序列」来讲一种设计动态规划的通用技巧：<strong>数学归纳思想。</strong></p><p>最长递增子序列（Longest Increasing Subsequence，简写 LIS）是比较经典的一个问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何写动态规划。</p><p>比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。</p><p>先看一下题目，很容易理解：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183006.jpg" alt=""></p><p>注意<strong>「子序列」</strong>和<strong>「子串」</strong>这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来一步一步设计动态规划算法解决这个问题。</p><h3 id="一、动态规划解法"><a href="#一、动态规划解法" class="headerlink" title="一、动态规划解法"></a>一、动态规划解法</h3><p><strong>动态规划的核心设计思想是数学归纳法。</strong></p><p>相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么我们先假设这个结论在 k &lt; n 时成立，然后想办法证明 k=<em>n</em> 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。</p><p>类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 <strong>dp[0…i−1]</strong> 都已经被算出来了，然后问自己：怎么通过这些结果算出<em>dp[i] ?</em></p><p>直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 dp[i] 的值到底代表着什么？</p><p><strong>我们的定义是这样的：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。</strong></p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183020.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183039.PNG" alt=""></p><p>算法演进的过程是这样的:</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183224.gif" alt=""></p><p>根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p>读者也许会问，刚才这个过程中每个 dp[i] 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 dp[i] 呢？</p><p><strong>这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想</strong></p><p>我们已经知道了 dp[0…4] 的所有结果，我们如何通过这些已知结果推出 dp[5]呢？</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183054.PNG" alt=""></p><p>根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。</p><p>nums[5] = 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</p><p>当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183309.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">    <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i],  dp[j]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这段代码的逻辑就可以算出 dp[5]。到这里，这道算法题我们就基本做完了。读者也许会问，我们刚才只是算了 dp[5] 呀，dp[4], dp[3] 这些怎么算呢？</p><p>类似数学归纳法，你已经可以通过 dp[0…4] 算出 dp[5] 了，那么任意 dp[i] 你肯定都可以算出来:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">    <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>还有一个细节问题，就是 base case。dp 数组应该全部初始化为 1，因为子序列最少也要包含自己，所以长度最小为 1。下面我们看一下完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp = [<span class="number">1</span>]*n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">         <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">                    </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><p>至此，这道题就解决了，时间复杂度 O(N^2)。总结一下动态规划的设计流程：</p><p>首先明确 dp 数组所存数据的含义。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。</p><p>然后根据 dp 数组的定义，运用数学归纳法的思想，假设 dp[0…<em>i</em>−1] 都已知，想办法求出 dp[i]，一旦这一步完成，整个题目基本就解决了。</p><p>但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。</p><h3 id="二、二分查找解法"><a href="#二、二分查找解法" class="headerlink" title="二、二分查找解法"></a>二、二分查找解法</h3><p>这个解法的时间复杂度会将为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以如果大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。</p><p>根据题目的意思，我都很难想象这个问题竟然能和二分查找扯上关系。其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。</p><p>为了简单起见，后文跳过所有数学证明，通过一个简化的例子来理解一下思路。</p><p>首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183118.jpg" alt=""></p><p>处理这些扑克牌要遵循以下规则：</p><p>只能把点数小的牌压到点数比它大的牌上。如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去。如果当前牌有多个堆可供选择，则选择最左边的堆放置。</p><p>比如说上述的扑克牌最终会被分成这样 5 堆（我们认为 A 的值是最大的，而不是 1）。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183133.jpg" alt=""></p><p>为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q），证明略。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183151.jpg" alt=""></p><p>按照上述规则执行，可以<strong>算出最长递增子序列，牌的堆数就是我们想求的最长递增子序列的长度</strong>，证明略。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210615183204.jpg" alt=""></p><p>我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是有序吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    top = [<span class="number">0</span>]*n</span><br><span class="line">    <span class="comment"># 初始化牌堆数为 0</span></span><br><span class="line">    piles = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 要处理的扑克牌</span></span><br><span class="line">        poker = nums[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 搜索左侧边界的二分查找</span></span><br><span class="line">        left, right = <span class="number">0</span>, piles</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> top[mid] &gt; poker:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">elif</span> top[mid] &lt; poker:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">                </span><br><span class="line"><span class="comment"># 没找到合适的牌堆，新建一个堆</span></span><br><span class="line">        <span class="keyword">if</span> left == piles:</span><br><span class="line">            piles += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 把这张牌放到牌堆顶</span></span><br><span class="line">        top[left] = poker</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 牌堆数就是LIS的长度    </span></span><br><span class="line"><span class="keyword">return</span> piles            </span><br></pre></td></tr></table></figure><p>至此，二分查找的解法也讲解完毕。</p><p>这个解法确实很难想到。首先涉及数学证明，谁能想到按照这些规则执行，就能得到最长递增子序列呢？其次还有二分查找的运用，要是对二分查找的细节不清楚，给了思路也很难写对。</p><p>所以，这个方法作为思维拓展好了。但动态规划的设计方法应该完全理解：<strong>假设之前的答案已知，利用数学归纳的思想正确进行状态的推演转移，最终得到答案。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很多人了解了动态规划，但还是不会写状态转移方程，没有思路，怎么办？本文就借助「最长递增子序列」来讲一种设计动态规划的通用技巧：&lt;strong&gt;数学归纳思想。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最长递增子序列（Longest Increasing Subsequence，简写 </summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>01-初识动态规划</title>
    <link href="https://xxren8218.github.io/20210611/01-%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html"/>
    <id>https://xxren8218.github.io/20210611/01-%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html</id>
    <published>2021-06-11T10:41:34.000Z</published>
    <updated>2021-06-11T10:46:07.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-初识动态规划"><a href="#01-初识动态规划" class="headerlink" title="01-初识动态规划"></a>01-初识动态规划</h2><p><strong>动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离呀等等。</p><p>既然是要求最值，核心问题是什么呢？<strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。动态规划就这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！</p><p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p><p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p><p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p><p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p><p><strong>明确「状态」 -&gt; 定义 dp 数组/函数的含义 -&gt; 明确「选择」-&gt; 明确 base case。</strong></p><p>下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列严格来说不是动态规划问题），后者主要集中于如何列出状态转移方程。</p><h3 id="一、-斐波那契数列"><a href="#一、-斐波那契数列" class="headerlink" title="一、 斐波那契数列"></a>一、 斐波那契数列</h3><h4 id="1-暴力递归"><a href="#1-暴力递归" class="headerlink" title="1.暴力递归"></a>1.暴力递归</h4><p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> <span class="keyword">and</span> N == <span class="number">2</span>): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。</p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611184311.PNG" alt=""></p><p>这个递归树怎么理解？就是说想要计算原问题<code>f(20)</code>，我就得先计算出子问题<code>f(19)</code>和<code>f(18)</code>，然后要计算<code>f(19)</code>，我就要先算出子问题<code>f(18)</code>和<code>f(17)</code>，以此类推。最后遇到<code>f(1)</code>或者<code>f(2)</code>的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p><strong>递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如<code>f(18)</code>被计算了两次，而且你可以看到，以<code>f(18)</code>为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止<code>f(18)</code>这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><h4 id="2-带备忘录的递归解法"><a href="#2-带备忘录的递归解法" class="headerlink" title="2.带备忘录的递归解法"></a>2.带备忘录的递归解法</h4><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个<strong>数组</strong>充当这个<strong>「备忘录」</strong>，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="keyword">if</span> N &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 备忘录全初始化为 0</span></span><br><span class="line">    memo = [<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 初始化最简情况</span></span><br><span class="line">    <span class="keyword">return</span> helper(memo, N)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">memo, n</span>):</span></span><br><span class="line">    <span class="comment"># base case </span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 已经计算过</span></span><br><span class="line">    <span class="keyword">if</span> memo[n] != <span class="number">0</span>: <span class="keyword">return</span> memo[n]</span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure><p>现在，画出递归树，你就知道「备忘录」到底做了什么：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611184323.PNG" alt=""></p><p>实际上，带<strong>「备忘录」</strong>的递归算法，把一棵存在巨量冗余的递归树通过<strong>「剪枝」</strong>，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611184329.PNG" alt=""></p><p><strong>递归算法的时间复杂度怎么算？</strong>子问题个数乘以解决一个子问题需要的时间。</p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是<code>f(1)</code>,<code>f(2)</code>,<code>f(3)</code>…<code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和迭代的动态规划一样了。实际上，这种解法和迭代的动态规划思想已经差不多，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p><strong>啥叫「自顶向下」？</strong>注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说<code>f(20)</code>，向下逐渐分解规模，直到<code>f(1)</code>和<code>f(2)</code>触底，然后逐层返回答案，这就叫「自顶向下」。</p><p><strong>啥叫「自底向上」？</strong>反过来，我们直接从最底下，最简单，问题规模最小的<code>f(1)</code>和<code>f(2)</code>开始往上推，直到推到我们想要的答案<code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><h4 id="3-dp数组的迭代解法"><a href="#3-dp数组的迭代解法" class="headerlink" title="3.dp数组的迭代解法"></a>3.dp数组的迭代解法</h4><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">N</span>):</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(N + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">3</span>, N + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611184334.PNG" alt=""></p><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出<strong>「状态转移方程」</strong>这个名词，实际上就是描述问题结构的数学形式：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611184341.png" alt=""></p><p>为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程</strong>，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="keyword">if</span> N == <span class="number">1</span> <span class="keyword">or</span> N == <span class="number">2</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    prev, cur, add = <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, N + <span class="number">1</span>):</span><br><span class="line">        add = prev + cur</span><br><span class="line">        prev = cur</span><br><span class="line">        cur = add</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><p>有人会问，动态规划的另一个重要特性<strong>「最优子结构」</strong>，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在演示算法设计螺旋上升的过程。</p><p>下面，看第二个例子，<strong>凑零钱问题</strong>。</p><h3 id="二、凑零钱问题"><a href="#二、凑零钱问题" class="headerlink" title="二、凑零钱问题"></a>二、凑零钱问题</h3><p>先看下题目：给你<code>k</code>种面值的硬币，面值分别为<code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额<code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coins 中是可选硬币面值，amount 是目标金额</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins, amount</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>比如说<code>k = 3</code>，面值分别为 1，2，5，总金额<code>amount = 11</code>。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p><p>你认为计算机应该如何解决这个问题？显然，就是把所有肯能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p><h4 id="1-暴力递归-1"><a href="#1-暴力递归-1" class="headerlink" title="1.暴力递归"></a>1.暴力递归</h4><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。</p><p>比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求<code>amount = 11</code>时的最少硬币数（原问题），如果你知道凑出<code>amount = 10</code>的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案，因为硬币的数量是没有限制的，子问题之间没有相互制，是互相独立的。</p><p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>。</p><p><strong>先确定「状态」</strong>，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额<code>amount</code>。</p><p><strong>然后确定<code>dp</code>函数的定义</strong>：函数 dp(n)表示，当前的目标金额是<code>n</code>，至少需要<code>dp(n)</code>个硬币凑出该金额。</p><p><strong>然后确定「选择」并择优</strong>，也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当的目标金额是多少，选择就是从面额列表<code>coins</code>中选择一个硬币，然后目标金额就会减少：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">coins, amount</span>):</span></span><br><span class="line">    <span class="comment"># 定义：要凑出金额 n，至少要 dp(n) 个硬币</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="comment"># 做选择，需要硬币最少的那个结果就是答案</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + dp(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment"># 我们要求目标金额是 amount</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p><strong>最后明确 base case</strong>，显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">coins, amount</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> subproblem == -<span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611184346.png" alt=""></p><p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如<code>amount = 11, coins = &#123;1,2,5&#125;</code>时画出递归树看看：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611184350.PNG" alt=""></p><p><strong>时间复杂度分析：子问题总数 x 解决每个子问题的时间</strong>。</p><p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p><h4 id="2-带备忘录的递归"><a href="#2-带备忘录的递归" class="headerlink" title="2.带备忘录的递归"></a>2.带备忘录的递归</h4><p>只需要稍加修改，就可以通过备忘录消除子问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">coins, amount</span>):</span></span><br><span class="line">    <span class="comment"># 备忘录</span></span><br><span class="line">    memo = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="comment"># 查备忘录，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == -<span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记入备忘录</span></span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><h4 id="3-dp数组的迭代解法-1"><a href="#3-dp数组的迭代解法-1" class="headerlink" title="3.dp数组的迭代解法"></a>3.dp数组的迭代解法</h4><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，<code>dp</code>数组的定义和刚才<code>dp</code>函数类似，定义也是一样的：</p><p><strong><code>dp[i] = x</code>表示，当目标金额为<code>i</code>时，至少需要<code>x</code>枚硬币</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">coins, amount</span>):</span></span><br><span class="line">    <span class="comment"># 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    dp = [amount + <span class="number">1</span>]*(amount + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp)):</span><br><span class="line">        <span class="comment"># 内层 for 在求所有子问题 + 1 的最小值</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>): <span class="keyword">continue</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin])</span><br><span class="line">    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != amount + <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611184355.PNG" alt=""></p><p>PS：为啥<code>dp</code>数组初始化为<code>amount + 1</code>呢，因为凑成<code>amount</code>金额的硬币数最多只可能等于<code>amount</code>（全用 1 元面值的硬币），所以初始化为<code>amount + 1</code>就相当于初始化为正无穷，便于后续取最小值。</p><h3 id="三、最后总结"><a href="#三、最后总结" class="headerlink" title="三、最后总结"></a>三、最后总结</h3><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p><p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;01-初识动态规划&quot;&gt;&lt;a href=&quot;#01-初识动态规划&quot; class=&quot;headerlink&quot; title=&quot;01-初识动态规划&quot;&gt;&lt;/a&gt;01-初识动态规划&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;动态规划问题的一般形式就是求最值&lt;/strong&gt;。动态规划其实是运</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer（十六）：合并两个排序的链表</title>
    <link href="https://xxren8218.github.io/20210611/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.html"/>
    <id>https://xxren8218.github.io/20210611/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.html</id>
    <published>2021-06-11T10:37:37.000Z</published>
    <updated>2021-06-11T10:39:59.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2 id="2-思路一"><a href="#2-思路一" class="headerlink" title="2.思路一"></a>2.思路一</h2><p>先判断输入的链表是否为空的指针。如果第一个链表为空，则直接返回第二个链表；如果第二个链表为空，则直接返回第一个链表。如果两个链表都是空链表，合并的结果是得到一个空链表。</p><p>两个链表都是排序好的，我们只需要从头遍历链表，判断当前指针，哪个链表中的值小，即赋给合并链表指针即可。使用递归就可以轻松实现。</p><h2 id="3-代码一"><a href="#3-代码一" class="headerlink" title="3.代码一"></a>3.代码一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span>(<span class="params">self, pHead1, pHead2</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1:</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        pMergehead = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">            pMergehead = pHead1</span><br><span class="line">            pMergehead.<span class="built_in">next</span> = self.Merge(pHead1.<span class="built_in">next</span>, pHead2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pMergehead = pHead2</span><br><span class="line">            pMergehead.<span class="built_in">next</span> = self.Merge(pHead1, pHead2.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> pMergehead</span><br></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611183911.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611183929.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611183943.PNG" alt=""></p><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = dum = l</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 其中一个为空时，将另外一个接入即可</span></span><br><span class="line">        cur.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2  </span><br><span class="line">        <span class="keyword">return</span> dum.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。&lt;/p&gt;
&lt;h2 id=&quot;2-思</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="递归" scheme="https://xxren8218.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="链表" scheme="https://xxren8218.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="多脂针" scheme="https://xxren8218.github.io/tags/%E5%A4%9A%E8%84%82%E9%92%88/"/>
    
    <category term="伪头节点" scheme="https://xxren8218.github.io/tags/%E4%BC%AA%E5%A4%B4%E8%8A%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十五）：反转链表</title>
    <link href="https://xxren8218.github.io/20210611/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html"/>
    <id>https://xxren8218.github.io/20210611/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html</id>
    <published>2021-06-11T10:35:07.000Z</published>
    <updated>2021-06-11T10:48:50.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个链表，反转链表后，输出链表的所有元素。</p><h2 id="2-思路一"><a href="#2-思路一" class="headerlink" title="2.思路一"></a>2.思路一</h2><p>采用递归的思想：last = reverseList(head.next)，即：将1-&gt;2-&gt;3-&gt;4-&gt;5，变为(last)5-&gt;4-&gt;3-&gt;2&lt;-1(head),然后进行转换即可</p><h2 id="3-代码一"><a href="#3-代码一" class="headerlink" title="3.代码一"></a>3.代码一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:<span class="keyword">return</span> head</span><br><span class="line">        last = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>我们使用三个指针，分别指向当前遍历到的结点、它的前一个结点以及后一个结点。在遍历的时候，做当前结点的尾结点和前一个结点的替换。</p><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        last = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            tmp = pHead.<span class="built_in">next</span></span><br><span class="line">            pHead.<span class="built_in">next</span> = last</span><br><span class="line">            last = pHead</span><br><span class="line">            pHead = tmp</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个链表，反转链表后，输出链表的所有元素。&lt;/p&gt;
&lt;h2 id=&quot;2-思路一&quot;&gt;&lt;a href=&quot;#2-思路一&quot; cl</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="多指针" scheme="https://xxren8218.github.io/tags/%E5%A4%9A%E6%8C%87%E9%92%88/"/>
    
    <category term="递归" scheme="https://xxren8218.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="链表" scheme="https://xxren8218.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十四）：链表中倒数第k个结点</title>
    <link href="https://xxren8218.github.io/20210611/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.html"/>
    <id>https://xxren8218.github.io/20210611/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.html</id>
    <published>2021-06-11T10:00:55.000Z</published>
    <updated>2021-06-11T10:47:48.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="2-思路一"><a href="#2-思路一" class="headerlink" title="2.思路一"></a>2.思路一</h2><p>建立一个辅助的列表，将链表的值进行存储，然后取出倒数第k个值。</p><h2 id="3-代码一"><a href="#3-代码一" class="headerlink" title="3.代码一"></a>3.代码一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param pHead ListNode类 </span></span><br><span class="line"><span class="comment"># @param k int整型 </span></span><br><span class="line"><span class="comment"># @return ListNode类</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span>(<span class="params">self , pHead , k </span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l=[]</span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            l.append(pHead)</span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(l) &lt; k <span class="keyword">or</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> l[-k]</span><br></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>我们可以定义两个指针。第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针（走在后面的）指针正好是倒数第k个结点。</p><p>效果示意图，以链表总共6个结点，求倒数第3个结点为例：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210611180232.PNG" alt=""></p><p>除此之外，要注意代码的鲁棒性。需要判断传入参数合法性问题。</p><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        phead = head</span><br><span class="line">        pbehind = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> phead.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                phead = phead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> phead.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            phead = phead.<span class="built_in">next</span></span><br><span class="line">            pbehind = pbehind.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pbehind</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个链表，输出该链表中倒数第k个结点。&lt;/p&gt;
&lt;h2 id=&quot;2-思路一&quot;&gt;&lt;a href=&quot;#2-思路一&quot; clas</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="多指针" scheme="https://xxren8218.github.io/tags/%E5%A4%9A%E6%8C%87%E9%92%88/"/>
    
    <category term="链表" scheme="https://xxren8218.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="辅助列表" scheme="https://xxren8218.github.io/tags/%E8%BE%85%E5%8A%A9%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三）：从尾到头打印链表</title>
    <link href="https://xxren8218.github.io/20210611/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.html"/>
    <id>https://xxren8218.github.io/20210611/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.html</id>
    <published>2021-06-11T09:58:16.000Z</published>
    <updated>2021-06-11T09:59:43.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>通常，这种情况下，我们不希望修改原链表的结构。返回一个反序的链表，这就是经典的“后进先出”，我们可以使用栈实现这种顺序。每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，给一个新的链表结构，这样链表就实现了反转。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>采用辅助栈的策略，重新创建一个列表，每次来向首位插入元素即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding:utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            stack.insert(<span class="number">0</span>,listNode.val)</span><br><span class="line">            listNode = listNode.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;通常，这种情况下，我们不希望修改原链表的结构。返回一个反序的链表，这就是经典的“后进先出”，我们可以使用栈实现这种顺序。每经</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="辅助栈" scheme="https://xxren8218.github.io/tags/%E8%BE%85%E5%8A%A9%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>08-算法实现：Item-Based CF 预测评分</title>
    <link href="https://xxren8218.github.io/20210610/08-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9AItem-Based-CF-%E9%A2%84%E6%B5%8B%E8%AF%84%E5%88%86.html"/>
    <id>https://xxren8218.github.io/20210610/08-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9AItem-Based-CF-%E9%A2%84%E6%B5%8B%E8%AF%84%E5%88%86.html</id>
    <published>2021-06-10T09:40:42.000Z</published>
    <updated>2021-06-10T09:41:33.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="案例—算法实现：Item-Based-CF-预测评分"><a href="#案例—算法实现：Item-Based-CF-预测评分" class="headerlink" title="案例—算法实现：Item-Based CF 预测评分"></a>案例—算法实现：Item-Based CF 预测评分</h2><p><strong>评分预测公式：</strong></p><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{j\in I_{rated}}sim(i,j)*r_{uj}}{\sum_{j\in I_{rated}}sim(i,j)}</script><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><ul><li><p>实现评分预测方法：<code>predict</code></p><ul><li><p>方法说明：</p><p>利用原始评分矩阵、以及物品间两两相似度，预测指定用户对指定物品的评分。</p><p>如果无法预测，则抛出异常</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">uid, iid, ratings_matrix, item_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测给定用户对给定物品的评分值</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param iid: 物品ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :param item_similar: 物品两两相似度矩阵</span></span><br><span class="line"><span class="string">    :return: 预测的评分值</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&quot;开始预测用户&lt;%d&gt;对电影&lt;%d&gt;的评分...&quot;</span>%(uid, iid))</span><br><span class="line">    <span class="comment"># 1. 找出iid物品的相似物品</span></span><br><span class="line">    similar_items = item_similar[iid].drop([iid]).dropna()</span><br><span class="line">    <span class="comment"># 相似物品筛选规则：正相关的物品</span></span><br><span class="line">    similar_items = similar_items.where(similar_items&gt;<span class="number">0</span>).dropna()</span><br><span class="line">    <span class="keyword">if</span> similar_items.empty <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;物品&lt;%d&gt;没有相似的物品&quot;</span> %<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 从iid物品的近邻相似物品中筛选出uid用户评分过的物品</span></span><br><span class="line">    ids = <span class="built_in">set</span>(ratings_matrix.ix[uid].dropna().index)&amp;<span class="built_in">set</span>(similar_items.index)</span><br><span class="line">    finally_similar_items = similar_items.ix[<span class="built_in">list</span>(ids)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 结合iid物品与其相似物品的相似度和uid用户对其相似物品的评分，预测uid对iid的评分</span></span><br><span class="line">    sum_up = <span class="number">0</span>    <span class="comment"># 评分预测公式的分子部分的值</span></span><br><span class="line">    sum_down = <span class="number">0</span>    <span class="comment"># 评分预测公式的分母部分的值</span></span><br><span class="line">    <span class="keyword">for</span> sim_iid, similarity <span class="keyword">in</span> finally_similar_items.iteritems():</span><br><span class="line">        <span class="comment"># 近邻物品的评分数据</span></span><br><span class="line">        sim_item_rated_movies = ratings_matrix[sim_iid].dropna()</span><br><span class="line">        <span class="comment"># uid用户对相似物品物品的评分</span></span><br><span class="line">        sim_item_rating_from_user = sim_item_rated_movies[uid]</span><br><span class="line">        <span class="comment"># 计算分子的值</span></span><br><span class="line">        sum_up += similarity * sim_item_rating_from_user</span><br><span class="line">        <span class="comment"># 计算分母的值</span></span><br><span class="line">        sum_down += similarity</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算预测的评分值并返回</span></span><br><span class="line">    predict_rating = sum_up/sum_down</span><br><span class="line">    print(<span class="string">&quot;预测出用户&lt;%d&gt;对电影&lt;%d&gt;的评分：%0.2f&quot;</span> % (uid, iid, predict_rating))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">round</span>(predict_rating, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;item&quot;</span>)</span><br><span class="line">    <span class="comment"># 预测用户1对物品1的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">1</span>, ratings_matrix, item_similar)</span><br><span class="line">    <span class="comment"># 预测用户1对物品2的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">2</span>, ratings_matrix, item_similar)</span><br></pre></td></tr></table></figure></li><li><p>实现预测全部评分方法：<code>predict_all</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span>(<span class="params">uid, ratings_matrix, item_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param item_similar: 物品两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 准备要预测的物品的id列表</span></span><br><span class="line">    item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, item_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;item&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, item_similar):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>添加过滤规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_predict_all</span>(<span class="params">uid, item_ids,ratings_matrix, item_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param item_ids: 要预测物品id列表</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param item_similar: 物品两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, item_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span>(<span class="params">uid, ratings_matrix, item_similar, filter_rule=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分，并可根据条件进行前置过滤</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param item_similar: 物品两两间的相似度</span></span><br><span class="line"><span class="string">    :param filter_rule: 过滤规则，只能是四选一，否则将抛异常：&quot;unhot&quot;,&quot;rated&quot;,[&quot;unhot&quot;,&quot;rated&quot;],None</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> filter_rule:</span><br><span class="line">        item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">str</span>) <span class="keyword">and</span> filter_rule == <span class="string">&quot;unhot&quot;</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤非热门电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 统计每部电影的评分数</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        <span class="comment"># 过滤出评分数高于10的电影，作为热门电影</span></span><br><span class="line">        item_ids = count.where(count&gt;<span class="number">10</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">str</span>) <span class="keyword">and</span> filter_rule == <span class="string">&quot;rated&quot;</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤用户评分过的电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 获取用户对所有电影的评分记录</span></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        <span class="comment"># 评分范围是1-5，小于6的都是评分过的，除此以外的都是没有评分的</span></span><br><span class="line">        _ = user_ratings&lt;<span class="number">6</span></span><br><span class="line">        item_ids = _.where(_==<span class="literal">False</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">set</span>(filter_rule) == <span class="built_in">set</span>([<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>]):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤非热门和用户已经评分过的电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        ids1 = count.where(count &gt; <span class="number">10</span>).dropna().index</span><br><span class="line"></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        _ = user_ratings &lt; <span class="number">6</span></span><br><span class="line">        ids2 = _.where(_ == <span class="literal">False</span>).dropna().index</span><br><span class="line">        <span class="comment"># 取二者交集</span></span><br><span class="line">        item_ids = <span class="built_in">set</span>(ids1)&amp;<span class="built_in">set</span>(ids2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;无效的过滤参数&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> _predict_all(uid, item_ids, ratings_matrix, item_similar)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;item&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, item_similar, filter_rule=[<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>]):</span><br><span class="line">        print(result)</span><br></pre></td></tr></table></figure></li><li><p>为指定用户推荐TOP-N结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_k_rs_result</span>(<span class="params">k</span>):</span></span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;item&quot;</span>)</span><br><span class="line">    results = predict_all(<span class="number">1</span>, ratings_matrix, item_similar, filter_rule=[<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(results, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>], reverse=<span class="literal">True</span>)[:k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">    result = top_k_rs_result(<span class="number">20</span>)</span><br><span class="line">    pprint(result)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;案例—算法实现：Item-Based-CF-预测评分&quot;&gt;&lt;a href=&quot;#案例—算法实现：Item-Based-CF-预测评分&quot; class=&quot;headerlink&quot; title=&quot;案例—算法实现：Item-Based CF 预测评分&quot;&gt;&lt;/a&gt;案例—算法实现：</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>07-算法实现：User-Based CF 预测评分</title>
    <link href="https://xxren8218.github.io/20210610/07-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9AUser-Based-CF-%E9%A2%84%E6%B5%8B%E8%AF%84%E5%88%86.html"/>
    <id>https://xxren8218.github.io/20210610/07-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9AUser-Based-CF-%E9%A2%84%E6%B5%8B%E8%AF%84%E5%88%86.html</id>
    <published>2021-06-10T09:39:12.000Z</published>
    <updated>2021-06-10T09:40:19.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="案例—算法实现：User-Based-CF-预测评分"><a href="#案例—算法实现：User-Based-CF-预测评分" class="headerlink" title="案例—算法实现：User-Based CF 预测评分"></a>案例—算法实现：User-Based CF 预测评分</h2><p><strong>评分预测公式：</strong></p><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}</script><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><ul><li><p>实现评分预测方法：<code>predict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">uid, iid, ratings_matrix, user_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测给定用户对给定物品的评分值</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param iid: 物品ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两相似度矩阵</span></span><br><span class="line"><span class="string">    :return: 预测的评分值</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&quot;开始预测用户&lt;%d&gt;对电影&lt;%d&gt;的评分...&quot;</span>%(uid, iid))</span><br><span class="line">    <span class="comment"># 1. 找出uid用户的相似用户</span></span><br><span class="line">    similar_users = user_similar[uid].drop([uid]).dropna()</span><br><span class="line">    <span class="comment"># 相似用户筛选规则：正相关的用户</span></span><br><span class="line">    similar_users = similar_users.where(similar_users&gt;<span class="number">0</span>).dropna()</span><br><span class="line">    <span class="keyword">if</span> similar_users.empty <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;用户&lt;%d&gt;没有相似的用户&quot;</span> % uid)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 从uid用户的近邻相似用户中筛选出对iid物品有评分记录的近邻用户</span></span><br><span class="line">    ids = <span class="built_in">set</span>(ratings_matrix[iid].dropna().index)&amp;<span class="built_in">set</span>(similar_users.index)</span><br><span class="line">    finally_similar_users = similar_users.ix[<span class="built_in">list</span>(ids)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 结合uid用户与其近邻用户的相似度预测uid用户对iid物品的评分</span></span><br><span class="line">    sum_up = <span class="number">0</span>    <span class="comment"># 评分预测公式的分子部分的值</span></span><br><span class="line">    sum_down = <span class="number">0</span>    <span class="comment"># 评分预测公式的分母部分的值</span></span><br><span class="line">    <span class="keyword">for</span> sim_uid, similarity <span class="keyword">in</span> finally_similar_users.iteritems():</span><br><span class="line">        <span class="comment"># 近邻用户的评分数据</span></span><br><span class="line">        sim_user_rated_movies = ratings_matrix.ix[sim_uid].dropna()</span><br><span class="line">        <span class="comment"># 近邻用户对iid物品的评分</span></span><br><span class="line">        sim_user_rating_for_item = sim_user_rated_movies[iid]</span><br><span class="line">        <span class="comment"># 计算分子的值</span></span><br><span class="line">        sum_up += similarity * sim_user_rating_for_item</span><br><span class="line">        <span class="comment"># 计算分母的值</span></span><br><span class="line">        sum_down += similarity</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算预测的评分值并返回</span></span><br><span class="line">    predict_rating = sum_up/sum_down</span><br><span class="line">    print(<span class="string">&quot;预测出用户&lt;%d&gt;对电影&lt;%d&gt;的评分：%0.2f&quot;</span> % (uid, iid, predict_rating))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">round</span>(predict_rating, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    <span class="comment"># 预测用户1对物品1的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">1</span>, ratings_matrix, user_similar)</span><br><span class="line">    <span class="comment"># 预测用户1对物品2的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">2</span>, ratings_matrix, user_similar)</span><br></pre></td></tr></table></figure></li><li><p>实现预测全部评分方法：<code>predict_all</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span>(<span class="params">uid, ratings_matrix, user_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 准备要预测的物品的id列表</span></span><br><span class="line">    item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, user_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, user_similar):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>添加过滤规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_predict_all</span>(<span class="params">uid, item_ids, ratings_matrix, user_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param item_ids: 要预测的物品id列表</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, user_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span>(<span class="params">uid, ratings_matrix, user_similar, filter_rule=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分，并可根据条件进行前置过滤</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :param filter_rule: 过滤规则，只能是四选一，否则将抛异常：&quot;unhot&quot;,&quot;rated&quot;,[&quot;unhot&quot;,&quot;rated&quot;],None</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> filter_rule:</span><br><span class="line">        item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">str</span>) <span class="keyword">and</span> filter_rule == <span class="string">&quot;unhot&quot;</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤非热门电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 统计每部电影的评分数</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        <span class="comment"># 过滤出评分数高于10的电影，作为热门电影</span></span><br><span class="line">        item_ids = count.where(count&gt;<span class="number">10</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">str</span>) <span class="keyword">and</span> filter_rule == <span class="string">&quot;rated&quot;</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤用户评分过的电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 获取用户对所有电影的评分记录</span></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        <span class="comment"># 评分范围是1-5，小于6的都是评分过的，除此以外的都是没有评分的</span></span><br><span class="line">        _ = user_ratings&lt;<span class="number">6</span></span><br><span class="line">        item_ids = _.where(_==<span class="literal">False</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">set</span>(filter_rule) == <span class="built_in">set</span>([<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>]):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤非热门和用户已经评分过的电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        ids1 = count.where(count &gt; <span class="number">10</span>).dropna().index</span><br><span class="line"></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        _ = user_ratings &lt; <span class="number">6</span></span><br><span class="line">        ids2 = _.where(_ == <span class="literal">False</span>).dropna().index</span><br><span class="line">        <span class="comment"># 取二者交集</span></span><br><span class="line">        item_ids = <span class="built_in">set</span>(ids1)&amp;<span class="built_in">set</span>(ids2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;无效的过滤参数&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> _predict_all(uid, item_ids, ratings_matrix, user_similar)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, user_similar, filter_rule=[<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>]):</span><br><span class="line">        print(result)</span><br></pre></td></tr></table></figure></li><li><p>根据预测评分为指定用户进行TOP-N推荐：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_k_rs_result</span>(<span class="params">k</span>):</span></span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    results = predict_all(<span class="number">1</span>, ratings_matrix, user_similar, filter_rule=[<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(results, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>], reverse=<span class="literal">True</span>)[:k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">    result = top_k_rs_result(<span class="number">20</span>)</span><br><span class="line">    pprint(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;案例—算法实现：User-Based-CF-预测评分&quot;&gt;&lt;a href=&quot;#案例—算法实现：User-Based-CF-预测评分&quot; class=&quot;headerlink&quot; title=&quot;案例—算法实现：User-Based CF 预测评分&quot;&gt;&lt;/a&gt;案例—算法实现：</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>06-案例--基于协同过滤的电影推荐</title>
    <link href="https://xxren8218.github.io/20210610/06-%E6%A1%88%E4%BE%8B-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%9A%84%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90.html"/>
    <id>https://xxren8218.github.io/20210610/06-%E6%A1%88%E4%BE%8B-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%9A%84%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90.html</id>
    <published>2021-06-10T09:37:29.000Z</published>
    <updated>2021-06-10T09:38:38.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="案例—基于协同过滤的电影推荐"><a href="#案例—基于协同过滤的电影推荐" class="headerlink" title="案例—基于协同过滤的电影推荐"></a>案例—基于协同过滤的电影推荐</h2><p>前面我们已经基本掌握了协同过滤推荐算法，以及其中两种最基本的实现方案：User-Based CF和Item-Based CF，下面我们将利用真是的数据来进行实战演练。</p><p>案例需求 演示效果</p><p>分析案例</p><h4 id="数据集下载"><a href="#数据集下载" class="headerlink" title="数据集下载"></a>数据集下载</h4><p><a href="https://grouplens.org/datasets/movielens/latest/">MovieLens Latest Datasets Small</a></p><p>建议下载<a href="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip">ml-latest-small.zip</a>，数据量小，便于我们单机使用和运行</p><p>目标：根据<code>ml-latest-small/ratings.csv</code>（用户-电影评分数据），分别实现User-Based CF和Item-Based CF，并进行电影评分的预测，然后为用户实现电影推荐</p><h4 id="数据集加载"><a href="#数据集加载" class="headerlink" title="数据集加载"></a>数据集加载</h4><ul><li><p>加载ratings.csv，并转换为用户-电影评分矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">DATA_PATH = <span class="string">&quot;./datasets/ml-latest-small/ratings.csv&quot;</span></span><br><span class="line">CACHE_DIR = <span class="string">&quot;./datasets/cache/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>(<span class="params">data_path</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    加载数据</span></span><br><span class="line"><span class="string">    :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">    :param cache_path: 数据集缓存路径</span></span><br><span class="line"><span class="string">    :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 数据集缓存地址</span></span><br><span class="line">    cache_path = os.path.join(CACHE_DIR, <span class="string">&quot;ratings_matrix.cache&quot;</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;开始加载数据集...&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(cache_path):    <span class="comment"># 判断是否存在缓存文件</span></span><br><span class="line">        print(<span class="string">&quot;加载缓存中...&quot;</span>)</span><br><span class="line">        ratings_matrix = pd.read_pickle(cache_path)</span><br><span class="line">        print(<span class="string">&quot;从缓存加载数据集完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;加载新数据中...&quot;</span>)</span><br><span class="line">        <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">        dtype = &#123;<span class="string">&quot;userId&quot;</span>: np.int32, <span class="string">&quot;movieId&quot;</span>: np.int32, <span class="string">&quot;rating&quot;</span>: np.float32&#125;</span><br><span class="line">        <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">        ratings = pd.read_csv(data_path, dtype=dtype, usecols=<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">        <span class="comment"># 透视表，将电影ID转换为列名称，转换成为一个User-Movie的评分矩阵</span></span><br><span class="line">        ratings_matrix = ratings.pivot_table(index=[<span class="string">&quot;userId&quot;</span>], columns=[<span class="string">&quot;movieId&quot;</span>], values=<span class="string">&quot;rating&quot;</span>)</span><br><span class="line">        <span class="comment"># 存入缓存文件</span></span><br><span class="line">        ratings_matrix.to_pickle(cache_path)</span><br><span class="line">        print(<span class="string">&quot;数据集加载完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span>  ratings_matrix</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line">    print(ratings_matrix)</span><br></pre></td></tr></table></figure></li></ul><h4 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h4><ul><li><p>计算用户或物品两两相似度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_pearson_similarity</span>(<span class="params">ratings_matrix, based=<span class="string">&quot;user&quot;</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    计算皮尔逊相关系数</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :param based: &quot;user&quot; or &quot;item&quot;</span></span><br><span class="line"><span class="string">    :return: 相似度矩阵</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    user_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">&quot;user_similarity.cache&quot;</span>)</span><br><span class="line">    item_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">&quot;item_similarity.cache&quot;</span>)</span><br><span class="line">    <span class="comment"># 基于皮尔逊相关系数计算相似度</span></span><br><span class="line">    <span class="comment"># 用户相似度</span></span><br><span class="line">    <span class="keyword">if</span> based == <span class="string">&quot;user&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(user_similarity_cache_path):</span><br><span class="line">            print(<span class="string">&quot;正从缓存加载用户相似度矩阵&quot;</span>)</span><br><span class="line">            similarity = pd.read_pickle(user_similarity_cache_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;开始计算用户相似度矩阵&quot;</span>)</span><br><span class="line">            similarity = ratings_matrix.T.corr()</span><br><span class="line">            similarity.to_pickle(user_similarity_cache_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> based == <span class="string">&quot;item&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(item_similarity_cache_path):</span><br><span class="line">            print(<span class="string">&quot;正从缓存加载物品相似度矩阵&quot;</span>)</span><br><span class="line">            similarity = pd.read_pickle(item_similarity_cache_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;开始计算物品相似度矩阵&quot;</span>)</span><br><span class="line">            similarity = ratings_matrix.corr()</span><br><span class="line">            similarity.to_pickle(item_similarity_cache_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Unhandled &#x27;based&#x27; Value: %s&quot;</span>%based)</span><br><span class="line">    print(<span class="string">&quot;相似度矩阵计算/加载完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> similarity</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    print(user_similar)</span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;item&quot;</span>)</span><br><span class="line">    print(item_similar)</span><br></pre></td></tr></table></figure></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>以上实现，仅用于实验阶段，因为工业上、或生产环境中，数据量是远超过我们本例中使用的数据量的，而pandas是无法支撑起大批量数据的运算的，因此工业上通常会使用spark、mapReduce等分布式计算框架来实现，我们后面的课程中也是建立在此基础上进行实践的。</p><p>但是正如前面所说，推荐算法的思想和理念都是统一的，不论使用什么平台工具、有多大的数据体量，其背后的实现原理都是不变的。</p><p>所以在本节，大家要深刻去学习的是推荐算法的业务流程，以及在具体的业务场景中，如本例的电影推荐，如何实现出推荐算法，并产生推荐结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;案例—基于协同过滤的电影推荐&quot;&gt;&lt;a href=&quot;#案例—基于协同过滤的电影推荐&quot; class=&quot;headerlink&quot; title=&quot;案例—基于协同过滤的电影推荐&quot;&gt;&lt;/a&gt;案例—基于协同过滤的电影推荐&lt;/h2&gt;&lt;p&gt;前面我们已经基本掌握了协同过滤推荐算法，以及</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>05-推荐系统冷启动问题</title>
    <link href="https://xxren8218.github.io/20210610/05-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%86%B7%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210610/05-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%86%B7%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98.html</id>
    <published>2021-06-10T09:33:03.000Z</published>
    <updated>2021-06-10T09:46:03.192Z</updated>
    
    <content type="html"><![CDATA[<h3 id="推荐系统的冷启动问题"><a href="#推荐系统的冷启动问题" class="headerlink" title="推荐系统的冷启动问题"></a>推荐系统的冷启动问题</h3><ul><li><p>推荐系统冷启动概念</p><ul><li>⽤户冷启动：如何为新⽤户做个性化推荐</li><li>物品冷启动：如何将新物品推荐给⽤户（协同过滤）</li><li>系统冷启动：⽤户冷启动+物品冷启动</li><li>本质是推荐系统依赖历史数据，没有历史数据⽆法预测⽤户偏好</li></ul></li><li><p>用户冷启动</p><ul><li><p>1.收集⽤户特征</p><ul><li><p>⽤户注册信息：性别、年龄、地域</p></li><li><p>设备信息：定位、⼿机型号、app列表</p></li><li><p>社交信息、推⼴素材、安装来源</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173438.png" alt=""></p></li></ul></li><li><p>2 引导用户填写兴趣</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173458.png" alt=""></p></li><li><p>3 使用其它站点的行为数据, 例如腾讯视频&amp;QQ音乐 今日头条&amp;抖音</p></li><li><p>4 新老用户推荐策略的差异</p><ul><li>新⽤户在冷启动阶段更倾向于热门排⾏榜，⽼⽤户会更加需要长尾推荐</li><li>Explore Exploit⼒度</li><li>使⽤单独的特征和模型预估</li></ul></li><li><p>举例 性别与电视剧的关系</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173540.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173600.png" alt=""></p></li><li><p>物品冷启动</p><ul><li>给物品打标签</li><li>利用物品的内容信息，将新物品先投放给曾经喜欢过和它内容相似的其他物品的用户。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173622.png" alt=""></p></li><li><p>系统冷启动</p><ul><li>基于内容的推荐 系统早期</li><li>基于内容的推荐逐渐过渡到协同过滤</li><li>基于内容的推荐和协同过滤的推荐结果都计算出来 加权求和得到最终推荐结果</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;推荐系统的冷启动问题&quot;&gt;&lt;a href=&quot;#推荐系统的冷启动问题&quot; class=&quot;headerlink&quot; title=&quot;推荐系统的冷启动问题&quot;&gt;&lt;/a&gt;推荐系统的冷启动问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;推荐系统冷启动概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⽤户冷启动：</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>04-推荐系统评估</title>
    <link href="https://xxren8218.github.io/20210610/04-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BC%B0.html"/>
    <id>https://xxren8218.github.io/20210610/04-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BC%B0.html</id>
    <published>2021-06-10T09:30:03.000Z</published>
    <updated>2021-06-10T09:32:24.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二-推荐系统评估"><a href="#二-推荐系统评估" class="headerlink" title="二 推荐系统评估"></a>二 推荐系统评估</h2><ul><li>好的推荐系统可以实现用户, 服务提供方, 内容提供方的共赢</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173145.png" alt=""></p><ul><li><p>显示反馈和隐式反馈</p><table style="overflow: scroll;">  <tr>    <th></th>    <th>显式反馈</th>    <th>隐式反馈</th>  </tr>  <tr> <td> 例子 </td> <td> 电影/书籍评分  是否喜欢这个推荐 </td> <td> 播放/点击 评论 下载 购买 </td>  </tr>  <tr>    <td> 准确性 </td>    <td> 高 </td>    <td> 低 </td>  </tr>  <tr>    <td> 数量 </td>    <td> 少 </td>    <td> 多 </td>  </tr>  <tr>    <td> 获取成本 </td>    <td> 高 </td>    <td> 低 </td>  </tr></table></li><li><p>常用评估指标</p><p>• 准确性  • 信任度<br>• 满意度  • 实时性<br>• 覆盖率  • 鲁棒性<br>• 多样性  • 可扩展性<br>• 新颖性  • 商业⽬标<br>• 惊喜度  • ⽤户留存</p><ul><li>准确性 (理论角度) Netflix 美国录像带租赁<ul><li>评分预测<ul><li>RMSE   MAE</li></ul></li><li>topN推荐<ul><li>召回率 精准率</li></ul></li></ul></li><li>准确性 (业务角度)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173209.png" alt=""></p><ul><li>覆盖度<ul><li>信息熵 对于推荐越大越好</li><li>覆盖率</li></ul></li><li>多样性&amp;新颖性&amp;惊喜性<ul><li>多样性：推荐列表中两两物品的不相似性。（相似性如何度量？</li><li>新颖性：未曾关注的类别、作者；推荐结果的平均流⾏度</li><li>惊喜性：历史不相似（惊）但很满意（喜）</li><li>往往需要牺牲准确性</li><li>使⽤历史⾏为预测⽤户对某个物品的喜爱程度</li><li>系统过度强调实时性</li></ul></li><li>Exploitation &amp; Exploration 探索与利用问题<ul><li>Exploitation(开发 利用)：选择现在可能最佳的⽅案</li><li>Exploration(探测 搜索)：选择现在不确定的⼀些⽅案，但未来可能会有⾼收益的⽅案</li><li>在做两类决策的过程中，不断更新对所有决策的不确定性的认知，优化<br>长期的⽬标</li></ul></li><li>EE问题实践<ul><li>兴趣扩展: 相似话题, 搭配推荐</li><li>人群算法: userCF 用户聚类</li><li>平衡个性化推荐和热门推荐比例</li><li>随机丢弃用户行为历史</li><li>随机扰动模型参数</li></ul></li><li>EE可能带来的问题<ul><li>探索伤害用户体验, 可能导致用户流失</li><li>探索带来的长期收益(留存率)评估周期长, KPI压力大</li><li>如何平衡实时兴趣和长期兴趣</li><li>如何平衡短期产品体验和长期系统生态</li><li>如何平衡大众口味和小众需求</li></ul></li><li>评估方法<ul><li>问卷调查: 成本高</li><li>离线评估:<ul><li>只能在用户看到过的候选集上做评估, 且跟线上真实效果存在偏差</li><li>只能评估少数指标</li><li>速度快, 不损害用户体验</li></ul></li><li>在线评估: 灰度发布 &amp; A/B测试 50% 全量上线</li><li>实践: 离线评估和在线评估结合, 定期做问卷调查</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二-推荐系统评估&quot;&gt;&lt;a href=&quot;#二-推荐系统评估&quot; class=&quot;headerlink&quot; title=&quot;二 推荐系统评估&quot;&gt;&lt;/a&gt;二 推荐系统评估&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;好的推荐系统可以实现用户, 服务提供方, 内容提供方的共赢&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>03-推荐算法</title>
    <link href="https://xxren8218.github.io/20210602/03-%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95.html"/>
    <id>https://xxren8218.github.io/20210602/03-%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95.html</id>
    <published>2021-06-01T16:22:39.000Z</published>
    <updated>2021-06-07T15:37:54.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><ul><li>推荐模型构建流程</li><li>推荐算法概述</li><li>基于协同过滤的推荐算法</li><li>协同过滤实现</li></ul><h3 id="一-推荐模型构建流程"><a href="#一-推荐模型构建流程" class="headerlink" title="一 推荐模型构建流程"></a>一 推荐模型构建流程</h3><p>Data(数据)-&gt;Features(特征)-&gt;ML Algorithm(机器学习算法)-&gt;Prediction Output(预测输出)</p><ul><li>数据清洗/数据处理</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002426.png" alt=""></p><ul><li>数据来源<ul><li>显性数据<ul><li>Rating 打分</li><li>Comments 评论/评价</li></ul></li><li>隐形数据<ul><li> Order history 历史订单</li><li> Cart events    加购物车</li><li> Page views    页面浏览</li><li> Click-thru      点击</li><li> Search log     搜索记录</li></ul></li></ul></li><li>数据量/数据能否满足要求</li><li>特征工程</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002445.png" alt=""></p><ul><li>从数据中筛选特征<ul><li>一个给定的商品，可能被拥有类似品味或需求的用户购买</li><li>使用用户行为数据描述商品</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002501.png" alt=""></p><ul><li><p>用数据表示特征</p><ul><li><p>将所有用户行为合并在一起 ，形成一个user-item 矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002522.png" alt=""></p></li></ul></li><li><p>选择合适的算法</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002539.png" alt=""></p><ul><li><p>产生推荐结果</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002556.png" alt=""></p></li></ul><h3 id="二-最经典的推荐算法：协同过滤推荐算法（Collaborative-Filtering）"><a href="#二-最经典的推荐算法：协同过滤推荐算法（Collaborative-Filtering）" class="headerlink" title="二 最经典的推荐算法：协同过滤推荐算法（Collaborative Filtering）"></a>二 最经典的推荐算法：协同过滤推荐算法（Collaborative Filtering）</h3><p>算法思想：<strong>物以类聚，人以群分</strong></p><p>基本的协同过滤推荐算法基于以下假设：</p><ul><li>“跟你喜好<strong>相似的人</strong>喜欢的东西你也很有可能喜欢” ：基于用户的协同过滤推荐（User-based CF）——好哥们</li><li>“跟你喜欢的东西<strong>相似的东西</strong>你也很有可能喜欢 ”：基于物品的协同过滤推荐（Item-based CF）——iphone8、iphoneXs</li></ul><p>实现协同过滤推荐有以下几个步骤：</p><ol><li><p><strong>找出最相似的人或物品：TOP-N相似的人或物品</strong></p><p>通过计算两两的相似度来进行排序，即可找出TOP-N相似的人或物品</p></li><li><p><strong>根据相似的人或物品产生推荐结果</strong></p><p>利用TOP-N结果生成初始推荐结果，然后过滤掉用户已经有过记录的物品或明确表示不感兴趣的物品</p></li></ol><p>以下是一个简单的示例，数据集相当于一个用户对物品的购买记录表：打勾表示用户对物品的有购买记录</p><ul><li><p>关于相似度计算这里先用一个简单的思想：如有两个同学X和Y，X同学爱好[足球、篮球、乒乓球]，Y同学爱好[网球、足球、篮球、羽毛球]，可见他们的共同爱好有2个，那么他们的相似度可以用：2/3 * 2/4 = 1/3 ≈ 0.33 来表示。</p><p><strong>User-Based CF</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002706.png" alt=""></p><p><strong>Item-Based CF</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002804.png" alt=""></p></li></ul><p>  通过前面两个demo，相信大家应该已经对协同过滤推荐算法的设计与实现有了比较清晰的认识。</p><h3 id="三-相似度计算-Similarity-Calculation"><a href="#三-相似度计算-Similarity-Calculation" class="headerlink" title="三 相似度计算(Similarity Calculation)"></a>三 相似度计算(Similarity Calculation)</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002856.png" alt=""></p><ul><li><p>相似度的计算方法</p><ul><li>数据分类<ul><li>实数值(物品评分情况)</li><li>布尔值(用户的行为 是否点击 是否收藏)</li></ul></li><li>欧氏距离, 是一个欧式空间下度量距离的方法. 两个物体, 都在同一个空间下表示为两个点, 假如叫做p,q, 分别都是n个坐标, 那么欧式距离就是衡量这两个点之间的距离. 欧氏距离不适用于布尔向量之间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002930.png" alt=""></p><script type="math/tex; mode=display">E(p,q) = \sqrt{\sum_{i=1}^n (p_i - q_i)^2}</script></li></ul><p>  ​    欧氏距离的值是一个非负数, 最大值正无穷, 通常计算相似度的结果希望是[-1,1]或[0,1]之间,一般可以使用</p><p>  ​    如下转化公式:<img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002945.png" alt=""></p><p>  ​    </p><ul><li>杰卡德相似度&amp;余弦相似度&amp;皮尔逊相关系数<ul><li>余弦相似度<ul><li>度量的是两个向量之间的夹角, 用夹角的余弦值来度量相似的情况</li><li>两个向量的夹角为0是,余弦值为1, 当夹角为90度是余弦值为0,为180度是余弦值为-1</li><li>余弦相似度在度量文本相似度, 用户相似度 物品相似度的时候较为常用</li><li>余弦相似度的特点, 与向量长度无关,余弦相似度计算要对向量长度归一化, 两个向量只要方向一致,无论程度强弱, 都可以视为’相似’</li></ul></li><li>皮尔逊相关系数Pearson<ul><li>实际上也是一种余弦相似度, 不过先对向量做了中心化, 向量a b 各自减去向量的均值后, 再计算余弦相似度</li><li>皮尔逊相似度计算结果在-1,1之间 -1表示负相关, 1表示正相关</li><li>度量两个变量是不是同增同减</li><li>皮尔逊相关系数度量的是两个变量的变化趋势是否一致, <strong>不适合计算布尔值向量之间的相关度</strong></li></ul></li><li>杰卡德相似度 Jaccard<ul><li>两个集合的交集元素个数在并集中所占的比例, 非常适用于布尔向量表示</li><li>分子是两个布尔向量做点积计算, 得到的就是交集元素的个数</li><li>分母是两个布尔向量做或运算, 再求元素和</li></ul></li><li>余弦相似度适合用户评分数据(实数值), 杰卡德相似度适用于隐式反馈数据(0,1布尔值)(是否收藏,是否点击,是否加购物车)</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003009.png" alt=""></p><ul><li>余弦相似度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003028.png" alt=""></p><ul><li>皮尔逊相关系数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003053.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003109.png" alt=""></p><ul><li>计算出用户1和其它用户之间的相似度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003128.png" alt=""></p><ul><li>按照相似度大小排序, K近邻 如K取4: </li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003148.png" alt=""></p><ul><li>取出近邻用户的购物清单</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003201.png" alt=""></p><ul><li>去除用户1已经购买过的商品</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003217.png" alt=""></p><ul><li>在剩余的物品中根据评分排序</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003231.png" alt=""></p><ul><li>物品相似度计算<ul><li>余弦相似度对绝对值大小不敏感带来的问题<ul><li>用户A对两部电影评分分别是1分和2分, 用户B对同样这两部电影进行评分是4分,5分 用余弦相似度计算,两个用户的相似度达到0.98    </li><li>可以采用改进的余弦相似度, 先计算向量每个维度上的均值, 然后每个向量在各个维度上都减去均值后,在计算余弦相似度, 用调整的余弦相似度计算得到的相似度是-0.1</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003348.png" alt=""></p><ul><li>物品相似度计算案例</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003408.png" alt=""></p><ul><li>找出物品1的相似商品</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003454.png" alt=""></p><ul><li>选择最近似的物品</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003701.png" alt=""></p><ul><li>基于用户与物品的协同过滤比较</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003645.png" alt=""><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003610.png" alt=""></p><h3 id="协同过滤推荐算法代码实现："><a href="#协同过滤推荐算法代码实现：" class="headerlink" title="协同过滤推荐算法代码实现："></a>协同过滤推荐算法代码实现：</h3><ul><li><p>构建数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 构建数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>计算时我们数据通常都需要对数据进行处理，或者编码，目的是为了便于我们对数据进行运算处理，比如这里是比较简单的情形，我们用1、0分别来表示用户的是否购买过该物品，则我们的数据集其实应该是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></li><li><p>有了数据集，接下来我们就可以进行相似度的计算，不过对于相似度的计算其实是有很多专门的相似度计算方法的，比如余弦相似度、皮尔逊相关系数、杰卡德相似度等等。这里我们选择使用杰卡德相似系数[0,1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接计算某两项的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> jaccard_similarity_score</span><br><span class="line"><span class="comment"># 计算Item A 和Item B的相似度</span></span><br><span class="line">print(jaccard_similarity_score(df[<span class="string">&quot;Item A&quot;</span>], df[<span class="string">&quot;Item B&quot;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算用户间相似度</span></span><br><span class="line">user_similar = <span class="number">1</span> - pairwise_distances(df, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">user_similar = pd.DataFrame(user_similar, columns=users, index=users)</span><br><span class="line">print(<span class="string">&quot;用户之间的两两相似度：&quot;</span>)</span><br><span class="line">print(user_similar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算物品间相似度</span></span><br><span class="line">item_similar = <span class="number">1</span> - pairwise_distances(df.T, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">item_similar = pd.DataFrame(item_similar, columns=items, index=items)</span><br><span class="line">print(<span class="string">&quot;物品之间的两两相似度：&quot;</span>)</span><br><span class="line">print(item_similar)</span><br></pre></td></tr></table></figure><p>有了两两的相似度，接下来就可以筛选TOP-N相似结果，并进行推荐了</p></li><li><p>User-Based CF</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算用户间相似度</span></span><br><span class="line">user_similar = <span class="number">1</span> - pairwise_distances(df, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">user_similar = pd.DataFrame(user_similar, columns=users, index=users)</span><br><span class="line">print(<span class="string">&quot;用户之间的两两相似度：&quot;</span>)</span><br><span class="line">print(user_similar)</span><br><span class="line"></span><br><span class="line">topN_users = &#123;&#125;</span><br><span class="line"><span class="comment"># 遍历每一行数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> user_similar.index:</span><br><span class="line">    <span class="comment"># 取出每一列数据，并删除自身，然后排序数据</span></span><br><span class="line">    _df = user_similar.loc[i].drop([i])</span><br><span class="line">    _df_sorted = _df.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    top2 = <span class="built_in">list</span>(_df_sorted.index[:<span class="number">2</span>])</span><br><span class="line">    topN_users[i] = top2</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Top2相似用户：&quot;</span>)</span><br><span class="line">print(topN_users)</span><br><span class="line"></span><br><span class="line">rs_results = &#123;&#125;</span><br><span class="line"><span class="comment"># 构建推荐结果</span></span><br><span class="line"><span class="keyword">for</span> user, sim_users <span class="keyword">in</span> topN_users.items():</span><br><span class="line">    rs_result = <span class="built_in">set</span>()    <span class="comment"># 存储推荐结果</span></span><br><span class="line">    <span class="keyword">for</span> sim_user <span class="keyword">in</span> sim_users:</span><br><span class="line">        <span class="comment"># 构建初始的推荐结果</span></span><br><span class="line">        rs_result = rs_result.union(<span class="built_in">set</span>(df.ix[sim_user].replace(<span class="number">0</span>,np.nan).dropna().index))</span><br><span class="line">    <span class="comment"># 过滤掉已经购买过的物品</span></span><br><span class="line">    rs_result -= <span class="built_in">set</span>(df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index)</span><br><span class="line">    rs_results[user] = rs_result</span><br><span class="line">print(<span class="string">&quot;最终推荐结果：&quot;</span>)</span><br><span class="line">pprint(rs_results)</span><br></pre></td></tr></table></figure></li><li><p>Item-Based CF</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算物品间相似度</span></span><br><span class="line">item_similar = <span class="number">1</span> - pairwise_distances(df.T, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">item_similar = pd.DataFrame(item_similar, columns=items, index=items)</span><br><span class="line">print(<span class="string">&quot;物品之间的两两相似度：&quot;</span>)</span><br><span class="line">print(item_similar)</span><br><span class="line"></span><br><span class="line">topN_items = &#123;&#125;</span><br><span class="line"><span class="comment"># 遍历每一行数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> item_similar.index:</span><br><span class="line">    <span class="comment"># 取出每一列数据，并删除自身，然后排序数据</span></span><br><span class="line">    _df = item_similar.loc[i].drop([i])</span><br><span class="line">    _df_sorted = _df.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    top2 = <span class="built_in">list</span>(_df_sorted.index[:<span class="number">2</span>])</span><br><span class="line">    topN_items[i] = top2</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Top2相似物品：&quot;</span>)</span><br><span class="line">pprint(topN_items)</span><br><span class="line"></span><br><span class="line">rs_results = &#123;&#125;</span><br><span class="line"><span class="comment"># 构建推荐结果</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> df.index:    <span class="comment"># 遍历所有用户</span></span><br><span class="line">    rs_result = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index:   <span class="comment"># 取出每个用户当前已购物品列表</span></span><br><span class="line">        <span class="comment"># 根据每个物品找出最相似的TOP-N物品，构建初始推荐结果</span></span><br><span class="line">        rs_result = rs_result.union(topN_items[item])</span><br><span class="line">    <span class="comment"># 过滤掉用户已购的物品</span></span><br><span class="line">    rs_result -= <span class="built_in">set</span>(df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index)</span><br><span class="line">    <span class="comment"># 添加到结果中</span></span><br><span class="line">    rs_results[user] = rs_result</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;最终推荐结果：&quot;</span>)</span><br><span class="line">pprint(rs_results)</span><br></pre></td></tr></table></figure></li></ul><p><strong>关于协同过滤推荐算法使用的数据集</strong></p><p>在前面的demo中，我们只是使用用户对物品的一个购买记录，类似也可以是比如浏览点击记录、收听记录等等。这样数据我们预测的结果其实相当于是在预测用户是否对某物品感兴趣，对于喜好程度不能很好的预测。</p><p>因此在协同过滤推荐算法中其实会更多的利用用户对物品的“评分”数据来进行预测，通过评分数据集，我们可以预测用户对于他没有评分过的物品的评分。其实现原理和思想和都是一样的，只是使用的数据集是用户-物品的评分数据。</p><p><strong>关于用户-物品评分矩阵</strong></p><p>用户-物品的评分矩阵，根据评分矩阵的稀疏程度会有不同的解决方案</p><ul><li><p>稠密评分矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003819.png" alt=""></p></li><li><p>稀疏评分矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003905.png" alt=""></p></li></ul><p>这里先介绍稠密评分矩阵的处理，稀疏矩阵的处理相对会复杂一些，我们到后面再来介绍。</p><h4 id="使用协同过滤推荐算法对用户进行评分预测"><a href="#使用协同过滤推荐算法对用户进行评分预测" class="headerlink" title="使用协同过滤推荐算法对用户进行评分预测"></a>使用协同过滤推荐算法对用户进行评分预测</h4><ul><li><p>数据集：<img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003819.png" alt=""></p><p><strong>目的：预测用户1对物品E的评分</strong></p></li><li><p>构建数据集：注意这里构建评分数据时，对于缺失的部分我们需要保留为None，如果设置为0那么会被当作评分值为0去对待</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>计算相似度：对于评分数据这里我们采用皮尔逊相关系数[-1,1]来计算，-1表示强负相关，+1表示强正相关</p><blockquote><p>pandas中corr方法可直接用于计算皮尔逊相关系数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;用户之间的两两相似度：&quot;</span>)</span><br><span class="line"><span class="comment"># 直接计算皮尔逊相关系数</span></span><br><span class="line"><span class="comment"># 默认是按列进行计算，因此如果计算用户间的相似度，当前需要进行转置</span></span><br><span class="line">user_similar = df.T.corr()</span><br><span class="line">print(user_similar.<span class="built_in">round</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;物品之间的两两相似度：&quot;</span>)</span><br><span class="line">item_similar = df.corr()</span><br><span class="line">print(item_similar.<span class="built_in">round</span>(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 运行结果：</span><br><span class="line">用户之间的两两相似度：</span><br><span class="line">        User1   User2   User3   User4   User5</span><br><span class="line">User1  1.0000  0.8528  0.7071  0.0000 -0.7921</span><br><span class="line">User2  0.8528  1.0000  0.4677  0.4900 -0.9001</span><br><span class="line">User3  0.7071  0.4677  1.0000 -0.1612 -0.4666</span><br><span class="line">User4  0.0000  0.4900 -0.1612  1.0000 -0.6415</span><br><span class="line">User5 -0.7921 -0.9001 -0.4666 -0.6415  1.0000</span><br><span class="line">物品之间的两两相似度：</span><br><span class="line">        Item A  Item B  Item C  Item D  Item E</span><br><span class="line">Item A  1.0000 -0.4767 -0.1231  0.5322  0.9695</span><br><span class="line">Item B -0.4767  1.0000  0.6455 -0.3101 -0.4781</span><br><span class="line">Item C -0.1231  0.6455  1.0000 -0.7206 -0.4276</span><br><span class="line">Item D  0.5322 -0.3101 -0.7206  1.0000  0.5817</span><br><span class="line">Item E  0.9695 -0.4781 -0.4276  0.5817  1.0000</span><br></pre></td></tr></table></figure><p>可以看到与用户1最相似的是用户2和用户3；与物品A最相似的物品分别是物品E和物品D。</p><p><strong>注意：</strong>我们在预测评分时，往往是通过与其有正相关的用户或物品进行预测，如果不存在正相关的情况，那么将无法做出预测。这一点尤其是在稀疏评分矩阵中尤为常见，因为稀疏评分矩阵中很难得出正相关系数。</p></li><li><p><strong>评分预测：</strong></p><p><strong>User-Based CF 评分预测：使用用户间的相似度进行预测</strong></p><p>关于评分预测的方法也有比较多的方案，下面介绍一种效果比较好的方案，该方案考虑了用户本身的评分评分以及近邻用户的加权平均相似度打分来进行预测：</p><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}</script></li></ul><p>  我们要预测用户1对物品E的评分，那么可以根据与用户1最近邻的用户2和用户3进行预测，计算如下：</p><p>  ​    </p><script type="math/tex; mode=display">pred(u_1, i_5) =\cfrac{0.85*3+0.71*5}{0.85+0.71} = 3.91</script><p>  最终预测出用户1对物品5的评分为3.91</p><p>  <strong>Item-Based CF 评分预测：使用物品间的相似度进行预测</strong></p><p>  这里利用物品相似度预测的计算同上，同样考虑了用户自身的平均打分因素，结合预测物品与相似物品的加权平均相似度打分进行来进行预测</p><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{j\in I_{rated}}sim(i,j)*r_{uj}}{\sum_{j\in I_{rated}}sim(i,j)}</script><p>  我们要预测用户1对物品E的评分，那么可以根据与物品E最近邻的物品A和物品D进行预测，计算如下：</p><script type="math/tex; mode=display">pred(u_1, i_5) = \cfrac {0.97*5+0.58*4}{0.97+0.58} = 4.63</script><p>  对比可见，User-Based CF预测评分和Item-Based CF的评分结果也是存在差异的，因为严格意义上他们其实应当属于两种不同的推荐算法，各自在不同的领域不同场景下，都会比另一种的效果更佳，但具体哪一种更佳，必须经过合理的效果评估，因此在实现推荐系统时这两种算法往往都是需要去实现的，然后对产生的推荐效果进行评估分析选出更优方案。</p><h3 id="基于模型的方法"><a href="#基于模型的方法" class="headerlink" title="基于模型的方法"></a>基于模型的方法</h3><ul><li><p>思想</p><ul><li>通过机器学习算法，在数据中找出模式，并将用户与物品间的互动方式模式化</li><li>基于模型的协同过滤方式是构建协同过滤更高级的算法</li></ul></li><li><p>近邻模型的问题</p><ul><li>物品之间存在相关性, 信息量并不随着向量维度增加而线性增加</li><li>矩阵元素稀疏, 计算结果不稳定,增减一个向量维度, 导致近邻结果差异很大的情况存在</li></ul></li><li><p>算法分类</p><ul><li>基于图的模型</li><li><strong>基于矩阵分解的方法</strong></li></ul></li><li><p>基于图的模型</p><ul><li>基于邻域的模型看做基于图的模型的简单形式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602004043.png" alt=""></p><ul><li>原理<ul><li>将用户的行为数据表示为二分图</li><li>基于二分图为用户进行推荐</li><li>根据两个顶点之间的路径数、路径长度和经过的顶点数来评价两个顶点的相关性</li></ul></li></ul></li><li><p>基于矩阵分解的模型</p><ul><li><p>原理</p><ul><li><p>根据用户与物品的潜在表现，我们就可以预测用户对未评分的物品的喜爱程度</p></li><li><p>把原来的大矩阵, 近似分解成两个小矩阵的乘积, 在实际推荐计算时不再使用大矩阵, 而是使用分解得到的两个小矩阵  </p></li><li><p>用户-物品评分矩阵A是M X N维, 即一共有M个用户, n个物品 我们选一个很小的数 K (K&lt;&lt; M, K&lt;&lt;N)</p></li><li><p>通过计算得到两个矩阵U V  U是M <em> K矩阵 , 矩阵V是 N </em> K</p><p>$U_{m<em>k} V^{T}_{n</em>k} 约等于 A_{m*n}$</p><p>类似这样的计算过程就是矩阵分解</p></li></ul></li><li><p>基于矩阵分解的方法</p><ul><li>ALS交替最小二乘<ul><li>ALS-WR(加权正则化交替最小二乘法): alternating-least-squares with weighted-λ –regularization</li><li>将用户(user)对商品(item)的评分矩阵分解为两个矩阵：一个是用户对商品隐含特征的偏好矩阵，另一个是商品所包含的隐含特征的矩阵。在这个矩阵分解的过程中，评分缺失项得到了填充，也就是说我们可以基于这个填充的评分来给用户做商品推荐了。</li></ul></li><li>SVD奇异值分解矩阵</li></ul></li></ul></li><li><p>ALS方法</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602004107.png" alt=""></p><ul><li>ALS的矩阵分解算法常应用于推荐系统中，将用户(user)对商品(item)的评分矩阵，分解为用户对商品隐含特征的偏好矩阵，和商品在隐含特征上的映射矩阵。</li><li>与传统的矩阵分解SVD方法来分解矩阵R(R∈ℝm×n)不同的是，ALS(alternating least squares)希望找到两个低维矩阵，以 R̃ =XY 来逼近矩阵R，其中 ，X∈ℝm×d，Y∈ℝd×n，这样，将问题的复杂度由O(m<em>n)转换为O((m+n)</em>d)。</li><li>计算X和Y过程：首先用一个小于1的随机数初始化Y，并根据公式求X，此时就可以得到初始的XY矩阵了，根据平方差和得到的X，重新计算并覆盖Y，计算差平方和，反复进行以上两步的计算，直到差平方和小于一个预设的数，或者迭代次数满足要求则停止</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;推荐算法&quot;&gt;&lt;a href=&quot;#推荐算法&quot; class=&quot;headerlink&quot; title=&quot;推荐算法&quot;&gt;&lt;/a&gt;推荐算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;推荐模型构建流程&lt;/li&gt;
&lt;li&gt;推荐算法概述&lt;/li&gt;
&lt;li&gt;基于协同过滤的推荐算法&lt;/li&gt;
&lt;li&gt;协</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>02-推荐系统设计</title>
    <link href="https://xxren8218.github.io/20210602/02-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html"/>
    <id>https://xxren8218.github.io/20210602/02-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html</id>
    <published>2021-06-01T16:16:15.000Z</published>
    <updated>2021-06-01T16:22:07.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二-推荐系统设计"><a href="#二-推荐系统设计" class="headerlink" title="二 推荐系统设计"></a>二 推荐系统设计</h2><h3 id="2-1-推荐系统要素"><a href="#2-1-推荐系统要素" class="headerlink" title="2.1 推荐系统要素"></a>2.1 推荐系统要素</h3><ul><li>UI 和 UE(前端界面)</li><li>数据 (Lambda架构)</li><li>业务知识</li><li>算法</li></ul><h3 id="2-2-推荐系统架构"><a href="#2-2-推荐系统架构" class="headerlink" title="2.2 推荐系统架构"></a>2.2 推荐系统架构</h3><ul><li><p>推荐系统整体架构</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602001914.png" alt=""></p></li><li><p>大数据Lambda架构</p><ul><li><p>由Twitter工程师Nathan Marz(storm项目发起人)提出</p></li><li><p>Lambda系统架构提供了一个结合实时数据和Hadoop预先计算的数据环境和混合平台, 提供一个实时的数据视图</p></li><li><p>分层架构</p><ul><li>批处理层<ul><li>数据不可变, 可进行任何计算, 可水平扩展</li><li>高延迟  几分钟~几小时(计算量和数据量不同)</li><li>日志收集 Flume</li><li>分布式存储 Hadoop hdfs</li><li>分布式计算 Hadoop MapReduce &amp; spark</li><li>视图存储数据库<ul><li>nosql(HBase/Cassandra)</li><li>Redis/memcache</li><li>MySQL</li></ul></li></ul></li><li>实时处理层<ul><li>流式处理, 持续计算</li><li>存储和分析某个窗口期内的数据</li><li>最终正确性(Eventual accuracy)</li><li>实时数据收集 flume &amp; kafka</li><li>实时数据分析  spark streaming/storm/flink</li></ul></li><li>服务层<ul><li>支持随机读</li><li>需要在非常短的时间内返回结果</li><li>读取批处理层和实时处理层结果并对其归并</li></ul></li></ul></li><li><p>Lambda架构图</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602001941.png" alt=""></p></li></ul></li><li><p>推荐算法架构</p><ul><li>召回阶段(<strong>海选</strong>)<ul><li>召回决定了最终推荐结果的天花板</li><li>常用算法:<ul><li>协同过滤(基于用户 基于物品的)</li><li>基于内容 (根据用户行为总结出自己的偏好 根据偏好 通过文本挖掘技术找到内容上相似的商品)</li><li>基于隐语义（矩阵分解）</li></ul></li></ul></li><li>排序阶段<ul><li>召回决定了最终推荐结果的天花板, 排序逼近这个极限, 决定了最终的推荐效果</li><li>CTR预估 (点击率预估 使用LR算法)  估计用户是否会点击某个商品 需要用户的点击数据</li></ul></li><li>策略调整</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002010.jpeg" alt=""></p><ul><li><p>推荐系统的整体架构</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002137.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002155.png" alt=""></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二-推荐系统设计&quot;&gt;&lt;a href=&quot;#二-推荐系统设计&quot; class=&quot;headerlink&quot; title=&quot;二 推荐系统设计&quot;&gt;&lt;/a&gt;二 推荐系统设计&lt;/h2&gt;&lt;h3 id=&quot;2-1-推荐系统要素&quot;&gt;&lt;a href=&quot;#2-1-推荐系统要素&quot; class=&quot;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>01-推荐系统简介</title>
    <link href="https://xxren8218.github.io/20210602/01-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B.html"/>
    <id>https://xxren8218.github.io/20210602/01-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B.html</id>
    <published>2021-06-01T16:12:16.000Z</published>
    <updated>2021-06-01T16:16:27.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-推荐系统简介"><a href="#一-推荐系统简介" class="headerlink" title="一 推荐系统简介"></a>一 推荐系统简介</h2><p>​        个性化推荐(推荐系统)经历了多年的发展，已经成为互联网产品的标配，也是AI成功落地的分支之一，在电商(淘宝/京东)、资讯(今日头条/微博)、音乐(网易云音乐/QQ音乐)、短视频(抖音/快手)等热门应用中,推荐系统都是核心组件之一。</p><ul><li><p>推荐系统产生背景</p><ul><li>信息过载 &amp; 用户需求不明确<ul><li>分类⽬录（1990s）：覆盖少量热门⽹站。Hao123 Yahoo</li><li>搜索引擎（2000s）：通过搜索词明确需求。Google Baidu</li><li>推荐系统（2010s）：不需要⽤户提供明确的需求，通过分析⽤<br>户的历史⾏为给⽤户的兴趣进⾏建模，从⽽主动给⽤户推荐能<br>够满⾜他们兴趣和需求的信息。</li></ul></li></ul></li><li><p>什么是推荐系统</p><ul><li>没有明确需求的用户访问了我们的服务, 且服务的物品对用户构成了信息过载, 系统通过一定的规则对物品进行排序,并将排在前面的物品展示给用户,这样的系统就是推荐系统</li></ul></li><li><p>推荐系统 V.S. 搜索引擎</p><table style="overflow: scroll;">  <tr>    <th></th>    <th>搜索</th>    <th>推荐</th>  </tr>  <tr>    <td> 行为方式 </td>    <td> 主动 </td>    <td> 被动 </td>  </tr>  <tr>    <td> 意图 </td>    <td> 明确 </td>    <td> 模糊 </td>  </tr>  <tr>    <td> 个性化 </td>    <td> 弱 </td>    <td> 强 </td>  </tr>  <tr>    <td> 流量分布 </td>    <td> 马太效应（二八效应），基本上返回的都是一样的优质的网站。如 CSDN </td>    <td> 长尾效应 （与马太效应相反），兼顾更多的小厂</td>  </tr>  <tr>    <td> 目标 </td>    <td> 快速满足  </td>    <td> 持续服务 （收集注意力，卖广告）</td>  </tr>  <tr>    <td> 评估指标 </td>    <td> 简明 </td>    <td> 复杂 </td>  </tr></table></li><li><p>推荐系统的作用</p><ul><li>高效连接用户和物品, 发现长尾商品</li><li>留住用户和内容生产者, 实现商业目标</li></ul></li><li><p>推荐系统的工作原理</p><ul><li><strong>社会化推荐</strong> 向朋友咨询, 社会化推荐, 让好友给自己推荐物品</li><li><strong>基于内容的推荐</strong> 打开搜索引擎, 输入自己喜欢的演员的名字, 然后看看返回结果中还有什么电影是自己没看过的</li><li><strong>基于流行度的推荐</strong> 查看票房排行榜, </li><li><strong>基于协同过滤的推荐</strong> 找到和自己历史兴趣相似的用户, 看看他们最近在看什么电影</li></ul></li><li><p>推荐系统的应用场景 feed 流 信息流 </p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602001521.png" alt=""></p><ul><li><p>推荐系统和Web项目的区别</p><ul><li>稳定的信息流通系统 V.S. 通过信息过滤实现目标提升 <ul><li>web项目: 处理复杂逻辑 处理高并发 实现高可用 为用户提供稳定服务, 构建一个稳定的信息流通的服务</li><li>推荐系统: 追求指标增长, 留存率/阅读时间/GMV (Gross Merchandise Volume电商网站成交金额)/视频网站VV (Video View)</li></ul></li><li>确定 V.S. 不确定思维<ul><li>web项目: 对结果有确定预期</li><li>推荐系统: 结果是概率问题</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-推荐系统简介&quot;&gt;&lt;a href=&quot;#一-推荐系统简介&quot; class=&quot;headerlink&quot; title=&quot;一 推荐系统简介&quot;&gt;&lt;/a&gt;一 推荐系统简介&lt;/h2&gt;&lt;p&gt;​        个性化推荐(推荐系统)经历了多年的发展，已经成为互联网产品的标配，也是AI</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（五十一）：构建乘积数组</title>
    <link href="https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.html"/>
    <id>https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.html</id>
    <published>2021-06-01T16:09:27.000Z</published>
    <updated>2021-06-01T16:11:16.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>暴力解法：直接构造一个B列表，使得B[i]都初始化为i，再分别乘a中除了i的所有元素。</p><h2 id="3-代码——力扣超时43-44"><a href="#3-代码——力扣超时43-44" class="headerlink" title="3.代码——力扣超时43/44"></a>3.代码——力扣超时43/44</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        B = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> B:</span><br><span class="line">            B[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> (A[:i]+A[i+<span class="number">1</span>:]):</span><br><span class="line">                B[i] *= j</span><br><span class="line">        <span class="keyword">return</span> B </span><br></pre></td></tr></table></figure><h2 id="新思路："><a href="#新思路：" class="headerlink" title="新思路："></a>新思路：</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602001037.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602001055.PNG" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span>(<span class="params">self, a: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        b, tmp = [<span class="number">1</span>] * <span class="built_in">len</span>(a), <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(a)):</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>] <span class="comment"># 下三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>): </span><br><span class="line">            tmp *= a[i + <span class="number">1</span>] <span class="comment"># 上三角</span></span><br><span class="line">            b[i] *= tmp <span class="comment"># 下三角 * 上三角</span></span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]&lt;em&gt;A[1</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（五十）：数组中重复的数字</title>
    <link href="https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html</id>
    <published>2021-06-01T16:08:08.000Z</published>
    <updated>2021-06-01T16:08:53.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>直接哈希表解决。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://xxren8218.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三十七）：数字在排序数组中出现的次数</title>
    <link href="https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.html</id>
    <published>2021-06-01T16:05:07.000Z</published>
    <updated>2021-06-01T16:07:33.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>统计一个数字在排序数组中出现的次数。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>我最先想到的是count方法，直接可以计数。那么就会失去本题原来的意义。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span>(<span class="params">self, data, k</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> data.count(k)</span><br></pre></td></tr></table></figure><h2 id="思路二——二分查找"><a href="#思路二——二分查找" class="headerlink" title="思路二——二分查找"></a>思路二——二分查找</h2><p>既然是排序的数组，那第一感觉肯定是二分查找；<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000617.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000638.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000650.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000703.PNG" alt=""></p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: [<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 搜索右边界 right</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt;= target: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">        right = i</span><br><span class="line">        <span class="comment"># 若数组中无 target ，则提前返回</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] != target: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 搜索左边界 left</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; target: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">        left = j</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000720.PNG" alt=""></p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">nums,target</span>):</span></span><br><span class="line">            i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">                m = (i + j)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt;= target:</span><br><span class="line">                    i = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(nums,target) - helper(nums,target-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;统计一个数字在排序数组中出现的次数。&lt;/p&gt;
&lt;h2 id=&quot;2-思路&quot;&gt;&lt;a href=&quot;#2-思路&quot; class=&quot;he</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分法" scheme="https://xxren8218.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四十）：数组中只出现一次的数字</title>
    <link href="https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html</id>
    <published>2021-06-01T16:03:24.000Z</published>
    <updated>2021-06-01T16:04:20.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>直接使用一个哈希表进行计数即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:dic[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> dic[j] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> j</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://xxren8218.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三十五）：数组中的逆序对</title>
    <link href="https://xxren8218.github.io/20210601/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.html"/>
    <id>https://xxren8218.github.io/20210601/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.html</id>
    <published>2021-06-01T15:58:50.000Z</published>
    <updated>2021-06-01T16:02:22.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。</p><p>题目保证输入的数组中没有的相同的数字</p><p>数据范围：</p><p>对于%50的数据,size&lt;=10^4</p><p>对于%75的数据,size&lt;=10^5</p><p>对于%100的数据,size&lt;=2*10^5</p><h2 id="2-思路——暴力解法"><a href="#2-思路——暴力解法" class="headerlink" title="2.思路——暴力解法"></a>2.思路——暴力解法</h2><p>直接暴力解法——O（n^2），代码超时</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="解法二——归并排序"><a href="#解法二——归并排序" class="headerlink" title="解法二——归并排序"></a>解法二——归并排序</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；。<br>分治思想，采用归并排序的思路来处理，如下图，先分后治：<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000121.PNG" alt=""><br>先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000140.PNG" alt=""><br>逆序对的总数 = 左边数组中的逆序对的数量 + 右边数组中逆序对的数量 + 左右结合成新的顺序数组时中出现的逆序对的数量<br>总结一下：</p><p>这是一个归并排序的合并过程，主要是考虑合并两个有序序列时，计算逆序对数。</p><p>对于两个升序序列，设置两个下标：两个有序序列的末尾。每次比较两个末尾值，如果前末尾大于后末尾值，则有”后序列当前长度“个逆序对；否则不构成逆序对。然后把较大值拷贝到辅助数组的末尾，即最终要将两个有序序列合并到辅助数组并有序。</p><p>这样，每次在合并前，先递归地处理左半段、右半段，则左、右半段有序，且左右半段的逆序对数可得到，再计算左右半段合并时逆序对的个数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment">#####</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">self, alist</span>):</span></span><br><span class="line">        <span class="comment"># 先进性拆分</span></span><br><span class="line">        n = <span class="built_in">len</span>(alist)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> alist</span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># left 采用归并排序后形成的有序的新的列表</span></span><br><span class="line">        left_li = self.merge_sort(alist[:mid])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># right 采用归并排序后形成的有序的新的列表</span></span><br><span class="line">        right_li = self.merge_sort(alist[mid:])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将两个有序的子序列合并为一个新的整体</span></span><br><span class="line">        <span class="comment"># merge(left, right)</span></span><br><span class="line">        left_pointer, right_pointer = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left_pointer &lt; <span class="built_in">len</span>(left_li) <span class="keyword">and</span> right_pointer &lt; <span class="built_in">len</span>(right_li):</span><br><span class="line">            <span class="keyword">if</span> left_li[left_pointer] &lt;= right_li[right_pointer]:</span><br><span class="line">                result.append(left_li[left_pointer])</span><br><span class="line">                left_pointer += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(right_li[right_pointer])</span><br><span class="line">                right_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">####### [3] 4 5     [1] 2 6  左边游标第一个比后面的大，则，后面的4,5肯定比 1 也大</span></span><br><span class="line">                self.count += (<span class="built_in">len</span>(left_li) - (left_pointer))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 其中一个列表取完了，另一个没有。进行判断。list[n:]返回空列表。可以同时判断两个列表情况。</span></span><br><span class="line">        result += left_li[left_pointer:]</span><br><span class="line">        result += right_li[right_pointer:]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.merge_sort(data)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="归并排序" scheme="https://xxren8218.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    <category term="递归" scheme="https://xxren8218.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
