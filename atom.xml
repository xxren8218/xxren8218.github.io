<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-07-21T09:08:04.973Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>11-子集问题二</title>
    <link href="https://xxren8218.github.io/20210721/11-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E4%BA%8C.html"/>
    <id>https://xxren8218.github.io/20210721/11-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E4%BA%8C.html</id>
    <published>2021-07-21T09:07:10.000Z</published>
    <updated>2021-07-21T09:08:04.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子集问题二"><a href="#子集问题二" class="headerlink" title="子集问题二"></a>子集问题二</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170739.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目【子集问题】区别就是集合里有重复元素了，而且求取的子集要去重。</p><p>那么关于回溯算法中的去重问题，<strong>「在【组合总和II】中已经详细讲解过了，和本题是一个套路」</strong>。</p><p><strong>「剧透一下，后期要讲解的排列问题里去重也是这个套路，所以理解“树层去重”和“树枝去重”非常重要」</strong>。</p><p>用示例中的[1, 2, 2] 来举例，如图所示：（<strong>「注意去重需要先对集合排序」</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170753.jpg" alt=""></p><p>从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！</p><p>本题就是其实就是【子集问题】基础上加上了去重，去重我们在【组合总和三】也讲过了，所以我就直接给出代码了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        used = [<span class="literal">False</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        self.backtracking(nums, <span class="number">0</span>, used)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, nums, startIndex, used</span>):</span></span><br><span class="line">        self.res.append(self.path[:])</span><br><span class="line">        <span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            self.backtracking(nums, i + <span class="number">1</span>, used)</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这道题目的知识点，我们之前都讲过了，如果之前讲过的子集问题和去重问题都掌握的好，这道题目应该分分钟AC。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;子集问题二&quot;&gt;&lt;a href=&quot;#子集问题二&quot; class=&quot;headerlink&quot; title=&quot;子集问题二&quot;&gt;&lt;/a&gt;子集问题二&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>10-求子集问题</title>
    <link href="https://xxren8218.github.io/20210721/10-%E6%B1%82%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210721/10-%E6%B1%82%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98.html</id>
    <published>2021-07-21T09:05:30.000Z</published>
    <updated>2021-07-21T09:06:37.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="求子集问题"><a href="#求子集问题" class="headerlink" title="求子集问题"></a>求子集问题</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170559.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求子集问题和【求组合】和【分割问题】又不一样了。</p><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>「那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！」</strong></p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p><p><strong>「那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！」</strong></p><p>有同学问了，什么时候for可以从0开始呢？</p><p>求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续会讲到的。</p><p>以示例中nums = [1,2,3]为例把求子集抽象为树型结构，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170615.png" alt=""></p><p>从图中红线部分，可以看出<strong>「遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合」</strong>。</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数参数</li></ul><p>全局变量数组path为子集收集元素，二维数组result存放子集组合。（也可以放到递归函数参数里）</p><p>递归函数参数在上面讲到了，需要startIndex。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">path = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums, startIndex</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>从图中可以看出：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170615.png" alt=""></p><p>剩余集合为空的时候，就是叶子节点。</p><p>那么什么时候剩余集合为空呢？</p><p>就是startIndex已经大于数组的长度了，就终止了，因为没有元素可取了，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(nums):</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>「其实可以不需要加终止条件，因为startIndex &gt;= nums.size()，本层for循环本来也结束了」</strong>。</p><ul><li>单层搜索逻辑</li></ul><p><strong>「求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树」</strong>。</p><p>那么单层递归逻辑代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">    path.append(nums[i])        <span class="comment"># 子集收集元素</span></span><br><span class="line">    backtracking(nums, i + <span class="number">1</span>)   <span class="comment"># 注意从i+1开始，元素不重复取</span></span><br><span class="line">    path.pop()                  <span class="comment"># 回溯</span></span><br></pre></td></tr></table></figure><p>整体代码如下：</p><p>回溯算法模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">参数</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">       存放结果</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择：本层集合中元素（树中节点孩子的数量就是集合的大小）:</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表) <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.backtracking(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, nums, startIndex</span>):</span></span><br><span class="line">        <span class="comment"># 注意处理节点在这里</span></span><br><span class="line">        self.result.append(self.path[:])</span><br><span class="line">        <span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            self.backtracking(nums, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在注释中，可以发现可以不写终止条件，因为本来我们就要遍历整颗树。</p><p>有的同学可能担心不写终止条件会不会无限递归？</p><p>并不会，因为每次递归的下一层就是从i+1开始的。</p><p><strong>子集问题有点简单了，其实这就是一道标准的模板题。</strong></p><p>但是要清楚子集问题和组合问题、分割问题的的区别，<strong>「子集是收集树形结构中树的所有节点的结果」</strong>。</p><p><strong>「而组合问题、分割问题是收集树形结构中叶子节点的结果」</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;求子集问题&quot;&gt;&lt;a href=&quot;#求子集问题&quot; class=&quot;headerlink&quot; title=&quot;求子集问题&quot;&gt;&lt;/a&gt;求子集问题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>22-修剪一颗搜索树</title>
    <link href="https://xxren8218.github.io/20210721/22-%E4%BF%AE%E5%89%AA%E4%B8%80%E9%A2%97%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>https://xxren8218.github.io/20210721/22-%E4%BF%AE%E5%89%AA%E4%B8%80%E9%A2%97%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2021-07-21T09:03:15.000Z</published>
    <updated>2021-07-21T09:05:06.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修剪一颗搜索树"><a href="#修剪一颗搜索树" class="headerlink" title="修剪一颗搜索树"></a>修剪一颗搜索树</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170351.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170407.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题真的不简单！</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>直接想法就是：递归处理，然后遇到 <code>root.val &lt; low or root.val &gt; high</code> 的时候直接return None，一波修改，干净利落。</p><p>不难写出如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">root, low, high</span>):</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val &lt; low <span class="keyword">or</span> root.val &gt; high: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root.left = trimBST(root.left, low, high)</span><br><span class="line">    root.right = trimBST(root.right, low, high)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>「然而[1, 3]区间在二叉搜索树的中可不是单纯的节点3和左孩子节点0就决定的，还要考虑节点0的右子树」</strong>。</p><p>我们在重新关注一下第二个示例，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170429.png" alt=""></p><p><strong>「所以以上的代码是不可行的！」</strong></p><p>从图中可以看出需要重构二叉树，想想是不是本题就有点复杂了。</p><p>其实不用重构那么复杂。</p><p>在上图中我们发现节点0并不符合区间要求，那么将节点0的右孩子 节点2 直接赋给 节点3的左孩子就可以了（就是把节点0从二叉树中移除），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170447.jpg" alt=""></p><p>理解了最关键部分了我们在递归三部曲：</p><ul><li>确定递归函数的参数以及返回值</li></ul><p>这里我们为什么需要返回值呢？</p><p>因为是要遍历整棵树，做修改，其实不需要返回值也可以，我们也可以完成修剪（其实就是从二叉树中移除节点）的操作。</p><p>但是有返回值，更方便，可以通过递归函数的返回值来移除节点。</p><p>这样的做法【搜索树中的插入操作】和【搜索树中的删除操作】中大家已经了解过了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">root, low, high</span>):</span></span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><ul><li>确定单层递归的逻辑</li></ul><p>如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">right = trimBST(root.right, low, high) <span class="comment"># 寻找符合区间[low, high]的节点</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><p>如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &gt; high:</span><br><span class="line">    left = trimBST(root.left, low, high) <span class="comment"># 寻找符合区间[low, high]的节点</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>接下来要将下一层处理完左子树的结果赋给root.left，处理完右子树的结果赋给root.right。</p><p>最后返回root节点，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root.left = trimBST(root.left, low, high) <span class="comment"># root.left接入符合条件的左孩子</span></span><br><span class="line">root.right = trimBST(root.right, low, high) <span class="comment"># root.right接入符合条件的右孩子</span></span><br><span class="line"><span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>此时大家是不是还没发现这多余的节点究竟是如何从二叉树中移除的呢？</p><p>在回顾一下上面的代码，针对下图中二叉树的情况</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170447.jpg" alt=""></p><p>如下代码相当于把节点0的右孩子（节点2）返回给上一层，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">right = trimBST(root.right, low, high) <span class="comment"># 寻找符合区间[low, high]的节点</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><p>然后如下代码相当于用节点3的左孩子 把下一层返回的 节点0的右孩子（节点2） 接住。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.left = trimBST(root.left, low, high)</span><br></pre></td></tr></table></figure><p>此时节点3的右孩子就变成了节点2，将节点0从二叉树中移除了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">self, root, low, high</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type low: int</span></span><br><span class="line"><span class="string">        :type high: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">            right = self.trimBST(root.right, low, high)</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; high:</span><br><span class="line">            left = self.trimBST(root.left, low, high)</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        root.left = self.trimBST(root.left, low, high)</span><br><span class="line">        root.right = self.trimBST(root.right, low, high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>因为二叉搜索树的有序性，不需要使用栈模拟递归的过程。</p><p>在剪枝的时候，可以分为三步：</p><ul><li>将root移动到[L, R] 范围内，注意是左闭右闭区间</li><li>剪枝左子树</li><li>剪枝右子树</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">self, root, low, high</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type low: int</span></span><br><span class="line"><span class="string">        :type high: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">and</span> (root.val &lt; low <span class="keyword">or</span> root.val &gt; high):</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; low: root = root.right <span class="comment"># 小于L往右走</span></span><br><span class="line">            <span class="keyword">else</span>: root = root.left               <span class="comment"># 大于R往右走</span></span><br><span class="line"></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="comment"># 此时root已经在[L, R] 范围内，处理左孩子元素小于L的情况</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur.left <span class="keyword">and</span> cur.left.val &lt; low:</span><br><span class="line">                cur.left = cur.left.right</span><br><span class="line">            </span><br><span class="line">            cur = cur.left</span><br><span class="line"></span><br><span class="line">        cur = root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时root已经在[L, R] 范围内，处理右孩子大于R的情况</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur.right <span class="keyword">and</span> cur.right.val &gt; high:</span><br><span class="line">                cur.right = cur.right.left</span><br><span class="line"></span><br><span class="line">            cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>修剪二叉搜索树其实并不难，但在递归法中大家可看出我费了很大的功夫来讲解如何删除节点的，这个思路其实是比较绕的。</p><p>最终的代码倒是很简洁。</p><p><strong>「如果不对递归有深刻的理解，这道题目还是有难度的！」</strong></p><p>本题我依然给出递归法和迭代法，初学者掌握递归就可以了，如果想进一步学习，就把迭代法也写一写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;修剪一颗搜索树&quot;&gt;&lt;a href=&quot;#修剪一颗搜索树&quot; class=&quot;headerlink&quot; title=&quot;修剪一颗搜索树&quot;&gt;&lt;/a&gt;修剪一颗搜索树&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>09-复原ip地址</title>
    <link href="https://xxren8218.github.io/20210720/09-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80.html"/>
    <id>https://xxren8218.github.io/20210720/09-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80.html</id>
    <published>2021-07-20T09:29:08.000Z</published>
    <updated>2021-07-20T09:30:42.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复原ip地址"><a href="#复原ip地址" class="headerlink" title="复原ip地址"></a>复原ip地址</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210720172946.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>做这道题目之前，最好先把【分割回文串】这个做了。</p><p>这道题目相信大家刚看的时候，应该会一脸茫然。</p><p>其实只要意识到这是切割问题，<strong>「切割问题就可以使用回溯搜索法把所有可能性搜出来」</strong>，和刚做过的【分割回文串】十分类似了。</p><p>切割问题可以抽象为树型结构，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210720173000.png" alt=""></p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归参数</li></ul><p>在【分割回文串】中我们就提到切割问题类似组合问题。</p><p>startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。</p><p>本题我们还需要一个变量pointNum，记录添加逗点的数量。</p><p>所以代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []  <span class="comment"># 记录结果</span></span><br><span class="line"><span class="comment"># startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">s, startIndex, pointNum</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>终止条件和【分割回文串】情况就不同了，本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是<strong>分割的段数作为终止条件。</strong></p><p>pointNum表示逗点数量，pointNum为3说明字符串分成了4段了。</p><p>然后验证一下第四段是否合法，如果合法就加入到结果集里</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pointNum == <span class="number">3</span>:  <span class="comment"># 逗点数量为3时，分隔结束</span></span><br><span class="line">    <span class="comment"># 判断第四段子字符串是否合法，如果合法就放进result中</span></span><br><span class="line">    <span class="keyword">if</span> isValid(s, startIndex, <span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">        result.append(s)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>单层搜索的逻辑</li></ul><p>在【分割回文串】中已经讲过在循环遍历中如何截取子串。</p><p>在<code>for i in range(startIndex, len(s)):</code>循环中 [startIndex, i]这个区间就是截取的子串，需要判断这个子串是否合法。</p><p>如果合法就在字符串后面加上符号<code>.</code>表示已经分割。</p><p>如果不合法就结束本层循环，如图中剪掉的分支：</p><p><img src="C:\Users\Administrator\Desktop\剑指\04_回溯法\09\2.png" alt=""></p><p>然后就是递归和回溯的过程：</p><p>递归调用时，下一层递归的startIndex要从i+2开始（因为需要在字符串中加入了分隔符<code>.</code>），同时记录分割符的数量pointNum 要 +1。</p><p>回溯的时候，就将刚刚加入的分隔符<code>.</code> 删掉就可以了，pointNum也要-1。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">if</span> isValid(s, startIndex, i):            <span class="comment"># 判断 [startIndex,i] 这个区间的子串是否合法</span></span><br><span class="line">            </span><br><span class="line">        tmp = <span class="built_in">list</span>(s)                        <span class="comment"># 在i的后面插入一个逗点</span></span><br><span class="line">        tmp.insert(i + <span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span>.join(tmp)</span><br><span class="line">        pointNum += <span class="number">1</span></span><br><span class="line">        backtracking(s, i + <span class="number">2</span>, pointNum)     <span class="comment"># 插入逗点之后下一个子串的起始位置为i+2</span></span><br><span class="line">        pointNum -= <span class="number">1</span>                        <span class="comment"># 回溯</span></span><br><span class="line">        tmp = <span class="built_in">list</span>(s)</span><br><span class="line">        tmp.pop(i + <span class="number">1</span>)</span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span>.join(tmp)                     <span class="comment"># 回溯删掉逗点</span></span><br><span class="line">                   </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span>                                <span class="comment"># 不合法，直接结束本层循环</span></span><br></pre></td></tr></table></figure><h3 id="判断子串是否合法"><a href="#判断子串是否合法" class="headerlink" title="判断子串是否合法"></a>判断子串是否合法</h3><p>最后就是在写一个判断段位是否是有效段位了。</p><p>主要考虑到如下三点：</p><ul><li>以0为开头的数字不合法</li><li>含有非整数的字符不合法</li><li>大于255不合法</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">s, start, end</span>):</span></span><br><span class="line">    <span class="keyword">if</span> start &gt; end:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> s[start] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> start != end:  <span class="comment">#  0开头的数字不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i] &gt; <span class="string">&#x27;9&#x27;</span> <span class="keyword">or</span> s[i] &lt; <span class="string">&#x27;0&#x27;</span>:      <span class="comment"># 遇到非数字字符不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        num = num * <span class="number">10</span> + (<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> num &gt; <span class="number">255</span>:                     <span class="comment"># 如果大于255了不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据回溯算法的模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">参数</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">       存放结果</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择：本层集合中元素（树中节点孩子的数量就是集合的大小）:</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表)  <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.backtracking(s, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, s, startIndex, pointNum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pointNum == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> self.isValid(s, startIndex, <span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">                self.result.append(s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> self.isValid(s, startIndex, i):</span><br><span class="line">                tmp = <span class="built_in">list</span>(s)                        <span class="comment"># 在i的后面插入一个逗点</span></span><br><span class="line">                tmp.insert(i + <span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                s = <span class="string">&#x27;&#x27;</span>.join(tmp)</span><br><span class="line">                pointNum += <span class="number">1</span></span><br><span class="line">                self.backtracking(s, i + <span class="number">2</span>, pointNum)     <span class="comment"># 插入逗点之后下一个子串的起始位置为i+2</span></span><br><span class="line">                pointNum -= <span class="number">1</span>                        <span class="comment"># 回溯</span></span><br><span class="line">                tmp = <span class="built_in">list</span>(s)</span><br><span class="line">                tmp.pop(i + <span class="number">1</span>)</span><br><span class="line">                s = <span class="string">&#x27;&#x27;</span>.join(tmp)                     <span class="comment"># 回溯删掉逗点</span></span><br><span class="line">                   </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s, start, end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> s[start] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> start != end:  <span class="comment">#  0开头的数字不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] &gt; <span class="string">&#x27;9&#x27;</span> <span class="keyword">or</span> s[i] &lt; <span class="string">&#x27;0&#x27;</span>:       <span class="comment"># 遇到非数字字符不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            num = num * <span class="number">10</span> + (<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">255</span>:                     <span class="comment"># 如果大于255了不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在【分割回文串】列举的分割字符串的难点，本题都覆盖了。</p><p>而且本题还需要操作字符串添加逗号作为分隔符，并验证区间的合法性。</p><p>可以说是【分割回文串】的加强版。</p><p>在本文的树形结构图中，我已经把详细的分析思路都画了出来，相信大家看了之后一定会思路清晰不少！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;复原ip地址&quot;&gt;&lt;a href=&quot;#复原ip地址&quot; class=&quot;headerlink&quot; title=&quot;复原ip地址&quot;&gt;&lt;/a&gt;复原ip地址&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>21-搜索树中的删除操作</title>
    <link href="https://xxren8218.github.io/20210720/21-%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html"/>
    <id>https://xxren8218.github.io/20210720/21-%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html</id>
    <published>2021-07-20T09:27:18.000Z</published>
    <updated>2021-07-20T09:28:42.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜索树中的删除操作"><a href="#搜索树中的删除操作" class="headerlink" title="搜索树中的删除操作"></a>搜索树中的删除操作</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210720172757.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210720172811.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>递归三部曲：</p><ul><li>确定递归函数参数以及返回值</li></ul><p>说道递归函数的返回值，在【搜索树中的插入操作】中通过递归返回值来加入新节点， 这里也可以通过递归返回值删除节点。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">root, key</span>) </span></span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>遇到空返回，其实这也说明没找到删除的节点，遍历到空节点直接返回了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><ul><li>确定单层递归的逻辑</li></ul><p>这里就把平衡二叉树中删除节点遇到的情况都搞清楚。</p><p>有以下五种情况：</p><ul><li><p>第一种情况：没找到删除的节点，遍历到空节点直接返回了</p></li><li><p>找到删除的节点</p></li><li><ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210720172825.gif" alt=""></p><p>动画中颗二叉搜索树中，删除元素7， 那么删除节点（元素7）的左孩子就是5，删除节点（元素7）的右子树的最左面节点是元素8。</p><p>将删除节点（元素7）的左孩子放到删除节点（元素7）的右子树的最左面节点（元素8）的左孩子上，就是把5为根节点的子树移到了8的左孩子的位置。</p><p>要删除的节点（元素7）的右孩子（元素9）为新的根节点。.</p><p>这样就完成删除元素7的逻辑，最好动手画一个图，尝试删除一个节点试试。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val == key:</span><br><span class="line">    <span class="comment"># 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">    <span class="comment"># 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left: <span class="keyword">return</span> root.right </span><br><span class="line">    <span class="comment"># 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> root.left </span><br><span class="line">    <span class="comment"># 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">    <span class="comment"># 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        cur = root.right <span class="comment"># 找右子树最左面的节点</span></span><br><span class="line">        <span class="keyword">while</span> cur.left: </span><br><span class="line">            cur = cur.left</span><br><span class="line"></span><br><span class="line">        cur.left = root.left    <span class="comment"># 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class="line">        tmp = root              <span class="comment"># 把root节点保存一下，下面来删除</span></span><br><span class="line">        root = root.right       <span class="comment"># 返回旧root的右孩子作为新root</span></span><br><span class="line">        <span class="keyword">del</span> tmp                 <span class="comment"># 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>这里相当于把新的节点返回给上一层，上一层就要用 root.left 或者 root.right接住，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &gt; key: root.left = deleteNode(root.left, key)</span><br><span class="line"><span class="keyword">if</span> root.val &lt; key: root.right = deleteNode(root.right, key)</span><br><span class="line"><span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>「整体代码如下：（注释中：情况1，2，3，4，5和上面分析严格对应）」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.val == key:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left: <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = root.right</span><br><span class="line">                <span class="keyword">while</span> cur.left:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                </span><br><span class="line">                cur.left = root.left</span><br><span class="line">                tmp = root</span><br><span class="line">                root = root.right </span><br><span class="line">                <span class="keyword">del</span> tmp</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key: root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key: root.left = self.deleteNode(root.left, key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>读完本篇，大家会发现二叉搜索树删除节点比增加节点复杂的多。</p><p><strong>「因为二叉搜索树添加节点只需要在叶子上添加就可以的，不涉及到结构的调整，而删除节点操作涉及到结构的调整」</strong>。</p><p>这里我们依然使用递归函数的返回值来完成把节点从二叉树中移除的操作。</p><p><strong>「这里最关键的逻辑就是第五种情况（删除一个左右孩子都不为空的节点），这种情况一定要想清楚」</strong>。</p><p>而且就算想清楚了，对应的代码也未必可以写出来，所以<strong>「这道题目即考察思维逻辑，也考察代码能力」</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;搜索树中的删除操作&quot;&gt;&lt;a href=&quot;#搜索树中的删除操作&quot; class=&quot;headerlink&quot; title=&quot;搜索树中的删除操作&quot;&gt;&lt;/a&gt;搜索树中的删除操作&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxre</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>08-分割回文串</title>
    <link href="https://xxren8218.github.io/20210719/08-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html"/>
    <id>https://xxren8218.github.io/20210719/08-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html</id>
    <published>2021-07-19T09:36:53.000Z</published>
    <updated>2021-07-19T09:38:12.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173728.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题涉及到两个关键问题：</p><ol><li>切割问题，有不同的切割方式</li><li>判断回文</li></ol><p>相信这里不同的切割方式可以搞懵很多同学了。</p><p>这种题目，想用for循环暴力解法，可能都不那么容易写出来，所以要换一种暴力的方式，就是回溯。</p><p>一些同学可能想不清楚 回溯究竟是如果切割字符串呢？</p><p>我们来分析一下切割，<strong>「其实切割问题类似组合问题」</strong>。</p><p>例如对于字符串abcdef：</p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选取第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li></ul><p>感受出来了不？</p><p>所以切割问题，也可以抽象为一颗树形结构，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173742.png" alt=""></p><p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p><p>此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数参数</li></ul><p>全局变量数组path存放切割后回文的子串，数组result存放结果集。（这两个参数可以放到函数参数里）</p><p>本题递归函数参数还需要startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。</p><p>在【求组合总和二】中我们深入探讨了组合问题什么时候需要startIndex，什么时候不需要startIndex。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">path = [] <span class="comment"># 放已经回文的子串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span> (<span class="params">s, startIndex</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归函数终止条件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173742.png" alt=""></p><p>从树形结构的图中可以看出：切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止终止条件。</p><p><strong>「那么在代码里什么是切割线呢？」</strong></p><p>在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。</p><p>所以终止条件代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span> (<span class="params">s, startIndex</span>):</span></span><br><span class="line">    <span class="comment"># 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span></span><br><span class="line">    <span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(s):</span><br><span class="line">        result.append(path)</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>单层搜索的逻辑</li></ul><p><strong>「来看看在递归循环，中如何截取子串呢？」</strong></p><p>在<code>for i in range(startIndex, len(s)):</code>循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。</p><p>首先判断这个子串是不是回文，如果是回文，就加入在<code>path</code>中，path用来记录切割过的回文子串。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="comment"># 是回文子串</span></span><br><span class="line">    <span class="keyword">if</span> isPalindrome(s, startIndex, i): </span><br><span class="line">        <span class="comment"># 获取[startIndex,i]在s中的子串</span></span><br><span class="line">        Str = s[startIndex, i - startIndex + <span class="number">1</span>]</span><br><span class="line">        path.append(Str)</span><br><span class="line">    <span class="keyword">else</span>:                <span class="comment"># 如果不是则直接跳过</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">   </span><br><span class="line">    backtracking(s, i + <span class="number">1</span>) <span class="comment"># 寻找i+1为起始位置的子串</span></span><br><span class="line">    path.pop()        <span class="comment"># 回溯过程，弹出本次已经填在的子串</span></span><br></pre></td></tr></table></figure><p><strong>「注意切割过的位置，不能重复切割，所以，backtracking(s, i + 1); 传入下一层的起始位置为i + 1」</strong>。</p><h3 id="判断回文子串"><a href="#判断回文子串" class="headerlink" title="判断回文子串"></a>判断回文子串</h3><p>最后我们看一下回文子串要如何判断了，判断一个字符串是否是回文。</p><p>可以使用双指针法，一个指针从前向后，一个指针从后先前，如果前后指针所指向的元素是相等的，就是回文字符串了。</p><p>那么判断回文的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">s, start, end</span>):</span></span><br><span class="line">    i, j = start, end</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[j]):</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>此时关键代码已经讲解完毕.</p><p>根据回溯算法模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def backtracking(参数) &#123;</span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择：本层集合中元素（树中节点孩子的数量就是集合的大小）:</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表) <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure><p>不难写出如下代码：</p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.backtracking(s, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, s, startIndex</span>):</span></span><br><span class="line">        <span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(s):</span><br><span class="line">            self.result.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> self.isPalandrome(s, startIndex, i):</span><br><span class="line">                Str = s[startIndex: i + <span class="number">1</span>]</span><br><span class="line">                self.path.append(Str)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            self.backtracking(s, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalandrome</span>(<span class="params">self, s, start, end</span>):</span></span><br><span class="line">        i, j = start, end</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题目在leetcode上是中等，但可以说是hard的题目了，但是代码其实就是按照模板的样子来的。</p><p>那么难究竟难在什么地方呢？</p><p><strong>「我列出如下几个难点：」</strong></p><ul><li>切割问题可以抽象为组合问题</li><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><p><strong>「我们平时在做难题的时候，总结出来难究竟难在哪里也是一种需要锻炼的能力」</strong>。</p><p>一些同学可能遇到题目比较难，但是不知道题目难在哪里，反正就是很难。其实这样还是思维不够清晰，这种总结的能力需要多接触多锻炼。</p><p><strong>「本题我相信很多同学主要卡在了第一个难点上：就是不知道如何切割，甚至知道要用回溯法，也不知道如何用。也就是没有体会到按照求组合问题的套路就可以解决切割」</strong>。</p><p>如果意识到这一点，算是重大突破了。接下来就可以对着模板照葫芦画瓢。</p><p><strong>「但接下来如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了」</strong>。</p><p>除了这些难点，<strong>「本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1」</strong>。</p><p>所以本题应该是一个道hard题目了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分割回文串&quot;&gt;&lt;a href=&quot;#分割回文串&quot; class=&quot;headerlink&quot; title=&quot;分割回文串&quot;&gt;&lt;/a&gt;分割回文串&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>20-搜索树中的插入操作</title>
    <link href="https://xxren8218.github.io/20210719/20-%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html"/>
    <id>https://xxren8218.github.io/20210719/20-%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html</id>
    <published>2021-07-19T09:35:24.000Z</published>
    <updated>2021-07-19T09:36:34.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜索树中的插入操作"><a href="#搜索树中的插入操作" class="headerlink" title="搜索树中的插入操作"></a>搜索树中的插入操作</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173551.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173604.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实这道题目其实是一道简单题目，<strong>「但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人」</strong>，瞬间感觉题目复杂了很多。</p><p>其实<strong>「可以不考虑题目中提示所说的改变树的结构的插入方式。」</strong></p><p>如下演示视频中可以看出：只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173621.gif" alt=""></p><p>例如插入元素10 ，需要找到末尾节点插入便可，一样的道理来插入元素15，插入元素0，插入元素6，<strong>「需要调整二叉树的结构么？并不需要。」</strong>。</p><p>只要遍历二叉搜索树，找到空节点 插入元素就可以了，那么这道题其实就简单了。</p><p>接下来就是遍历二叉搜索树的过程了。</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归三部曲：</p><ul><li>确定递归函数参数以及返回值</li></ul><p>参数就是根节点指针，以及要插入元素，这里递归函数要不要有返回值呢？</p><p>可以有，也可以没有，但递归函数如果没有返回值的话，实现是比较麻烦的，下面也会给出其具体实现代码。</p><p><strong>「有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作」</strong>。（下面会进一步解释）</p><p>递归函数的返回类型为节点类型 。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">root, val</span>) </span></span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>终止条件就是找到遍历的节点为None的时候，就是要插入节点的位置了，并把插入的节点返回。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">    node = TreeNode(val)</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p>这里把添加的节点返回给上一层，就完成了父子节点的赋值操作了，详细再往下看。</p><ul><li>确定单层递归的逻辑</li></ul><p>此时要明确，需要遍历整棵树么？</p><p>别忘了这是搜索树，遍历整颗搜索树简直是对搜索树的侮辱，哈哈。</p><p>搜索树是有方向了，可以根据插入元素的数值，决定递归方向。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &gt; val: </span><br><span class="line">    root.left = insertIntoBST(root.left, val)</span><br><span class="line">if root-&gt;val &lt; val: </span><br><span class="line">    root.right = insertIntoBST(root.right, val)</span><br><span class="line"><span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>「到这里，大家应该能感受到，如何通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root.left或者root.right将其接住」</strong>。</p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            node = TreeNode(val)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            root.left = self.insertIntoBST(root.left, val)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            root.right = self.insertIntoBST(root.right, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>再来看看迭代法，对二叉搜索树迭代写法不熟悉，可以看：【二叉搜索树】</p><p>在迭代法遍历的过程中，需要记录一下当前遍历的节点的父节点，这样才能做插入节点的操作。</p><p>在【搜索树的最小绝对差】和【二叉树的众数】中，都是用了记录pre和cur两个指针的技巧，本题也是一样的。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            node = TreeNode(val)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        parent = root</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            parent = cur</span><br><span class="line">            <span class="keyword">if</span> cur.val &gt; val: </span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">        node = TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> val &lt; parent.val:</span><br><span class="line">            parent.left = node</span><br><span class="line">        <span class="keyword">if</span> val &gt; parent.val:</span><br><span class="line">            parent.right = node </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先在二叉搜索树中的插入操作，大家不用恐惧其重构搜索树，其实根本不用重构。</p><p>然后在递归中，我们重点讲了如果通过递归函数的返回值完成新加入节点和其父节点的赋值操作，并强调了搜索树的有序性。</p><p>最后依然给出了迭代的方法，迭代的方法就需要记录当前遍历节点的父节点了，这个和没有返回值的递归函数实现的代码逻辑是一样的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;搜索树中的插入操作&quot;&gt;&lt;a href=&quot;#搜索树中的插入操作&quot; class=&quot;headerlink&quot; title=&quot;搜索树中的插入操作&quot;&gt;&lt;/a&gt;搜索树中的插入操作&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxre</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>19-搜索树的公共祖先问题</title>
    <link href="https://xxren8218.github.io/20210719/19-%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210719/19-%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98.html</id>
    <published>2021-07-19T09:33:30.000Z</published>
    <updated>2021-07-19T09:35:07.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜索树的公共祖先问题"><a href="#搜索树的公共祖先问题" class="headerlink" title="搜索树的公共祖先问题"></a>搜索树的公共祖先问题</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173438.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>做过【公共祖先问题】题目的同学应该知道，利用回溯从底向上搜索，遇到一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。</p><p>那么本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。</p><p>在有序树里，如果判断一个节点的左子树里有p，右子树里有q呢？</p><p>其实只要从上到下遍历的时候，cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了。</p><p>理解这一点，本题就很好解了。</p><p>和【公共祖先问题】不同，普通二叉树求最近公共祖先需要使用回溯，从底向上来查找，二叉搜索树就不用了，因为搜索树有序（相当于自带方向），那么只要从上向下遍历就可以了。</p><p>那么我们可以采用前序遍历（其实这里没有中节点的处理逻辑，遍历顺序无所谓了）。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173452.png" alt=""></p><p>可以看出直接按照指定的方向，就可以找到节点4，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！</p><p>递归三部曲如下：</p><ul><li>确定递归函数返回值以及参数</li></ul><p>参数就是 当前节点，以及两个结点 p、q。</p><p>返回值是要返回最近公共祖先，所以是  。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">cur, p, q</span>) </span></span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>遇到空返回就可以了，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>其实都不需要这个终止条件，因为题目中说了p、q 为不同节点且均存在于给定的二叉搜索树中。也就是说一定会找到公共祖先的，所以并不存在遇到空的情况。</p><ul><li>确定单层递归的逻辑</li></ul><p>在遍历二叉搜索树的时候就是寻找区间[p.val, q.val]（注意这里是左闭右闭）</p><p>那么如果 cur.val 大于 p.val，同时 cur.val 大于q.val，那么就应该向左遍历（说明目标区间在左子树上）。</p><p><strong>「需要注意的是此时不知道p和q谁大，所以两个都要判断」</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cur.val &gt; p.val <span class="keyword">and</span> cur.val &gt; q.val:</span><br><span class="line">    left = traversal(cur.left, p, q)</span><br><span class="line">    <span class="keyword">if</span> left:</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>「细心的同学会发现，在这里调用递归函数的地方，把递归函数的返回值left，直接return」</strong>。</p><p>在【公共祖先问题】中，如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树。</p><p>搜索一条边的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 递归函数(root.left)： <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 递归函数(root.right)： <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>搜索整个树写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root.left)</span><br><span class="line">right = 递归函数(root.right)</span><br><span class="line">left与right的逻辑处理</span><br></pre></td></tr></table></figure><p>本题就是标准的搜索一条边的写法，遇到递归函数的返回值，如果不为空，立刻返回。</p><p>如果 cur.val 小于 p.val，同时 cur.val 小于 q.val，那么就应该向右遍历（目标区间在右子树）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cur.val &lt; p.val <span class="keyword">and</span> cur.val &lt; q.val:</span><br><span class="line">    right = traversal(cur.right, p, q)</span><br><span class="line">    <span class="keyword">if</span> right:</span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><p>剩下的情况，就是cur节点在区间（p.val &lt;=  cur.val and cur.val &lt;= q.val）或者 （q.val &lt;=  cur.val and cur.val &lt;= p.val）中，那么cur就是最近公共祖先了，直接返回cur。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><p>那么整体递归代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.traversal(root, p, q)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, cur, p, q</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; p.val <span class="keyword">and</span> cur.val &lt; q.val:</span><br><span class="line">            right = self.traversal(cur.right, p, q)</span><br><span class="line">            <span class="keyword">if</span> right: <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">elif</span> cur.val &gt; p.val <span class="keyword">and</span> cur.val &gt; q.val:</span><br><span class="line">            left = self.traversal(cur.left, p, q)</span><br><span class="line">            <span class="keyword">if</span> left: <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>对于二叉搜索树的迭代法，大家应该在【二叉搜索树】就了解了。</p><p>利用其有序性，迭代的方式还是比较简单的，解题思路在递归中已经分析了。</p><p>迭代代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">elif</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>灵魂拷问：是不是又被简单的迭代法感动到痛哭流涕？</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于二叉搜索树的最近祖先问题，其实要比【普通二叉树公共祖先问题】简单的多。</p><p>不用使用回溯了，二叉搜索树自带方向性，可以方便的从上向下查找目标区间，遇到目标区间内的节点，直接返回。</p><p>最后给出了对应的迭代法，二叉搜索树的迭代法甚至比递归更容易理解，也是因为其有序性（自带方向性），按照目标区间找就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;搜索树的公共祖先问题&quot;&gt;&lt;a href=&quot;#搜索树的公共祖先问题&quot; class=&quot;headerlink&quot; title=&quot;搜索树的公共祖先问题&quot;&gt;&lt;/a&gt;搜索树的公共祖先问题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>07-求组和总和三</title>
    <link href="https://xxren8218.github.io/20210716/07-%E6%B1%82%E7%BB%84%E5%92%8C%E6%80%BB%E5%92%8C%E4%B8%89.html"/>
    <id>https://xxren8218.github.io/20210716/07-%E6%B1%82%E7%BB%84%E5%92%8C%E6%80%BB%E5%92%8C%E4%B8%89.html</id>
    <published>2021-07-16T14:26:03.000Z</published>
    <updated>2021-07-16T14:27:16.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="求组合总和三"><a href="#求组合总和三" class="headerlink" title="求组合总和三"></a>求组合总和三</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222634.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目和【组合总和】如下区别：</p><ol><li>本题candidates 中的每个数字在每个组合中只能使用一次。</li><li>本题数组candidates的元素是有重复的，而【组合总和】是无重复元素的数组candidates</li></ol><p>最后本题和【组合总和】要求一样，解集不能包含重复的组合。</p><p><strong>「本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合」</strong>。</p><p>一些同学可能想了：我把所有组合求出来，再用set或者map去重，这么做很容易超时！</p><p>所以要在搜索的过程中就去掉重复组合。</p><p>很多同学在去重的问题上想不明白，其实很多题解也没有讲清楚，反正代码是能过的，感觉是那么回事，稀里糊涂的先把题目过了。</p><p>这个去重为什么很难理解呢，<strong>「所谓去重，其实就是使用过的元素不能重复选取。」</strong>这么一说好像很简单！</p><p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<strong>「没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。」</strong></p><p>那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？</p><p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>「所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重」</strong>。</p><p>为了理解去重我们来举一个例子，candidates = [1, 1, 2], target = 3，（方便起见candidates已经排序了）</p><p>选择过程树形结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222650.png" alt=""></p><p>可以看到图中，每个节点相对于 【组合总和】我多加了used数组，这个used数组下面会重点介绍。</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li><strong>「递归函数参数」</strong></li></ul><p>与【组合总和】套路相同，此题还需要加一个bool型数组used，用来记录同一树枝上的元素是否使用过。</p><p>这个集合去重的重任就是used来完成的。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []                 <span class="comment"># 存放组合集合</span></span><br><span class="line">path = []                   <span class="comment"># 符合条件的组合</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">candidates, target, Sum, startIndex, used</span>):</span></span><br></pre></td></tr></table></figure><ul><li><strong>「递归终止条件」</strong></li></ul><p>与【组合总和】套路相同，终止条件为 <code>sum &gt; target</code> 和 <code>sum == target</code>。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> Sum &gt; target:     <span class="comment"># 这个条件其实可以省略 </span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Sum == target: </span><br><span class="line">    result.append(path)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>Sum &gt; target</code> 这个条件其实可以省略，因为和在递归单层遍历的时候，会有剪枝的操作，下面会介绍到。</p><ul><li><strong>「单层搜索的逻辑」</strong></li></ul><p>这里与【组合总和】最大的不同就是要去重了。</p><p>前面我们提到：要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。</p><p><strong>「如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == False</code>，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]」</strong>。</p><p>此时for循环里就应该做continue的操作。</p><p>这块比较抽象，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222705.png" alt=""></p><p>我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：</p><ul><li>used[i - 1] == True，说明同一树支candidates[i - 1]使用过</li><li>used[i - 1] == False，说明同一树层candidates[i - 1]使用过</li></ul><p><strong>「这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！」</strong></p><p>那么单层搜索的逻辑代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">    <span class="keyword">if</span> Sum + candidates[i] &lt;= target:</span><br><span class="line">    <span class="comment"># used[i - 1] == True，说明同一树支candidates[i - 1]使用过</span></span><br><span class="line">    <span class="comment"># used[i - 1] == False，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">    <span class="comment"># 要对同一树层使用过的元素进行跳过</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        Sum += candidates[i]</span><br><span class="line">        path.append(candidates[i])</span><br><span class="line">        used[i] = <span class="literal">True</span></span><br><span class="line">        backtracking(candidates, target, Sum, i + <span class="number">1</span>, used) <span class="comment"># 和组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次</span></span><br><span class="line">        used[i] = <span class="literal">False</span></span><br><span class="line">        Sum -= candidates[i]</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure><p><strong>「注意sum + candidates[i] &lt;= target为剪枝操作，在【组合总和】有讲解过！」</strong></p><p>整体代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates: <span class="keyword">return</span> []</span><br><span class="line">        used = [<span class="literal">False</span>]*<span class="built_in">len</span>(candidates)</span><br><span class="line">        <span class="comment"># 首先把给candidates排序，让其相同的元素都挨在一起。</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>, used)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, candidates, target, Sum, startIndex, used</span>):</span></span><br><span class="line">        <span class="keyword">if</span> Sum == target: self.result.append(self.path[:])</span><br><span class="line">        <span class="keyword">if</span> Sum &gt; target: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.path.append(candidates[i])</span><br><span class="line">            Sum += candidates[i]</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            self.backtracking(candidates, target, Sum, i + <span class="number">1</span>, used)</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">            Sum -= candidates[i]</span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题同样是求组合总和，但就是因为其数组candidates有重复元素，而要求不能有重复的组合，所以相对于【组合求和】难度提升了不少。</p><p><strong>「关键是去重的逻辑，代码很简单，网上一搜一大把，但几乎没有能把这块代码含义讲明白的，基本都是给出代码，然后说这就是去重了，究竟怎么个去重法也是模棱两可」</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;求组合总和三&quot;&gt;&lt;a href=&quot;#求组合总和三&quot; class=&quot;headerlink&quot; title=&quot;求组合总和三&quot;&gt;&lt;/a&gt;求组合总和三&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>06-求组和总和二</title>
    <link href="https://xxren8218.github.io/20210716/06-%E6%B1%82%E7%BB%84%E5%92%8C%E6%80%BB%E5%92%8C%E4%BA%8C.html"/>
    <id>https://xxren8218.github.io/20210716/06-%E6%B1%82%E7%BB%84%E5%92%8C%E6%80%BB%E5%92%8C%E4%BA%8C.html</id>
    <published>2021-07-16T14:23:43.000Z</published>
    <updated>2021-07-16T14:25:26.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="求组合总和"><a href="#求组合总和" class="headerlink" title="求组合总和"></a>求组合总和</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222421.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目中的<strong>「无限制重复被选取，吓得我赶紧想想 出现0 可咋办」</strong>，然后看到下面提示：1 &lt;= candidates[i] &lt;= 200，我就放心了。</p><p>本题和【求组合问题】和【求组合总和】区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。</p><p>本题搜索的过程抽象成树形结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222435.jpg" alt=""></p><p>注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！</p><p>而在[求组合问题)和[求组合总和] 中都可以知道要递归K层，因为要取k个元素的组合</p><p>回溯三部曲</p><ul><li>递归函数参数</li></ul><p>这里依然是定义两个全局变量，二维数组result存放结果集，数组path存放符合条件的结果。（这两个变量可以作为函数参数传入）</p><p>首先是题目中给出的参数，集合candidates, 和目标值target。</p><p>此外我还定义了int型的sum变量来统计单一结果path里的总和，其实这个Sum也可以不用，用target做相应的减法就可以了，最后如何target==0就说明找到符合的结果了，但为了代码逻辑清晰，我依然用了Sum。</p><p><strong>「本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？」</strong></p><p>我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如【求组合问题】和【求组合总和】</p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：【电话号码的字母组合】</p><p><strong>「注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍」</strong>。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">path = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">candidates, target, Sum, startIndex</span>) </span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>在如下树形结构中：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222453.jpg" alt=""></p><p>从叶子节点可以清晰看到，终止只有两种情况，Sum大于target和Sum等于target。</p><p>sum等于target的时候，需要收集结果，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> Sum &gt; target:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Sum == target:</span><br><span class="line">    result.append(path[:])</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>单层搜索的逻辑</li></ul><p>单层for循环依然是从startIndex开始，搜索candidates集合。</p><p><strong>「注意本题和[求组合问题]、[求组合总和]的一个区别是：本题元素为可重复选取的」</strong>。</p><p>如何重复选取呢，看代码，注释部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">    Sum += candidates[i]</span><br><span class="line">    path.append(candidates[i])</span><br><span class="line">    backtracking(candidates, target, Sum, i) <span class="comment"># 关键点:不用i+1了，表示可以重复读取当前的数</span></span><br><span class="line">    <span class="built_in">sum</span> -= candidates[i];   <span class="comment"># 回溯</span></span><br><span class="line">    path.pop()        <span class="comment"># 回溯</span></span><br></pre></td></tr></table></figure><p>按照回溯算法的的模板，不难写出完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates: <span class="keyword">return</span></span><br><span class="line">        self.backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, candidates, target, Sum, startIndex</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> Sum == target:</span><br><span class="line">            self.result.append(self.path[:])</span><br><span class="line">        <span class="keyword">if</span> Sum &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            Sum += candidates[i]</span><br><span class="line">            self.path.append(candidates[i])</span><br><span class="line">            self.backtracking(candidates, target, Sum, i)</span><br><span class="line">            Sum -= candidates[i]</span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><h3 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h3><p>在这个树形结构中：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222453.jpg" alt=""></p><p>以及上面的版本一的代码大家可以看到，对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum &gt; target的话就返回。</p><p>其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。</p><p>那么可以在for循环的搜索范围上做做文章了。</p><p><strong>「对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历」</strong>。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222516.jpg" alt=""></p><p>for循环剪枝代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates))： </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">sum</span> + candidates[i] &gt; target:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates: <span class="keyword">return</span></span><br><span class="line">        self.backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, candidates, target, Sum, startIndex</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> Sum == target:</span><br><span class="line">            self.result.append(self.path[:])</span><br><span class="line">        <span class="keyword">if</span> Sum &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            <span class="keyword">if</span> Sum + candidates[i] &gt; target:  <span class="comment"># 剪枝判断</span></span><br><span class="line">                <span class="keyword">continue</span>                      <span class="comment"># 剪枝操作。</span></span><br><span class="line">            Sum += candidates[i]</span><br><span class="line">            self.path.append(candidates[i])</span><br><span class="line">            self.backtracking(candidates, target, Sum, i)</span><br><span class="line">            Sum -= candidates[i]</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题和我们之前讲过的【求组合问题】【求组合总和】有两点不同：</p><ul><li>组合没有数量要求</li><li>元素可无限重复选取</li></ul><p>针对这两个问题，我都做了详细的分析。</p><p>并且给出了对于组合问题，什么时候用startIndex，什么时候不用，并用【电话号码的字母组合】做了对比。</p><p>最后还给出了本题的剪枝优化，这个优化如果是初学者的话并不容易想到。</p><p><strong>「在求和问题中，排序之后加剪枝是常见的套路！」</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;求组合总和&quot;&gt;&lt;a href=&quot;#求组合总和&quot; class=&quot;headerlink&quot; title=&quot;求组合总和&quot;&gt;&lt;/a&gt;求组合总和&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>18-最近公共祖先问题</title>
    <link href="https://xxren8218.github.io/20210716/18-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210716/18-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98.html</id>
    <published>2021-07-16T14:20:27.000Z</published>
    <updated>2021-07-16T14:23:07.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近公共祖先问题"><a href="#最近公共祖先问题" class="headerlink" title="最近公共祖先问题"></a>最近公共祖先问题</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222145.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222203.PNG" alt=""></p><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。</p><p>那么二叉树如何可以自底向上查找呢？</p><p>回溯啊，二叉树回溯的过程就是从低到上。</p><p>后序遍历就是天然的回溯过程，最先处理的一定是叶子节点。</p><p>接下来就看如何判断一个节点是节点q和节点p的公共公共祖先呢。</p><p><strong>「如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。」</strong></p><p>使用后序遍历，回溯的过程，就是从低向上遍历节点，一旦发现如何这个条件的节点，就是最近公共节点了。</p><p>递归三部曲：</p><ul><li>确定递归函数返回值以及参数</li></ul><p>需要递归函数返回值，来告诉我们是否找到节点q或者p，那么返回值为bool类型就可以了。</p><p>但我们还要返回最近公共节点，可以利用上题目中返回值是节点 ，那么如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">root, p, q</span>)</span></span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>如果找到了 节点p或者q，或者遇到空节点，就返回。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root == q <span class="keyword">or</span> root == p <span class="keyword">or</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><ul><li>确定单层递归逻辑</li></ul><p>值得注意的是 本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。</p><p><strong>递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！</strong></p><p>如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？</p><p>搜索一条边的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 递归函数(root.left): <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 递归函数(root.right): <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>搜索整个树写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root.left)</span><br><span class="line">right = 递归函数(root.right)</span><br><span class="line">left与right的逻辑处理</span><br></pre></td></tr></table></figure><p>看出区别了没？</p><p><strong>「在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）」</strong></p><p>那么为什么要遍历整颗树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了</p><p>如图:</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222225.png" alt=""></p><p>就像图中一样直接返回7，多美滋滋。</p><p>但事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点4、15、20。</p><p>因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root.left)</span><br><span class="line">right = 递归函数(root.right)</span><br><span class="line">left与right的逻辑处理</span><br></pre></td></tr></table></figure><p>所以此时大家要知道我们要遍历整棵树。知道这一点，对本题就有一定深度的理解了。</p><p>那么先用left和right接住左子树和右子树的返回值，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">right = lowestCommonAncestor(root.right, p, q)</span><br></pre></td></tr></table></figure><p><strong>「如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解」</strong></p><p><strong>「如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然」</strong>。</p><p>这里有的同学就理解不了了，为什么left为空，right不为空，目标节点通过right返回呢？</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222237.jpg" alt=""></p><p>图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！</p><p>这里点也很重要，可能刷过这道题目的同学，都不清楚结果究竟是如何从底层一层一层传到头结点的。</p><p>那么如果left和right都为空，则返回left或者right都是可以的，也就是返回空。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> right: <span class="keyword">return</span> right</span><br><span class="line"><span class="keyword">elif</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>那么寻找最小公共祖先，完整流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222253.png" alt=""></p><p><strong>「从图中，大家可以看到，我们是如何回溯遍历整颗二叉树，将结果返回给头结点的！」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root, p, q)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q <span class="keyword">or</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">        left = self.dfs(root.left, p, q)    </span><br><span class="line">        right = self.dfs(root.right, p, q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right: <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> left <span class="keyword">and</span> right: <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">elif</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题目刷过的同学未必真正了解这里面回溯的过程，以及结果是如何一层一层传上去的。</p><p><strong>「那么我给大家归纳如下三点」</strong>：</p><ol><li>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。</li><li>在回溯的过程中，必然要遍历整颗二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</li><li>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</li></ol><p>可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。</p><p>本题没有给出迭代法，因为迭代法不适合模拟回溯的过程。理解递归的解法就够了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最近公共祖先问题&quot;&gt;&lt;a href=&quot;#最近公共祖先问题&quot; class=&quot;headerlink&quot; title=&quot;最近公共祖先问题&quot;&gt;&lt;/a&gt;最近公共祖先问题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren821</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>05-电话号码的字母组合</title>
    <link href="https://xxren8218.github.io/20210715/05-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html"/>
    <id>https://xxren8218.github.io/20210715/05-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html</id>
    <published>2021-07-15T13:57:48.000Z</published>
    <updated>2021-07-15T13:58:54.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210715215824.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从示例上来说，输入”23”，最直接的想法就是两层for循环遍历了吧，正好把组合的情况都输出了。</p><p>如果输入”233”呢，那么就三层for循环，如果”2333”呢，就四层for循环…….</p><p>大家应该感觉出和【求组合问题】遇到的一样的问题，就是这for循环的层数如何写出来，此时又是回溯法登场的时候了。</p><p>理解本题后，要解决如下三个问题：</p><ol><li>数字和字母如何映射</li><li>两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来</li><li>输入1 * #按键等等异常情况</li></ol><h3 id="数字和字母如何映射"><a href="#数字和字母如何映射" class="headerlink" title="数字和字母如何映射"></a>数字和字母如何映射</h3><p>可以使用map或者定义一个数组，来做映射，我这里定义一个数组，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">letterMap = [</span><br><span class="line">    <span class="string">&quot;&quot;</span>,     <span class="comment"># 0</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>,     <span class="comment"># 1</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>,  <span class="comment"># 2</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>,  <span class="comment"># 3</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>,  <span class="comment"># 4</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>,  <span class="comment"># 5</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>,  <span class="comment"># 6</span></span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, <span class="comment"># 7</span></span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>,  <span class="comment"># 8</span></span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, <span class="comment"># 9</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="回溯法来解决n个for循环的问题"><a href="#回溯法来解决n个for循环的问题" class="headerlink" title="回溯法来解决n个for循环的问题"></a>回溯法来解决n个for循环的问题</h3><p>输入：”23”，抽象为树形结构，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210715215839.png" alt=""></p><p>图中可以看出遍历的深度，就是输入”23”的长度，而叶子节点就是我们要收集的结果，输出[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]。</p><p>回溯三部曲：</p><ul><li>确定回溯函数参数</li></ul><p>首先需要一个字符串s来收集叶子节点的结果，然后用一个字符串数组result保存起来，这两个变量我依然定义为全局。</p><p>再来看参数，参数指定是有题目中给的digits，然后还要有一个参数就是index。</p><p>注意这个index可不是[<code>求组合总和</code>]中的startIndex了。</p><p>这个index是记录遍历第几个数字了，就是用来遍历digits的（题目中给出数字字符串），同时index也表示树的深度。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">digits, index</span>) </span></span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>例如输入用例”23”，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。</p><p>那么终止条件就是如果index 等于 输入的数字个数<code>len(digits)</code>了（本来index就是用来遍历digits的）。</p><p>然后收集结果，结束本层递归。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> index == <span class="built_in">len</span>(digits): </span><br><span class="line">result.append(s)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>确定单层遍历逻辑</li></ul><p>首先要取index指向的数字，并找到对应的字符集（手机键盘的字符集）。</p><p>然后for循环来处理这个字符集，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">digit = <span class="built_in">int</span>(digits[index])        <span class="comment"># 将index指向的数字转为int</span></span><br><span class="line">letters = letterMap[digit]      <span class="comment"># 取数字对应的字符集</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(letters)):</span><br><span class="line">    s += letters[i]            <span class="comment"># 处理</span></span><br><span class="line">    backtracking(digits, index + <span class="number">1</span>)    <span class="comment"># 递归，注意index+1，一下层要处理下一个数字了</span></span><br><span class="line">    s = s[:-<span class="number">1</span>]                       <span class="comment"># 回溯</span></span><br></pre></td></tr></table></figure><p><strong>「注意这里for循环，可不像是在[求组合问题]和[求组合总和]中从startIndex开始遍历的」</strong>。</p><p><strong>「因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而[77. 组合]和[216.组合总和III]都是是求同一个集合中的组合！」</strong></p><h3 id="输入1-按键等等异常情况"><a href="#输入1-按键等等异常情况" class="headerlink" title="输入1 * #按键等等异常情况"></a>输入1 * #按键等等异常情况</h3><p>代码中最好考虑这些异常情况，但题目的测试数据中应该没有异常情况的数据，所以我就没有加了。</p><p><strong>「但是要知道会有这些异常，如果是现场面试中，一定要考虑到！」</strong></p><p>最终代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        self.letterMap = [</span><br><span class="line">            <span class="string">&quot;&quot;</span>,     <span class="comment"># 0</span></span><br><span class="line">            <span class="string">&quot;&quot;</span>,     <span class="comment"># 1</span></span><br><span class="line">            <span class="string">&quot;abc&quot;</span>,  <span class="comment"># 2</span></span><br><span class="line">            <span class="string">&quot;def&quot;</span>,  <span class="comment"># 3</span></span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>,  <span class="comment"># 4</span></span><br><span class="line">            <span class="string">&quot;jkl&quot;</span>,  <span class="comment"># 5</span></span><br><span class="line">            <span class="string">&quot;mno&quot;</span>,  <span class="comment"># 6</span></span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="comment"># 7</span></span><br><span class="line">            <span class="string">&quot;tuv&quot;</span>,  <span class="comment"># 8</span></span><br><span class="line">            <span class="string">&quot;wxyz&quot;</span>, <span class="comment"># 9</span></span><br><span class="line">        ]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        self.backtrackong(digits, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrackong</span>(<span class="params">self, digits, index</span>):</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(digits):</span><br><span class="line">            self.result.append(self.s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        digit = <span class="built_in">int</span>(digits[index])</span><br><span class="line">        letters = self.letterMap[digit]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(letters)):</span><br><span class="line">            self.s += letters[i]</span><br><span class="line">            self.backtrackong(digits, index + <span class="number">1</span>)</span><br><span class="line">            self.s = self.s[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇将题目的三个要点一一列出，并重点强调了和前面讲解过的[77. 组合]和[216.组合总和III]的区别，本题是多个集合求组合，所以在回溯的搜索过程中，都有一些细节需要注意的。</p><p>其实本题不算难，但也处处是细节，大家还要自己亲自动手写一写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;电话号码的字母组合&quot;&gt;&lt;a href=&quot;#电话号码的字母组合&quot; class=&quot;headerlink&quot; title=&quot;电话号码的字母组合&quot;&gt;&lt;/a&gt;电话号码的字母组合&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxre</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>17-二叉搜素树的众数</title>
    <link href="https://xxren8218.github.io/20210715/17-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A0%E6%A0%91%E7%9A%84%E4%BC%97%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210715/17-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A0%E6%A0%91%E7%9A%84%E4%BC%97%E6%95%B0.html</id>
    <published>2021-07-15T13:56:03.000Z</published>
    <updated>2021-07-15T13:57:13.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜素树的众数"><a href="#二叉搜素树的众数" class="headerlink" title="二叉搜素树的众数"></a>二叉搜素树的众数</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210715215704.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目呢，递归法我从两个维度来做。</p><p>首先如果不是二叉搜索树的话，应该怎么解题，是二叉搜索树，又应该如何解题，两种方式做一个比较，可以加深大家对二叉树的理解。</p><h3 id="递归法：不是二叉搜索树"><a href="#递归法：不是二叉搜索树" class="headerlink" title="递归法：不是二叉搜索树"></a>递归法：不是二叉搜索树</h3><p>如果不是二叉搜索树，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。</p><p>具体步骤如下：</p><ol><li>这个树都遍历了，用map统计频率</li></ol><p>至于用前中后序那种遍历也不重要，因为就是要全遍历一遍，怎么个遍历法都行，层序遍历都没毛病！</p><p>这里采用前序遍历，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Map = &#123;&#125; key:元素，value:出现频率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">cur</span>):</span>  <span class="comment"># 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> cur.val <span class="keyword">not</span> <span class="keyword">in</span> Map:</span><br><span class="line">        Map[cur.val] = <span class="number">0</span></span><br><span class="line">    Map[cur.val] += <span class="number">1</span> <span class="comment"># 统计元素频率</span></span><br><span class="line">    traversal(cur.left)</span><br><span class="line">    traversal(cur.right)</span><br></pre></td></tr></table></figure><ol><li>把统计的出来的出现频率（即map中的value）排个序</li></ol><p>直接对map中的value排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map = <span class="built_in">sorted</span>( Map.items(),key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ol><li>取前面高频的元素</li></ol><p>那么把前面高频的元素取出来就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Map)):</span><br><span class="line">    <span class="keyword">if</span> v &gt;= <span class="number">2</span>:</span><br><span class="line">        result.append(k)</span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉搜素树的众数&quot;&gt;&lt;a href=&quot;#二叉搜素树的众数&quot; class=&quot;headerlink&quot; title=&quot;二叉搜素树的众数&quot;&gt;&lt;/a&gt;二叉搜素树的众数&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren821</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>16-二叉搜索树的最小绝对差</title>
    <link href="https://xxren8218.github.io/20210715/16-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html"/>
    <id>https://xxren8218.github.io/20210715/16-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html</id>
    <published>2021-07-15T13:52:04.000Z</published>
    <updated>2021-07-15T13:55:34.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210715215250.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p><p><strong>「注意是二叉搜索树」</strong>，二叉搜索树可是有序的。</p><p>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>那么二叉搜索树采用中序遍历，其实就是一个有序数组。</p><p><strong>「在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。」</strong></p><p>最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    traversal(root.left)</span><br><span class="line">    li.append(root.val)</span><br><span class="line">    traversal(root.right)</span><br></pre></td></tr></table></figure><p>以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</p><p>需要用一个pre节点记录一下cur节点的前一个节点。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210715215520.png" alt=""></p><p>一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">cur</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">    traversal(cur.left)     <span class="comment"># 左</span></span><br><span class="line">    <span class="keyword">if</span> pre:                 <span class="comment"># 中</span></span><br><span class="line">        result = <span class="built_in">min</span>(result, cur.val - pre.val)</span><br><span class="line">    pre = cur <span class="comment"># 记录前一个</span></span><br><span class="line">    traversal(cur.right)    <span class="comment"># 右</span></span><br></pre></td></tr></table></figure><p>是不是看上去也并不复杂！</p><p>整体代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        self.result = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, cur</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">        self.traversal(cur.left)</span><br><span class="line">        <span class="keyword">if</span> self.pre:</span><br><span class="line">            self.result = <span class="built_in">min</span>(self.result, <span class="built_in">abs</span>(cur.val - self.pre.val))</span><br><span class="line">        self.pre = cur</span><br><span class="line">        self.traversal(cur.right)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>「遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。」</strong></p><p>同时要学会在递归遍历的过程中如何记录前后两个指针，这也是一个小技巧，学会了还是很受用的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉搜索树的最小绝对差&quot;&gt;&lt;a href=&quot;#二叉搜索树的最小绝对差&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的最小绝对差&quot;&gt;&lt;/a&gt;二叉搜索树的最小绝对差&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>04-求组合总和</title>
    <link href="https://xxren8218.github.io/20210713/04-%E6%B1%82%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html"/>
    <id>https://xxren8218.github.io/20210713/04-%E6%B1%82%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html</id>
    <published>2021-07-13T10:23:07.000Z</published>
    <updated>2021-07-13T10:24:30.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="求组合总和"><a href="#求组合总和" class="headerlink" title="求组合总和"></a>求组合总和</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210713182331.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题就是在[1,2,3,4,5,6,7,8,9]这个集合中找到和为n的k个数的组合。</p><p>相对于求组合问题，无非就是多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的了[1,…,9]。</p><p>想到这一点了，做过[77. 组合]之后，本题是简单一些了。</p><p>本题k相当于了树的深度，9（因为整个集合就是9个数）就是树的宽度。</p><p>例如 k = 2，n = 4的话，就是在集合[1,2,3,4,5,6,7,8,9]中求 k（个数） = 2, n（和） = 4的组合。</p><p>选取过程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210713182351.png" alt=""></p><p>图中，可以看出，只有最后取到集合（1，3）和为4 符合条件。</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li><strong>「确定递归函数参数」</strong></li></ul><p>和求组合问题一样，依然需要一维数组path来存放符合条件的结果，二维数组result来存放结果集。</p><p>这里我依然定义path 和 result为全局变量。</p><p>至于为什么取名为path？从上面树形结构中，可以看出，结果其实就是一条根节点到叶子节点的路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = [] <span class="comment"># 存放符合条件结果的集合</span></span><br><span class="line">path = [] <span class="comment"># 用来存放符合条件结果</span></span><br></pre></td></tr></table></figure><p>接下来还需要如下参数：</p><ul><li>targetSum（int）目标和，也就是题目中的n。</li><li>k（int）就是题目中要求k个数的集合。</li><li>Sum（int）为已经收集的元素的总和，也就是path里元素的总和。</li><li>startIndex（int）为下一层for循环搜索的起始位置。</li></ul><p>所以代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = [] <span class="comment"># 存放符合条件结果的集合</span></span><br><span class="line">path = []   <span class="comment"># 用来存放符合条件单一结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">targetSum, k, Sum, startIndex</span>):</span>  </span><br></pre></td></tr></table></figure><p>其实这里sum这个参数也可以省略，每次targetSum减去选取的元素数值，然后判断如果targetSum为0了，说明收集到符合条件的结果了，我这里为了直观便于理解，还是加一个Sum参数。</p><p>还要强调一下，回溯法中递归函数参数很难一次性确定下来，一般先写逻辑，需要啥参数了，填什么参数。</p><ul><li>确定终止条件</li></ul><p>什么时候终止呢？</p><p>在上面已经说了，k其实就已经限制树的深度，因为就取k个元素，树再往下深了没有意义。</p><p>所以如果len(path) 和 k相等了，就终止。</p><p>如果此时path里收集到的元素和（Sum） 和targetSum（就是题目描述的n）相同了，就用result收集当前的结果。</p><p>所以 终止代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">    <span class="keyword">if</span> Sum == targetSum: result.append(path[:])</span><br><span class="line">    <span class="keyword">return</span> <span class="comment"># 如果len(path) == k 但Sum != targetSum 直接返回</span></span><br></pre></td></tr></table></figure><ul><li><strong>「单层搜索过程」</strong></li></ul><p>本题和求组合问题的区别之一就是集合固定的就是9个数[1,…,9]，所以for循环固定i&lt;=9</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210713182405.png" alt=""></p><p>处理过程就是 path收集每次选取的元素，相当于树型结构里的边，Sum来统计path里元素的总和。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, <span class="number">10</span>):</span><br><span class="line">    Sum += i</span><br><span class="line">    path.append(i)</span><br><span class="line">    backtracking(targetSum, k, Sum, i + <span class="number">1</span>)  <span class="comment"># 注意i+1调整startIndex</span></span><br><span class="line">    Sum -= i <span class="comment"># 回溯 </span></span><br><span class="line">    path.pop() <span class="comment"># 回溯 </span></span><br></pre></td></tr></table></figure><p><strong>「别忘了处理过程 和 回溯过程是一一对应的，处理有加，回溯就要有减！」</strong></p><p>参照回溯算法中的模板，不难写出如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = [] <span class="comment"># 存放结果集 </span></span><br><span class="line">        self.path = [] <span class="comment"># 符合条件的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span>(<span class="params">self, k, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.backtracking(n, k, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, targetSum, k, Sum, startindex</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">targetSum：目标和，也就是题目中的n。 </span></span><br><span class="line"><span class="string">     k：题目中要求k个数的集合。 </span></span><br><span class="line"><span class="string">     Sum：已经收集的元素的总和，也就是path里元素的总和。 </span></span><br><span class="line"><span class="string">     startIndex：下一层for循环搜索的起始位置。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == k:</span><br><span class="line">            <span class="keyword">if</span> Sum == targetSum:</span><br><span class="line">                self.res.append(self.path[:]) <span class="comment"># 注意append的不能是引用。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="comment"># 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, <span class="number">10</span>):</span><br><span class="line">            Sum += i <span class="comment"># 处理</span></span><br><span class="line">            self.path.append(i) <span class="comment"># 处理</span></span><br><span class="line">            self.backtracking(targetSum, k, Sum, i + <span class="number">1</span>) <span class="comment"># 注意i+1调整startIndex</span></span><br><span class="line">            Sum -= i <span class="comment"># 回溯</span></span><br><span class="line">            self.path.pop() <span class="comment"># 回溯</span></span><br></pre></td></tr></table></figure><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>这道题目，剪枝操作其实是很容易想到了，想必大家看上面的树形图的时候已经想到了。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210713182418.jpg" alt=""></p><p>已选元素总和如果已经大于n（图中数值为4）了，那么往后遍历就没有意义了，直接剪掉。</p><p>那么剪枝的地方一定是在递归终止的地方剪，剪枝代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">sum</span> &gt; targetSum: <span class="comment"># 剪枝操作</span></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>最终代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = [] <span class="comment"># 存放结果集 </span></span><br><span class="line">        self.path = [] <span class="comment"># 符合条件的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span>(<span class="params">self, k, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.backtracking(n, k, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, targetSum, k, Sum, startindex</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">targetSum：目标和，也就是题目中的n。 </span></span><br><span class="line"><span class="string">     k：题目中要求k个数的集合。 </span></span><br><span class="line"><span class="string">     Sum：已经收集的元素的总和，也就是path里元素的总和。 </span></span><br><span class="line"><span class="string">     startIndex：下一层for循环搜索的起始位置。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> Sum &gt; targetSum:  <span class="comment"># 剪枝操作</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == k:</span><br><span class="line">            <span class="keyword">if</span> Sum == targetSum:</span><br><span class="line">                self.res.append(self.path[:]) <span class="comment"># 注意append的不能是引用。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="comment"># 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, <span class="number">10</span>):</span><br><span class="line">            Sum += i <span class="comment"># 处理</span></span><br><span class="line">            self.path.append(i) <span class="comment"># 处理</span></span><br><span class="line">            self.backtracking(targetSum, k, Sum, i + <span class="number">1</span>) <span class="comment"># 注意i+1调整startIndex</span></span><br><span class="line">            Sum -= i <span class="comment"># 回溯</span></span><br><span class="line">            self.path.pop() <span class="comment"># 回溯</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>开篇就介绍了本题与组合问题的区别，相对来说加了元素总和的限制，如果做完77组合问题。再做本题再合适不过。</p><p>分析完区别，依然把问题抽象为树形结构，按照回溯三部曲进行讲解，最后给出剪枝的优化。</p><p>相信做完本题，大家对组合问题应该有初步了解了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;求组合总和&quot;&gt;&lt;a href=&quot;#求组合总和&quot; class=&quot;headerlink&quot; title=&quot;求组合总和&quot;&gt;&lt;/a&gt;求组合总和&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>03-回溯算法的剪枝策略</title>
    <link href="https://xxren8218.github.io/20210713/03-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E5%89%AA%E6%9E%9D%E7%AD%96%E7%95%A5.html"/>
    <id>https://xxren8218.github.io/20210713/03-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E5%89%AA%E6%9E%9D%E7%AD%96%E7%95%A5.html</id>
    <published>2021-07-13T10:21:36.000Z</published>
    <updated>2021-07-13T10:22:51.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯算法的剪枝策略"><a href="#回溯算法的剪枝策略" class="headerlink" title="回溯算法的剪枝策略"></a>回溯算法的剪枝策略</h2><p>在上文中，我们通过回溯搜索法，解决了n个数中求k个数的组合问题。</p><p>文中的回溯法是可以剪枝优化的，本篇我们继续来看一下题目77. 组合。</p><p>链接：<a href="https://leetcode-cn.com/problems/combinations/">https://leetcode-cn.com/problems/combinations/</a></p><p><strong>「看本篇之前，需要先看[回溯算法：求组合问题！]</strong>。</p><p>大家先回忆一下[77. 组合]给出的回溯法的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.backtracking(n, k, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, n, k, startindex</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == k:</span><br><span class="line">            <span class="comment"># 注意此处传递的不能是引用。即append(a)不能传递引用，若是引用，a变，整体都变。</span></span><br><span class="line">            path = self.path[:]</span><br><span class="line">            self.res.append(path)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 也可下面(节省空间复杂度)</span></span><br><span class="line">            <span class="comment"># self.res.append(self.path[:])</span></span><br><span class="line">         </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, n + <span class="number">1</span>):</span><br><span class="line">            self.path.append(i)</span><br><span class="line">            self.backtracking(n, k, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><h3 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h3><p>我们说过，回溯法虽然是暴力搜索，但也有时候可以有点剪枝优化一下的。</p><p>在遍历的过程中有如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, n + <span class="number">1</span>):</span><br><span class="line">    self.path.append(i)</span><br><span class="line">    self.backtracking(n, k, i + <span class="number">1</span>)</span><br><span class="line">    self.path.pop()</span><br></pre></td></tr></table></figure><p>这个遍历的范围是可以剪枝优化的，怎么优化呢？</p><p>来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。在第二层for循环，从元素3开始的遍历都没有意义了。</p><p>这么说有点抽象，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210713182238.png" alt=""></p><p>图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。</p><p><strong>「所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置」</strong>。</p><p><strong>「如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了」</strong>。</p><p>注意代码中i，就是for循环里选择的起始位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, n + <span class="number">1</span>):</span><br></pre></td></tr></table></figure><p>接下来看一下优化过程如下：</p><ol><li>已经选择的元素个数：len(path)</li><li>还需要的元素个数为: k - len(path)</li><li>在集合n中至多要从该起始位置 : n - (k - len(path)) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><p>举个例子，n = 4，k = 3， 目前已经选取的元素为0（len(path)为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。</p><p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p><p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p><p>所以优化之后的for循环是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, n - (k - <span class="built_in">len</span>(path)) + <span class="number">1</span>): <span class="comment"># i为本次搜索的起始位置</span></span><br></pre></td></tr></table></figure><p>优化后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.backtracking(n, k, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, n, k, startindex</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == k:</span><br><span class="line">            </span><br><span class="line">            self.res.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 此处有两 + 1，一个是循环至多的起始位置，一个是range()函数的半闭半开区间。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, n - (k - <span class="built_in">len</span>(self.path)) + <span class="number">1</span> + <span class="number">1</span>):</span><br><span class="line">            self.path.append(i)</span><br><span class="line">            self.backtracking(n, k, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><p><code>这个代码运行后，将之前的代码的416ms的时间降低到了28ms。</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇我们针对求组合问题的回溯法代码做了剪枝优化，这个优化如果不画图的话，其实不好理解，也不好讲清楚。</p><p>所以我依然是把整个回溯过程抽象为一颗树形结构，然后可以直观的看出，剪枝究竟是剪的哪里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回溯算法的剪枝策略&quot;&gt;&lt;a href=&quot;#回溯算法的剪枝策略&quot; class=&quot;headerlink&quot; title=&quot;回溯算法的剪枝策略&quot;&gt;&lt;/a&gt;回溯算法的剪枝策略&lt;/h2&gt;&lt;p&gt;在上文中，我们通过回溯搜索法，解决了n个数中求k个数的组合问题。&lt;/p&gt;
&lt;p&gt;文中</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>15-验证二叉搜索树</title>
    <link href="https://xxren8218.github.io/20210713/15-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>https://xxren8218.github.io/20210713/15-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2021-07-13T10:20:16.000Z</published>
    <updated>2021-07-13T10:21:08.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210713182047.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p><p>有了这个特性，<strong>「验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。」</strong></p><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    traversal(root.left)</span><br><span class="line">    li.append(root.val) <span class="comment"># 将二叉搜索树转换为有序数组</span></span><br><span class="line">    traversal(root.right)</span><br></pre></td></tr></table></figure><p>然后只要比较一下，这个数组是否是有序的，<strong>「注意二叉搜索树中不能有重复元素」</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">traversal(root)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(li)):</span><br><span class="line">    <span class="comment"># 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">    <span class="keyword">if</span> li[i] &lt;= li[i - <span class="number">1</span>]: </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.li = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(self.li)):</span><br><span class="line">        <span class="comment"># 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">            <span class="keyword">if</span> self.li[i] &lt;= self.li[i - <span class="number">1</span>]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归将二叉搜索树变为有序数组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="comment"># 注意为空的判断</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.traversal(root.left)</span><br><span class="line">        self.li.append(root.val)</span><br><span class="line">        self.traversal(root.right)</span><br></pre></td></tr></table></figure><p>以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。</p><p>这道题目比较容易陷入一个陷阱：</p><ul><li>陷阱1</li></ul><p><strong>「不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了」</strong>。</p><p>写出了类似这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &gt; root.left.val <span class="keyword">and</span> root.val &lt; root.right.val:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    <span class="keyword">return</span> false</span><br></pre></td></tr></table></figure><p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点</strong>。所以以上代码的判断逻辑是错误的。</p><p>例如：[10,5,15,null,null,6,20] 这个case：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210713182101.png" alt=""></p><p>节点10小于左节点5，大于右节点15，但右子树里出现了一个6 这就不符合了！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题目是一个简单题，但对于没接触过的同学还是有难度的。</p><p>所以初学者刚开始学习算法的时候，看到简单题目没有思路很正常，千万别怀疑自己智商，学习过程都是这样的，大家智商都差不多，哈哈。</p><p>只要把基本类型的题目都做过，总结过之后，思路自然就开阔了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;验证二叉搜索树&quot;&gt;&lt;a href=&quot;#验证二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;验证二叉搜索树&quot;&gt;&lt;/a&gt;验证二叉搜索树&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>14-二叉搜索树</title>
    <link href="https://xxren8218.github.io/20210713/14-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>https://xxren8218.github.io/20210713/14-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2021-07-13T10:18:55.000Z</published>
    <updated>2021-07-13T10:20:01.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210713181931.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>之前我们讲了都是普通二叉树，那么接下来看看二叉搜索树。</p><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</p><p>本题，其实就是在二叉搜索树中搜索一个节点。那么我们来看看应该如何遍历。</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><ul><li>确定递归函数的参数和返回值</li></ul><p>递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">root, val</span>):</span></span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>如果root为空，或者找到这个数值了，就返回root节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val: <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><ul><li>确定单层递归的逻辑</li></ul><p>看看二叉搜索树的单层递归逻辑有何不同。</p><p>因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。</p><p>如果root.val &gt; val，搜索左子树，如果root.val &lt; val，就搜索右子树，最后如果都没有搜索到，就返回None。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &gt; val: </span><br><span class="line">    <span class="keyword">return</span> searchBST(root.left, val) <span class="comment"># 注意这里加了return </span></span><br><span class="line"><span class="keyword">if</span> root.val &lt; val: </span><br><span class="line">    <span class="keyword">return</span> searchBST(root.right, val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>这里可能会疑惑，在递归遍历的时候，什么时候直接return 递归函数的返回值，什么时候不用加这个 return呢。</p><p>如果要搜索一条边，递归函数就要加返回值，这里也是一样的道理。</p><p><strong>「因为搜索到目标节点了，就要立即return了，这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。」</strong></p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val: <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left, val) <span class="comment"># 注意这里加了return </span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right, val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。</p><p><strong>对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法。</strong></p><p>对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。</p><p>而<strong>「对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。」</strong></p><p>例如要搜索元素为3的节点，<strong>「我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。」</strong></p><p>中间节点如果大于3就向左走，如果小于3就向右走，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210713181949.png" alt=""></p><p>所以迭代法代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val: <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; val: </span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>第一次看到了如此简单的迭代法，是不是感动的痛哭流涕，哭一会~</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇我们介绍了二叉搜索树的遍历方式，因为二叉搜索树的有序性，遍历的时候要比普通二叉树简单很多。</p><p>但是一些同学很容易忽略二叉搜索树的特性，所以写出遍历的代码就未必真的简单了。</p><p>所以针对二叉搜索树的题目，一样要利用其特性。</p><p>文中我依然给出递归和迭代两种方式，可以看出写法都非常简单，就是利用了二叉搜索树有序的特点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉搜索树&quot;&gt;&lt;a href=&quot;#二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树&quot;&gt;&lt;/a&gt;二叉搜索树&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>02-回溯求组合问题</title>
    <link href="https://xxren8218.github.io/20210712/02-%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%B1%82%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210712/02-%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%B1%82%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98.html</id>
    <published>2021-07-12T14:01:19.000Z</published>
    <updated>2021-07-15T14:12:47.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯法求组合问题"><a href="#回溯法求组合问题" class="headerlink" title="回溯法求组合问题"></a>回溯法求组合问题</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210712220203.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题这是回溯法的经典题目。</p><p>直接的解法当然是使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line">n = <span class="number">4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">       res.append([i,j])</span><br></pre></td></tr></table></figure><p>输入：n = 100, k = 3 那么就三层for循环，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j + <span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">res.append([i,j,k])</span><br></pre></td></tr></table></figure><p><strong>「如果n为100，k为50呢，那就50层for循环，是不是开始窒息」</strong>。</p><p><strong>「此时就会发现虽然想暴力搜索，但是用for循环嵌套连暴力都写不出来！」</strong></p><p>咋整？</p><p>回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像for循环嵌套k层让人绝望。</p><p>那么回溯法怎么暴力搜呢？</p><p>上面我们说了<strong>「要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题」</strong>。</p><p>递归来做层叠嵌套（可以理解是开k层for循环），<strong>「每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了」</strong>。</p><p>此时递归的层数大家应该知道了，例如：n为100，k为50的情况下，就是递归50层。</p><p>一些同学本来对递归就懵，回溯法中递归还要嵌套for循环，可能就直接晕倒了！</p><p>如果脑洞模拟回溯搜索的过程，绝对可以让人窒息，所以需要抽象图形结构来进一步理解。</p><p><strong>「我们在上篇文章中说道回溯法解决的问题都可以抽象为树形结构（N叉树），用树形结构来理解回溯就容易多了」</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210712220222.png" alt=""></p><p>可以看出这个棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不在重复取。</p><p>第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。</p><p><strong>「每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围」</strong>。</p><p><strong>「图中可以发现n相当于树的宽度，k相当于树的深度」</strong>。</p><p>那么如何在这个树上遍历，然后收集到我们要的结果集呢？</p><p><strong>「图中每次搜索到了叶子节点，我们就找到了一个结果」</strong>。</p><p>相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。</p><p>在上文中我们提到了回溯法三部曲，那么我们按照回溯法三部曲开始正式讲解代码了。</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数的返回值以及参数</li></ul><p>在这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = [] <span class="comment"># 存放符合条件结果的集合</span></span><br><span class="line">path = [] <span class="comment"># 用来存放符合条件结果</span></span><br></pre></td></tr></table></figure><p>其实不定义这两个全局遍历也是可以的，把这两个变量放进递归函数的参数里，但函数里参数太多影响可读性，所以我定义全局变量了。</p><p>函数里一定有两个参数，既然是集合n里面取k的数，那么n和k是两个int型的参数。</p><p>然后还需要一个参数，为int型变量startIndex，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,…,n] ）。</p><p>为什么要有这个startIndex呢？</p><p><strong>「每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex」</strong>。</p><p>从下图中红线部分可以看出，在集合[1,2,3,4]取1之后，下一层递归，就要在[2,3,4]中取数了，那么下一层递归如何知道从[2,3,4]中取数呢，靠的就是startIndex。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210712220240.png" alt=""></p><p>所以需要startIndex来记录下一层递归，搜索的起始位置。</p><p>那么整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = [] <span class="comment"># 存放符合条件结果的集合</span></span><br><span class="line">path = []   <span class="comment"># 用来存放符合条件单一结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">n, k, startIndex</span>):</span> </span><br></pre></td></tr></table></figure><ul><li>回溯函数终止条件</li></ul><p>什么时候到达所谓的叶子节点了呢？</p><p>path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。</p><p>如图红色部分：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210712220254.png" alt=""></p><p>此时用result二维数组，把path保存起来，并终止本层递归。</p><p>所以终止条件代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">    result.append(path)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>单层搜索的过程</li></ul><p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210712220308.jpg" alt=""></p><p>如此我们才遍历完图中的这棵树。</p><p>for循环每次从startIndex开始遍历，然后用path保存取到的节点i。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, n + <span class="number">1</span>): <span class="comment"># 控制树的横向遍历</span></span><br><span class="line">    path.append(i) <span class="comment"># 处理节点 </span></span><br><span class="line">    backtracking(n, k, i + <span class="number">1</span>); <span class="comment"># 递归：控制树的纵向遍历，注意下一层搜索要从i + 1开始</span></span><br><span class="line">    path.pop() <span class="comment"># 回溯，撤销处理的节点</span></span><br></pre></td></tr></table></figure><p>可以看出backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。</p><p>backtracking的下面部分就是回溯的操作了，撤销本次处理的结果。</p><p>关键地方都讲完了，组合问题完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.backtracking(n, k, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, n, k, startindex</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == k:</span><br><span class="line">            <span class="comment"># 注意此处传递的不能是引用。即append(a)不能传递引用，若是引用，a变，整体都变。</span></span><br><span class="line">            path = self.path[:]</span><br><span class="line">            self.res.append(path)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 也可下面(节省空间复杂度)</span></span><br><span class="line">            <span class="comment"># self.res.append(self.path[:])</span></span><br><span class="line">         </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startindex, n + <span class="number">1</span>):</span><br><span class="line">            self.path.append(i)</span><br><span class="line">            self.backtracking(n, k, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><p>还记得我们在上文中给出的回溯法模板么？</p><p>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">参数</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）):</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表) <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure><p><strong>「对比一下本题的代码，是不是发现有点像！」</strong> 所以有了这个模板，就有解题的大体方向，不至于毫无头绪。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>组合问题是回溯法解决的经典问题，我们开始的时候给大家列举一个很形象的例子，就是n为100，k为50的话，直接想法就需要50层for循环。</p><p>从而引出了回溯法就是解决这种k层for循环嵌套的问题。</p><p>然后进一步把回溯法的搜索过程抽象为树形结构，可以直观的看出搜索的过程。</p><p>接着用回溯法三部曲，逐步分析了函数参数、终止条件和单层搜索的过程。</p><p><strong>「本题其实是可以剪枝优化的，大家可以思考一下，具体如何剪枝」</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回溯法求组合问题&quot;&gt;&lt;a href=&quot;#回溯法求组合问题&quot; class=&quot;headerlink&quot; title=&quot;回溯法求组合问题&quot;&gt;&lt;/a&gt;回溯法求组合问题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren821</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>01-回溯法的框架</title>
    <link href="https://xxren8218.github.io/20210712/01-%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.html"/>
    <id>https://xxren8218.github.io/20210712/01-%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.html</id>
    <published>2021-07-12T13:58:58.000Z</published>
    <updated>2021-07-15T14:11:45.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯法概述"><a href="#回溯法概述" class="headerlink" title="回溯法概述"></a>回溯法概述</h2><h3 id="什么是回溯法？"><a href="#什么是回溯法？" class="headerlink" title="什么是回溯法？"></a>什么是回溯法？</h3><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。</p><p><strong>「所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数」</strong>。</p><h3 id="回溯法的效率？"><a href="#回溯法的效率？" class="headerlink" title="回溯法的效率？"></a>回溯法的效率？</h3><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>「虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法」</strong>。</p><p><strong>「因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案」</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><p>那么既然回溯法并不高效为什么还要用它呢？</p><p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p><p>此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。</p><h3 id="回溯法解决的问题？"><a href="#回溯法解决的问题？" class="headerlink" title="回溯法解决的问题？"></a>回溯法解决的问题？</h3><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><p><strong>「相信大家看着这些之后会发现，每个问题，都不简单！」</strong></p><p>另外，会有一些同学可能分不清什么是组合，什么是排列？</p><p><strong>「组合是不强调元素顺序的，排列是强调元素顺序」</strong>。</p><p>例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</p><p>记住组合无序，排列有序，就可以了。</p><h3 id="如何理解回溯法？"><a href="#如何理解回溯法？" class="headerlink" title="如何理解回溯法？"></a>如何理解回溯法？</h3><p><strong>「回溯法解决的问题都可以抽象为树形结构」</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>「集合的大小就构成了树的宽度，递归的深度，都构成的树的深度」</strong>。</p><p>递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。</p><p>这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行。</p><h3 id="回溯法模板？"><a href="#回溯法模板？" class="headerlink" title="回溯法模板？"></a>回溯法模板？</h3><p>这里给出回溯算法模板。</p><p>前面我们说了递归三部曲，这里我再给大家列出回溯三部曲。</p><ul><li><p>回溯函数模板返回值以及参数</p><p>在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。</p><p>回溯算法中函数返回值一般为void。</p><p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p><p>但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。</p><p>回溯函数伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">参数</span>):</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>回溯函数终止条件:</p><p>既然是树形结构，就知道遍历树形结构一定要有终止条件。</p><p>所以回溯也有要终止条件。</p><p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><p>所以回溯函数终止条件伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 终止条件:</span><br><span class="line">    存放结果</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>回溯搜索的遍历过程</p><p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210712220015.png" alt=""></p><p>  回溯函数遍历过程伪代码如下：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）):</span><br><span class="line">    处理节点</span><br><span class="line">    backtracking(路径，选择列表)  <span class="comment"># 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br></pre></td></tr></table></figure><p>  for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p><p>  backtracking这里自己调用自己，实现递归。</p><p>  大家可以从图中看出<strong>「for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历」</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><ul><li><p>分析完过程，回溯算法模板框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">参数</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）):</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表) <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure></li></ul><p><strong>「这份模板很重要，后面做回溯法的题目都靠它了！」</strong></p><p>如果从来没有学过回溯算法的录友们，看到这里会有点懵，后面开始讲解具体题目的时候就会好一些了，已经做过回溯法题目的录友，看到这里应该会感同身受了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇我们讲解了，什么是回溯算法，知道了回溯和递归是相辅相成的。</p><p>接着提到了回溯法的效率，回溯法其实就是暴力查找，并不是什么高效的算法。</p><p>然后列出了回溯法可以解决几类问题，可以看出每一类问题都不简单。</p><p>最后我们讲到回溯法解决的问题都可以抽象为树形结构（N叉树），并给出了回溯法的模板。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回溯法概述&quot;&gt;&lt;a href=&quot;#回溯法概述&quot; class=&quot;headerlink&quot; title=&quot;回溯法概述&quot;&gt;&lt;/a&gt;回溯法概述&lt;/h2&gt;&lt;h3 id=&quot;什么是回溯法？&quot;&gt;&lt;a href=&quot;#什么是回溯法？&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
