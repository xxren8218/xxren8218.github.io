<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-08-16T16:26:23.913Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>06-两数之和</title>
    <link href="https://xxren8218.github.io/20210817/06-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html"/>
    <id>https://xxren8218.github.io/20210817/06-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</id>
    <published>2021-08-16T16:25:43.000Z</published>
    <updated>2021-08-16T16:26:23.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210817002609.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。</p><p>本题呢，则要使用map，那么来看一下使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下表位置，因为要返回x 和 y的下表。所以set 也不能用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            hashmap[num] = ind</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            j = hashmap.get(target - num)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">and</span> i != j:</span><br><span class="line">                <span class="keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>05-快乐数</title>
    <link href="https://xxren8218.github.io/20210817/05-%E5%BF%AB%E4%B9%90%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210817/05-%E5%BF%AB%E4%B9%90%E6%95%B0.html</id>
    <published>2021-08-16T16:24:44.000Z</published>
    <updated>2021-08-16T16:25:30.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210817002500.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目看上去貌似一道数学问题，其实并不是！</p><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        set_ = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            sum_ = self.getSum(n)</span><br><span class="line">            <span class="keyword">if</span> sum_ == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false</span></span><br><span class="line">            <span class="keyword">if</span> sum_ <span class="keyword">in</span> set_:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                set_.add(sum_)</span><br><span class="line">            n = sum_</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 取数值各个位上的单数之和</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            sum_ += (n % <span class="number">10</span>) * (n % <span class="number">10</span>)</span><br><span class="line">            n //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> sum_</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快乐数&quot;&gt;&lt;a href=&quot;#快乐数&quot; class=&quot;headerlink&quot; title=&quot;快乐数&quot;&gt;&lt;/a&gt;快乐数&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>04-两个数组的交集</title>
    <link href="https://xxren8218.github.io/20210817/04-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html"/>
    <id>https://xxren8218.github.io/20210817/04-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html</id>
    <published>2021-08-16T16:23:40.000Z</published>
    <updated>2021-08-16T16:24:28.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210817002412.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。</p><p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序</strong></p><p>这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。</p><p><strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        result_set = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        set1 = <span class="built_in">set</span>(nums1)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> set1:</span><br><span class="line">                result_set.add(num) <span class="comment"># set1里出现的nums2元素 存放到结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(result_set)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两个数组的交集&quot;&gt;&lt;a href=&quot;#两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;两个数组的交集&quot;&gt;&lt;/a&gt;两个数组的交集&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>03-查找常用字符</title>
    <link href="https://xxren8218.github.io/20210817/03-%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6.html"/>
    <id>https://xxren8218.github.io/20210817/03-%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6.html</id>
    <published>2021-08-16T16:22:06.000Z</published>
    <updated>2021-08-16T16:23:27.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查找常用字符"><a href="#查找常用字符" class="headerlink" title="查找常用字符"></a>查找常用字符</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210817002247.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题意一起就有点绕，不是那么容易懂，其实就是26个小写字符中有字符 在所有字符串里都出现的话，就输出，重复的也算。</p><p>例如：</p><p>输入：[“ll”,”ll”,”ll”] 输出：[“l”,”l”]</p><p>这道题目一眼看上去，就是用哈希法，<strong>“小写字符”，“出现频率”， 这些关键字都是为哈希法量身定做的啊</strong></p><p>首先可以想到的是暴力解法，一个字符串一个字符串去搜，时间复杂度是O(n^m)，n是字符串长度，m是有几个字符串。</p><p>可以看出这是指数级别的时间复杂度，非常高，而且代码实现也不容易，因为要统计 重复的字符，还要适当的替换或者去重。</p><p>了解了哈希法，理解了数组在哈希法中的应用之后，可以来看解题思路了。</p><p>整体思路就是统计出搜索字符串里26个字符的出现的频率，然后取每个字符频率最小值，最后转成输出格式就可以了。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210817002306.png" alt=""></p><p>先统计第一个字符串所有字符出现的次数，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span> = [<span class="number">0</span>] * <span class="number">26</span> <span class="comment"># 用来统计所有字符串里字符出现的最小频率</span></span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(words[<span class="number">0</span>]):  <span class="comment"># 用第一个字符串给hash初始化</span></span><br><span class="line"><span class="built_in">hash</span>[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>接下来，把其他字符串里字符的出现次数也统计出来一次放在hashOtherStr中。</p><p>然后hash 和 hashOtherStr 取最小值，这是本题关键所在，此时取最小值，就是 一个字符在所有字符串里出现的最小次数了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计除第一个字符串外字符的出现频率</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(words)):</span><br><span class="line">    hashOtherStr = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words[<span class="number">0</span>])):</span><br><span class="line">        hashOtherStr[<span class="built_in">ord</span>(words[i][j]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">        <span class="built_in">hash</span>[k] = <span class="built_in">min</span>(<span class="built_in">hash</span>[k], hashOtherStr[k])</span><br></pre></td></tr></table></figure><p>此时hash里统计着字符在所有字符串里出现的最小次数，那么把hash转成题目要求的输出格式就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将hash统计的字符次数，转成输出形式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">hash</span>[i] != <span class="number">0</span>: <span class="comment"># 注意这里是while，多个重复的字符</span></span><br><span class="line">    result.extend(<span class="built_in">chr</span>(i + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">        <span class="built_in">hash</span>[i] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commonChars</span>(<span class="params">self, words: List[<span class="built_in">str</span>]</span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words: <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="built_in">hash</span> = [<span class="number">0</span>] * <span class="number">26</span> <span class="comment"># 用来统计所有字符串里字符出现的最小频率</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(words[<span class="number">0</span>]):  <span class="comment"># 用第一个字符串给hash初始化</span></span><br><span class="line">            <span class="built_in">hash</span>[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 统计除第一个字符串外字符的出现频率</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(words)):</span><br><span class="line">            hashOtherStr = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words[<span class="number">0</span>])):</span><br><span class="line">                hashOtherStr[<span class="built_in">ord</span>(words[i][j]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                <span class="built_in">hash</span>[k] = <span class="built_in">min</span>(<span class="built_in">hash</span>[k], hashOtherStr[k])</span><br><span class="line">        <span class="comment"># 将hash统计的字符次数，转成输出形式</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">hash</span>[i] != <span class="number">0</span>: <span class="comment"># 注意这里是while，多个重复的字符</span></span><br><span class="line">                result.extend(<span class="built_in">chr</span>(i + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">                <span class="built_in">hash</span>[i] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;查找常用字符&quot;&gt;&lt;a href=&quot;#查找常用字符&quot; class=&quot;headerlink&quot; title=&quot;查找常用字符&quot;&gt;&lt;/a&gt;查找常用字符&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>02-有效字母异位词</title>
    <link href="https://xxren8218.github.io/20210811/02-%E6%9C%89%E6%95%88%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html"/>
    <id>https://xxren8218.github.io/20210811/02-%E6%9C%89%E6%95%88%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html</id>
    <published>2021-08-11T15:27:19.000Z</published>
    <updated>2021-08-11T15:28:12.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有效字母异位词"><a href="#有效字母异位词" class="headerlink" title="有效字母异位词"></a>有效字母异位词</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232757.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>创建Hash表，键为字符，值为出现次数。default默认可以同时给字典增加键和值</p></li><li><p>不用这个高级函数的话，还可以用数组实现，数组的索引为字母，值为出现个数，对于s值加，对于t，值减。</p></li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">        s_dict = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        t_dict = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            s_dict[x] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> t:</span><br><span class="line">            t_dict[x] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s_dict == t_dict </span><br></pre></td></tr></table></figure><p>方法二的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        record = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">            record[<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">            record[<span class="built_in">ord</span>(t[i]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> record[i] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有效字母异位词&quot;&gt;&lt;a href=&quot;#有效字母异位词&quot; class=&quot;headerlink&quot; title=&quot;有效字母异位词&quot;&gt;&lt;/a&gt;有效字母异位词&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>01-哈希表基础</title>
    <link href="https://xxren8218.github.io/20210811/01-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E7%A1%80.html"/>
    <id>https://xxren8218.github.io/20210811/01-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-08-11T15:24:15.000Z</published>
    <updated>2021-08-11T15:27:05.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希表基础"><a href="#哈希表基础" class="headerlink" title="哈希表基础"></a>哈希表基础</h2><p>首先什么是 哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>这么这官方的解释可能有点懵，其实直白来讲其实数组就是一张哈希表。</p><p>哈希表中关键码就是数组的索引下表，然后通过下表直接访问数组中的元素，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232505.png" alt=""></p><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>例如要查询一个名字是否在这所学校里。</p><p>要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1) 就可以做到。</p><p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p><p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下表快速知道这位同学是否在这所学校里了。</p><p>哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232505.png" alt=""></p><p>如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？</p><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p><p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。</p><p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下表的位置。</p><p>接下来<strong>哈希碰撞</strong>登场</p><h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>如图所示，小李和小王都映射到了索引下表 1的位置，<strong>这一现象叫做哈希碰撞</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232505.png" alt=""></p><p>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232635.png" alt=""></p><p>（数据规模是dataSize， 哈希表的大小为tableSize）</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232650.png" alt=""></p><h3 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h3><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;哈希表基础&quot;&gt;&lt;a href=&quot;#哈希表基础&quot; class=&quot;headerlink&quot; title=&quot;哈希表基础&quot;&gt;&lt;/a&gt;哈希表基础&lt;/h2&gt;&lt;p&gt;首先什么是 哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>08-判断环的入口</title>
    <link href="https://xxren8218.github.io/20210811/08-%E5%88%A4%E6%96%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3.html"/>
    <id>https://xxren8218.github.io/20210811/08-%E5%88%A4%E6%96%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3.html</id>
    <published>2021-08-11T15:22:29.000Z</published>
    <updated>2021-08-11T15:23:48.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断环的入口"><a href="#判断环的入口" class="headerlink" title="判断环的入口"></a>判断环的入口</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232311.PNG" alt=""></p><p>思路：可以参考之前的文章：</p><p><a href="https://xxren8218.github.io/20210617/剑指Offer（五十五）：链表中环的入口结点.html">剑指Offer（五十五）：链表中环的入口结点 </a></p><ul><li><p>思路一：双指针</p></li><li><p>思路二：辅助列表</p></li></ul><h4 id="如果有环，如何找到这个环的入口"><a href="#如果有环，如何找到这个环的入口" class="headerlink" title="如果有环，如何找到这个环的入口"></a>如果有环，如何找到这个环的入口</h4><p><strong>此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。</strong></p><p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232334.png" alt=""></p><p>那么相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</p><p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x + y) * 2 &#x3D; x + y + n (y + z)</span><br></pre></td></tr></table></figure><p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p><p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p><p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code>注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>这个公式说明什么呢？</p><p>先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p><p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p><p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 如果相遇</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                p = head</span><br><span class="line">                q = slow</span><br><span class="line">                <span class="keyword">while</span> p != q:</span><br><span class="line">                    p = p.<span class="built_in">next</span></span><br><span class="line">                    q = q.<span class="built_in">next</span></span><br><span class="line">                <span class="comment">#你也可以return q</span></span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;判断环的入口&quot;&gt;&lt;a href=&quot;#判断环的入口&quot; class=&quot;headerlink&quot; title=&quot;判断环的入口&quot;&gt;&lt;/a&gt;判断环的入口&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>07-链表相交</title>
    <link href="https://xxren8218.github.io/20210811/07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html"/>
    <id>https://xxren8218.github.io/20210811/07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html</id>
    <published>2021-08-11T15:21:13.000Z</published>
    <updated>2021-08-11T15:22:15.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232142.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点</p><p>我们可以把两个链表拼接起来，一个 <code>headA</code> 在前 <code>headB</code> 在后，一个 <code>headB</code> 在前 <code>headA</code> 在后。这样，生成了两个相同长度的链表，那么我们只要同时遍历这两个表，就一定能找到公共结点。时间复杂度O(m+n)，空间复杂度O(m+n)。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        cur1, cur2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> cur1 != cur2:</span><br><span class="line">            cur1 = cur1.<span class="built_in">next</span> <span class="keyword">if</span> cur1 != <span class="literal">None</span> <span class="keyword">else</span> headB</span><br><span class="line">            cur2 = cur2.<span class="built_in">next</span> <span class="keyword">if</span> cur2 != <span class="literal">None</span> <span class="keyword">else</span> headA</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链表相交&quot;&gt;&lt;a href=&quot;#链表相交&quot; class=&quot;headerlink&quot; title=&quot;链表相交&quot;&gt;&lt;/a&gt;链表相交&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>06-删除链表的第倒数N个结点</title>
    <link href="https://xxren8218.github.io/20210811/06-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E5%80%92%E6%95%B0N%E4%B8%AA%E7%BB%93%E7%82%B9.html"/>
    <id>https://xxren8218.github.io/20210811/06-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E5%80%92%E6%95%B0N%E4%B8%AA%E7%BB%93%E7%82%B9.html</id>
    <published>2021-08-11T15:18:06.000Z</published>
    <updated>2021-08-11T15:20:54.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811231856.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p><p>思路是这样的，但要注意一些细节。</p><p>分为如下几步：</p><ul><li>首先这里我推荐大家使用虚拟头结点，这样方面处理删除实际头结点的逻辑。</li><li>定义fast指针和slow指针，初始值为虚拟头结点，如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811231919.png" alt=""></p><ul><li>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811231940.png" alt=""></p><ul><li>fast和slow同时移动，之道fast指向末尾，如题：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811231957.png" alt=""></p><ul><li>删除slow指向的下一个节点，如图： </li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232026.png" alt=""></p><p>此时不难写出如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line"></span><br><span class="line">        fast, slow = dummy_head, dummy_head</span><br><span class="line">        <span class="comment"># fast先往前走n + 1步</span></span><br><span class="line">        <span class="keyword">while</span> n!= -<span class="number">1</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当fast走到空的时候</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># fast走到结尾后，slow的下一个节点为倒数第N个节点</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;删除链表的倒数第N个节点&quot;&gt;&lt;a href=&quot;#删除链表的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;删除链表的倒数第N个节点&quot;&gt;&lt;/a&gt;删除链表的倒数第N个节点&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>05-两两交换链表中的节点</title>
    <link href="https://xxren8218.github.io/20210808/05-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html"/>
    <id>https://xxren8218.github.io/20210808/05-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</id>
    <published>2021-08-08T14:57:21.000Z</published>
    <updated>2021-08-08T14:58:46.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225747.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目正常模拟就可以了。</p><p>建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。</p><p>接下来就是交换相邻两个元素了，<strong>此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序</strong></p><p>初始时，cur指向虚拟头结点，然后进行如下三步：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225801.png" alt=""></p><p>操作之后，链表如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225816.png" alt=""></p><p>看这个可能就更直观一些了：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225830.png" alt=""></p><p>对应的代码实现如下： （注释中详细和如上图中的三步做对应）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head) <span class="comment"># 设置一个虚拟头结点</span></span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>: </span><br><span class="line">            tmp = cur.<span class="built_in">next</span> <span class="comment"># 记录临时节点</span></span><br><span class="line">            tmp1 = cur.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># 记录临时节点</span></span><br><span class="line">            </span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>          <span class="comment"># 步骤一</span></span><br><span class="line">            cur.<span class="built_in">next</span>.<span class="built_in">next</span> = tmp               <span class="comment"># 步骤二</span></span><br><span class="line">            cur.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = tmp1         <span class="comment"># 步骤三</span></span><br><span class="line">            </span><br><span class="line">            cur = cur.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># cur移动两位，准备下一轮交换</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;两两交换链表中的节点&quot;&gt;&lt;/a&gt;两两交换链表中的节点&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>04-反转链表(双指针)</title>
    <link href="https://xxren8218.github.io/20210808/04-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88.html"/>
    <id>https://xxren8218.github.io/20210808/04-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88.html</id>
    <published>2021-08-08T14:54:25.000Z</published>
    <updated>2021-08-08T14:57:06.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反转链表-双指针"><a href="#反转链表-双指针" class="headerlink" title="反转链表(双指针)"></a>反转链表(双指针)</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225449.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。</p><p>其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表，如图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225507.png" alt=""></p><p>之前链表的头节点是元素1， 反转之后头结点就是元素5 ，这里并没有添加或者删除节点，仅仅是改表next指针的方向。</p><p>那么接下来看一看是如何反转呢？</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225632.gif" alt=""></p><p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p><p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p><p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p><p>接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。</p><p>最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。</p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 创建一个临时变量来存储cur后面的值</span></span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            <span class="comment"># 向前递推</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。</p><p>关键是初始化的地方，可能有的同学会不理解， 可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。</p><p>具体可以看代码（已经详细注释），<strong>双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">pre, cur</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> pre</span><br><span class="line">            <span class="comment"># 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span></span><br><span class="line">        <span class="comment"># pre = cur</span></span><br><span class="line">            <span class="comment"># cur = temp</span></span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> reverse(cur, tmp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">None</span>, head)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;反转链表-双指针&quot;&gt;&lt;a href=&quot;#反转链表-双指针&quot; class=&quot;headerlink&quot; title=&quot;反转链表(双指针)&quot;&gt;&lt;/a&gt;反转链表(双指针)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>03-设计链表</title>
    <link href="https://xxren8218.github.io/20210808/03-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html"/>
    <id>https://xxren8218.github.io/20210808/03-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html</id>
    <published>2021-08-08T14:52:07.000Z</published>
    <updated>2021-08-08T14:53:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225307.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>删除链表节点：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225325.png" alt=""></p><p>添加链表节点：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225342.png" alt=""></p><p>这道题目设计链表的五个接口：</p><ul><li>获取链表第index个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第index个节点前面插入一个节点</li><li>删除链表的第index个节点</li></ul><p>可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目</p><p><strong>链表操作的两种方式：</strong></p><ol><li>直接使用原来的链表来进行操作。</li><li>设置一个虚拟头结点在进行操作。</li></ol><p>下面采用的设置一个虚拟头结点（这样更方便一些，大家看代码就会感受出来）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__head = Node(<span class="number">0</span>) <span class="comment"># 添加虚拟头节点</span></span><br><span class="line">        self.__count = <span class="number">0</span>      <span class="comment"># 添加计数</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= index &lt; self.__count:</span><br><span class="line">            node = self.__head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):   <span class="comment"># 添加虚拟头节点此处需要加1</span></span><br><span class="line">                node = node.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 超出范围</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>, val)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(self.__count, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span>(<span class="params">self, index, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 判断范围</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>: index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> index &gt; self.__count: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行计数加一</span></span><br><span class="line">        self.__count += <span class="number">1</span></span><br><span class="line">        new_node = Node(val)</span><br><span class="line"></span><br><span class="line">        pre_node, cur_node = <span class="literal">None</span>, self.__head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">            pre_node, cur_node = cur_node, cur_node.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加新的节点</span></span><br><span class="line">        pre_node.<span class="built_in">next</span> = new_node</span><br><span class="line">        new_node.<span class="built_in">next</span> = cur_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 判断指标的对错</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= index &lt; self.__count:</span><br><span class="line">            <span class="comment"># 计数减一</span></span><br><span class="line">            self.__count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            pre_node, cur_node = <span class="literal">None</span>, self.__head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">                pre_node, cur_node = cur_node, cur_node.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 删除指定元素</span></span><br><span class="line">            pre_node.<span class="built_in">next</span>, cur_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span>, <span class="literal">None</span> </span><br><span class="line">        <span class="comment"># 超出范围</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计链表&quot;&gt;&lt;a href=&quot;#设计链表&quot; class=&quot;headerlink&quot; title=&quot;设计链表&quot;&gt;&lt;/a&gt;设计链表&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>02-移除链表元素(虚拟头结点)</title>
    <link href="https://xxren8218.github.io/20210808/02-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-%E8%99%9A%E6%8B%9F%E5%A4%B4%E7%BB%93%E7%82%B9.html"/>
    <id>https://xxren8218.github.io/20210808/02-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-%E8%99%9A%E6%8B%9F%E5%A4%B4%E7%BB%93%E7%82%B9.html</id>
    <published>2021-08-08T14:49:24.000Z</published>
    <updated>2021-08-08T14:51:50.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移除链表元素-虚拟头节点"><a href="#移除链表元素-虚拟头节点" class="headerlink" title="移除链表元素(虚拟头节点)"></a>移除链表元素(虚拟头节点)</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224948.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里以链表 1 4 2 4 来举例，移除元素4。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225006.png" alt=""></p><p>清理节点内存之后如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225024.png" alt=""></p><p><strong>如果使用java ，python的话就不用手动管理内存了。</strong></p><p>这种情况下的移除操作，就是让节点next指针直接指向下下一个节点就可以了，</p><p>那么因为单链表的特殊性，只能指向下一个节点，刚刚删除的是链表的中第二个，和第四个节点，那么如果删除的是头结点又该怎么办呢？</p><p>这里就涉及如下链表操作的两种方式：</p><ul><li><strong>直接使用原来的链表来进行删除操作。</strong></li><li><strong>设置一个虚拟头结点在进行删除操作。</strong></li></ul><p>来看第一种操作：直接使用原来的链表来进行移除。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225040.png" alt=""></p><p>移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p><p>所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225103.png" alt=""></p><p>依然别忘将原头结点从内存中删掉。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225119.png" alt=""></p><p>这样移除了一个头结点，是不是发现，在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。</p><p>那么可不可以 以一种统一的逻辑来移除 链表的节点呢。</p><p>其实<strong>可以设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p><p>来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225134.png" alt=""></p><p>这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。</p><p>这样是不是就可以使用和移除链表其他节点的方式统一了呢？</p><p>来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。</p><p>最后呢在题目中，return 头结点的时候，别忘了 <code>return dummyNode.next</code>， 这才是新的头结点</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)  <span class="comment"># 添加一个虚拟头节点</span></span><br><span class="line">        cur = dummy_head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span>.val == val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>    <span class="comment"># 删除cur.next节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;移除链表元素-虚拟头节点&quot;&gt;&lt;a href=&quot;#移除链表元素-虚拟头节点&quot; class=&quot;headerlink&quot; title=&quot;移除链表元素(虚拟头节点)&quot;&gt;&lt;/a&gt;移除链表元素(虚拟头节点)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdeli</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>01-链表基础</title>
    <link href="https://xxren8218.github.io/20210808/01-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80.html"/>
    <id>https://xxren8218.github.io/20210808/01-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-08-08T14:46:27.000Z</published>
    <updated>2021-08-08T14:49:09.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表基础"><a href="#链表基础" class="headerlink" title="链表基础"></a>链表基础</h2><p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点是又两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p><p>链接的入口点称为列表的头结点也就是head。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224657.png" alt=""></p><h3 id="1-链表的类型"><a href="#1-链表的类型" class="headerlink" title="1.链表的类型"></a>1.链表的类型</h3><p>接下来说一下链表的几种类型:</p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>刚刚说的就是单链表。</p><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>单链表中的节点只能指向节点的下一个节点。</p><p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p><p>双链表 既可以向前查询也可以向后查询。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224715.png" alt=""></p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表，顾名思义，就是链表首尾相连。</p><p>循环链表可以用来解决约瑟夫环问题。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224732.png" alt=""></p><h3 id="2-链表的存储方式"><a href="#2-链表的存储方式" class="headerlink" title="2.链表的存储方式"></a>2.链表的存储方式</h3><p>了解完链表的类型，再来说一说链表在内存中的存储方式。</p><p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p><p>链表是通过指针域的指针链接在内存中各个节点。</p><p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224748.png" alt=""></p><p>这个链表起始节点为2， 终止节点为7， 各个节点分布在内存个不同地址空间上，通过指针串联在一起。</p><h3 id="3-链表的定义"><a href="#3-链表的定义" class="headerlink" title="3.链表的定义"></a>3.链表的定义</h3><p>接下来说一说链表的定义。</p><p>链表节点的定义，很多同学在面试的时候都写不好。</p><p>这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p><p>而在面试的时候，一旦要自己手写链表，就写的错漏百出。</p><p>这里我给出python的定义链表节点方式，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># cur游标，用来移动遍历节点</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># count记录数量</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        print(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表头部添加元素，头插法&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__head</span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表尾部添加元素, 尾插法&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.__head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, pos, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;指定位置添加元素</span></span><br><span class="line"><span class="string">        :param  pos 从0开始</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()-<span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self.__head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos-<span class="number">1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 当循环退出后，pre指向pos-1位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除节点&quot;&quot;&quot;</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 先判断此结点是否是头节点</span></span><br><span class="line">                <span class="comment"># 头节点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.__head:</span><br><span class="line">                    self.__head = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ll = SingleLinkList()</span><br><span class="line">    print(ll.is_empty())</span><br><span class="line">    print(ll.length())</span><br><span class="line"></span><br><span class="line">    ll.append(<span class="number">1</span>)</span><br><span class="line">    print(ll.is_empty())</span><br><span class="line">    print(ll.length())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ll.append(<span class="number">2</span>)</span><br><span class="line">    ll.add(<span class="number">8</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.append(<span class="number">4</span>)</span><br><span class="line">    ll.append(<span class="number">5</span>)</span><br><span class="line">    ll.append(<span class="number">6</span>)</span><br><span class="line">    <span class="comment"># 8 1 2 3 4 5 6</span></span><br><span class="line">    ll.insert(-<span class="number">1</span>, <span class="number">9</span>) <span class="comment"># 9 8 1 23456</span></span><br><span class="line">    ll.travel()</span><br><span class="line">    ll.insert(<span class="number">3</span>, <span class="number">100</span>) <span class="comment"># 9 8 1 100 2 3456</span></span><br><span class="line">    ll.travel()</span><br><span class="line">    ll.insert(<span class="number">10</span>, <span class="number">200</span>) <span class="comment"># 9 8 1 100 23456 200</span></span><br><span class="line">    ll.travel()</span><br><span class="line">    ll.remove(<span class="number">100</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    ll.remove(<span class="number">9</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    ll.remove(<span class="number">200</span>)</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure><h3 id="4-链表的操作"><a href="#4-链表的操作" class="headerlink" title="4.链表的操作"></a>4.链表的操作</h3><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>删除D节点，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224811.png" alt=""></p><p>只要将C节点的next指针 指向E节点就可以了。</p><p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p><p>Java、Python，就有自己的内存回收机制，不用自己手动释放了。</p><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224826.png" alt=""></p><p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>再把链表的特性和数组的特性进行一个对比，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224845.png" alt=""></p><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p><p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链表基础&quot;&gt;&lt;a href=&quot;#链表基础&quot; class=&quot;headerlink&quot; title=&quot;链表基础&quot;&gt;&lt;/a&gt;链表基础&lt;/h2&gt;&lt;p&gt;什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点是又两部分组成，一个是数据域一个是指针域（存放指向下一个节点的</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>06-螺旋矩阵问题</title>
    <link href="https://xxren8218.github.io/20210808/06-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210808/06-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98.html</id>
    <published>2021-08-07T16:13:14.000Z</published>
    <updated>2021-08-07T16:15:30.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001350.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目可以说在面试中出现频率较高的题目，<strong>本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</strong></p><p>要如何画出这个螺旋排列的正方形矩阵呢？</p><p>相信很多同学刚开始做这种题目的时候，上来就是一波判断猛如虎。</p><p>结果运行的时候各种问题，然后开始各种修修补补，最后发现改了这里哪里有问题，改了那里这里又跑不起来了。</p><p>大家还记得我们在这篇文章【二分查找】中讲解了二分法，提到如果要写出正确的二分法一定要坚持<strong>循环不变量原则</strong>。</p><p>而求解本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开的原则，来画一圈，大家看一下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001421.png" alt=""></p><p>这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。</p><p>这也是坚持了每条边左闭右开的原则。</p><p>一些同学做这道题目之所以一直写不好，代码越写越乱。</p><p>就是因为在画每一条边的时候，一会左开又闭，一会左闭右闭，一会又来左闭右开，岂能不乱。</p><p>代码如下，已经详细注释了每一步的目的，可以看出while循环里判断的情况是很多的，代码里处理的原则也是统一的左闭右开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right, up, down = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n -<span class="number">1</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化矩阵  n x n 的矩阵</span></span><br><span class="line">        matrix = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">            <span class="comment"># 从左到右</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                matrix[up][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上到下</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down + <span class="number">1</span>):</span><br><span class="line">                matrix[i][right] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从右到左</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                matrix[down][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从下到上</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                matrix[i][left] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001437.PNG" alt=""></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和上面的思路一样，不过这次不是给矩阵赋值而已。</p><ul><li>注意这里有个坑：这里不是方阵了，即m和n不一定一样。所以，需要添加一个判断。（更进去while的时候满足条件。通过第一步和第二步后不一定满足条件。）<ul><li>在第三步和第四步，需要额外添加判断。</li></ul></li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        left, right, up, down = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, m - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">            <span class="comment"># 从左往右</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[up][i])</span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上往下</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从右往左</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> up &lt;= down:</span><br><span class="line">                    res.append(matrix[down][i])</span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从下往上</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                    res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>由此可以得到螺旋打印的一个框架（无论是方阵与否）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right, up, down = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n -<span class="number">1</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化矩阵  n x n 的矩阵</span></span><br><span class="line">        matrix = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">            <span class="comment"># 从左到右</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                matrix[up][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上到下</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down + <span class="number">1</span>):</span><br><span class="line">                matrix[i][right] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从右到左</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> up &lt;= down:                   <span class="comment">##############</span></span><br><span class="line">                    matrix[down][i] = num</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从下到上</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> left &lt;= right:                <span class="comment">##############</span></span><br><span class="line">                    matrix[i][left] = num</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001512.PNG" alt=""></p><p>一样套路，这里就不写了。注意特殊情况的判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这三道题，我们总结出了顺时针打印矩阵的模板，以后按照模板写就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;螺旋矩阵II&quot;&gt;&lt;a href=&quot;#螺旋矩阵II&quot; class=&quot;headerlink&quot; title=&quot;螺旋矩阵II&quot;&gt;&lt;/a&gt;螺旋矩阵II&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>05-长度最小的子数组</title>
    <link href="https://xxren8218.github.io/20210808/05-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html"/>
    <id>https://xxren8218.github.io/20210808/05-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html</id>
    <published>2021-08-07T16:11:12.000Z</published>
    <updated>2021-08-07T16:12:55.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="长度最小值的子数组"><a href="#长度最小值的子数组" class="headerlink" title="长度最小值的子数组"></a>长度最小值的子数组</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001139.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p><p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001207.png" alt=""></p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, target, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        Sum = <span class="number">0</span>             <span class="comment"># 定义子数组的和</span></span><br><span class="line">        index = <span class="number">0</span>           <span class="comment"># 定义子数组的初始位置</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 定义子数组的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            Sum += nums[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> Sum &gt;= target:</span><br><span class="line">                res = <span class="built_in">min</span>(res, i - index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 重新选取子数组的范围</span></span><br><span class="line">                Sum -= nums[index]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><p><strong>为什么时间复杂度是O(n)</strong>。</p><p>不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;长度最小值的子数组&quot;&gt;&lt;a href=&quot;#长度最小值的子数组&quot; class=&quot;headerlink&quot; title=&quot;长度最小值的子数组&quot;&gt;&lt;/a&gt;长度最小值的子数组&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxre</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>04-有序数组的平方</title>
    <link href="https://xxren8218.github.io/20210808/04-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html"/>
    <id>https://xxren8218.github.io/20210808/04-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html</id>
    <published>2021-08-07T16:09:36.000Z</published>
    <updated>2021-08-07T16:10:57.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001038.PNG" alt=""></p><h3 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h3><p>直接写个lambda匿名函数将其按照绝对值排序，而后将每个元素变为二倍即可</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort(key = <span class="keyword">lambda</span> x: <span class="built_in">abs</span>(x))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] *= nums[i] </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h3 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h3><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>如动画所示：</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        i, j, k = <span class="number">0</span>, n - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">        ans = [-<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            lm = nums[i] ** <span class="number">2</span></span><br><span class="line">            rm = nums[j] ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> lm &gt; rm:</span><br><span class="line">                ans[k] = lm</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[k] = rm</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>这里还是说一下，大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。</strong></p><p>做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，</p><p>一样的代码多提交几次可能就击败百分之百了…..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有序数组的平方&quot;&gt;&lt;a href=&quot;#有序数组的平方&quot; class=&quot;headerlink&quot; title=&quot;有序数组的平方&quot;&gt;&lt;/a&gt;有序数组的平方&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>03-移除元素</title>
    <link href="https://xxren8218.github.io/20210808/03-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html"/>
    <id>https://xxren8218.github.io/20210808/03-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html</id>
    <published>2021-08-07T16:03:37.000Z</published>
    <updated>2021-08-07T16:09:17.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000407.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000429.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有的同学可能说了，多余的元素，删掉不就得了。</p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != val:</span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;移除元素&quot;&gt;&lt;a href=&quot;#移除元素&quot; class=&quot;headerlink&quot; title=&quot;移除元素&quot;&gt;&lt;/a&gt;移除元素&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>02-二分查找</title>
    <link href="https://xxren8218.github.io/20210808/02-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"/>
    <id>https://xxren8218.github.io/20210808/02-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</id>
    <published>2021-08-07T16:01:14.000Z</published>
    <updated>2021-08-07T16:02:39.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000143.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><p>下面我用这两种区间的定义分别讲解两种不同的二分写法。</p><h4 id="二分法第一种写法"><a href="#二分法第一种写法" class="headerlink" title="二分法第一种写法"></a>二分法第一种写法</h4><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p>例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000200.PNG" alt=""></p><p>代码如下：（详细注释）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>    <span class="comment"># 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:              <span class="comment"># 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            middle = (left + right) // <span class="number">2</span>  <span class="comment"># 防止溢出 等同于(left + right)//2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &lt; target:    </span><br><span class="line">                left = middle + <span class="number">1</span>         <span class="comment"># target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle - <span class="number">1</span>        <span class="comment"># target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">                <span class="keyword">return</span> middle             <span class="comment"># 数组中找到目标值，直接返回下标</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>                         <span class="comment"># 未找到目标值</span></span><br></pre></td></tr></table></figure><h4 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h4><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><p>在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（<strong>注意和方法一的区别</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000221.PNG" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left,right = <span class="number">0</span>, <span class="built_in">len</span>(nums)   <span class="comment"># 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:         <span class="comment"># 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:  </span><br><span class="line">                left = mid + <span class="number">1</span>        <span class="comment"># target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid         <span class="comment"># target 在左区间，在[left, middle)中</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> mid          <span class="comment"># 数组中找到目标值，直接返回下标 ###########注意</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>                   <span class="comment"># 未找到目标值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二分法是非常重要的基础算法，为什么很多同学对于二分法都是<strong>一看就会，一写就废</strong>？</p><p>其实主要就是对区间的定义没有理解清楚，在循环中没有始终坚持根据查找区间的定义来做边界处理。</p><p>区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。</p><p>本篇根据两种常见的区间定义，给出了两种二分法的写法，每一个边界为什么这么处理，都根据区间的定义做了详细介绍。</p><p>更多关于二分查找的技巧，<a href="https://xxren8218.github.io/20210615/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html">二分查找详解</a>里面有讲解寻找左边界和寻找右边界的二分查找的方法。</p><h3 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left,right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:        以使用 &lt;</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:  </span><br><span class="line">                left = mid + <span class="number">1</span>        </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid               <span class="comment">########</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                right = mid               <span class="comment">########</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left                       <span class="comment">########</span></span><br></pre></td></tr></table></figure><h3 id="寻找右侧边界的二分搜索"><a href="#寻找右侧边界的二分搜索" class="headerlink" title="寻找右侧边界的二分搜索"></a>寻找右侧边界的二分搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left,right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:        以使用 &lt;</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:  </span><br><span class="line">                left = mid + <span class="number">1</span>        </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid               <span class="comment">########</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                left = mid + <span class="number">1</span>            <span class="comment">########</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>                   <span class="comment">########           </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>01-数组基础</title>
    <link href="https://xxren8218.github.io/20210807/01-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80.html"/>
    <id>https://xxren8218.github.io/20210807/01-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-08-07T15:56:43.000Z</published>
    <updated>2021-08-07T15:58:06.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h2><p>数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力</p><p>也就是说，想法很简单，但实现起来 可能就不是那么回事了。</p><p>首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题</p><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p><p>举一个字符数组的例子，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235716.PNG" alt=""></p><p>需要两点注意的是</p><ul><li><strong>数组下标都是从0开始的。</strong></li><li><strong>数组内存空间的地址是连续的</strong></li></ul><p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p><p>例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235734.PNG" alt=""></p><p>那么二维数组直接上图，大家应该就知道怎么回事了</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235755.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组基础&quot;&gt;&lt;a href=&quot;#数组基础&quot; class=&quot;headerlink&quot; title=&quot;数组基础&quot;&gt;&lt;/a&gt;数组基础&lt;/h2&gt;&lt;p&gt;数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力&lt;/p&gt;
&lt;p&gt;也就是说，想</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
</feed>
