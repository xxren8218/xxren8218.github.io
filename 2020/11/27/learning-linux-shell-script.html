<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Linux下shell脚本编程学习 | X.X.Ren</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="摘要：从11月27日到12月9日，大概花了一个星期的时间，终于啃完了621页的《Linux命令行与shell脚本编程大全》。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux下shell脚本编程学习">
<meta property="og:url" content="https://xxren8218.github.io/2020/11/27/learning-linux-shell-script.html">
<meta property="og:site_name" content="X.X.Ren">
<meta property="og:description" content="摘要：从11月27日到12月9日，大概花了一个星期的时间，终于啃完了621页的《Linux命令行与shell脚本编程大全》。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201抓取所有参数的两种方法.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201移动变量.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201分离参数和选项.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201处理带值的选项.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202getopts命令用法.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202环境变量OPTIND.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202read命令接受指定字符.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202从文件中读取数据.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209使用函数输出返回值.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209遍历数组累加.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209从函数返回数组.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209计算简单阶乘.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209命令行上使用函数.png">
<meta property="article:published_time" content="2020-11-27T06:19:03.000Z">
<meta property="article:modified_time" content="2020-12-09T11:14:50.000Z">
<meta property="article:author" content="任晓雄">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201抓取所有参数的两种方法.png">
  
    <link rel="alternate" href="/atom.xml" title="X.X.Ren" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">X.X.Ren</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xxren8218.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-learning-linux-shell-script" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/27/learning-linux-shell-script.html" class="article-date">
  <time class="dt-published" datetime="2020-11-27T06:19:03.000Z" itemprop="datePublished">2020-11-27 14:19:03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Linux下shell脚本编程学习
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>摘要：从11月27日到12月9日，大概花了一个星期的时间，终于啃完了621页的《Linux命令行与shell脚本编程大全》。<span id="more"></span></p>
<blockquote>
<p><font size=5><b>文章说明</b></font><br><strong>文章作者：</strong><a target="_blank" rel="noopener" href="https://hwame.top">鴻塵</a><br><strong>文章说明：</strong>学习<code>shell</code>过程中的记录，参考书籍主要有《Linux命令行与shell脚本编程大全（第3版）》，《鸟哥的Linux私房菜（第三版）》系列和《快乐的 Linux 命令行》，参考资料主要有<a target="_blank" rel="noopener" href="https://man.linuxde.net/">Linux命令大全</a>等。<br><strong>文章链接：</strong><a target="_blank" rel="noopener" href="https://hwame.top/20201127/learning-linux-shell-script.html">https://hwame.top/20201127/learning-linux-shell-script.html</a></p>
</blockquote>
<h2 id="1-构建基本脚本"><a href="#1-构建基本脚本" class="headerlink" title="1.构建基本脚本"></a>1.构建基本脚本</h2><h3 id="1-1-创建shell脚本文件"><a href="#1-1-创建shell脚本文件" class="headerlink" title="1.1.创建shell脚本文件"></a>1.1.创建shell脚本文件</h3><p>创建shell脚本文件时，必须在文件的<strong>第一行</strong>指定要使用的shell。其格式为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4-处理用户输入"><a href="#4-处理用户输入" class="headerlink" title="4.处理用户输入"></a>4.处理用户输入</h2><h3 id="4-1-命令行参数"><a href="#4-1-命令行参数" class="headerlink" title="4.1.命令行参数"></a>4.1.命令行参数</h3><p><strong>注意：</strong>利用<code>$0</code>读取脚本名时存在一个潜在的问题，即<code>$0</code>参数会同时包含路径和连在一起的命令，如下表所示。解决这个问题只需要使用<code>basename</code>命令，他会返回不包含路径的脚本名：<code>basename $0</code>，例如<code>script=$(basename $0)</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">执行命令</th>
<th style="text-align:center"><code>$0</code>变量</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>bash mz.sh</code></td>
<td style="text-align:center"><code>mz.sh</code></td>
<td style="text-align:left">没有问题</td>
</tr>
<tr>
<td style="text-align:center"><code>./mz.sh</code></td>
<td style="text-align:center"><code>./mz.sh</code></td>
<td style="text-align:left">包含命令</td>
</tr>
<tr>
<td style="text-align:center"><code>bash /home/hwame/mz.sh</code></td>
<td style="text-align:center"><code>/home/hwame/mz.sh</code></td>
<td style="text-align:left">包含路径</td>
</tr>
</tbody>
</table>
</div>
<p>在shell脚本中使用命令行参数时要小心些。当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。<br>通俗的说，当脚本中使用了变量<code>$1</code>、<code>$2</code>、<code>$3</code>时，如果允许脚本时没有给出对应的命令行参数则会报错。</p>
<p>因此<strong>在使用参数前一定要检查其中是否存在数据</strong>，一种方法是使用<code>-n</code>测试来检查命令行参数<code>$1</code>中是否有数据：<code>if [ -n &quot;$1&quot;]; then</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Grabbing the last parameter</span></span><br><span class="line">params=<span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> The last parameter is <span class="variable">$params</span></span><br><span class="line"><span class="built_in">echo</span> The last parameter is <span class="variable">$&#123;!#&#125;</span></span><br></pre></td></tr></table></figure>
<p>上述示例中的两种方式都没问题。但要注意，当命令行上没有任何参数时，<code>$#</code>的值为<code>0</code>，<code>params</code>变量的值也一样，但<code>$&#123;!#&#125;</code>变量会返回命令行用到的脚本名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;$*&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;\$* Parameter #<span class="variable">$count</span> = <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;\$@ Parameter #<span class="variable">$count</span> = <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201抓取所有参数的两种方法.png" alt="抓取所有参数的两种方法"></p>
<h3 id="4-3-移动变量"><a href="#4-3-移动变量" class="headerlink" title="4.3.移动变量"></a>4.3.移动变量</h3><p>bash shell的<code>shift</code>命令能够用来操作命令行参数。顾名思义，他会根据它们的相对位置来移动命令行参数。<br>默认情况下它会将每个参数变量向左移动一个位置。所以，变量<code>$3</code>的值会移到<code>$2</code>中，变量<code>$2</code>的值会移到<code>$1</code>中，而变量<code>$1</code>的值则会被删除（注意，变量<code>$0</code>的值即程序名不会改变）。也可以一次性移动多个位置，只需要给<code>shift</code>命令提供一个参数指明要移动的位置数就行了：<code>shift n</code>。<br><strong>注意：</strong>如果某个参数被移出，它的值就被丢弃了，无法再恢复。</p>
<p>这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span> = <span class="variable">$1</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><br>运行结果如图所示：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201移动变量.png" alt="移动变量"></p>
<h3 id="4-4-处理选项"><a href="#4-4-处理选项" class="headerlink" title="4.4.处理选项"></a>4.4.处理选项</h3><p>「<code>选项</code>」是跟在单破折线后面的<strong>单个字母</strong>，它能改变命令的行为，此处介绍3种在脚本中处理选项的方法。</p>
<h4 id="1-查找选项"><a href="#1-查找选项" class="headerlink" title="(1)查找选项"></a>(1)查找选项</h4><p>表面上看，命令行选项也没什么特殊的。在命令行上，它们紧跟在脚本名之后，就跟命令行参数一样。实际上，如果愿意，你可以像处理命令行参数一样处理命令行选项。</p>
<ul>
<li><strong>①处理简单选项：</strong>可以用<code>shift</code>命令来处理脚本程序携带的命令行选项，用<code>case</code>语句来判断某个参数是否为选项。<code>case</code>语句会检查每个参数是不是有效选项，如果是就运行对应语句中的命令。不管选项按什么顺序出现在命令行上，这种方法都适用。示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># extracting command line options as parameters</span></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;;</span><br><span class="line">        -b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option&quot;</span> ;;</span><br><span class="line">        -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;;</span><br><span class="line">         *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span> ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
<li><strong>②分离参数和选项：</strong>对于在shell脚本中同时使用<strong>选项</strong>和<strong>参数</strong>的情况，标准方式是用特殊字符（双破折线<code>--</code>）来将二者分开，该字符会告诉脚本<strong>何时选项结束</strong>以及<strong>普通参数何时开始</strong>。<br>shell会用双破折线来表明选项列表结束。在双破折线之后，脚本就可以放心地将剩下的命令行参数当作<strong>参数</strong>，而不是<strong>选项</strong>来处理了。要检查双破折线，只要在case语句中加一项就行了，如下例所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># extracting options and parameters</span></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;;</span><br><span class="line">        -b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option&quot;</span> ;;</span><br><span class="line">        -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;;</span><br><span class="line">        --) <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">break</span> ;;</span><br><span class="line">         *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span> ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
运行结果如图，可以看出，第一次未分离时脚本认为所有的命令行参数都是选项；第二次使用<code>--</code>分离后，当脚本遇到双破折线时，它会停止处理选项，并将剩下的参数都当作命令行参数。<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201分离参数和选项.png" alt="分离参数和选项"></li>
<li><strong>③处理带值的选项：</strong>有些选项会带上一个额外的参数值，例如：<code>./mz.sh -a test1 -b -c -d test2</code>。当命令行选项要求额外的参数时，脚本必须能检测到并正确处理，如下例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># extracting command line options and values</span></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span>;;</span><br><span class="line">        -b) param=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with parameter value <span class="variable">$param</span>&quot;</span></span><br><span class="line">            <span class="built_in">shift</span> ;;</span><br><span class="line">        -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span>;;</span><br><span class="line">        --) <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">break</span> ;;</span><br><span class="line">         *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
在这个例子中，<code>case</code>语句定义了三个它要处理的选项，其中<code>-b</code>选项还需要一个额外的参数值。由于要处理的参数是<code>$1</code>，额外的参数值就应该位于<code>$2</code>（因为所有的参数在处理完之后都会被移出）。只要将参数值从<code>$2</code>变量中提取出来就可以了。当然，因为这个选项占用了两个参数位，所以你还需要使用<code>shift</code>命令多移动一个位置。运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201处理带值的选项.png" alt="处理带值的选项"></li>
</ul>
<p>该方法会将原始脚本的命令行参数传给<code>getopt</code>命令，之后再将<code>getopt</code>命令的输出传给<code>set</code>命令，用<code>getopt</code>格式化后的命令行参数来替换原始的命令行参数，格式看起来如下所示：<code>set -- $(getopt -q ab:cd &quot;$@&quot;)</code>。<br>现在原始的命令行参数变量的值会被<code>getopt</code>命令的输出替换，而<code>getopt</code>已经为我们格式化<br>好了命令行参数。利用该方法就可以写出能帮我们处理命令行参数的脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -- $(getopt -q ab:<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;;</span><br><span class="line">        -b) param=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with parameter value <span class="variable">$param</span>&quot;</span></span><br><span class="line">            <span class="built_in">shift</span> ;;</span><br><span class="line">        -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;;</span><br><span class="line">        --) <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">break</span> ;;</span><br><span class="line">         *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><br>注意到该例和上文<a href="#1-%E6%9F%A5%E6%89%BE%E9%80%89%E9%A1%B9">查找选项</a>中第三种情况「处理带值的选项」一样，唯一不同的是加入了<code>getopt</code>命令来帮助格式化命令行参数。并且可以运行带有复杂选项的脚本如合并的选项：<code>./mz.sh -ac</code>，同时之前的功能照样没有问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># simple demonstration of the getopts command</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :ab:c opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;;</span><br><span class="line">        b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with value <span class="variable">$OPTARG</span>&quot;</span>;;</span><br><span class="line">        c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;Unknown option: <span class="variable">$opt</span>&quot;</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>while</code>语句定义了<code>getopts</code>命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（<code>opt</code>）。注意到在本例中<code>case</code>语句的用法有些不同：<code>getopts</code>命令解析命令行选项时会移除开头的单破折线，所以在<code>case</code>定义中不用单破折线。<br><code>getopts</code>命令有几个好用的功能：①可以在参数值中包含空格；②可以将选项字母和参数值放在一起使用，而不用加空格，<code>getopts</code>命令能够从选项中正确解析出参数值；③可以将命令行上所有未定义的选项统一输出成问号，以问号形式发送给代码。<br>上述代码运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202getopts命令用法.png" alt="getopts命令用法"></p>
<p><code>getopts</code>命令知道何时停止处理选项，并将参数留给你处理。在<code>getopts</code>处理每个选项时，它会将<code>OPTIND</code>环境变量值增一。在<code>getopts</code>完成处理时，你可以使用<code>shift</code>命令和<code>OPTIND</code>值来移动参数。如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :ab:<span class="built_in">cd</span> opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;;</span><br><span class="line">        b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with value <span class="variable">$OPTARG</span>&quot;</span> ;;</span><br><span class="line">        c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;;</span><br><span class="line">        d) <span class="built_in">echo</span> <span class="string">&quot;Found the -d option&quot;</span> ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;Unknown option: <span class="variable">$opt</span>&quot;</span> ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span> $[ <span class="variable">$OPTIND</span> - 1 ]</span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Parameter <span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><br>运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202环境变量OPTIND.png" alt="环境变量OPTIND"></p>
<h3 id="4-5-将选项标准化"><a href="#4-5-将选项标准化" class="headerlink" title="4.5.将选项标准化"></a>4.5.将选项标准化</h3><p>所谓选项标准化，就是尽量遵循某些字母选项在Linux世界里已经拥有的某种程度的标准含义，而不是随意决定用哪些字母选项以及它们的用法，将选项标准化使得脚本看起来能更友好一些。常用的Linux命令选项如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">含义</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-a</code></td>
<td style="text-align:center"><code>all</code></td>
<td style="text-align:left">显示所有对象</td>
</tr>
<tr>
<td style="text-align:center"><code>-c</code></td>
<td style="text-align:center"><code>count</code></td>
<td style="text-align:left">生成一个计数</td>
</tr>
<tr>
<td style="text-align:center"><code>-d</code></td>
<td style="text-align:center"><code>directory</code></td>
<td style="text-align:left">指定一个目录</td>
</tr>
<tr>
<td style="text-align:center"><code>-e</code></td>
<td style="text-align:center"><code>extend</code></td>
<td style="text-align:left">扩展一个对象</td>
</tr>
<tr>
<td style="text-align:center"><code>-f</code></td>
<td style="text-align:center"><code>file</code></td>
<td style="text-align:left">指定读入数据的文件</td>
</tr>
<tr>
<td style="text-align:center"><code>-h</code></td>
<td style="text-align:center"><code>help</code></td>
<td style="text-align:left">显示命令的帮助信息</td>
</tr>
<tr>
<td style="text-align:center"><code>-i</code></td>
<td style="text-align:center"><code>ignorecase</code></td>
<td style="text-align:left">忽略文本大小写</td>
</tr>
<tr>
<td style="text-align:center"><code>-l</code></td>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:left">产生输出的长格式版本</td>
</tr>
<tr>
<td style="text-align:center"><code>-n</code></td>
<td style="text-align:center"><code>non-interactive</code></td>
<td style="text-align:left">使用非交互模式（批处理）</td>
</tr>
<tr>
<td style="text-align:center"><code>-o</code></td>
<td style="text-align:center"><code>output redirect</code></td>
<td style="text-align:left">将所有输出重定向到指定的输出文件</td>
</tr>
<tr>
<td style="text-align:center"><code>-q</code><br><code>-s</code></td>
<td style="text-align:center"><code>quiet</code><br><code>silent</code></td>
<td style="text-align:left">以安静模式运行</td>
</tr>
<tr>
<td style="text-align:center"><code>-r</code></td>
<td style="text-align:center"><code>recursive</code></td>
<td style="text-align:left">递归地处理目录和文件</td>
</tr>
<tr>
<td style="text-align:center"><code>-v</code></td>
<td style="text-align:center"><code>verbose</code></td>
<td style="text-align:left">生成详细输出</td>
</tr>
<tr>
<td style="text-align:center"><code>-x</code></td>
<td style="text-align:center"><code>exclude</code></td>
<td style="text-align:left">排除某个对象</td>
</tr>
<tr>
<td style="text-align:center"><code>-y</code></td>
<td style="text-align:center"><code>yes</code></td>
<td style="text-align:left">对所有问题回答yes</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-6-获得用户输入"><a href="#4-6-获得用户输入" class="headerlink" title="4.6.获得用户输入"></a>4.6.获得用户输入</h3><p>尽管命令行选项和参数是从脚本用户处获得输入的一种重要方式，但有时脚本的交互性还需要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本的人来回答。bash shell为此提供了<code>read</code>命令。</p>
<h4 id="1-基本的读取"><a href="#1-基本的读取" class="headerlink" title="(1)基本的读取"></a>(1)基本的读取</h4><p><code>read</code>命令从标准输入（键盘）或另一个文件描述符中接受输入，在收到输入后会将数据放进一个指定的变量。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Enter your name: &quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$name</span>, welcome to my program. &quot;</span></span><br></pre></td></tr></table></figure><br>注意，上例中生成提示的<code>echo</code>命令使用了<code>-n</code>选项。该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。这让脚本看起来更像表单。<br>实际上，<strong><code>read</code>命令包含了<code>-p</code>选项，允许你直接在<code>read</code>命令行指定提示符</strong>。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please enter your age: &quot;</span> age</span><br><span class="line">days=$[ <span class="variable">$age</span> * 365 ]</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;That makes you over <span class="variable">$days</span> days old! &quot;</span></span><br></pre></td></tr></table></figure><br><code>read</code>命令也允许指定多个变量，输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量。是不是和Python中的<code>*args</code>和<code>**kwargs</code>有点像呢？<br>也可以在<code>read</code>命令行中不指定变量，这样它收到的任何数据都会放进特殊环境变量<code>REPLY</code>中。<code>REPLY</code>环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用。</p>
<h4 id="2-超时"><a href="#2-超时" class="headerlink" title="(2)超时"></a>(2)超时</h4><p>如果不管是否有数据输入，脚本都必须继续执行，你可以用<code>-t</code>选项来指定一个计时器，他指定了<code>read</code>命令等待输入的秒数。当计时器过期后，<code>read</code>命令会返回一个非零退出状态码，可以使用<code>if-then</code>语句或<code>while</code>循环这种标准的结构化语句来理清所发生的具体情况。</p>
<p>也可以不对输入过程计时，而是让<code>read</code>命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。可以将<code>-n</code>选项和值<code>1</code>一起使用，告诉<code>read</code>命令在接受<strong>单个字符</strong>后退出。只要按下单个字符回答后，<code>read</code>命令就会接受输入并将它传给变量，无需按回车键。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -n1 -p <span class="string">&quot;Do you want to continue [Y/N]? &quot;</span> answer</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$answer</span> <span class="keyword">in</span></span><br><span class="line">    Y | y) <span class="built_in">echo</span></span><br><span class="line">           <span class="built_in">echo</span> <span class="string">&quot;fine, continue on…&quot;</span>;;</span><br><span class="line">    N | n) <span class="built_in">echo</span></span><br><span class="line">           <span class="built_in">echo</span> OK, goodbye</span><br><span class="line">           <span class="built_in">exit</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is the end of the script&quot;</span></span><br></pre></td></tr></table></figure><br>运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202read命令接受指定字符.png" alt="read命令接受指定字符"></p>
<h4 id="3-隐藏方式读取"><a href="#3-隐藏方式读取" class="headerlink" title="(3)隐藏方式读取"></a>(3)隐藏方式读取</h4><p>当需要输入类似密码这种需要从脚本用户处得到输入，但又在屏幕上显示输入信息时，可以使用<code>-s</code>选项不回显终端的输入（实际上数据会被显示，只是<code>read</code>命令会将文本颜色设成跟背景色一样）。输入提示符输入的数据不会出现在屏幕上，但会赋给变量，以便在脚本中使用。例如：<code>read -s -p &quot;Enter your password: &quot; password</code>。</p>
<h4 id="4-从文件中读取"><a href="#4-从文件中读取" class="headerlink" title="(4)从文件中读取"></a>(4)从文件中读取</h4><p>可以用<code>read</code>命令来读取文件里的数据，每次调用<code>read</code>命令都会从文件中读取一行文本。当文件中再没有内容时，<code>read</code>命令会退出并返回非零退出状态码。<br>如何将文件中的数据传给<code>read</code>命令呢？最常见的方法是对文件使用<code>cat</code>命令，将结果通过管道直接传给含有<code>read</code>命令的<code>while</code>命令。见下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=1</span><br><span class="line">cat textfile | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Line <span class="variable">$count</span>: <span class="variable">$line</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Finished processing the file&quot;</span></span><br></pre></td></tr></table></figure><br>文件<code>textfile</code>内容及运行结果如下：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202从文件中读取数据.png" alt="从文件中读取数据"></p>
<h2 id="5-创建函数"><a href="#5-创建函数" class="headerlink" title="5.创建函数"></a>5.创建函数</h2><h3 id="5-1-基本脚本函数"><a href="#5-1-基本脚本函数" class="headerlink" title="5.1.基本脚本函数"></a>5.1.基本脚本函数</h3><p>函数是一个脚本代码块，你可以为其命名并在<strong>代码中任何位置</strong>重用，调用函数（在脚本中使用该代码块）时只要使用所起的函数名就行了。</p>
<p><strong>创建函数的第一种格式</strong>是采用关键字<code>function</code>，后跟分配给该代码块的函数名：<br><code>name</code>属性定义了赋予函数的唯一名称，脚本中定义的每个函数都必须有一个唯一的名称。<code>commands</code>是构成函数的一条或多条bash shell命令，在调用该函数时会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> name &#123;</span><br><span class="line">    commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>创建函数的第二种格式</strong>更接近于其他编程语言中定义函数的方式：<br>函数名后的空括号表明正在定义的是一个函数，这种格式的命名规则和之前定义shell脚本函数的格式一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">name</span></span>() &#123;</span><br><span class="line">    commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>至于使用函数，只需要像其他shell命令一样，在行中<strong>指定函数名</strong>就行了。</p>
<p><strong>注意①：</strong>函数定义不一定非得是shell脚本中首先要做的事，但必须在使用函数之前定义它，否则会收到一条<code>command not found</code>的错误消息。<br><strong>注意②：</strong>函数名必须是唯一的，如果你重定义了函数，新定义会覆盖原来函数的定义，这一切不会产生任何错误消息。</p>
<h3 id="5-2-返回值"><a href="#5-2-返回值" class="headerlink" title="5.2.返回值"></a>5.2.返回值</h3><p>bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码，生成退出状态码有以下3种不同的方法：</p>
<ul>
<li><strong>默认退出状态码：</strong>默认情况下，函数的退出状态码是<strong>函数中最后一条命令返回的退出状态码</strong>。在函数执行结束后，可以用标准变量<code>$?</code>来确定函数的退出状态码。<br><strong>注意</strong>：由于函数的默认退出状态码取决于函数体中最后一条命令的退出状态码，因此你无法知道函数中其他命令中是否成功运行，所以这种方法很危险。</li>
<li><strong>使用<code>return</code>命令：</strong>使用<code>return</code>命令来退出函数并返回特定的退出状态码，它允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。<br><strong>注意</strong>：①函数一结束就取返回值，否则可能会丢失返回值。②退出状态码的范围是0~255，超出则会取余。</li>
<li><strong>使用函数输出：</strong>正如可以将命令的输出保存到shell变量中一样，你也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中。见下例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> myfunc &#123;</span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;Enter a value: &quot;</span> value</span><br><span class="line">    <span class="built_in">echo</span> $[ <span class="variable">$value</span> * 2 ]</span><br><span class="line">&#125;</span><br><span class="line">result=$(myfunc)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The new value is <span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>
<strong>注意①</strong>：该函数实际上输出了两条消息，<code>read</code>命令输出了一条简短的消息来向用户询问输入值，但bash shell并不将其作为<code>STDOUT</code>输出的一部分，并且忽略掉它。如果你用<code>echo</code>语句生成这条消息来向用户查询，那么它会与输出值一起被读进shell变量中。<br><strong>注意②</strong>：这种方法还可以返回浮点值和字符串值，这使它成为一种获取函数返回值的强大方法。上例运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209使用函数输出返回值.png" alt="使用函数输出返回值"></li>
</ul>
<h3 id="5-3-在函数中使用变量"><a href="#5-3-在函数中使用变量" class="headerlink" title="5.3.在函数中使用变量"></a>5.3.在函数中使用变量</h3><blockquote>
<p>在函数中使用变量时，你需要注意它们的定义方式以及处理方式——这是shell脚本中常见错误的根源。</p>
</blockquote>
<h4 id="向函数传递参数"><a href="#向函数传递参数" class="headerlink" title="向函数传递参数"></a>向函数传递参数</h4><p>bash shell会将函数当作小型脚本来对待，这意味着你可以像普通脚本那样向函数传递参数。</p>
<p>函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在<code>$0</code>变量中定义，函数命令行上的任何参数都会通过<code>$1</code>、<code>$2</code>等定义。也可以用特殊变量<code>$#</code>来判断传给函数的参数数目。<br><strong>注意①：</strong>在脚本中指定函数时，必须将参数和函数放在同一行，例如<code>func1 $value1 10</code>，<code>result=$(func1 $value1 10)</code>；<br><strong>注意②：</strong>由于函数使用特殊参数环境变量作为自己的参数值，因此它<strong>无法直接获取脚本在命令行中的参数值</strong>。尽管函数也使用了<code>$1</code>和<code>$2</code>变量，但它们和脚本主体中的<code>$1</code>和<code>$2</code>变量并不相同。要在函数中使用这些值，必须在调用函数时手动将它们传过去。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> myfunc &#123;</span><br><span class="line">    <span class="built_in">echo</span> $[ <span class="variable">$1</span> * <span class="variable">$2</span> ]</span><br><span class="line">&#125;</span><br><span class="line">value1=$(myfunc 10 20)</span><br><span class="line">value2=$(myfunc)</span><br><span class="line">value3=$(myfunc <span class="variable">$1</span> <span class="variable">$2</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The result is <span class="variable">$valuex</span>&quot;</span></span><br></pre></td></tr></table></figure><br>如上例，<code>value1</code>是正常的函数调用方式，将参数和函数放在同一行。如果想让<code>value2</code>以这种方式直接获取命令行参数值将报错：<code>syntax error: operand expected...</code>，原因见上，解决办法就是按<code>value3</code>的方式。尽管在函数的定义和调用时都使用了<code>$1</code>和<code>$2</code>变量，但他们的区别就如同形参和实参。</p>
<h4 id="在函数中处理变量"><a href="#在函数中处理变量" class="headerlink" title="在函数中处理变量"></a>在函数中处理变量</h4><p>变量的作用域也会经常带来麻烦，作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同，也就是说，对脚本的其他部分而言，它们是隐藏的。</p>
<p>函数使用两种类型的变量：<strong>全局变量</strong>和<strong>局部变量</strong>。</p>
<ul>
<li><strong>全局变量：</strong>在shell脚本中任何地方都有效的变量。如果你在脚本的主体部分定义了一个全局变量，那么可以在函数内读取它的值。<strong>类似地，如果你在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。</strong>默认情况下，在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问。<br><strong>注意：</strong>在使用全局变量时，如果变量被修改后新值将依然有效，这有时会产生难以预料的后果。它要求你清清楚楚地知道函数中具体使用了哪些变量，包括那些用来计算非返回值的变量。</li>
<li><strong>局部变量：</strong><code>local</code>关键字保证了变量只局限在该函数中，如果脚本中在该函数之外有同样名字的变量，那么shell将会保持这两个变量的值是分离的。<br>如果要将函数内部使用的任何变量都声明成局部变量，只需要在变量声明的前面加上<code>local</code>关键字：<code>local temp</code>。也可以在变量赋值语句中使用<code>local</code>关键字：<code>local temp=$[ $value + 5 ]</code>。</li>
</ul>
<h3 id="5-4-数组变量和函数"><a href="#5-4-数组变量和函数" class="headerlink" title="5.4.数组变量和函数"></a>5.4.数组变量和函数</h3><h4 id="向函数传递数组参数"><a href="#向函数传递数组参数" class="headerlink" title="向函数传递数组参数"></a>向函数传递数组参数</h4><p>向脚本函数传递数组变量的方法会有点不好理解。将数组变量当作单个参数传递的话，它不会起作用。见下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> testit &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The parameters are: <span class="variable">$@</span>&quot;</span></span><br><span class="line">    thisarray=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The received array is <span class="variable">$&#123;thisarray[*]&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">myarray=(1 2 3 4 5)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The original array is: <span class="variable">$&#123;myarray[*]&#125;</span>&quot;</span></span><br><span class="line">testit <span class="variable">$myarray</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果如下：</span></span><br><span class="line"><span class="comment"># The original array is: 1 2 3 4 5</span></span><br><span class="line"><span class="comment"># The parameters are: 1</span></span><br><span class="line"><span class="comment"># The received array is 1</span></span><br></pre></td></tr></table></figure><br>如你所见，如果将该数组变量作为函数参数，函数只会取数组变量的第一个值。要解决这个问题，必须将该数组变量的值分解成单个值，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量。<br>如下例所示，<code>$myarray</code>变量来保存所有的数组元素，然后将它们都放在函数的命令行上。该函数随后从命令行参数中重建数组变量。在函数内部，数组仍然可以像其他数组一样使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> testit &#123;</span><br><span class="line">    <span class="built_in">local</span> newarray</span><br><span class="line">    newarray=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>))</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The new array value is: <span class="variable">$&#123;newarray[*]&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">myarray=(1 2 3 4 5)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The original array is <span class="variable">$&#123;myarray[*]&#125;</span>&quot;</span></span><br><span class="line">testit <span class="variable">$&#123;myarray[*]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果如下：</span></span><br><span class="line"><span class="comment"># The original array is 1 2 3 4 5</span></span><br><span class="line"><span class="comment"># The new array value is: 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><br>下面是一个遍历数组并将所有元素累加的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> addarray &#123;</span><br><span class="line">    <span class="built_in">local</span> sum=0</span><br><span class="line">    <span class="built_in">local</span> newarray</span><br><span class="line">    newarray=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> <span class="variable">$&#123;newarray[*]&#125;</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        sum=$[ <span class="variable">$sum</span> + <span class="variable">$value</span> ]</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$sum</span></span><br><span class="line">&#125;</span><br><span class="line">myarray=(1 2 3 4 5)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The original array is: <span class="variable">$&#123;myarray[*]&#125;</span>&quot;</span></span><br><span class="line">arg1=$(<span class="built_in">echo</span> <span class="variable">$&#123;myarray[*]&#125;</span>)</span><br><span class="line">result=$(addarray <span class="variable">$arg1</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The result is <span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure><br>运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209遍历数组累加.png" alt="遍历数组累加"></p>
<h4 id="从函数返回数组"><a href="#从函数返回数组" class="headerlink" title="从函数返回数组"></a>从函数返回数组</h4><p>从函数里向shell脚本传回数组变量也用类似的方法：函数用<code>echo</code>语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。见下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> returnarray &#123;</span><br><span class="line">    <span class="built_in">local</span> oriarray</span><br><span class="line">    <span class="built_in">local</span> newarray</span><br><span class="line">    <span class="built_in">local</span> elements</span><br><span class="line">    <span class="built_in">local</span> i</span><br><span class="line">    oriarray=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>))</span><br><span class="line">    newarray=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>))</span><br><span class="line">    elements=$[ <span class="variable">$#</span> - 1 ]</span><br><span class="line">    <span class="keyword">for</span> (( i = 0; i &lt;= <span class="variable">$elements</span>; i++ ))</span><br><span class="line">    &#123;</span><br><span class="line">        newarray[<span class="variable">$i</span>]=$[ <span class="variable">$&#123;oriarray[$i]&#125;</span> * 2 ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;newarray[*]&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">myarray=(1 2 3 4 5)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The original array is: <span class="variable">$&#123;myarray[*]&#125;</span>&quot;</span></span><br><span class="line">arg1=$(<span class="built_in">echo</span> <span class="variable">$&#123;myarray[*]&#125;</span>)</span><br><span class="line">result=($(returnarray <span class="variable">$arg1</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The new array is: <span class="variable">$&#123;result[*]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><br>该脚本用<code>$arg1</code>变量将数组值传给<code>returnarray</code>函数，函数将该数组重组到新的数组变量中，生成该输出数组变量的一个副本。然后对数据元素进行遍历，将每个元素值翻倍，并将结果存入函数中该数组变量的副本。<br><code>returnarray</code>函数使用<code>echo</code>语句来输出每个数组元素的值。脚本用<code>returnarray</code>函数的输出来重新生成一个新的数组变量。运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209从函数返回数组.png" alt="从函数返回数组"></p>
<h3 id="5-5-函数递归"><a href="#5-5-函数递归" class="headerlink" title="5.5.函数递归"></a>5.5.函数递归</h3><p>局部函数变量的一个特性是<strong>自成体系</strong>，除了从脚本命令行处获得的变量，自成体系的函数不需要使用任何外部资源。这个特性使得函数可以递归地调用，也就是说，函数可以调用自己来得到结果。<br>通常递归函数都有一个最终可以迭代到的基准值。许多高级数学算法用递归对复杂的方程进行逐级规约，直到基准值定义的那级。递归算法的经典例子是计算阶乘：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> factorial &#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$1</span> -eq 1 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> 1</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">local</span> temp=$[ <span class="variable">$1</span> - 1 ]</span><br><span class="line">        <span class="built_in">local</span> result=$(factorial <span class="variable">$temp</span>)</span><br><span class="line">        <span class="built_in">echo</span> $[ <span class="variable">$result</span> * <span class="variable">$1</span> ]</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter value: &quot;</span> value</span><br><span class="line">result=$(factorial <span class="variable">$value</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The factorial of <span class="variable">$value</span> is: <span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure><br>运行结果如下：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209计算简单阶乘.png" alt="计算简单阶乘"></p>
<h3 id="5-6-创建库"><a href="#5-6-创建库" class="headerlink" title="5.6.创建库"></a>5.6.创建库</h3><p>bash shell允许创建函数<strong>库文件</strong>，然后在多个脚本中引用该库文件。<br>第一步需要创建一个包含脚本中所需函数的公用库文件，例如定义了3个简单的函数的库文件<code>myfuncs</code>。第二步就是在用到这些函数的脚本文件中包含该库文件，但是问题就来了。</p>
<blockquote>
<p>和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行<code>myfuncs</code>的shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。<br>这同样适用于脚本：如果你尝试像普通脚本文件那样运行库文件，函数并不会出现在脚本中。例如运行下例将报错<code>addem: command not found</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">./myfuncs</span><br><span class="line"><span class="comment"># 库文件中的函数addem将两数相加</span></span><br><span class="line">result=$(addem 10 15)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The result is <span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>使用函数库的关键在于<code>source</code>命令。 <code>source</code>命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用<code>source</code>命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。<br><code>source</code>命令有个快捷的别名<code>.</code>，称作点操作符（dot operator）。要在shell脚本中运行<code>myfuncs</code>库文件，只需添加：<code>. ./myfuncs</code>。如果库文件和shell脚本不是位于同一目录，则需要使用相应路径访问该库文件。</p>
<h3 id="5-7-在命令行上使用函数"><a href="#5-7-在命令行上使用函数" class="headerlink" title="5.7.在命令行上使用函数"></a>5.7.在命令行上使用函数</h3><p>和在shell脚本中将脚本函数当命令使用一样，在命令行界面的提示符下你也可以直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在<code>PATH</code>环境变量里。<br><strong>重点在于让shell能够识别这些函数</strong>，有以下两种方法：</p>
<ul>
<li>在命令行上创建函数；</li>
<li>在<code>.bashrc</code>文件中定义函数。</li>
</ul>
<p>对于简单的函数，可以在命令行上直接定义一个函数，因为shell会解释用户输入的命令。如果采用<strong>单行方式定义函数</strong>，必须在每个命令后面加个分号，这样shell就能知道在哪里是命令的起止了；如果采用<strong>多行方式定义函数</strong>，则不需要添加分号，只需要回车即可。如图所示：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209命令行上使用函数.png" alt="命令行上使用函数"><br><strong>注意：</strong>在命令行上创建函数时，如果你给函数起了个跟内建命令或另一个命令相同的名字，函数将会覆盖原来的命令。</p>
<hr>
<p>在命令行上创建函数不仅输入不便，而且最主要的问题是退出shell时函数就消失了。最简单的解决办法就是将函数定义在<code>.bashrc</code>文件中，bash shell在每次启动时都会在主目录下查找这个文件，不管是交互式shell还是从现有shell中启动的新shell。</p>
<ul>
<li><strong>直接定义函数</strong>，可以直接在主目录下的<code>.bashrc</code>文件中定义函数。许多Linux发行版已经在<code>.bashrc</code>文件中定义了一些东西，所以注意不要误删了，把你写的函数放在文件末尾就行了。</li>
<li><strong>读取函数文件</strong>，只要是在shell脚本中，都可以用<code>source</code>命令（或者它的别名<code>.</code>操作符）将库文件中的函数添加到<code>.bashrc</code>脚本中。 shell还会将定义好的函数传给子shell进程，这样一来，这些函数就自动能够用于该shell会话中的任何shell脚本了。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xxren8218.github.io/2020/11/27/learning-linux-shell-script.html" data-id="cklvkr58f0014swv11ys3ci9r" data-title="Linux下shell脚本编程学习" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shell/" rel="tag">shell</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/02/02_%E7%AC%AC%E4%B8%80%E4%B8%AAPython%E7%A8%8B%E5%BA%8F.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          第一个python程序
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E5%9F%BA%E7%A1%80/" rel="tag">python基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/python%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">python基础</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/04/xxx.html">xxx</a>
          </li>
        
          <li>
            <a href="/2021/03/04/%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D.html">变量的命名</a>
          </li>
        
          <li>
            <a href="/2021/03/04/%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html">变量的基本使用</a>
          </li>
        
          <li>
            <a href="/2021/03/04/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.html">程序执行原理</a>
          </li>
        
          <li>
            <a href="/2021/03/04/%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6.html">算数运算符</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 任晓雄<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


</body>
</html>