<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-06-30T17:01:15.347Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>26-HBase概述</title>
    <link href="https://xxren8218.github.io/20210701/26-HBase%E6%A6%82%E8%BF%B0.html"/>
    <id>https://xxren8218.github.io/20210701/26-HBase%E6%A6%82%E8%BF%B0.html</id>
    <published>2021-06-30T16:54:44.000Z</published>
    <updated>2021-06-30T17:01:15.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HBase简介与环境部署"><a href="#HBase简介与环境部署" class="headerlink" title="HBase简介与环境部署"></a>HBase简介与环境部署</h2><h3 id="1-HBase简介-amp-在Hadoop生态中的地位"><a href="#1-HBase简介-amp-在Hadoop生态中的地位" class="headerlink" title="1. HBase简介&amp;在Hadoop生态中的地位"></a>1. HBase简介&amp;在Hadoop生态中的地位</h3><h4 id="1-1-什么是HBase"><a href="#1-1-什么是HBase" class="headerlink" title="1.1. 什么是HBase"></a>1.1. 什么是HBase</h4><ul><li>HBase是一个<strong>分布式</strong>的、<strong>面向列</strong>的<strong>开源数据库</strong></li><li>HBase是Google BigTable的开源实现</li><li>HBase不同于一般的关系数据库, 适合<strong>非结构化数据存储</strong></li></ul><h4 id="1-2-BigTable"><a href="#1-2-BigTable" class="headerlink" title="1.2 BigTable"></a>1.2 BigTable</h4><ul><li>BigTable是Google设计的分布式数据存储系统，用来处理海量的数据的一种非关系型的数据库。<ul><li>适合大规模海量数据，PB级数据；</li><li>分布式、并发数据处理，效率极高；</li><li>易于扩展，支持动态伸缩</li><li>适用于廉价设备；</li><li>不适用于传统关系型数据的存储；</li></ul></li></ul><h4 id="1-3-什么是非结构化数据存储"><a href="#1-3-什么是非结构化数据存储" class="headerlink" title="1.3 什么是非结构化数据存储"></a>1.3 什么是非结构化数据存储</h4><ul><li>结构化数据<ul><li>适合用二维表来展示的数据</li></ul></li><li>非结构化数据<ul><li>非结构化数据是数据结构不规则或不完整<ul><li>如名人词条：科学家：成果；演员：电影；其中如演员有50个字段，但是只有5个与科学家是公用的。如年龄、性别等。导致二维表出现很多数据稀疏。</li><li>或者处理业务时数据一直变，删一行，当达到100000行时，此时处理时间很长，需要把数据库锁起来，这样对线上的业务就有影响了。</li></ul></li><li>没有预定义的数据模型<ul><li>开始没想好字段是什么，随着业务逻辑增加。</li></ul></li><li>不方便用数据库二维逻辑表来表现<ul><li>办公文档、文本、图片、XML, HTML、各类报表、图像和音频/视频信息等</li></ul></li></ul></li></ul><h4 id="1-4-HBase在Hadoop生态中的地位"><a href="#1-4-HBase在Hadoop生态中的地位" class="headerlink" title="1.4 HBase在Hadoop生态中的地位"></a>1.4 HBase在Hadoop生态中的地位</h4><ul><li><p>HBase是Apache基金会顶级项目</p></li><li><p>HBase基于HDFS进行数据存储</p></li><li><p>HBase可以存储超大数据并适合用来进行大数据的实时查询</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005654.png" alt=""></p></li></ul><h4 id="1-5-HBase与HDFS"><a href="#1-5-HBase与HDFS" class="headerlink" title="1.5 HBase与HDFS"></a>1.5 HBase与HDFS</h4><ul><li>HBase建立在Hadoop文件系统上, 利用了HDFS的容错能力</li><li>HBase提供对数据的<strong>随机实时读/写访问功能</strong></li><li>HBase<strong>内部使用哈希表, 并存储索引</strong>, 可以<strong>快速查找HDFS中数据</strong></li></ul><h4 id="1-6-HBase使用场景"><a href="#1-6-HBase使用场景" class="headerlink" title="1.6 HBase使用场景"></a>1.6 HBase使用场景</h4><ul><li>瞬间写入量很大</li><li>大量数据需要长期保存, 且数量会持续增长</li><li>HBase不适合有join, 多级索引, 表关系复杂的数据模型</li></ul><h3 id="2-HBase的数据模型"><a href="#2-HBase的数据模型" class="headerlink" title="2 HBase的数据模型"></a>2 HBase的数据模型</h3><h4 id="2-1-ACID定义"><a href="#2-1-ACID定义" class="headerlink" title="2.1 ACID定义"></a>2.1 ACID定义</h4><ul><li>指数据库事务正确执行的四个基本要素的缩写<ul><li>原子性 A <ul><li><strong>要么都完成，要么都失败，事务过程不能分割。</strong></li><li>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li></ul></li><li>一致性 C<ul><li><strong>状态改变，无论并发的事务有多少，必须保持同一个状态。</strong></li><li>一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91"><strong>并发</strong></a>事务有多少。</li></ul></li><li>隔离性 I<ul><li><strong>两个事务同时运行必须是一个事务运行完了，再运行另一个事务。不能同时执行</strong>。</li><li>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</li></ul></li><li>持久性 D<ul><li><strong>事务一旦完成不会回滚</strong></li><li>在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li></ul></li><li>HBase<ul><li>不同于Hive，Hive只是涉及到查询操作，并不涉及事务的概念。但是HBase就不是了。</li><li>HBase 支持特定场景下的 ACID，即对<strong>行级别的事务</strong> 操作保证完全的 ACID</li></ul></li></ul></li></ul><h4 id="2-2-cap定理"><a href="#2-2-cap定理" class="headerlink" title="2.2 cap定理"></a>2.2 cap定理</h4><ul><li><p>分布式系统的最大难点，就是<strong>各个节点的状态如何同步</strong>。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。</p><ul><li><p><strong>一致性</strong>(所有节点在同一时间具有相同的数据)</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005726.png" alt=""></p></li><li><p><strong>可用性</strong>(保证每个请求不管成功或失败都有响应,但不保证获取的数据的正确性)</p></li><li><p><strong>分区容错性</strong>(系统中任意信息的丢失或失败不会影响系统的运行,系统如果不能在某个时限内达成数据一致性,就必须在上面两个操作之间做出选择)——<strong>任何时候都要保证的！</strong>其余两个就要做取舍了。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005748.jpg" alt=""></p><p><strong>hbase是CAP中的CP系统,即hbase是强一致性的</strong>——用牺牲可用性的代价。</p></li></ul><h4 id="2-3-HBase表结构"><a href="#2-3-HBase表结构" class="headerlink" title="2.3 HBase表结构"></a>2.3 HBase表结构</h4><ul><li><code>NameSpace</code>: 关系型数据库的”数据库”(database)</li><li>表(table)：用于存储管理数据，具有稀疏的、面向列的特点。HBase中的每一张表，就是所谓的大表(Bigtable)，可以有上亿行，上百万列。对于为值为空的列，并不占用存储空间，因此表可以设计的非常稀疏。</li><li>行(Row)：在表里面,每一行代表着一个数据对象,每一行都是以一个行键(Row Key)来进行唯一标识的, 行键并没有什么特定的数据类型, 以二进制的字节来存储</li><li>列(Column): HBase的列由 Column family 和 Column qualifier 组成, 由冒号: 进行行间隔, 如 family: qualifier</li><li>行键(RowKey)：类似于MySQL中的主键，HBase根据行键来快速检索数据，一个行键对应一条记录。与MySQL主键不同的是，HBase的行键是天然固有的，每一行数据都存在行键。</li><li>列族(ColumnFamily)：是列的集合。列族在表定义时需要指定，而列在插入数据时动态指定。列中的数据都是以二进制形式存在，没有数据类型。在物理存储结构上，<strong>每个表中的每个列族单独以一个文件存储</strong>。一个表可以有多个列簇。</li><li>列修饰符(<em>Column</em> <em>Qualifier</em>) : 列族中的数据通过列标识来进行映射, 可以理解为一个键值对(key-value), 列修饰符(<em>Column</em> <em>Qualifier</em>) 就是key 对应关系型数据库的列</li><li>时间戳(TimeStamp)：是列的一个属性，是一个64位整数。由行键和列确定的单元格，可以存储多个数据，每个数据含有时间戳属性，数据具有版本特性。可根据版本(VERSIONS)或时间戳来指定查询历史版本数据，如果都不指定，则默认返回最新版本的数据。</li><li>区域(Region)：HBase自动把表水平划分成的多个区域，划分的区域随着数据的增大而增多。</li><li>HBase 支持特定场景下的 ACID，即对行级别的 操作保证完全的 ACID</li></ul><h4 id="2-4-面向列的数据库"><a href="#2-4-面向列的数据库" class="headerlink" title="2.4 面向列的数据库"></a>2.4 面向列的数据库</h4><p><strong>HBase 与 传统关系数据库的区别</strong></p><table style="overflow: scroll;">  <tr>    <th></th>    <th>HBase</th>    <th>关系型数据库</th>  </tr>  <tr>    <td> 数据库大小 </td>    <td> PB级别  </td>    <td>GB TB</td>  </tr>  <tr>    <td> 数据类型 </td>    <td> Bytes </td>    <td> 丰富的数据类型 </td>  </tr>    <tr>    <td> 事务支持 </td>    <td> ACID只支持单个Row级别 </td>    <td> 全面的ACID支持, 对Row和表</td>  </tr>  <tr>    <td> 索引 </td>    <td> 只支持Row-key </td>    <td> 支持 </td>  </tr>    <tr>    <td> 吞吐量 </td>    <td> 百万写入/秒 </td>    <td> 数千写入/秒</td>  </tr></table><ul><li>关系型数据库中数据示例</li></ul><table style="overflow: scroll;">  <tr>    <th>ID</th>    <th>FILE NAME</th>    <th>FILE PATH</th>    <th>FILE TYPE</th>    <th>FILE SIZE</th>    <th>CREATOR</th>  </tr>  <tr>    <td> 1 </td>    <td> file1.txt  </td>    <td>/home</td>    <td> txt </td>    <td> 1024 </td>    <td> tom </td>  </tr>  <tr>    <td> 2 </td>    <td> file2.txt  </td>    <td>/home/pics</td>    <td> jpg </td>    <td> 5032 </td>    <td> jerry </td>  </tr></table><ul><li>同样数据保存到列式数据库中</li></ul><table style="overflow: scroll;"><tr><th>RowKey</th><th>FILE INFO（列族：列标识符[列名]：值）</th><th>SAVE INFO</th></tr><tr><td> 1 </td><td> file_info:name:file1.txt<br>file_info:type:txt<br>file_info:size:1024</td><td>path:/home/picscreator:Jerry</td></tr><tr><td> 2 </td><td>file_info:name:file2.jpg<br>file_info:type:jpg<br>file_info:size:5032</td><td> path:/homecreator:Tom</td></tr></table><ul><li>行数据库&amp;列数据库存储方式比较</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005813.png" alt=""></p><h3 id="3-HBase组件"><a href="#3-HBase组件" class="headerlink" title="3 HBase组件"></a>3 HBase组件</h3><h4 id="3-1-HBase-基础架构"><a href="#3-1-HBase-基础架构" class="headerlink" title="3.1 HBase 基础架构"></a>3.1 HBase 基础架构</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005839.jpg" alt=""></p><h5 id="3-1-1-Client"><a href="#3-1-1-Client" class="headerlink" title="3.1.1 Client"></a><strong>3.1.1 Client</strong></h5><ul><li>①与zookeeper通信, 找到数据入口地址</li><li>②使用HBase RPC机制与HMaster和HRegionServer进行通信；</li><li>③Client与HMaster进行通信进行管理类操作；</li><li>④Client与HRegionServer进行数据读写类操作。</li></ul><h5 id="3-1-2-Zookeeper"><a href="#3-1-2-Zookeeper" class="headerlink" title="3.1.2 Zookeeper"></a>3.1.2 <strong>Zookeeper</strong></h5><ul><li>①保证任何时候，集群中只有一个running master，避免单点问题；</li><li>②存贮所有Region的寻址入口，包括-ROOT-表地址、HMaster地址；</li><li>③实时监控Region Server的状态，将Region server的上线和下线信息，实时通知给Master；</li><li>④存储Hbase的schema，包括有哪些table，每个table有哪些column family。</li></ul><h5 id="3-1-3-HMaster（主）"><a href="#3-1-3-HMaster（主）" class="headerlink" title="3.1.3 HMaster（主）"></a>3.1.3 <strong>HMaster（主）</strong></h5><p>可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master运行。</p><p>角色功能：</p><ul><li>①为Region server分配region；</li><li>②负责region server的负载均衡；</li><li>③发现失效的region serve并重新分配其上的region；</li><li>④HDFS上的垃圾文件回收；</li><li>⑤处理用户对表的增删改查操作。</li></ul><h5 id="3-1-4-HRegionServer（从）"><a href="#3-1-4-HRegionServer（从）" class="headerlink" title="3.1.4 HRegionServer（从）"></a>3.1.4 <strong>HRegionServer（从）</strong></h5><p>HBase中最核心的模块，主要负责响应用户I/O请求，向HDFS文件系统中读写数据。</p><p>作用：</p><ul><li>①维护Master分配给它的region，处理对这些region的IO请求；</li><li>②负责切分在运行过程中变得过大的region。</li><li>此外，HRegionServer管理一系列HRegion对象，每个HRegion对应Table中一个Region，HRegion由多个HStore组成，每个HStore对应Table中一个Column Family的存储，Column Family就是一个集中的存储单元，故将具有相同IO特性的Column放在一个Column Family会更高效。</li></ul><h5 id="3-1-5-HStore"><a href="#3-1-5-HStore" class="headerlink" title="3.1.5 HStore"></a>3.1.5 <strong>HStore</strong></h5><ul><li>HBase存储的核心，由MemStore和StoreFile组成。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005904.png" alt=""></p><ul><li>用户写入数据的流程为：client访问ZK, ZK返回RegionServer地址-&gt; client访问RegionServer写入数据 -&gt; 数据存入MemStore，一直到MemStore满 -&gt; Flush成StoreFile</li><li>写也是一样的操作，先看内存有没，没有才去Storefile中读取。</li></ul><h5 id="3-1-6-HRegion"><a href="#3-1-6-HRegion" class="headerlink" title="3.1.6 HRegion"></a>3.1.6 <strong>HRegion</strong></h5><ul><li>一个表最开始存储的时候，是一个region。</li><li>一个Region中会有个多个store，<strong>每个store用来存储一个列簇</strong>。如果只有一个column family，就只有一个store。</li><li>region会随着插入的数据越来越多，会进行拆分。默认大小是<strong>10G</strong>一个。</li></ul><h5 id="3-1-7-HLog"><a href="#3-1-7-HLog" class="headerlink" title="3.1.7 HLog"></a>3.1.7 <strong>HLog</strong></h5><ul><li>在分布式系统环境中，无法避免系统出错或者宕机，一旦HRegionServer意外退出，MemStore中的内存数据就会丢失，引入HLog就是防止这种情况，其在磁盘上不会像内存那样出大问题，内存出问题，将其写进内存即可。</li><li>而且一旦MemStore的数据flush到Hstore中，HLog中的数据就会抹掉。——持久化后抹除。避免其过大</li></ul><h4 id="3-2-HBase模块协作"><a href="#3-2-HBase模块协作" class="headerlink" title="3.2 HBase模块协作"></a>3.2 HBase模块协作</h4><ul><li>HBase启动<ul><li>HMaster启动, 注册到Zookeeper, 等待RegionServer汇报</li><li>RegionServer注册到Zookeeper, 并向HMaster汇报</li><li>对各个RegionServer(包括失效的)的数据进行整理, 分配Region和meta信息</li></ul></li><li>RegionServer失效<ul><li>HMaster将失效RegionServer上的Region分配到其他节点</li><li>HMaster更新hbase: meta 表以保证数据正常访问</li></ul></li><li>HMaster失效<ul><li>处于Backup状态的其他HMaster节点推选出一个转为Active状态</li><li>数据能正常读写, 但是不能创建删除表, 也不能更改表结构</li></ul></li></ul><h3 id="4-HBase-的安装与实战"><a href="#4-HBase-的安装与实战" class="headerlink" title="4 HBase 的安装与实战"></a>4 HBase 的安装与实战</h3><h4 id="4-1-HBase的安装"><a href="#4-1-HBase的安装" class="headerlink" title="4.1 HBase的安装"></a>4.1 HBase的安装</h4><ul><li><p>下载安装包 <a href="http://archive.cloudera.com/cdh5/cdh/5/hbase-1.2.0-cdh5.7.0.tar.gz">http://archive.cloudera.com/cdh5/cdh/5/hbase-1.2.0-cdh5.7.0.tar.gz</a></p></li><li><p>配置伪分布式环境</p><ul><li><p>环境变量配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HBASE_HOME=/usr/local/development/hbase-1.2.4</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>配置hbase-env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/development/jdk1.7.0_15</span><br><span class="line">export HBASE_MANAGES_ZK=false  --如果你是使用hbase自带的zk就是true，如果使用自己的zk就是false</span><br></pre></td></tr></table></figure></li><li><p>配置hbase-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>　　--hbase持久保存的目录</span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020/opt/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  --是否是分布式</span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>     </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    --指定要连接zk的端口</span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>        </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/app/hbase/zkData<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>          </span><br></pre></td></tr></table></figure></li><li><p>启动hbase（启动的hbase的时候要保证hadoop集群已经启动）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hbase/bin/start-hbase.sh</span><br></pre></td></tr></table></figure></li><li><p>输入hbase shell（进入shell命令行）</p></li></ul></li></ul><h4 id="4-2-HBase-shell"><a href="#4-2-HBase-shell" class="headerlink" title="4.2 HBase shell"></a>4.2 HBase shell</h4><ul><li>HBase DDL 和 DML 命令</li></ul><table style="overflow: scroll;">  <tr>    <th>名称</th>    <th>命令表达式</th>  </tr>  <tr>    <td> 创建表 </td>   <td> create '表名', '列族名1','列族名2','列族名n' </td>  </tr>  <tr>    <td> 添加记录 </td>    <td> put '表名','行名','列名:','值 </td>  </tr>    <tr>    <td> 查看记录 </td>    <td> get '表名','行名' </td>  </tr>  <tr>    <td> 查看表中的记录总数 </td>    <td> count '表名' </td>  </tr>    <tr>    <td> 删除记录 </td>    <td> delete '表名', '行名','列名' </td>  </tr>  <tr>    <td> 删除一张表 </td>    <td> 第一步 disable '表名' 第二步 drop '表名' </td>  </tr>  <tr>    <td> 查看所有记录 </td>    <td> scan "表名称" </td>  </tr>  <tr>    <td> 查看指定表指定列所有数据 </td>    <td> scan '表名' ,{COLUMNS=>'列族名:列名'} </td>  </tr>   <tr>    <td> 更新记录 </td>    <td> 重写覆盖 </td>  </tr></table><ul><li>连接集群</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase shell</span><br></pre></td></tr></table></figure><ul><li>创建表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;base_info&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>删除表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable <span class="string">&#x27;user&#x27;</span></span><br><span class="line"><span class="keyword">drop</span> <span class="string">&#x27;user&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>创建名称空间</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_namespace <span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>展示现有名称空间</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_namespace</span><br></pre></td></tr></table></figure><ul><li>创建表的时候添加namespace</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="string">&#x27;test:user&#x27;</span>,<span class="string">&#x27;base_info&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>显示某个名称空间下有哪些表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_namespace_tables &#39;test&#39;</span><br></pre></td></tr></table></figure><ul><li><p>插入数据</p><p>put  ‘表名’，‘rowkey的值’，’列族：列标识符‘，’值‘</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">put &#39;user&#39;,&#39;rowkey_10&#39;,&#39;base_info:username&#39;,&#39;Tom&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_10&#39;,&#39;base_info:birthday&#39;,&#39;2014-07-10&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_10&#39;,&#39;base_info:sex&#39;,&#39;1&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_10&#39;,&#39;base_info:address&#39;,&#39;Tokyo&#39;</span><br><span class="line"></span><br><span class="line">put &#39;user&#39;,&#39;rowkey_16&#39;,&#39;base_info:username&#39;,&#39;Mike&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_16&#39;,&#39;base_info:birthday&#39;,&#39;2014-07-10&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_16&#39;,&#39;base_info:sex&#39;,&#39;1&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_16&#39;,&#39;base_info:address&#39;,&#39;beijing&#39;</span><br><span class="line"></span><br><span class="line">put &#39;user&#39;,&#39;rowkey_22&#39;,&#39;base_info:username&#39;,&#39;Jerry&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_22&#39;,&#39;base_info:birthday&#39;,&#39;2014-07-10&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_22&#39;,&#39;base_info:sex&#39;,&#39;1&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_22&#39;,&#39;base_info:address&#39;,&#39;Newyork&#39;</span><br><span class="line"></span><br><span class="line">put &#39;user&#39;,&#39;rowkey_24&#39;,&#39;base_info:username&#39;,&#39;Nico&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_24&#39;,&#39;base_info:birthday&#39;,&#39;2014-07-10&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_24&#39;,&#39;base_info:sex&#39;,&#39;1&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_24&#39;,&#39;base_info:address&#39;,&#39;shanghai&#39;</span><br><span class="line"></span><br><span class="line">put &#39;user&#39;,&#39;rowkey_25&#39;,&#39;base_info:username&#39;,&#39;Rose&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_25&#39;,&#39;base_info:birthday&#39;,&#39;2014-07-10&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_25&#39;,&#39;base_info:sex&#39;,&#39;1&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_25&#39;,&#39;base_info:address&#39;,&#39;Soul&#39;</span><br></pre></td></tr></table></figure><ul><li>查询表中的所有数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#39;user&#39;</span><br></pre></td></tr></table></figure><ul><li>查询某个rowkey的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get &#39;user&#39;,&#39;rowkey_16&#39;</span><br></pre></td></tr></table></figure><ul><li>查询某个列簇的数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get &#x27;user&#x27;,&#x27;rowkey_16&#x27;,&#x27;base_info&#x27;</span><br><span class="line">get &#x27;user&#x27;,&#x27;rowkey_16&#x27;,&#x27;base_info:username&#x27;</span><br><span class="line">get &#x27;user&#x27;, &#x27;rowkey_16&#x27;, &#123;COLUMN =&gt; [&#x27;base_info:username&#x27;,&#x27;base_info:sex&#x27;]&#125;</span><br></pre></td></tr></table></figure><ul><li>删除表中的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete &#39;user&#39;, &#39;rowkey_16&#39;, &#39;base_info:username&#39;</span><br></pre></td></tr></table></figure><ul><li>清空数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate &#39;user&#39;</span><br></pre></td></tr></table></figure><ul><li>操作列簇</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter &#39;user&#39;, NAME &#x3D;&gt; &#39;f2&#39;</span><br><span class="line">alter &#39;user&#39;, &#39;delete&#39; &#x3D;&gt; &#39;f2&#39;</span><br></pre></td></tr></table></figure><ul><li><p>HBase 追加型数据库 会保留多个版本数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> <span class="string">&#x27;user&#x27;</span></span><br><span class="line"><span class="keyword">Table</span> <span class="keyword">user</span> <span class="keyword">is</span> ENABLED</span><br><span class="line"><span class="keyword">user</span></span><br><span class="line"><span class="keyword">COLUMN</span> FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;base_info&#x27;, VERSIONS =&gt; &#x27;1&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_B</span><br><span class="line">HE_DATA_ON_WRITE <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;false&#x27;</span>, DATA_BLOCK_ENCODING <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;NONE&#x27;</span>, TTL <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;FOREVER&#x27;</span>, MI</span><br><span class="line">ER <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;NONE&#x27;</span>, CACHE_INDEX_ON_WRITE <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;false&#x27;</span>, IN_MEMORY <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;false&#x27;</span>, CACHE_BLOOM</span><br><span class="line">se<span class="string">&#x27;, COMPRESSION =&gt; &#x27;</span><span class="keyword">NONE</span><span class="string">&#x27;, BLOCKCACHE =&gt; &#x27;</span><span class="literal">false</span><span class="string">&#x27;, BLOCKSIZE =&gt; &#x27;</span><span class="number">65536</span><span class="string">&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>VERSIONS=&gt;’1’说明最多可以显示一个版本 修改数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put <span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;rowkey_10&#x27;</span>,<span class="string">&#x27;base_info:username&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>指定显示多个版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get &#x27;user&#x27;,&#x27;rowkey_10&#x27;,&#123;COLUMN=&gt;&#x27;base_info:username&#x27;,VERSIONS=&gt;2&#125;</span><br></pre></td></tr></table></figure><ul><li>修改可以显示的版本数量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &#x27;user&#x27;,NAME=&gt;&#x27;base_info&#x27;,VERSIONS=&gt;10</span><br></pre></td></tr></table></figure></li></ul><ul><li>命令表</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005940.jpg" alt=""></p><p>可以通过HbaseUi界面查看表的信息</p><p>端口60010打不开的情况，是因为hbase 1.0 以后的版本，需要自己手动配置，在文件 hbase-site</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;hbase.master.info.port&lt;&#x2F;name&gt;  </span><br><span class="line">&lt;value&gt;60010&lt;&#x2F;value&gt;  </span><br><span class="line">&lt;&#x2F;property&gt; </span><br></pre></td></tr></table></figure><h4 id="4-3-HappyBase操作Hbase"><a href="#4-3-HappyBase操作Hbase" class="headerlink" title="4.3 HappyBase操作Hbase"></a>4.3 HappyBase操作Hbase</h4><ul><li><p>什么是HappyBase</p><ul><li><strong>HappyBase</strong> is a developer-friendly <a href="http://python.org/">Python</a> library to interact with <a href="http://hbase.apache.org/">Apache HBase</a>. HappyBase is designed for use in standard HBase setups, and offers application developers a Pythonic API to interact with HBase. Below the surface, HappyBase uses the <a href="http://pypi.python.org/pypi/thrift">Python Thrift library</a> to connect to HBase using its <a href="http://thrift.apache.org/">Thrift</a> gateway, which is included in the standard HBase 0.9x releases.</li></ul></li><li><p>HappyBase 是FaceBook员工开发的操作HBase的python库, 其基于Python Thrift, 但使用方式比Thrift简单, 已被广泛应用</p></li><li><p>启动hbase thrift server : hbase-daemon.sh start thrift</p></li><li><p>安装happy base</p><ul><li>pip install happybase</li></ul></li><li><p>使用happy base时可能出现的问题(windows系统)</p><ul><li>happybase1.0在win下不支持绝对路径</li><li>解决方案：将488行的url_scheme == ”改为url_scheme in (‘代码盘符’, ”)</li></ul></li><li><p>如何使用HappyBase</p><ul><li>建立连接</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> happybase</span><br><span class="line">connection = happybase.Connection(<span class="string">&#x27;somehost&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>当连接建立时, 会自动创建一个与 HBase Thrift server的socket链接. 可以通过参数禁止自动链接, 然后再需要连接是调用 <a href="https://happybase.readthedocs.io/en/latest/api.html#happybase.Connection.open"><code>Connection.open()</code></a>:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection = happybase.Connection(<span class="string">&#x27;somehost&#x27;</span>, autoconnect=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># before first use:</span></span><br><span class="line">connection.<span class="built_in">open</span>()</span><br></pre></td></tr></table></figure><ul><li><a href="https://happybase.readthedocs.io/en/latest/api.html#happybase.Connection"><code>Connection</code></a>  这个类提供了一个与HBase交互的入口, 比如获取HBase中所有的表:  <a href="https://happybase.readthedocs.io/en/latest/api.html#happybase.Connection.tables"><code>Connection.tables()</code></a>:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(connection.tables())</span><br></pre></td></tr></table></figure><ul><li>操作表<ul><li>Table类提供了大量API, 这些API用于检索和操作HBase中的数据。 在上面的示例中，我们已经使用Connection.tables（）方法查询HBase中的表。 如果还没有任何表，可使用Connection.create_table（）创建一个新表：</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.create_table(<span class="string">&#x27;users&#x27;</span>,&#123;<span class="string">&#x27;cf1&#x27;</span>: <span class="built_in">dict</span>()&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>创建表之后可以传入表名获取到Table类的实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#x3D; connection.table(&#39;mytable&#39;)</span><br></pre></td></tr></table></figure></li><li><p>查询操作</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># api</span></span><br><span class="line">table.scan() <span class="comment">#全表查询</span></span><br><span class="line">table.row(row_keys[<span class="number">0</span>]) <span class="comment"># 查询一行</span></span><br><span class="line">table.rows(row_keys) <span class="comment"># 查询多行</span></span><br><span class="line"><span class="comment">#封装函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_rows</span>(<span class="params">table, row_keys=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> row_keys:</span><br><span class="line">        print(<span class="string">&#x27;show value of row named %s&#x27;</span> % row_keys)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(row_keys) == <span class="number">1</span>:</span><br><span class="line">            print(table.row(row_keys[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(table.rows(row_keys))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;show all row values of table named %s&#x27;</span> % table.name)</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> table.scan():</span><br><span class="line">            print(key, value)</span><br></pre></td></tr></table></figure><ul><li>插入数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#api</span></span><br><span class="line">table.put(row_key, &#123;cf:cq:value&#125;)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_row</span>(<span class="params">table, column_family, row_key, value</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;insert one row to hbase&#x27;</span>)</span><br><span class="line">    <span class="comment">#put &#x27;user&#x27;,&#x27;rowkey_10&#x27;,&#x27;base_info:username&#x27;,&#x27;Tom&#x27;</span></span><br><span class="line">    <span class="comment">#&#123;&#x27;cf:cq&#x27;:’数据‘&#125;</span></span><br><span class="line">    table.put(row_key, &#123;<span class="string">&#x27;%s:name&#x27;</span> % column_family:<span class="string">&#x27;name_%s&#x27;</span> % value&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_rows</span>(<span class="params">table, column_family, row_lines=<span class="number">30</span></span>):</span></span><br><span class="line">    print(<span class="string">&#x27;insert rows to hbase now&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row_lines):</span><br><span class="line">        put_row(table, column_family, <span class="string">&#x27;row_%s&#x27;</span> % i, i)</span><br></pre></td></tr></table></figure><ul><li>删除数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#api</span></span><br><span class="line">table.delete(row_key, cf_list)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#函数封装    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_row</span>(<span class="params">table, row_key, column_family=<span class="literal">None</span>, keys=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> keys:</span><br><span class="line">        print(<span class="string">&#x27;delete keys:%s from row_key:%s&#x27;</span> % (keys, row_key))</span><br><span class="line">        key_list = [<span class="string">&#x27;%s:%s&#x27;</span> % (column_family, key) <span class="keyword">for</span> key <span class="keyword">in</span> keys]</span><br><span class="line">        table.delete(row_key, key_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;delete row(column_family:) from hbase&#x27;</span>)</span><br><span class="line">        table.delete(row_key)</span><br></pre></td></tr></table></figure><ul><li>删除表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#api</span></span><br><span class="line">conn.delete_table(table_name, <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#函数封装</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_table</span>(<span class="params">table_name</span>):</span></span><br><span class="line">    pretty_print(<span class="string">&#x27;delete table %s now.&#x27;</span> % table_name)</span><br><span class="line">    conn.delete_table(table_name, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li>完整代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> happybase</span><br><span class="line"></span><br><span class="line">hostname = <span class="string">&#x27;192.168.199.188&#x27;</span></span><br><span class="line">table_name = <span class="string">&#x27;users&#x27;</span></span><br><span class="line">column_family = <span class="string">&#x27;cf&#x27;</span></span><br><span class="line">row_key = <span class="string">&#x27;row_1&#x27;</span></span><br><span class="line"></span><br><span class="line">conn = happybase.Connection(hostname)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_tables</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;show all tables now&#x27;</span>)</span><br><span class="line">    tables =  conn.tables()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> tables:</span><br><span class="line">        <span class="built_in">print</span> t</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_table</span>(<span class="params">table_name, column_family</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;create table %s&#x27;</span> % table_name)</span><br><span class="line">    conn.create_table(table_name, &#123;column_family:<span class="built_in">dict</span>()&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_rows</span>(<span class="params">table, row_keys=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> row_keys:</span><br><span class="line">        print(<span class="string">&#x27;show value of row named %s&#x27;</span> % row_keys)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(row_keys) == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span> table.row(row_keys[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span> table.rows(row_keys)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;show all row values of table named %s&#x27;</span> % table.name)</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> table.scan():</span><br><span class="line">            <span class="built_in">print</span> key, value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_row</span>(<span class="params">table, column_family, row_key, value</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;insert one row to hbase&#x27;</span>)</span><br><span class="line">    table.put(row_key, &#123;<span class="string">&#x27;%s:name&#x27;</span> % column_family:<span class="string">&#x27;name_%s&#x27;</span> % value&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_rows</span>(<span class="params">table, column_family, row_lines=<span class="number">30</span></span>):</span></span><br><span class="line">    print(<span class="string">&#x27;insert rows to hbase now&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row_lines):</span><br><span class="line">        put_row(table, column_family, <span class="string">&#x27;row_%s&#x27;</span> % i, i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_row</span>(<span class="params">table, row_key, column_family=<span class="literal">None</span>, keys=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> keys:</span><br><span class="line">        print(<span class="string">&#x27;delete keys:%s from row_key:%s&#x27;</span> % (keys, row_key))</span><br><span class="line">        key_list = [<span class="string">&#x27;%s:%s&#x27;</span> % (column_family, key) <span class="keyword">for</span> key <span class="keyword">in</span> keys]</span><br><span class="line">        table.delete(row_key, key_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;delete row(column_family:) from hbase&#x27;</span>)</span><br><span class="line">        table.delete(row_key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_table</span>(<span class="params">table_name</span>):</span></span><br><span class="line">    pretty_print(<span class="string">&#x27;delete table %s now.&#x27;</span> % table_name)</span><br><span class="line">    conn.delete_table(table_name, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool</span>():</span></span><br><span class="line">    pretty_print(<span class="string">&#x27;test pool connection now.&#x27;</span>)</span><br><span class="line">    pool = happybase.ConnectionPool(size=<span class="number">3</span>, host=hostname)</span><br><span class="line">    <span class="keyword">with</span> pool.connection() <span class="keyword">as</span> connection:</span><br><span class="line">        <span class="built_in">print</span> connection.tables()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># show_tables()</span></span><br><span class="line">    <span class="comment"># create_table(table_name, column_family)</span></span><br><span class="line">    <span class="comment"># show_tables()</span></span><br><span class="line"></span><br><span class="line">    table = conn.table(table_name)</span><br><span class="line">    show_rows(table)</span><br><span class="line">    put_rows(table, column_family)</span><br><span class="line">    show_rows(table)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 更新操作</span></span><br><span class="line">    <span class="comment"># put_row(table, column_family, row_key, &#x27;xiaoh.me&#x27;)</span></span><br><span class="line">    <span class="comment"># show_rows(table, [row_key])</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 删除数据</span></span><br><span class="line">    <span class="comment"># delete_row(table, row_key)</span></span><br><span class="line">    <span class="comment"># show_rows(table, [row_key])</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># delete_row(table, row_key, column_family, [&#x27;name&#x27;])</span></span><br><span class="line">    <span class="comment"># show_rows(table, [row_key])</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># counter(table, row_key, column_family)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># delete_table(table_name)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="5-HBase表设计"><a href="#5-HBase表设计" class="headerlink" title="5  HBase表设计"></a>5  HBase表设计</h3><ul><li>设计HBase表时需要注意的特点<ul><li>HBase中表的索引是通过rowkey实现的</li><li>在表中是通过Row key的字典顺序来对数据进行排序的, 表中Region的划分通过起始Rowkey和结束Rowkey来决定的</li><li>所有存储在HBase中的数据都是二进制字节, 没有数据类型</li><li>原子性只在行内保证, HBase表中没有多行事务</li><li>列族(Column Family)在表创建之前就要定义好</li><li>列族中的列标识(Column Qualifier)可以在表创建后动态插入数据的时候添加</li><li>不同的column family保存在不同的文件中。</li></ul></li><li>如何设计HBase表<ul><li>Row key的结构该如何设置, Row key中又该包含什么样的信息</li><li>表中应该有多少的列族</li><li>列族中应该存储什么样的数据</li><li>每个列族中存储多少列数据</li><li>列的名字分别是什么</li><li>cell中应该存储什么样的信息</li><li>每个cell中存储多少个版本信息</li></ul></li><li>DDI  目的是为了克服HBase架构上的缺陷(join繁琐 只有row key索引等)<ul><li>Denormalization (反规范化, 解决join麻烦的问题)</li><li>Duplication (数据冗余)</li><li>Intelligent keys(通过row key设计实现 索引 排序对读写优化) </li></ul></li></ul><h4 id="5-1-HBase表设计案例-社交应用互粉信息表"><a href="#5-1-HBase表设计案例-社交应用互粉信息表" class="headerlink" title="5.1 HBase表设计案例: 社交应用互粉信息表"></a>5.1 HBase表设计案例: 社交应用互粉信息表</h4><ul><li><p>设计表保存应用中用户互粉的信息</p><ul><li>读场景:<ul><li>某用户都关注了哪些用户</li><li>用户A有没有关注用户B</li><li>谁关注了用户A</li></ul></li><li>写场景<ul><li>用户关注了某个用户</li><li>用户取消关注了某个用户</li></ul></li></ul></li><li><p>设计1:</p><ul><li>colunm qulifier(列名)  1:  2:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701010027.png" alt=""></p></li><li><p>设计2</p><ul><li>添加了一个 count 记录当前的最后一个记录的列名</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701010042.png" alt=""></p></li><li><p>设计3</p><ul><li>列名 user_id</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701010057.png" alt=""></p></li><li><p>最终设计(DDI)</p><ul><li>解决谁关注了用户A问题<ul><li>① 设计一张新表, 里面保存某个用户和他的粉丝</li><li>② 在同一张表中同时记录粉丝列表的和用户关注的列表, 并通过Rowkey来区分<ul><li>01_userid: 用户关注列表</li><li>02_userid: 粉丝列表</li></ul></li><li>上两种设计方案的问题(事务)</li></ul></li></ul></li><li><p>案例总结</p><ul><li>Rowkey是HBase表结构设计中很重要的环节, 直接影响到HBase的效率和性能</li><li>HBase的表结构比传统关系型数据库更灵活, 能存储任何二进制数据,无需考虑数据类型</li><li>利用列标识(Column Qualifier)来存储数据</li><li>衡量设计好坏的简单标准 是否会全表查询 </li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HBase简介与环境部署&quot;&gt;&lt;a href=&quot;#HBase简介与环境部署&quot; class=&quot;headerlink&quot; title=&quot;HBase简介与环境部署&quot;&gt;&lt;/a&gt;HBase简介与环境部署&lt;/h2&gt;&lt;h3 id=&quot;1-HBase简介-amp-在Hadoop生态中的</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>25-Sqoop概述</title>
    <link href="https://xxren8218.github.io/20210630/25-Sqoop%E6%A6%82%E8%BF%B0.html"/>
    <id>https://xxren8218.github.io/20210630/25-Sqoop%E6%A6%82%E8%BF%B0.html</id>
    <published>2021-06-29T16:51:29.000Z</published>
    <updated>2021-06-29T16:53:26.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h2><h3 id="1-Sqoop概述"><a href="#1-Sqoop概述" class="headerlink" title="1 Sqoop概述"></a>1 Sqoop概述</h3><ul><li><p>什么是Sqoop</p><ul><li>Sqoop 是一款进行数据传输的工具, 可在hadoop 的 hdfs 和关系型数据库之间传输数据</li><li>可以使用Sqoop把数据从MySQL 或 Oracle导入到hdfs中, 也可以把数据从hdfs导入到MySQL或Oracle中</li><li>Sqoop可自动执行数据传输的大部分过程, 使用MapReduce导入和导出数据，提供并行操作和容错</li></ul></li><li><p>为什么要使用sqoop?</p><ul><li>快速实现Hadoop(HDFS/hive/hbase)与mysql/Oracle等关系型数据库之间的数据传递</li><li>Sqoop提供多种数据传输方式</li></ul></li><li><p>Sqoop原理</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630005225.png" alt=""></p></li></ul><h3 id="2-Sqoop安装"><a href="#2-Sqoop安装" class="headerlink" title="2 Sqoop安装"></a>2 Sqoop安装</h3><ul><li><p>下载安装包<a href="http://archive.cloudera.com/cdh5/cdh/5/sqoop-1.4.6-cdh5.7.0.tar.gz">url</a> </p></li><li><p>解压到centos中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf &#x2F;home&#x2F;hadoop&#x2F;software&#x2F;sqoop-1.4.6-cdh5.7.0.tar.gz  -C ~&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line">export SQOOP_HOME=/home/hadoop/app/sqoop-1.4.6-cdh5.7.0</span><br><span class="line">export PATH=$SQOOP_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>激活环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>到 $SQOOP_HOME/conf 目录下 配置sqoop_env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp sqoop-env-template.sh sqoop-env.sh</span><br><span class="line">vi sqoop-env.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">在sqoop_env.sh中</span></span><br><span class="line">export HADOOP_COMMON_HOME=/home/hadoop/app/hadoop-2.6.0-cdh5.7.0/</span><br><span class="line">export HADOOP_MAPRED_HOME=/home/hadoop/app/hadoop-2.6.0-cdh5.7.0/</span><br><span class="line">export HIVE_HOME=/home/hadoop/app/hive-1.1.0-cdh5.7.0/</span><br></pre></td></tr></table></figure></li><li><p>拷贝 mysql驱动到$SQOOP_HOME/lib目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /home/hadoop/app/hive-1.1.0-cdh5.7.0/lib/mysql-connector-java-5.1.47.jar /home/hadoop/app/sqoop-1.4.6-cdh5.7.0/lib/</span><br></pre></td></tr></table></figure></li><li><p>测试sqoop环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop-version</span><br></pre></td></tr></table></figure><p>看到如下输出 说明sqoop安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sqoop 1.4.6-cdh5.7.0</span><br><span class="line">git commit id</span><br><span class="line">Compiled by jenkins on ******</span><br></pre></td></tr></table></figure></li><li><p>然后进入到MySQL的Docker环境中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -ti mysql bash</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-使用Sqoop导入数据到hdfs中"><a href="#3-使用Sqoop导入数据到hdfs中" class="headerlink" title="3 使用Sqoop导入数据到hdfs中"></a>3 使用Sqoop导入数据到hdfs中</h3><ul><li><p>准备mysql数据</p><p>建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> u(id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,fname <span class="type">varchar</span>(<span class="number">20</span>),lname <span class="type">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> u3 (fname, lname) <span class="keyword">values</span>(<span class="string">&#x27;George&#x27;</span>,<span class="string">&#x27;washington&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> u3 (fname, lname) <span class="keyword">values</span>(<span class="string">&#x27;George&#x27;</span>,<span class="string">&#x27;bush&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> u3 (fname, lname) <span class="keyword">values</span>(<span class="string">&#x27;Bill&#x27;</span>,<span class="string">&#x27;clinton&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> u3 (fname, lname) <span class="keyword">values</span>(<span class="string">&#x27;Bill&#x27;</span>,<span class="string">&#x27;gates&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>Sqoop导入命令介绍</p><ul><li>命令语法: sqoop import (控制参数) (导入参数)</li><li>命令元素: 导入操作, 数据源, 访问方式, 导入控制, 目标地址 </li><li>命令理解: 数据从哪里来, 有什么控制, 到哪里去</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqoop import --connect jdbc:mysql://127.0.0.1:3306/test --username root --password root\!123A --table u -m 1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> -m 表示用几个MR任务执行，前提是文件小于128M，否则拆成多个block</span></span><br></pre></td></tr></table></figure><ul><li>添加—target-dir 指定hdfs上数据存放的目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop import --connect jdbc:mysql://localhost:3306/test --username root --password root!123A --table u --target-dir /tmp/u1 -m 1</span><br></pre></td></tr></table></figure></li><li><p>导入可能出现的问题 </p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630005303.png" alt=""></p><p>​    解决 上传java-json.jar到$SQOOP_HOME/lib目录下</p><ul><li><p>默认数据上传到hdfs中如下路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;user&#x2F;当前linux用户名&#x2F;mysql表名&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>通过hive 建立外表导入数据到hive</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> u4(</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    fname STRING,</span><br><span class="line">    lname STRING</span><br><span class="line">)</span><br><span class="line"><span class="type">ROW</span> FORMAT delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">LOCATION <span class="string">&#x27;/user/hadoop/u/&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>也可能出现断开连接的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive --service metastore&amp;  # 加上&amp;表示在后台跑。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Sqoop&quot;&gt;&lt;a href=&quot;#Sqoop&quot; class=&quot;headerlink&quot; title=&quot;Sqoop&quot;&gt;&lt;/a&gt;Sqoop&lt;/h2&gt;&lt;h3 id=&quot;1-Sqoop概述&quot;&gt;&lt;a href=&quot;#1-Sqoop概述&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>02_二叉树之深度遍历思想训练</title>
    <link href="https://xxren8218.github.io/20210629/02-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%80%9D%E6%83%B3%E8%AE%AD%E7%BB%83.html"/>
    <id>https://xxren8218.github.io/20210629/02-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%80%9D%E6%83%B3%E8%AE%AD%E7%BB%83.html</id>
    <published>2021-06-29T10:19:29.000Z</published>
    <updated>2021-06-29T10:22:51.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树之深度遍历思想训练"><a href="#二叉树之深度遍历思想训练" class="headerlink" title="二叉树之深度遍历思想训练"></a>二叉树之深度遍历思想训练</h2><p>读完本文，你能去力扣解决如下题目：</p><p>654.最大二叉树（难度 <strong>Medium</strong>）</p><p>105.从前序与中序遍历序列构造二叉树（难度 <strong>Medium</strong>）</p><p>106.从中序与后序遍历序列构造二叉树（难度 <strong>Medium</strong>）</p><p>先来复习一下，我们说过写树的算法，关键思路如下：</p><p><strong>把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了</strong>，我们千万不要跳进递归的细节里，你的脑袋才能压几个栈呀。</p><p>也许你还不太理解这句话，我们下面来看例子。</p><blockquote><h3 id="一、构造最大二叉树"><a href="#一、构造最大二叉树" class="headerlink" title="一、构造最大二叉树"></a>一、构造最大二叉树</h3></blockquote><p>先来道简单的，这是力扣第 654 题，题目如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182049.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：[<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,null,<span class="number">2</span>,<span class="number">0</span>,null,null,<span class="number">1</span>]</span><br><span class="line">返回: TreeNode</span><br></pre></td></tr></table></figure><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br></pre></td></tr></table></figure><p>按照我们刚才说的，先明确根节点做什么？<strong>对于构造二叉树的问题，根节点要做的就是把想办法把自己构造出来</strong>。</p><p>我们肯定要遍历数组把找到最大值<code>maxVal</code>，把根节点<code>root</code>做出来，然后对<code>maxVal</code>左边的数组和右边的数组进行递归调用，作为<code>root</code>的左右子树。</p><p>按照题目给出的例子，输入的数组为<code>[3,2,1,6,0,5]</code>，对于整棵树的根节点来说，其实在做这件事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>]</span>):</span></span><br><span class="line">    <span class="comment"># 找到数组中的最大值</span></span><br><span class="line">    root = TreeNode(<span class="number">6</span>)</span><br><span class="line">    <span class="comment"># 递归调用构造左右子树</span></span><br><span class="line">    root.left = constructMaximumBinaryTree([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">    root.right = constructMaximumBinaryTree([<span class="number">0</span>,<span class="number">5</span>])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>再详细一点，就是如下伪码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 找到数组中的最大值</span></span><br><span class="line">    maxVal = <span class="built_in">max</span>(nums)</span><br><span class="line">    index = nums.index(maxVal)</span><br><span class="line"></span><br><span class="line">root = TreeNode(maxVal)</span><br><span class="line">    <span class="comment"># 递归调用构造左右子树</span></span><br><span class="line">    root.left = constructMaximumBinaryTree(nums[:index])</span><br><span class="line">    root.right = constructMaximumBinaryTree(nums[index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>看懂了吗？<strong>对于每个根节点，只需要找到当前<code>nums</code>中的最大值和对应的索引，然后递归调用左右数组构造左右子树即可。</strong></p><p><strong>将其拆分成两个函数如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> build(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">nums. lo, hi</span>):</span></span><br><span class="line">    <span class="keyword">if</span> lo &gt; hi:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 找到数组中的最大值</span></span><br><span class="line">    maxVal = <span class="built_in">max</span>(nums[lo:hi + <span class="number">1</span>])</span><br><span class="line">    index = nums.index(maxVal)</span><br><span class="line"></span><br><span class="line">root = TreeNode(maxVal)</span><br><span class="line">    <span class="comment"># 递归调用构造左右子树</span></span><br><span class="line">    root.left = build(nums,lo, index - <span class="number">1</span>)</span><br><span class="line">    root.right = build(nums, index, hi)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>至此，这道题就做完了，还是挺简单的对吧，下面看两道更困难一些的。</p><blockquote><h3 id="二、通过前序和中序遍历结果构造二叉树"><a href="#二、通过前序和中序遍历结果构造二叉树" class="headerlink" title="二、通过前序和中序遍历结果构造二叉树"></a>二、通过前序和中序遍历结果构造二叉树</h3></blockquote><p>经典问题了，面试/笔试中常考，力扣第 105 题就是这个问题：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182105.jpg" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br></pre></td></tr></table></figure><p>废话不多说，直接来想思路，首先思考，根节点应该做什么。</p><p><strong>类似上一题，我们肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右子树即可</strong>。</p><p>我们先来回顾一下，前序遍历和中序遍历的结果有什么特点？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># 前序遍历</span></span><br><span class="line">    preorder.append(root.val)</span><br><span class="line">    traverse(root.left)</span><br><span class="line">    traverse(root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment"># 中序遍历</span></span><br><span class="line">    inorder.append(root.val)</span><br><span class="line">    traverse(root.right)</span><br></pre></td></tr></table></figure><p>这样的遍历顺序差异，导致了<code>preorder</code>和<code>inorder</code>数组中的元素分布有如下特点：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182119.jpg" alt=""></p><p>找到根节点是很简单的，前序遍历的第一个值<code>preorder[0]</code>就是根节点的值，关键在于如何通过根节点的值，将<code>preorder</code>和<code>postorder</code>数组划分成两半，构造根节点的左右子树？</p><p>换句话说，对于以下代码中的<code>?</code>部分应该填入什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">preorder, inorder</span>):</span></span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>,</span><br><span class="line">                 inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   若前序遍历数组为 preorder[preStart..preEnd]，</span></span><br><span class="line"><span class="string">   后续遍历数组为 postorder[postStart..postEnd]，</span></span><br><span class="line"><span class="string">   构造二叉树，返回该二叉树的根节点 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">preorder, preStart, preEnd, </span></span></span><br><span class="line"><span class="function"><span class="params">          inorder, inStart, inEnd</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">    rootVal = preorder[preStart]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># rootVal 在中序遍历数组中的索引</span></span><br><span class="line">    index = inorder.index(rootVal)</span><br><span class="line"></span><br><span class="line">    root = TreeNode(rootVal)</span><br><span class="line">    <span class="comment"># 递归构造左右子树</span></span><br><span class="line">    root.left = build(preorder, ?, ?,</span><br><span class="line">                      inorder, ?, ?)</span><br><span class="line"></span><br><span class="line">    root.right = build(preorder, ?, ?,</span><br><span class="line">                       inorder, ?, ?)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>对于代码中的<code>rootVal</code>和<code>index</code>变量，就是下图这种情况：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182133.jpg" alt=""></p><p>现在我们来看图做填空题，下面这几个问号处应该填什么：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root.left = build(preorder, ?, ?,</span><br><span class="line">                  inorder, ?, ?)</span><br><span class="line"></span><br><span class="line">root.right = build(preorder, ?, ?,</span><br><span class="line">                   inorder, ?, ?)</span><br></pre></td></tr></table></figure><p>对于左右子树对应的<code>inorder</code>数组的起始索引和终止索引比较容易确定：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182146.jpg" alt=""></p><p>对于<code>preorder</code>数组呢？如何确定左右数组对应的起始索引和终止索引？</p><p>这个可以通过左子树的节点数推导出来，假设左子树的节点数为<code>leftSize</code>，那么<code>preorder</code>数组上的索引情况是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182201.jpg" alt=""></p><p>看着这个图就可以把<code>preorder</code>对应的索引写进去了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leftSize = index - inStart</span><br><span class="line"></span><br><span class="line">root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize,</span><br><span class="line">                  inorder, inStart, index - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd,</span><br><span class="line">                   inorder, index + <span class="number">1</span>, inEnd)</span><br></pre></td></tr></table></figure><p>至此，整个算法思路就完成了，我们再补一补 base case 即可写出解法代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">preorder, inorder</span>):</span></span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>,</span><br><span class="line">                 inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   若前序遍历数组为 preorder[preStart..preEnd]，</span></span><br><span class="line"><span class="string">   后续遍历数组为 postorder[postStart..postEnd]，</span></span><br><span class="line"><span class="string">   构造二叉树，返回该二叉树的根节点 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">preorder, preStart, preEnd, </span></span></span><br><span class="line"><span class="function"><span class="params">          inorder, inStart, inEnd</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> preStart &gt; preEnd: <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">    rootVal = preorder[preStart]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># rootVal 在中序遍历数组中的索引</span></span><br><span class="line">    index = inorder.index(rootVal)</span><br><span class="line">    leftSize = index - inStart</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先构造出当前根节点</span></span><br><span class="line">    root = TreeNode(rootVal)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归构造左右子树</span></span><br><span class="line">    root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize,</span><br><span class="line">                      inorder, inStart, index - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd,</span><br><span class="line">                       inorder, index + <span class="number">1</span>, inEnd)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>我们的主函数只要调用<code>build</code>函数即可，你看着函数这么多参数，解法这么多代码，似乎比我们上面讲的那道题难很多，让人望而生畏，实际上呢，这些参数无非就是控制数组起止位置的，画个图就能解决了。</p><blockquote><h3 id="三、通过后序和中序遍历结果构造二叉树"><a href="#三、通过后序和中序遍历结果构造二叉树" class="headerlink" title="三、通过后序和中序遍历结果构造二叉树"></a>三、通过后序和中序遍历结果构造二叉树</h3></blockquote><p>类似上一题，这次我们利用<strong>后序</strong>和<strong>中序</strong>遍历的结果数组来还原二叉树，这是力扣第 106 题：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182214.png" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[<span class="built_in">int</span>], postorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br></pre></td></tr></table></figure><p>类似的，看下后序和中序遍历的特点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">TreeNode root</span>):</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment"># 前序遍历</span></span><br><span class="line">    postorder.append(root.val)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">TreeNode root</span>):</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment"># 中序遍历</span></span><br><span class="line">    inorder.append(root.val)</span><br><span class="line">    traverse(root.right)</span><br></pre></td></tr></table></figure><p>这样的遍历顺序差异，导致了<code>preorder</code>和<code>inorder</code>数组中的元素分布有如下特点：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182229.jpg" alt=""></p><p>这道题和上一题的关键区别是，后序遍历和前序遍历相反，根节点对应的值为<code>postorder</code>的最后一个元素。</p><p>整体的算法框架和上一题非常类似，我们依然写一个辅助函数<code>build</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">inorder, postorder</span>):</span></span><br><span class="line">    <span class="keyword">return</span> build(inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>,</span><br><span class="line">                 postorder, <span class="number">0</span>, <span class="built_in">len</span>(postorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">inorder, inStart, inEnd, </span></span></span><br><span class="line"><span class="function"><span class="params">          postorder, postStart, postEnd</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">    rootVal = postorder[preEnd]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># rootVal 在中序遍历数组中的索引</span></span><br><span class="line">    index = inorder.index(rootVal)</span><br><span class="line"></span><br><span class="line">    root = TreeNode(rootVal)</span><br><span class="line">    <span class="comment"># 递归构造左右子树</span></span><br><span class="line">    root.left = build(inorder, ?, ?,</span><br><span class="line">                      postorder, ?, ?)</span><br><span class="line"></span><br><span class="line">    root.right = build(inorder, ?, ?,</span><br><span class="line">                       postorder, ?, ?)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>现在<code>postoder</code>和<code>inorder</code>对应的状态如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182242.jpg" alt=""></p><p>我们可以按照上图将问号处的索引正确填入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leftSize = index - inStart</span><br><span class="line"></span><br><span class="line">root.left = build(inorder, inStart, index - <span class="number">1</span>,</span><br><span class="line">                  postorder, postStart, postStart + leftSize - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">root.right = build(inorder, index + <span class="number">1</span>, inEnd,</span><br><span class="line">                   postorder, postStart + leftSize, postEnd - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>综上，可以写出完整的解法代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">inorder, postorder</span>):</span></span><br><span class="line">    <span class="keyword">return</span> build(inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>,</span><br><span class="line">                 postorder, <span class="number">0</span>, <span class="built_in">len</span>(postorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">inorder, inStart, inEnd, </span></span></span><br><span class="line"><span class="function"><span class="params">          postorder, postStart, postEnd</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> inStart &gt; inEnd: <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">    rootVal = postorder[postEnd]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># rootVal 在中序遍历数组中的索引</span></span><br><span class="line">    index = inorder.index(rootVal)</span><br><span class="line"></span><br><span class="line">    leftSize = index - inStart</span><br><span class="line">    </span><br><span class="line">    root = TreeNode(rootVal)</span><br><span class="line">    <span class="comment"># 递归构造左右子树</span></span><br><span class="line">root.left = build(inorder, inStart, index - <span class="number">1</span>,</span><br><span class="line">                  postorder, postStart, postStart + leftSize - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">root.right = build(inorder, index + <span class="number">1</span>, inEnd,</span><br><span class="line">                   postorder, postStart + leftSize, postEnd - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>有了前一题的铺垫，这道题很快就解决了，无非就是<code>rootVal</code>变成了最后一个元素，再改改递归函数的参数而已，只要明白二叉树的特性，也不难写出来。</p><p>最后呼应下前文，<strong>做二叉树的问题，关键是把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树之深度遍历思想训练&quot;&gt;&lt;a href=&quot;#二叉树之深度遍历思想训练&quot; class=&quot;headerlink&quot; title=&quot;二叉树之深度遍历思想训练&quot;&gt;&lt;/a&gt;二叉树之深度遍历思想训练&lt;/h2&gt;&lt;p&gt;读完本文，你能去力扣解决如下题目：&lt;/p&gt;
&lt;p&gt;654.最</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>24-Hive概述</title>
    <link href="https://xxren8218.github.io/20210629/24-Hive%E6%A6%82%E8%BF%B0.html"/>
    <id>https://xxren8218.github.io/20210629/24-Hive%E6%A6%82%E8%BF%B0.html</id>
    <published>2021-06-28T16:47:32.000Z</published>
    <updated>2021-06-28T16:52:13.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><h2 id="一-Hive基本概念"><a href="#一-Hive基本概念" class="headerlink" title="一 Hive基本概念"></a>一 Hive基本概念</h2><h3 id="1-Hive简介"><a href="#1-Hive简介" class="headerlink" title="1 Hive简介 "></a>1 Hive简介 <img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629004922.jpg" alt=""></h3><p>学习目标</p><ul><li>了解什么是Hive</li><li>了解为什么使用Hive</li></ul><h4 id="1-1-什么是-Hive"><a href="#1-1-什么是-Hive" class="headerlink" title="1.1 什么是 Hive"></a>1.1 什么是 Hive</h4><ul><li>Hive 由 Facebook 实现并开源，是基于 Hadoop 的一个数据仓库工具，可以将结构化的数据映射为一张数据库表，并提供 HQL(Hive SQL)查询功能，底层数据是存储在 HDFS 上。</li><li>Hive 本质: 将 SQL 语句转换为 MapReduce 任务运行，使不熟悉 MapReduce 的用户很方便地利用 HQL 处理和计算 HDFS 上的结构化的数据,是一款基于 HDFS 的 MapReduce <strong>计算框架</strong>——相当于给MR套了壳子。</li><li>主要用途：用来做离线数据分析，比直接用 MapReduce 开发效率更高。</li></ul><h4 id="1-2-为什么使用-Hive"><a href="#1-2-为什么使用-Hive" class="headerlink" title="1.2 为什么使用 Hive"></a>1.2 为什么使用 Hive</h4><ul><li><p>直接使用 Hadoop MapReduce 处理数据所面临的问题：</p><ul><li>人员学习成本太高</li><li>MapReduce 实现复杂查询逻辑开发难度太大——得适应Map和Reduce的思维。</li></ul></li><li><p>使用 Hive</p><ul><li>操作接口采用类 SQL 语法，提供快速开发的能力</li></ul></li><li>避免了去写 MapReduce，减少开发人员的学习成本<ul><li>功能扩展很方便</li><li>缺点：非结构化数据不能用Hive，还是用MR来算。</li></ul></li></ul><h3 id="2-Hive-架构"><a href="#2-Hive-架构" class="headerlink" title="2 Hive 架构"></a>2 Hive 架构</h3><h4 id="2-1-Hive-架构图"><a href="#2-1-Hive-架构图" class="headerlink" title="2.1 Hive 架构图"></a>2.1 Hive 架构图</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629004940.jpg" alt=""></p><h4 id="2-2-Hive-组件"><a href="#2-2-Hive-组件" class="headerlink" title="2.2 Hive 组件"></a>2.2 Hive 组件</h4><ul><li>用户接口：包括 CLI、JDBC/ODBC、WebGUI。<ul><li>CLI(command line interface)为 shell 命令行</li><li>JDBC/ODBC 是 Hive 的 JAVA 实现，与传统数据库JDBC 类似</li><li>WebGUI 是通过浏览器访问 Hive。</li><li>HiveServer2基于Thrift, 允许远程客户端使用多种编程语言如Java、Python向Hive提交请求</li></ul></li><li>元数据存储：通常是存储在关系数据库如 mysql/derby 中。<ul><li>Hive 将元数据存储在数据库中。</li><li>Hive 中的元数据包括<ul><li>表的名字</li><li>表的列</li><li>分区及其属性</li><li>表的属性（是否为外部表等）</li><li>表的数据所在目录等。</li></ul></li></ul></li><li>解释器、编译器、优化器、执行器:完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在 HDFS 中，并在随后由 MapReduce 调用执行</li></ul><h4 id="2-3-Hive-与-Hadoop-的关系"><a href="#2-3-Hive-与-Hadoop-的关系" class="headerlink" title="2.3 Hive 与 Hadoop 的关系"></a>2.3 Hive 与 Hadoop 的关系</h4><p>Hive 利用 HDFS 存储数据，利用 MapReduce 查询分析数据。</p><p>Hive是数据仓库工具，没有集群的概念，如果想提交Hive作业只需要在hadoop集群 Master节点上装Hive就可以了</p><h3 id="3-Hive-与传统数据库对比"><a href="#3-Hive-与传统数据库对比" class="headerlink" title="3 Hive 与传统数据库对比"></a>3 Hive 与传统数据库对比</h3><ul><li>hive 用于海量数据的离线数据分析。</li></ul><table style="overflow: scroll;">  <tr>    <th></th>    <th>Hive</th>    <th>关系型数据库</th>  </tr>  <tr>    <td> ANSI SQL </td>    <td> 不完全支持 </td>    <td> 支持 </td>  </tr>  <tr>    <td> 更新 </td>    <td> INSERT OVERWRITE\INTO TABLE(默认) </td>    <td> UPDATE\INSERT\DELETE </td>  </tr>  <tr>    <td> 事务 </td>    <td> 不支持(默认) </td>    <td> 支持 </td>  </tr>  <tr>    <td> 模式 </td>    <td> 读模式 </td>    <td> 写模式 </td>  </tr>  <tr>    <td> 查询语言 </td>    <td> HQL  </td>    <td> SQL</td>  </tr>  <tr>    <td> 数据存储 </td>    <td> HDFS </td>    <td> Raw Device or Local FS </td>  </tr>  <tr>    <td> 执行 </td>    <td> MapReduce </td>    <td> Executor</td>  </tr>  <tr>    <td> 执行延迟 </td>    <td> 高 </td>    <td> 低 </td>  </tr>  <tr>    <td> 子查询 </td>    <td> 只能用在From子句中 </td>    <td> 完全支持 </td>  </tr>  <tr>    <td> 处理数据规模 </td>    <td> 大 </td>    <td> 小 </td>  </tr>  <tr>    <td> 可扩展性 </td>    <td> 高 </td>    <td> 低 </td>  </tr>  <tr>    <td> 索引 </td>    <td> 0.8版本后加入位图索引 </td>    <td> 有复杂的索引 </td>  </tr></table><ul><li>hive支持的数据类型<ul><li>原子数据类型  <ul><li>TINYINT SMALLINT INT BIGINT BOOLEAN FLOAT DOUBLE STRING BINARY TIMESTAMP DECIMAL CHAR VARCHAR DATE</li></ul></li><li>复杂数据类型<ul><li>ARRAY</li><li>MAP</li><li>STRUCT</li></ul></li></ul></li><li>hive中表的类型<ul><li>托管表 (managed table) (内部表)</li><li>外部表</li></ul></li></ul><h3 id="4-Hive-数据模型"><a href="#4-Hive-数据模型" class="headerlink" title="4 Hive 数据模型"></a>4 Hive 数据模型</h3><ul><li>Hive 中所有的数据都存储在 HDFS 中，没有专门的数据存储格式</li><li>在创建表时指定数据中的分隔符，Hive 就可以映射成功，解析数据。</li><li>Hive 中包含以下数据模型：<ul><li>db：在 hdfs 中表现为 hive.metastore.warehouse.dir 目录下一个文件夹</li><li>table：在 hdfs 中表现所属 db 目录下一个文件夹</li><li>external table：数据存放位置可以在 HDFS 任意指定路径</li><li>partition：在 hdfs 中表现为 table 目录下的子目录</li><li>bucket：在 hdfs 中表现为同一个表目录下根据 hash 散列之后的多个文件</li></ul></li></ul><h3 id="5-Hive-安装部署"><a href="#5-Hive-安装部署" class="headerlink" title="5 Hive 安装部署"></a>5 Hive 安装部署</h3><ul><li><p>Hive 安装前需要安装好 JDK 和 Hadoop。配置好环境变量。</p></li><li><p>下载Hive的安装包 <a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a> 并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hive-1.1.0-cdh5.7.0.tar.gz  -C ~/app/</span><br></pre></td></tr></table></figure></li><li><p>进入到 解压后的hive目录 找到 conf目录, 修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp hive-env.sh.template hive-env.sh</span><br><span class="line">vi hive-env.sh</span><br></pre></td></tr></table></figure><p>在hive-env.sh中指定hadoop的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HADOOP_HOME=/home/hadoop/app/hadoop-2.6.0-cdh5.7.0</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><ul><li><p>```shell<br>vi ~/.bash_profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;shell</span><br><span class="line">  export HIVE_HOME&#x3D;&#x2F;home&#x2F;hadoop&#x2F;app&#x2F;hive-1.1.0-cdh5.7.0</span><br><span class="line">  export PATH&#x3D;$HIVE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>```shell<br>source ~/.bash_profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 根据元数据存储的介质不同，分为下面两个版本，其中 derby 属于内嵌模式。实际生产环境中则使用 mysql 来进行元数据的存储。</span><br><span class="line"></span><br><span class="line">  - 内置 derby 版： </span><br><span class="line">    bin&#x2F;hive 启动即可使用</span><br><span class="line">    缺点：不同路径启动 hive，每一个 hive 拥有一套自己的元数据，无法共享</span><br><span class="line"></span><br><span class="line">  - mysql 版： </span><br><span class="line"></span><br><span class="line">    - 上传 mysql驱动到 hive安装目录的lib目录下</span><br><span class="line"></span><br><span class="line">      mysql-connector-java-5.*.jar</span><br><span class="line"></span><br><span class="line">    - vi conf&#x2F;hive-site.xml 配置 Mysql 元数据库信息(MySql安装见文档)</span><br><span class="line"></span><br><span class="line">      &#96;&#96;&#96;xml-dtd</span><br><span class="line">      &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; standalone&#x3D;&quot;no&quot;?&gt;</span><br><span class="line">      &lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;xsl&quot; href&#x3D;&quot;configuration.xsl&quot;?&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">      &lt;!-- 插入以下代码 --&gt;</span><br><span class="line">          &lt;property&gt;</span><br><span class="line">              &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;&#x2F;name&gt;</span><br><span class="line">              &lt;value&gt;hive&lt;&#x2F;value&gt;&lt;!-- 指定mysql用户名 --&gt;</span><br><span class="line">          &lt;&#x2F;property&gt;</span><br><span class="line">          &lt;property&gt;</span><br><span class="line">              &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;&#x2F;name&gt;</span><br><span class="line">              &lt;value&gt;hive&lt;&#x2F;value&gt;&lt;!-- 指定mysql密码 --&gt;</span><br><span class="line">          &lt;&#x2F;property&gt;</span><br><span class="line">         &lt;property&gt;</span><br><span class="line">              &lt;name&gt;javax.jdo.option.ConnectionURL&lt;&#x2F;name&gt;mysql</span><br><span class="line">              &lt;value&gt;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;hive&lt;&#x2F;value&gt;</span><br><span class="line">          &lt;&#x2F;property&gt;&lt;!-- 指定mysql数据库地址 --&gt;</span><br><span class="line">          &lt;property&gt;</span><br><span class="line">              &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;&#x2F;name&gt;</span><br><span class="line">              &lt;value&gt;com.mysql.jdbc.Driver&lt;&#x2F;value&gt;&lt;!-- 指定mysql驱动 --&gt;</span><br><span class="line">          &lt;&#x2F;property&gt;</span><br><span class="line">              &lt;!-- 到此结束代码 --&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">          &lt;name&gt;hive.exec.script.wrapper&lt;&#x2F;name&gt;</span><br><span class="line">          &lt;value&#x2F;&gt;</span><br><span class="line">          &lt;description&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">      &lt;&#x2F;configuration&gt;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li></ul></li><li><p>hive启动</p><ul><li><p>启动docker </p><p><code>service docker start</code></p></li><li><p>通过docker 启动mysql</p><p><code>docker start mysql</code></p></li><li><p>启动 hive的metastore元数据服务</p><p><code>hive --service metastore</code></p></li><li><p>启动hive</p><p><code>hive</code></p></li><li><p>MySQL root 密码 password         hive用户 密码 hive</p></li></ul></li></ul><h2 id="二-Hive-基本操作"><a href="#二-Hive-基本操作" class="headerlink" title="二 Hive 基本操作"></a>二 Hive 基本操作</h2><h3 id="2-1-Hive-HQL操作初体验"><a href="#2-1-Hive-HQL操作初体验" class="headerlink" title="2.1 Hive HQL操作初体验"></a>2.1 Hive HQL操作初体验</h3><ul><li><p>创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br></pre></td></tr></table></figure></li><li><p>显示所有数据库</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure></li><li><p>创建表</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(classNo string, stuNo string, score <span class="type">int</span>) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在text数据库下面创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> text.student(classNo string, stuNo string, score <span class="type">int</span>) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>row format delimited fields terminated by ‘,’  指定了字段的分隔符为逗号，所以load数据的时候，load的文本也要为逗号，否则加载后为NULL。hive只支持单个字符的分隔符，hive默认的分隔符是\001</li></ul></li><li><p>将数据load到表中</p><ul><li><p>在本地文件系统创建一个如下的文本文件：/home/hadoop/tmp/student.txt</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C01,N0101,82</span><br><span class="line">C01,N0102,59</span><br><span class="line">C01,N0103,65</span><br><span class="line">C02,N0201,81</span><br><span class="line">C02,N0202,82</span><br><span class="line">C02,N0203,79</span><br><span class="line">C03,N0301,56</span><br><span class="line">C03,N0302,92</span><br><span class="line">C03,N0306,72</span><br></pre></td></tr></table></figure></li><li><p>``` sql<br> load data local inpath ‘/home/hadoop/tmp/student.txt’overwrite into table student;<br> — 导入default.student</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">load data local inpath &#39;&#x2F;home&#x2F;hadoop&#x2F;tmp&#x2F;student.txt&#39;overwrite into table text.student; &#x2F;&#x2F;导入text下的studen</span><br></pre></td></tr></table></figure></li><li><p>这个命令将student.txt文件复制到hive的warehouse目录中，这个目录由hive.metastore.warehouse.dir配置项设置，默认值为/user/hive/warehouse。Overwrite选项将导致Hive事先删除student目录下所有的文件, 并将文件内容映射到表中。<br> Hive不会对student.txt做任何格式处理，因为Hive本身并不强调数据的存储格式。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 查询表中的数据 跟SQL类似——响应快（不涉及MR）</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96; sql</span><br><span class="line">   hive&gt;select * from student;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>分组查询group by和统计 count——响应慢（会启动一个MR作业，涉及MR）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span><span class="keyword">select</span> classNo,<span class="built_in">count</span>(score) <span class="keyword">from</span> student <span class="keyword">where</span> score<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">group</span> <span class="keyword">by</span> classNo;</span><br></pre></td></tr></table></figure><p>从执行结果可以看出 hive把查询的结果变成了MapReduce作业通过hadoop执行</p></li></ul><h3 id="2-2-Hive的内部表和外部表"><a href="#2-2-Hive的内部表和外部表" class="headerlink" title="2.2 Hive的内部表和外部表"></a>2.2 Hive的内部表和外部表</h3><table style="overflow: scroll;">  <tr>    <th></th>    <th>内部表(managed table)</th>    <th>外部表(external table)</th>  </tr>  <tr>    <td> 概念 </td>    <td> 创建表时无external修饰 </td>    <td> 创建表时被external修饰 </td>  </tr>  <tr>    <td> 数据管理 </td>    <td> 由Hive自身管理 </td>    <td> 由HDFS管理 </td>  </tr>  <tr>    <td> 数据保存位置 </td>    <td> hive.metastore.warehouse.dir  （默认：/user/hive/warehouse） </td>    <td> hdfs中任意位置 </td>  </tr>  <tr>    <td> 删除时影响 </td>    <td> 直接删除元数据（metadata）及存储数据 </td>    <td> 仅会删除元数据，HDFS上的文件并不会被删除 </td>  </tr>  <tr>    <td> 表结构修改时影响 </td>    <td> 修改会将修改直接同步给元数据  </td>    <td> 表结构和分区进行修改，则需要修复（MSCK REPAIR TABLE table_name;）</td>  </tr></table><ul><li><p>案例</p><ul><li>创建一个外部表student2</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> student2 (classNo string, stuNo string, score <span class="type">int</span>) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> location <span class="string">&#x27;/tmp/student&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>装载数据</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hadoop/tmp/student.txt&#x27;</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> student2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用...put 也可以放到/user/hive/warehouse中,不过上面的load是加载到了默认的路径/user/hive/warehouse中</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>显示表信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> formatted table_name;</span><br></pre></td></tr></table></figure></li><li><p>删除表查看结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure></li><li><p>再次创建外部表 student2</p></li><li><p>不插入数据直接查询查看结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student2;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-分区表——实际上是表目录下的子目录"><a href="#2-3-分区表——实际上是表目录下的子目录" class="headerlink" title="2.3 分区表——实际上是表目录下的子目录"></a>2.3 分区表——实际上是表目录下的子目录</h3><ul><li><p>什么是分区表</p><ul><li>随着表的不断增大，对于新纪录的增加，查找，删除等(DML)的维护也更加困难。对于数据库中的超大型表，可以通过把它的数据分成若干个小表，从而简化数据库的管理活动，对于每一个简化后的小表，我们称为一个单个的分区。</li><li>hive中分区表实际就是对应hdfs文件系统上独立的文件夹，该文件夹内的文件是该分区所有数据文件。</li><li>分区可以理解为分类，通过分类把不同类型的数据放到不同的目录下。</li><li>分类的标准就是分区字段，可以一个，也可以多个。</li><li>分区表的意义在于优化查询。查询时尽量利用分区字段。如果不使用分区字段，就会全部扫描。</li></ul></li><li><p>创建分区表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tom,4300</span><br><span class="line">jerry,12000</span><br><span class="line">mike,13000</span><br><span class="line">jake,11000</span><br><span class="line">rob,10000</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee (name string,salary <span class="type">bigint</span>) partitioned <span class="keyword">by</span> (date1 string) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> stored <span class="keyword">as</span> textfile;</span><br></pre></td></tr></table></figure><ul><li><p>查看表的分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> partitions employee;</span><br></pre></td></tr></table></figure></li><li><p>添加分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table employee add if not exists partition(date1&#x3D;&#39;2018-12-01&#39;);</span><br></pre></td></tr></table></figure></li><li><p>加载数据到分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hadoop/tmp/employee.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> employee <span class="keyword">partition</span>(date1<span class="operator">=</span><span class="string">&#x27;2018-12-01&#x27;</span>);</span><br><span class="line"><span class="comment">-- 也可以用put</span></span><br></pre></td></tr></table></figure></li><li><p>如果重复加载同名文件，不会报错，会自动创建一个*_copy_1.txt</p></li><li><p>外部分区表即使有分区的目录结构, 也必须要通过HQL添加分区, 才能看到相应的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /user/hive/warehouse/emp/dt=2018-12-04</span><br><span class="line">hadoop fs -copyFromLocal /tmp/employee.txt /user/hive/warehouse/test.db/emp/dt=2018-12-04/employee.txt</span><br></pre></td></tr></table></figure><ul><li><p>此时查看表中数据发现数据并没有变化, 需要通过hql添加分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp add if not exists partition(dt&#x3D;&#39;2018-12-04&#39;);</span><br></pre></td></tr></table></figure></li><li><p>此时再次查看才能看到新加入的数据</p></li></ul></li><li><p>总结</p><ul><li>利用分区表方式减少查询时需要扫描的数据量<ul><li>分区字段不是表中的列, 数据文件中没有对应的列</li><li>分区仅仅是一个目录名</li><li>查看数据时, hive会自动添加分区列</li><li>支持多级分区, 多级子目录</li></ul></li></ul></li></ul><h3 id="2-4-动态分区"><a href="#2-4-动态分区" class="headerlink" title="2.4 动态分区"></a>2.4 动态分区</h3><ul><li><p>在写入数据时自动创建分区(包括目录结构)</p></li><li><p>创建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table employee2 (name string,salary bigint) partitioned by (date1 string) row format delimited fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39; stored as textfile;</span><br></pre></td></tr></table></figure></li><li><p>导入数据——没有reduce,只有map。每条数据都丢过去。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> employee2 <span class="keyword">partition</span>(date1) <span class="keyword">select</span> name,salary,date1 <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure></li><li><p>使用动态分区需要设置参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set hive.exec.dynamic.partition.mode=nonstrict;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三-Hive-函数"><a href="#三-Hive-函数" class="headerlink" title="三 Hive 函数"></a>三 Hive 函数</h2><h3 id="3-1-内置运算符"><a href="#3-1-内置运算符" class="headerlink" title="3.1 内置运算符"></a>3.1 内置运算符</h3><p>在 Hive 有四种类型的运算符：</p><ul><li><p>关系运算符</p></li><li><p>算术运算符</p></li><li><p>逻辑运算符</p></li><li><p>复杂运算</p><p>(内容较多，见《Hive 官方文档》》)</p></li></ul><h3 id="3-2-内置函数"><a href="#3-2-内置函数" class="headerlink" title="3.2 内置函数"></a>3.2 内置函数</h3><p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF</a></p><ul><li>简单函数: 日期函数 字符串函数 类型转换 </li><li>统计函数: sum avg distinct</li><li>集合函数</li><li>分析函数</li><li>show functions;  显示所有函数</li><li>desc function 函数名;</li><li>desc function extended 函数名;</li></ul><h3 id="3-3-Hive-自定义函数和-Transform"><a href="#3-3-Hive-自定义函数和-Transform" class="headerlink" title="3.3 Hive 自定义函数和 Transform"></a>3.3 Hive 自定义函数和 Transform</h3><ul><li><p>UDF</p><ul><li><p>当 Hive 提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-defined function）。</p></li><li><p><strong>TRANSFORM</strong>,and <strong>UDF</strong> and <strong>UDAF</strong></p><p>it is possible to plug in your own custom mappers and reducers</p><p> A UDF is basically only a transformation done by a mapper meaning that each row should be mapped to exactly one row. A UDAF on the other hand allows us to transform a group of rows into one or more rows, meaning that we can reduce the number of input rows to a single output row by some custom aggregation.</p><p><strong>UDF</strong>：就是做一个mapper，对每一条输入数据，映射为一条输出数据。（输入一个，输出一个）</p><p><strong>UDAF</strong>:就是一个reducer，把一组输入数据映射为一条(或多条)输出数据。（输入100个，输出10个）</p><p>一个脚本至于是做mapper还是做reducer，又或者是做udf还是做udaf，取决于我们把它放在什么样的hive操作符中。放在select中的基本就是udf，放在distribute by和cluster by中的就是reducer。</p><p>We can control if the script is run in a mapper or reducer step by the way we formulate our HiveQL query.</p><p>The statements DISTRIBUTE BY and CLUSTER BY allow us to indicate that we want to actually perform an aggregation.</p><p>User-Defined Functions (UDFs) for transformations and even aggregations which are therefore called User-Defined Aggregation Functions (UDAFs)</p></li></ul></li><li><p>UDF示例(运行java已经编写好的UDF)</p><ul><li><p>在hdfs中创建 /user/hive/lib目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /user/hive/lib</span><br></pre></td></tr></table></figure></li><li><p>把 hive目录下 lib/hive-contrib-hive-contrib-1.1.0-cdh5.7.0.jar 放到hdfs中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put hive-contrib-1.1.0-cdh5.7.0.jar /user/hive/lib/</span><br></pre></td></tr></table></figure></li><li><p>把集群中jar包的位置添加到hive中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> add jar hdfs:///user/hive/lib/hive-contrib-1.1.0-cdh2.3.4.jar;</span></span><br></pre></td></tr></table></figure></li><li><p>在hive中创建<strong>临时</strong>UDF</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">CREATE</span> TEMPORARY <span class="keyword">FUNCTION</span> row_sequence <span class="keyword">as</span> <span class="string">&#x27;org.apache.hadoop.hive.contrib.udf.UDFRowSequence&#x27;</span> <span class="comment">-- 相当于给这个jar包重起名字叫row_FUNCTION了。</span></span><br></pre></td></tr></table></figure></li><li><p>在之前的案例中使用<strong>临时</strong>自定义函数(函数功能: 添加自增长的行号)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> row_sequence(),<span class="operator">*</span> <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure></li><li><p>创建<strong>非临时</strong>自定义函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> row_sequence <span class="keyword">as</span> <span class="string">&#x27;org.apache.hadoop.hive.contrib.udf.UDFRowSequence&#x27;</span> <span class="keyword">using</span> jar <span class="string">&#x27;hdfs:///user/hive/lib/hive-contrib-1.1.0-cdh2.3.4.jar&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Python UDF</p><ul><li><p>准备案例环境</p><ul><li><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> u(fname STRING,lname STRING);</span><br></pre></td></tr></table></figure></li><li><p>向表中插入数据(不要一条一条放，应该load或put)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> u2 <span class="keyword">values</span>(<span class="string">&#x27;George&#x27;</span>,<span class="string">&#x27;washington&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> u2 <span class="keyword">values</span>(<span class="string">&#x27;George&#x27;</span>,<span class="string">&#x27;bush&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> u2 <span class="keyword">values</span>(<span class="string">&#x27;Bill&#x27;</span>,<span class="string">&#x27;clinton&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> u2 <span class="keyword">values</span>(<span class="string">&#x27;Bill&#x27;</span>,<span class="string">&#x27;gates&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写map风格脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    line = line.strip()</span><br><span class="line">    fname , lname = line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    l_name = lname.upper()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;\t&#x27;</span>.join([fname, <span class="built_in">str</span>(l_name)])</span><br></pre></td></tr></table></figure></li><li><p>通过hdfs向hive中ADD file</p><ul><li><p>加载文件到hdfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put udf.py /user/hive/lib/</span><br></pre></td></tr></table></figure></li><li><p>hive从hdfs中加载python脚本——自己写的必须有这一步。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD FILE hdfs:///user/hive/lib/udf.py;</span><br><span class="line">ADD FILE /root/tmp/udf1.py;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Transform</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TRANSFORM(fname, lname) <span class="keyword">USING</span> <span class="string">&#x27;python udf1.py&#x27;</span> <span class="keyword">AS</span> (fname, l_name) <span class="keyword">FROM</span> u;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>Python UDAF</li></ul><h2 id="四-hive综合案例"><a href="#四-hive综合案例" class="headerlink" title="四 hive综合案例"></a>四 hive综合案例</h2><ul><li><p>内容推荐数据处理</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629005037.png" alt=""></p><ul><li>需求<ul><li>根据用户行为以及文章标签筛选出用户最感兴趣(阅读最多)的标签</li></ul></li></ul></li><li><p>相关数据</p><p>​    user_id article_id event_time</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">11,101,2018-12-01 06:01:10</span><br><span class="line">22,102,2018-12-01 07:28:12</span><br><span class="line">33,103,2018-12-01 07:50:14</span><br><span class="line">11,104,2018-12-01 09:08:12</span><br><span class="line">22,103,2018-12-01 13:37:12</span><br><span class="line">33,102,2018-12-02 07:09:12</span><br><span class="line">11,101,2018-12-02 18:42:12</span><br><span class="line">35,105,2018-12-03 09:21:12</span><br><span class="line">22,104,2018-12-03 16:42:12</span><br><span class="line">77,103,2018-12-03 18:31:12</span><br><span class="line">99,102,2018-12-04 00:04:12</span><br><span class="line">33,101,2018-12-04 19:10:12</span><br><span class="line">11,101,2018-12-05 09:07:12</span><br><span class="line">35,102,2018-12-05 11:00:12</span><br><span class="line">22,103,2018-12-05 12:11:12</span><br><span class="line">77,104,2018-12-05 18:02:02</span><br><span class="line">99,105,2018-12-05 20:09:11</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>文章数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">artical_id,artical_url,artical_keywords</span><br><span class="line">101,http:&#x2F;&#x2F;www.itcast.cn&#x2F;1.html,kw8|kw1</span><br><span class="line">102,http:&#x2F;&#x2F;www.itcast.cn&#x2F;2.html,kw6|kw3</span><br><span class="line">103,http:&#x2F;&#x2F;www.itcast.cn&#x2F;3.html,kw7</span><br><span class="line">104,http:&#x2F;&#x2F;www.itcast.cn&#x2F;4.html,kw5|kw1|kw4|kw9</span><br><span class="line">105,http:&#x2F;&#x2F;www.itcast.cn&#x2F;5.html,</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>要做的事情</strong>：将文章的关键词和用户联系起来。拿到任何一个用户可以知道他看这个标签文章的频率。</li></ul><ul><li><p>数据上传hdfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /tmp/demo</span><br><span class="line">hadoop fs -mkdir /tmp/demo/user_action</span><br></pre></td></tr></table></figure></li><li><p>创建外部表</p><ul><li>用户行为表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> user_actions;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> user_actions(</span><br><span class="line">    user_id STRING,</span><br><span class="line">    article_id STRING,</span><br><span class="line">    time_stamp STRING</span><br><span class="line">)</span><br><span class="line"><span class="type">ROW</span> FORMAT delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">LOCATION <span class="string">&#x27;/tmp/demo/user_action&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>文章表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> articles;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> articles(</span><br><span class="line">    article_id STRING,</span><br><span class="line">    url STRING,</span><br><span class="line">    key_words <span class="keyword">array</span><span class="operator">&lt;</span>STRING<span class="operator">&gt;</span></span><br><span class="line">)</span><br><span class="line"><span class="type">ROW</span> FORMAT delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">COLLECTION ITEMS terminated <span class="keyword">BY</span> <span class="string">&#x27;|&#x27;</span>   <span class="comment">-- key1|key2</span></span><br><span class="line">LOCATION <span class="string">&#x27;/tmp/demo/article_keywords&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">key_words array&lt;STRING&gt;  数组的数据类型</span></span><br><span class="line"><span class="comment">COLLECTION ITEMS terminated BY &#x27;|&#x27;  数组的元素之间用&#x27;|&#x27;分割</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>查看数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_actions;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> articles;</span><br></pre></td></tr></table></figure><ul><li><p>分组查询每个用户的浏览记录</p><ul><li>collect_set/collect_list作用:<ul><li>将group by中的某列转为一个数组返回</li><li>collect_list<strong>不去重</strong>而collect_set<strong>去重</strong></li></ul></li><li>collect_set</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,collect_set(article_id) </span><br><span class="line"><span class="keyword">from</span> user_actions <span class="keyword">group</span> <span class="keyword">by</span> user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11      [&quot;101&quot;,&quot;104&quot;]</span><br><span class="line">22      [&quot;102&quot;,&quot;103&quot;,&quot;104&quot;]</span><br><span class="line">33      [&quot;103&quot;,&quot;102&quot;,&quot;101&quot;]</span><br><span class="line">35      [&quot;105&quot;,&quot;102&quot;]</span><br><span class="line">77      [&quot;103&quot;,&quot;104&quot;]</span><br><span class="line">99      [&quot;102&quot;,&quot;105&quot;]</span><br></pre></td></tr></table></figure><ul><li>collect_list</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,collect_list(article_id) </span><br><span class="line"><span class="keyword">from</span> user_actions <span class="keyword">group</span> <span class="keyword">by</span> user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">11      [&quot;101&quot;,&quot;104&quot;,&quot;101&quot;,&quot;101&quot;]</span><br><span class="line">22      [&quot;102&quot;,&quot;103&quot;,&quot;104&quot;,&quot;103&quot;]</span><br><span class="line">33      [&quot;103&quot;,&quot;102&quot;,&quot;101&quot;]</span><br><span class="line">35      [&quot;105&quot;,&quot;102&quot;]</span><br><span class="line">77      [&quot;103&quot;,&quot;104&quot;]</span><br><span class="line">99      [&quot;102&quot;,&quot;105&quot;]</span><br></pre></td></tr></table></figure></li><li><p>sort_array: 对数组排序</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,sort_array(collect_list(article_id)) <span class="keyword">as</span> contents </span><br><span class="line"><span class="keyword">from</span> user_actions <span class="keyword">group</span> <span class="keyword">by</span> user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11      [&quot;101&quot;,&quot;101&quot;,&quot;101&quot;,&quot;104&quot;]</span><br><span class="line">22      [&quot;102&quot;,&quot;103&quot;,&quot;103&quot;,&quot;104&quot;]</span><br><span class="line">33      [&quot;101&quot;,&quot;102&quot;,&quot;103&quot;]</span><br><span class="line">35      [&quot;102&quot;,&quot;105&quot;]</span><br><span class="line">77      [&quot;103&quot;,&quot;104&quot;]</span><br><span class="line">99      [&quot;102&quot;,&quot;105&quot;]</span><br></pre></td></tr></table></figure><ul><li><p>如上所示：11与77都含有”104”,在Array里面不好统计次数。所以将其展开——拆分。</p></li><li><p>查看每一篇文章的关键字 lateral view explode</p><ul><li>explode函数 将array 拆分</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> explode(key_words) <span class="keyword">from</span> articles;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kw8</span><br><span class="line">kw1</span><br><span class="line">kw6</span><br><span class="line">kw3</span><br><span class="line">kw7</span><br><span class="line">kw5</span><br><span class="line">kw1</span><br><span class="line">kw4</span><br><span class="line">kw9</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- lateral view 和 explode 配合使用,将一行数据拆分成多行数据，在此基础上可以对拆分的数据进行聚合。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles <span class="keyword">lateral</span> <span class="keyword">view</span> explode(key_words) t <span class="keyword">as</span> kw;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">101     kw8</span><br><span class="line">101     kw1</span><br><span class="line">102     kw6</span><br><span class="line">102     kw3</span><br><span class="line">103     kw7</span><br><span class="line">104     kw5</span><br><span class="line">104     kw1</span><br><span class="line">104     kw4</span><br><span class="line">104     kw9</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">101     kw8</span><br><span class="line">101     kw1</span><br><span class="line">102     kw6</span><br><span class="line">102     kw3</span><br><span class="line">103     kw7</span><br><span class="line">104     kw5</span><br><span class="line">104     kw1</span><br><span class="line">104     kw4</span><br><span class="line">104     kw9</span><br><span class="line">105     NULL</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>含有outer——将105留下</p></li><li><p>根据文章id找到用户查看文章的关键字</p><ul><li>原始数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">101     http://www.itcast.cn/1.html     [&quot;kw8&quot;,&quot;kw1&quot;]</span><br><span class="line">102     http://www.itcast.cn/2.html     [&quot;kw6&quot;,&quot;kw3&quot;]</span><br><span class="line">103     http://www.itcast.cn/3.html     [&quot;kw7&quot;]</span><br><span class="line">104     http://www.itcast.cn/4.html     [&quot;kw5&quot;,&quot;kw1&quot;,&quot;kw4&quot;,&quot;kw9&quot;]</span><br><span class="line">105     http://www.itcast.cn/5.html     []</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_id, b.kw <span class="keyword">from</span> user_actions </span><br><span class="line"><span class="keyword">as</span> a <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line"><span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a.user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">11      kw1</span><br><span class="line">11      kw8</span><br><span class="line">11      kw5</span><br><span class="line">11      kw1</span><br><span class="line">11      kw4</span><br><span class="line">11      kw1</span><br><span class="line">11      kw9</span><br><span class="line">11      kw8</span><br><span class="line">11      kw1</span><br><span class="line">11      kw8</span><br><span class="line">22      kw1</span><br><span class="line">22      kw7</span><br><span class="line">22      kw9</span><br><span class="line">22      kw4</span><br><span class="line">22      kw5</span><br><span class="line">22      kw7</span><br><span class="line">22      kw3</span><br><span class="line">22      kw6</span><br><span class="line">33      kw8</span><br><span class="line">33      kw1</span><br><span class="line">33      kw3</span><br><span class="line">33      kw6</span><br><span class="line">33      kw7</span><br><span class="line">35      NULL</span><br><span class="line">35      kw6</span><br><span class="line">35      kw3</span><br><span class="line">77      kw9</span><br><span class="line">77      kw1</span><br><span class="line">77      kw7</span><br><span class="line">77      kw4</span><br><span class="line">77      kw5</span><br><span class="line">99      kw3</span><br><span class="line">99      kw6</span><br><span class="line">99      NULL</span><br></pre></td></tr></table></figure></li><li><p>根据文章id找到用户查看文章的关键字并统计频率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">select</span> a.user_id, b.kw,<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> weight </span><br><span class="line">  <span class="keyword">from</span> user_actions <span class="keyword">as</span> a </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line">  <span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> a.user_id,b.kw </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a.user_id,weight <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">11      kw1     4</span><br><span class="line">11      kw8     3</span><br><span class="line">11      kw5     1</span><br><span class="line">11      kw9     1</span><br><span class="line">11      kw4     1</span><br><span class="line">22      kw7     2</span><br><span class="line">22      kw9     1</span><br><span class="line">22      kw1     1</span><br><span class="line">22      kw3     1</span><br><span class="line">22      kw4     1</span><br><span class="line">22      kw5     1</span><br><span class="line">22      kw6     1</span><br><span class="line">33      kw3     1</span><br><span class="line">33      kw8     1</span><br><span class="line">33      kw7     1</span><br><span class="line">33      kw6     1</span><br><span class="line">33      kw1     1</span><br><span class="line">35      NULL    1</span><br><span class="line">35      kw3     1</span><br><span class="line">35      kw6     1</span><br><span class="line">77      kw1     1</span><br><span class="line">77      kw4     1</span><br><span class="line">77      kw5     1</span><br><span class="line">77      kw7     1</span><br><span class="line">77      kw9     1</span><br><span class="line">99      NULL    1</span><br><span class="line">99      kw3     1</span><br><span class="line">99      kw6     1</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>CONCAT：——将其链接在一起。<br>  CONCAT(str1,str2,…)  </p><p>  返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(user_id,article_id) <span class="keyword">from</span> user_actions;</span><br></pre></td></tr></table></figure><p>  CONCAT_WS:</p><p>  使用语法为：CONCAT_WS(separator,str1,str2,…)</p><p>  CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL，则结果为 NULL。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat_ws(<span class="string">&#x27;:&#x27;</span>,user_id,article_id) <span class="keyword">from</span> user_actions;</span><br></pre></td></tr></table></figure><ul><li><p>将用户查看的关键字和频率合并成 key:value形式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">select</span> a.user_id, concat_ws(<span class="string">&#x27;:&#x27;</span>,b.kw,<span class="built_in">cast</span> (<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> string)) <span class="keyword">as</span> kw_w  <span class="comment">--cast类型转化。</span></span><br><span class="line">  <span class="keyword">from</span> user_actions <span class="keyword">as</span> a </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line">  <span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.user_id,b.kw;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">11      kw1:4</span><br><span class="line">11      kw4:1</span><br><span class="line">11      kw5:1</span><br><span class="line">11      kw8:3</span><br><span class="line">11      kw9:1</span><br><span class="line">22      kw1:1</span><br><span class="line">22      kw3:1</span><br><span class="line">22      kw4:1</span><br><span class="line">22      kw5:1</span><br><span class="line">22      kw6:1</span><br><span class="line">22      kw7:2</span><br><span class="line">22      kw9:1</span><br><span class="line">33      kw1:1</span><br><span class="line">33      kw3:1</span><br><span class="line">33      kw6:1</span><br><span class="line">33      kw7:1</span><br><span class="line">33      kw8:1</span><br><span class="line">35      1</span><br><span class="line">35      kw3:1</span><br><span class="line">35      kw6:1</span><br><span class="line">77      kw1:1</span><br><span class="line">77      kw4:1</span><br><span class="line">77      kw5:1</span><br><span class="line">77      kw7:1</span><br><span class="line">77      kw9:1</span><br><span class="line">99      1</span><br><span class="line">99      kw3:1</span><br><span class="line">99      kw6:1</span><br></pre></td></tr></table></figure></li><li><p>将用户查看的关键字和频率合并成 key:value形式并按用户聚合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">select</span> cc.user_id,concat_ws(<span class="string">&#x27;,&#x27;</span>,collect_set(cc.kw_w))</span><br><span class="line">  <span class="keyword">from</span>(</span><br><span class="line">  <span class="keyword">select</span> a.user_id, concat_ws(<span class="string">&#x27;:&#x27;</span>,b.kw,<span class="built_in">cast</span> (<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> string)) <span class="keyword">as</span> kw_w </span><br><span class="line">  <span class="keyword">from</span> user_actions <span class="keyword">as</span> a </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line">  <span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> a.user_id,b.kw</span><br><span class="line">  ) <span class="keyword">as</span> cc </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cc.user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11      kw1:4,kw4:1,kw5:1,kw8:3,kw9:1</span><br><span class="line">22      kw1:1,kw3:1,kw4:1,kw5:1,kw6:1,kw7:2,kw9:1</span><br><span class="line">33      kw1:1,kw3:1,kw6:1,kw7:1,kw8:1</span><br><span class="line">35      1,kw3:1,kw6:1</span><br><span class="line">77      kw1:1,kw4:1,kw5:1,kw7:1,kw9:1</span><br><span class="line">99      1,kw3:1,kw6:1</span><br></pre></td></tr></table></figure></li><li><p>将上面聚合结果转换成map</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cc.user_id,str_to_map(concat_ws(<span class="string">&#x27;,&#x27;</span>,collect_set(cc.kw_w))) <span class="keyword">as</span> wm</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line"><span class="keyword">select</span> a.user_id, concat_ws(<span class="string">&#x27;:&#x27;</span>,b.kw,<span class="built_in">cast</span> (<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> string)) <span class="keyword">as</span> kw_w </span><br><span class="line"><span class="keyword">from</span> user_actions <span class="keyword">as</span> a </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line"><span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.user_id,b.kw</span><br><span class="line">) <span class="keyword">as</span> cc </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cc.user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  11      &#123;&quot;kw1&quot;:&quot;4&quot;,&quot;kw4&quot;:&quot;1&quot;,&quot;kw5&quot;:&quot;1&quot;,&quot;kw8&quot;:&quot;3&quot;,&quot;kw9&quot;:&quot;1&quot;&#125;</span><br><span class="line">  22      &#123;&quot;kw1&quot;:&quot;1&quot;,&quot;kw3&quot;:&quot;1&quot;,&quot;kw4&quot;:&quot;1&quot;,&quot;kw5&quot;:&quot;1&quot;,&quot;kw6&quot;:&quot;1&quot;,&quot;kw7&quot;:&quot;2&quot;,&quot;kw9&quot;:&quot;1&quot;&#125;</span><br><span class="line">  33      &#123;&quot;kw1&quot;:&quot;1&quot;,&quot;kw3&quot;:&quot;1&quot;,&quot;kw6&quot;:&quot;1&quot;,&quot;kw7&quot;:&quot;1&quot;,&quot;kw8&quot;:&quot;1&quot;&#125;</span><br><span class="line">  35      &#123;&quot;1&quot;:null,&quot;kw3&quot;:&quot;1&quot;,&quot;kw6&quot;:&quot;1&quot;&#125;</span><br><span class="line">  77      &#123;&quot;kw1&quot;:&quot;1&quot;,&quot;kw4&quot;:&quot;1&quot;,&quot;kw5&quot;:&quot;1&quot;,&quot;kw7&quot;:&quot;1&quot;,&quot;kw9&quot;:&quot;1&quot;&#125;</span><br><span class="line">99      &#123;&quot;1&quot;:null,&quot;kw3&quot;:&quot;1&quot;,&quot;kw6&quot;:&quot;1&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>将用户的阅读偏好结果保存到表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">create</span> <span class="keyword">table</span> user_kws <span class="keyword">as</span> </span><br><span class="line">  <span class="keyword">select</span> cc.user_id,str_to_map(concat_ws(<span class="string">&#x27;,&#x27;</span>,collect_set(cc.kw_w))) <span class="keyword">as</span> wm</span><br><span class="line">  <span class="keyword">from</span>(</span><br><span class="line">  <span class="keyword">select</span> a.user_id, concat_ws(<span class="string">&#x27;:&#x27;</span>,b.kw,<span class="built_in">cast</span> (<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> string)) <span class="keyword">as</span> kw_w </span><br><span class="line">  <span class="keyword">from</span> user_actions <span class="keyword">as</span> a </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line">  <span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> a.user_id,b.kw</span><br><span class="line">  ) <span class="keyword">as</span> cc </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cc.user_id;</span><br></pre></td></tr></table></figure></li><li><p>从表中通过key查询map中的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id, wm[<span class="string">&#x27;kw1&#x27;</span>] <span class="keyword">from</span> user_kws;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11      4</span><br><span class="line">22      1</span><br><span class="line">33      1</span><br><span class="line">35      NULL</span><br><span class="line">77      1</span><br><span class="line">99      NULL</span><br></pre></td></tr></table></figure></li><li><p>从表中获取map中所有的key 和 所有的value</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,map_keys(wm),map_values(wm) <span class="keyword">from</span> user_kws;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11      [&quot;kw1&quot;,&quot;kw4&quot;,&quot;kw5&quot;,&quot;kw8&quot;,&quot;kw9&quot;] [&quot;4&quot;,&quot;1&quot;,&quot;1&quot;,&quot;3&quot;,&quot;1&quot;]</span><br><span class="line">22      [&quot;kw1&quot;,&quot;kw3&quot;,&quot;kw4&quot;,&quot;kw5&quot;,&quot;kw6&quot;,&quot;kw7&quot;,&quot;kw9&quot;]     [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;2&quot;,&quot;1&quot;]</span><br><span class="line">33      [&quot;kw1&quot;,&quot;kw3&quot;,&quot;kw6&quot;,&quot;kw7&quot;,&quot;kw8&quot;] [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">35      [&quot;1&quot;,&quot;kw3&quot;,&quot;kw6&quot;]       [null,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">77      [&quot;kw1&quot;,&quot;kw4&quot;,&quot;kw5&quot;,&quot;kw7&quot;,&quot;kw9&quot;] [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">99      [&quot;1&quot;,&quot;kw3&quot;,&quot;kw6&quot;]       [null,&quot;1&quot;,&quot;1&quot;]</span><br></pre></td></tr></table></figure></li><li><p>用lateral view explode把map中的数据转换成多列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,keyword,weight <span class="keyword">from</span> user_kws <span class="keyword">lateral</span> <span class="keyword">view</span> explode(wm) t <span class="keyword">as</span> keyword,weight;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">11      kw1     4</span><br><span class="line">11      kw4     1</span><br><span class="line">11      kw5     1</span><br><span class="line">11      kw8     3</span><br><span class="line">11      kw9     1</span><br><span class="line">22      kw1     1</span><br><span class="line">22      kw3     1</span><br><span class="line">22      kw4     1</span><br><span class="line">22      kw5     1</span><br><span class="line">22      kw6     1</span><br><span class="line">22      kw7     2</span><br><span class="line">22      kw9     1</span><br><span class="line">33      kw1     1</span><br><span class="line">33      kw3     1</span><br><span class="line">33      kw6     1</span><br><span class="line">33      kw7     1</span><br><span class="line">33      kw8     1</span><br><span class="line">35      1       NULL</span><br><span class="line">35      kw3     1</span><br><span class="line">35      kw6     1</span><br><span class="line">77      kw1     1</span><br><span class="line">77      kw4     1</span><br><span class="line">77      kw5     1</span><br><span class="line">77      kw7     1</span><br><span class="line">77      kw9     1</span><br><span class="line">99      1       NULL</span><br><span class="line">99      kw3     1</span><br><span class="line">99      kw6     1</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hive&quot;&gt;&lt;a href=&quot;#Hive&quot; class=&quot;headerlink&quot; title=&quot;Hive&quot;&gt;&lt;/a&gt;Hive&lt;/h1&gt;&lt;h2 id=&quot;一-Hive基本概念&quot;&gt;&lt;a href=&quot;#一-Hive基本概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>01-二叉树之常用框架</title>
    <link href="https://xxren8218.github.io/20210628/01-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6.html"/>
    <id>https://xxren8218.github.io/20210628/01-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6.html</id>
    <published>2021-06-28T14:07:14.000Z</published>
    <updated>2021-06-28T14:13:54.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树之常用框架"><a href="#二叉树之常用框架" class="headerlink" title="二叉树之常用框架"></a>二叉树之常用框架</h2><p>读完本文，你可以去力扣拿下：</p><p>226.翻转二叉树，难度 <strong>Easy</strong></p><p>116.将二叉树展开为链表，难度 <strong>Medium</strong></p><p>114.填充二叉树节点的右侧指针，难度 <strong>Medium</strong></p><p>先刷二叉树的题目，先刷二叉树的题目，先刷二叉树的题目，因为很多经典算法，回溯、动归、分治算法，其实都是树的问题，而树的问题就永远逃不开树的递归遍历框架这几行破代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># 前序遍历</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment"># 中序遍历</span></span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment"># 后序遍历</span></span><br></pre></td></tr></table></figure><p>递归解法应该是最简单，最容易理解的才对，行云流水地写递归代码是学好算法的基本功，而二叉树相关的题目就是最练习递归基本功，最练习框架思维的。</p><blockquote><h3 id="一、二叉树的重要性"><a href="#一、二叉树的重要性" class="headerlink" title="一、二叉树的重要性"></a>一、二叉树的重要性</h3></blockquote><p>举个例子，比如说我们的经典算法<code>「快速排序」</code>和<code>「归并排序」</code>，对于这两个算法，你有什么理解？<strong>如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后续遍历，那么我就知道你是个算法高手了</strong>。</p><p>为什么快速排序和归并排序能和二叉树扯上关系？我们来简单分析一下他们的算法思想和代码框架：</p><p>快速排序的逻辑是，若要对<code>nums[lo..hi]</code>进行排序，我们先找一个分界点<code>p</code>，通过交换元素使得<code>nums[lo..p-1]</code>都小于等于<code>nums[p]</code>，且<code>nums[p+1..hi]</code>都大于<code>nums[p]</code>，然后递归地去<code>nums[lo..p-1]</code>和<code>nums[p+1..hi]</code>中寻找新的分界点，最后整个数组就被排序了。</p><p>快速排序的代码框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">nums, lo, hi</span>):</span></span><br><span class="line">    <span class="comment">##### 前序遍历位置 ##### </span></span><br><span class="line">    <span class="comment"># 通过交换元素构建分界点 p</span></span><br><span class="line">    p = partition(nums, lo, hi)</span><br><span class="line"></span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>)</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi)</span><br></pre></td></tr></table></figure><p>先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？</p><p>再说说归并排序的逻辑，若要对<code>nums[lo..hi]</code>进行排序，我们先对<code>nums[lo..mid]</code>排序，再对<code>nums[mid+1..hi]</code>排序，最后把这两个有序的子数组合并，整个数组就排好序了。</p><p>归并排序的代码框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">nums, lo, hi</span>):</span></span><br><span class="line">    mid = (lo + hi) / <span class="number">2</span></span><br><span class="line">    sort(nums, lo, mid)</span><br><span class="line">    sort(nums, mid + <span class="number">1</span>, hi)</span><br><span class="line"></span><br><span class="line">    <span class="comment">###### 后序遍历位置 #####</span></span><br><span class="line">    <span class="comment"># 合并两个排好序的子数组</span></span><br><span class="line">    merge(nums, lo, mid, hi)</span><br><span class="line">    <span class="comment">########################</span></span><br></pre></td></tr></table></figure><p>先对左右子数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是二叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀。</p><p>如果你一眼就识破这些排序算法的底细，还需要背这些算法代码吗？这不是手到擒来，从框架慢慢扩展就能写出算法了。</p><p>说了这么多，旨在说明，二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树的问题。</p><p><strong>所以接下来，我们直接上几道比较有意思，且能体现出递归算法精妙的二叉树题目</strong>。</p><blockquote><h3 id="二、写递归算法的秘诀"><a href="#二、写递归算法的秘诀" class="headerlink" title="二、写递归算法的秘诀"></a>二、写递归算法的秘诀</h3></blockquote><p><strong>写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要试图跳入递归</strong>。</p><p>怎么理解呢，我们用一个具体的例子来说，比如说让你计算一棵二叉树共有几个节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义：count(root) 返回以 root 为根的树有多少节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 自己加上子树的节点数就是整棵树的节点数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + count(root.left) + count(root.right)</span><br></pre></td></tr></table></figure><p>这个问题非常简单，大家应该都会写这段代码，<code>root</code>本身就是一个节点，加上左右子树的节点数就是以<code>root</code>为根的树的节点总数。</p><p>左右子树的节点数怎么算？其实就是计算根为<code>root.left</code>和<code>root.right</code>两棵树的节点数呗，按照定义，递归调用<code>count</code>函数即可算出来。</p><p><strong>写树相关的算法，简单说就是，先搞清楚当前<code>root</code>节点该做什么，然后根据函数定义递归调用子节点</strong>，递归调用会让孩子节点做相同的事情。</p><p>我们接下来看几道算法题目实操一下。</p><blockquote><h3 id="三、算法实践"><a href="#三、算法实践" class="headerlink" title="三、算法实践"></a>三、算法实践</h3></blockquote><h4 id="第一题、翻转二叉树"><a href="#第一题、翻转二叉树" class="headerlink" title="第一题、翻转二叉树"></a>第一题、翻转二叉树</h4><p>我们先从简单的题开始，看看力扣第 226 题「翻转二叉树」，输入一个二叉树根节点<code>root</code>，让你把整棵树镜像翻转，比如输入的二叉树如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>算法原地翻转二叉树，使得以<code>root</code>为根的树变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><p>通过观察，<strong>我们发现只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树</strong>。</p><p>可以直接写出解法代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将整棵树的节点翻转</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前序遍历位置</span></span><br><span class="line">    <span class="comment"># root 节点需要交换它的左右子节点</span></span><br><span class="line">    tmp = root.left</span><br><span class="line">    root.left = root.right</span><br><span class="line">    root.right = tmp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 让左右子节点继续翻转它们的子节点</span></span><br><span class="line">    invertTree(root.left)</span><br><span class="line">    invertTree(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>这道题目比较简单，关键思路在于我们发现翻转整棵树就是交换每个节点的左右子节点，于是我们把交换左右子节点的代码放在了前序遍历的位置。</p><p>值得一提的是，如果把交换左右子节点的代码放在后序遍历的位置也是可以的，但是放在中序遍历的位置是不行的，请你想一想为什么？这个应该不难想到。</p><p><code>中序遍历换节点 根据左根右的遍历顺序 相当于左侧节点交换了两次 右侧节点没换  因为遍历根的时候交换了左右节点 遍历右侧的时候还是之前那个左节点</code></p><p>首先讲这道题目是想告诉你，<strong>二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情</strong>。</p><p>这种洞察力需要多刷题训练，我们看下一道题</p><h4 id="第二题、填充二叉树节点的右侧指针"><a href="#第二题、填充二叉树节点的右侧指针" class="headerlink" title="第二题、填充二叉树节点的右侧指针"></a>第二题、填充二叉树节点的右侧指针</h4><p>这是力扣第 116 题，看下题目：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220806.jpg" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">root</span>):</span></span><br></pre></td></tr></table></figure><p>题目的意思就是把二叉树的每一层节点都用<code>next</code>指针连接起来：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220820.jpg" alt=""></p><p>而且题目说了，输入是一棵「完美二叉树」，形象地说整棵二叉树是一个正三角形，除了最右侧的节点<code>next</code>指针会指向<code>null</code>，其他节点的右侧一定有相邻的节点。</p><p>这道题怎么做呢？把每一层的节点穿起来，是不是只要把每个节点的左右子节点都穿起来就行了？</p><p>我们可以模仿上一道题，写出如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">and</span> root.left == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    root.left.<span class="built_in">next</span> = root.right</span><br><span class="line"></span><br><span class="line">    connect(root.left)</span><br><span class="line">    connect(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>这样其实有很大问题，再看看这张图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220834.jpg" alt=""></p><p>节点 5 和节点 6 不属于同一个父节点，那么按照这段代码的逻辑，它俩就没办法被穿起来，这是不符合题意的。</p><p>回想刚才说的，<strong>二叉树的问题难点在于，如何把题目的要求细化成每个节点需要做的事情</strong>，但是如果只依赖一个节点的话，肯定是没办法连接<code>「跨父节点」</code>的两个相邻节点的。</p><p>那么，我们的做法就是增加函数参数，一个节点做不到，我们就给他安排两个节点，<code>「将每一层二叉树节点连接起来」</code>可以细化成<code>「将每两个相邻节点都连接起来」</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    connectTwoNode(root.left, root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义：输入两个节点，将它俩连接起来</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectTwoNode</span>(<span class="params">Node node1, Node node2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node1 == <span class="literal">None</span> <span class="keyword">and</span> node2 == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">#### 前序遍历位置 ####</span></span><br><span class="line">    <span class="comment"># 将传入的两个节点连接</span></span><br><span class="line">    node1.<span class="built_in">next</span> = node2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接相同父节点的两个子节点</span></span><br><span class="line">    connectTwoNode(node1.left, node1.right)</span><br><span class="line">    connectTwoNode(node2.left, node2.right)</span><br><span class="line">    <span class="comment"># 连接跨越父节点的两个子节点</span></span><br><span class="line">    connectTwoNode(node1.right, node2.left)</span><br></pre></td></tr></table></figure><p>这样，<code>connectTwoNode</code>函数不断递归，可以无死角覆盖整棵二叉树，将所有相邻节点都连接起来，也就避免了我们之前出现的问题，这道题就解决了。</p><h4 id="第三题、将二叉树展开为链表"><a href="#第三题、将二叉树展开为链表" class="headerlink" title="第三题、将二叉树展开为链表"></a>第三题、将二叉树展开为链表</h4><p>这是力扣第 114 题，看下题目：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220851.jpg" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">root</span>):</span></span><br></pre></td></tr></table></figure><p>我们尝试给出这个函数的定义：</p><p><strong>给<code>flatten</code>函数输入一个节点<code>root</code>，那么以<code>root</code>为根的二叉树就会被拉平为一条链表</strong>。</p><p>我们再梳理一下，如何按题目要求把一棵树拉平成一条链表？很简单，以下流程：</p><p>1、将<code>root</code>的左子树和右子树拉平。</p><p>2、将<code>root</code>的右子树接到左子树下方，然后将整个左子树作为右子树。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220915.jpg" alt=""></p><p>上面三步看起来最难的应该是第一步对吧，如何把<code>root</code>的左右子树拉平？其实很简单，按照<code>flatten</code>函数的定义，对<code>root</code>的左右子树递归调用<code>flatten</code>函数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义：将以 root 为根的树拉平为链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    flatten(root.left)</span><br><span class="line">    flatten(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment">##### 后序遍历位置 #####</span></span><br><span class="line">    <span class="comment"># 1、左右子树已经被拉平成一条链表</span></span><br><span class="line">    left = root.left</span><br><span class="line">    right = root.right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、将左子树作为右子树</span></span><br><span class="line">    root.left = <span class="literal">None</span></span><br><span class="line">    root.right = left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3、将原先的右子树接到当前右子树的末端</span></span><br><span class="line">    p = root</span><br><span class="line">    <span class="keyword">while</span> p.right != <span class="literal">None</span>:</span><br><span class="line">        p = p.right</span><br><span class="line">        </span><br><span class="line">    p.right = right</span><br></pre></td></tr></table></figure><p>你看，这就是递归的魅力，你说<code>flatten</code>函数是怎么把左右子树拉平的？不容易说清楚，<strong>但是只要知道<code>flatten</code>的定义如此，相信这个定义，让<code>root</code>做它该做的事情，然后<code>flatten</code>函数就会按照定义工作。</strong></p><p>另外注意递归框架是后序遍历，因为我们要先拉平左右子树才能进行后续操作。</p><p>至此，这道题也解决了，与 <code>[k 个一组反转链表]</code> 的递归思路和本题也有一些类似。</p><blockquote><h3 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h3></blockquote><p>递归算法的关键要明确函数的定义，相信这个定义，而不要跳进递归细节。</p><p>写二叉树的算法题，都是基于递归框架的，我们先要搞清楚<code>root</code>节点它自己要做什么，然后根据题目要求选择使用前序，中序，后续的递归框架。</p><p>二叉树题目的难点在于如何通过题目的要求思考出每一个节点需要做什么，这个只能通过多刷题进行练习了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树之常用框架&quot;&gt;&lt;a href=&quot;#二叉树之常用框架&quot; class=&quot;headerlink&quot; title=&quot;二叉树之常用框架&quot;&gt;&lt;/a&gt;二叉树之常用框架&lt;/h2&gt;&lt;p&gt;读完本文，你可以去力扣拿下：&lt;/p&gt;
&lt;p&gt;226.翻转二叉树，难度 &lt;strong&gt;Eas</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>08-动态规划之详解最长公共子序列系列问题</title>
    <link href="https://xxren8218.github.io/20210628/08-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%AF%A6%E8%A7%A3%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210628/08-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%AF%A6%E8%A7%A3%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98.html</id>
    <published>2021-06-28T14:02:58.000Z</published>
    <updated>2021-06-28T16:46:17.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划之详解最长公共子序列"><a href="#动态规划之详解最长公共子序列" class="headerlink" title="动态规划之详解最长公共子序列"></a>动态规划之详解最长公共子序列</h2><p><strong>本文从「最长公共子序列问题」展开，总结三道子序列问题</strong>，解这道题仔细讲讲这种子序列问题的套路，你就能感受到这种思维方式了。</p><blockquote><h3 id="一、最长公共子序列"><a href="#一、最长公共子序列" class="headerlink" title="一、最长公共子序列"></a>一、最长公共子序列</h3></blockquote><p>计算最长公共子序列（Longest Common Subsequence，简称 LCS）是一道经典的动态规划题目，大家应该都见过：</p><p>给你输入两个字符串<code>s1</code>和<code>s2</code>，请你找出他们俩的最长公共子序列，返回这个子序列的长度。</p><p>力扣第 1143 题就是这道题，函数签名如下：</p><p>计算最长公共子序列（Longest Common Subsequence，简称 LCS）是一道经典的动态规划题目，大家应该都见过：</p><p>给你输入两个字符串<code>s1</code>和<code>s2</code>，请你找出他们俩的最长公共子序列，返回这个子序列的长度。</p><p>力扣第 1143 题就是这道题，函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">s1, s2</span>):</span></span><br></pre></td></tr></table></figure><p>比如说输入<code>s1 = &quot;zabcde&quot;, s2 = &quot;acez&quot;</code>，它俩的最长公共子序列是<code>lcs = &quot;ace&quot;</code>，长度为 3，所以算法返回 3。</p><p>如果没有做过这道题，一个最简单的暴力算法就是，把<code>s1</code>和<code>s2</code>的所有子序列都穷举出来，然后看看有没有公共的，然后在所有公共子序列里面再寻找一个长度最大的。</p><p>显然，这种思路的复杂度非常高，你要穷举出所有子序列，这个复杂度就是指数级的，肯定不实际。</p><p>正确的思路是不要考虑整个字符串，而是细化到<code>s1</code>和<code>s2</code>的每个字符。前文 子序列解题模板 中总结的一个规律：</p><p><strong>对于两个字符串求子序列的问题，都是用两个指针<code>i</code>和<code>j</code>分别在两个字符串上移动，大概率是动态规划思路</strong>。</p><p>最长公共子序列的问题也可以遵循这个规律，我们可以先写一个<code>dp</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line">dp(s1, i, s2, j)</span><br></pre></td></tr></table></figure><p>这个<code>dp</code>函数的定义是：<strong><code>dp(s1, i, s2, j)</code>计算<code>s1[i..]</code>和<code>s2[j..]</code>的最长公共子序列长度</strong>。</p><p>根据这个定义，那么我们想要的答案就是<code>dp(s1, 0, s2, 0)</code>，且 base case 就是<code>i == len(s1)</code>或<code>j == len(s2)</code>时，因为这时候<code>s1[i..]</code>或<code>s2[j..]</code>就相当于空串了，最长公共子序列的长度显然是 0：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">s1, s2</span>):</span> </span><br><span class="line">    <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">s1, i, s2, j</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="built_in">len</span>(s1) <span class="keyword">or</span> j == <span class="built_in">len</span>(s2):</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p><strong>接下来，咱不要看<code>s1</code>和<code>s2</code>两个字符串，而是要具体到每一个字符，思考每个字符该做什么</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220432.jpg" alt=""></p><p>我们只看<code>s1[i]</code>和<code>s2[j]</code>，<strong>如果<code>s1[i] == s2[j]</code>，说明这个字符一定在<code>lcs</code>中</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220447.jpg" alt=""></p><p>这样，就找到了一个<code>lcs</code>中的字符，根据<code>dp</code>函数的定义，我们可以完善一下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">s1, i, s2, j</span>):</span></span><br><span class="line">    <span class="keyword">if</span> si[i] == s2[j]:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 必然在 lcs 中，</span></span><br><span class="line">        <span class="comment"># 加上 s1[i+1..] 和 s2[j+1..] 中的 lcs 长度，就是答案</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>刚才说的<code>s1[i] == s2[j]</code>的情况，但如果<code>s1[i] != s2[j]</code>，应该怎么办呢？</p><p><strong><code>s1[i] != s2[j]</code>意味着，<code>s1[i]</code>和<code>s2[j]</code>中至少有一个字符不在<code>lcs</code>中</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220502.jpg" alt=""></p><p>如上图，总共可能有三种情况，我怎么知道具体是那种情况呢？</p><p>其实我们也不知道，那就把这三种情况的答案都算出来，取其中结果最大的那个呗，因为题目让我们算「最长」公共子序列的长度嘛。</p><p>这三种情况的答案怎么算？回想一下我们的<code>dp</code>函数定义，不就是专门为了计算它们而设计的嘛！</p><p>代码可以再进一步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">s1, i, s2, j</span>):</span></span><br><span class="line">    <span class="keyword">if</span> si[i] == s2[j]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 中至少有一个字符不在 lcs 中，</span></span><br><span class="line">        <span class="comment"># 穷举三种情况的结果，取其中的最大结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(</span><br><span class="line">                    <span class="comment"># 情况一、s1[i] 不在 lcs 中</span></span><br><span class="line">                    dp(s1, i + <span class="number">1</span>, s2, j),</span><br><span class="line">                    <span class="comment"># 情况二、s2[j] 不在 lcs 中</span></span><br><span class="line">                    dp(s1, i, s2, j + <span class="number">1</span>),</span><br><span class="line">                    <span class="comment"># 情况三、都不在 lcs 中</span></span><br><span class="line">                    dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">          )</span><br></pre></td></tr></table></figure><p>这里就已经非常接近我们的最终答案了，<strong>还有一个小的优化，情况三「<code>s1[i]</code>和<code>s2[j]</code>都不在 lcs 中」其实可以直接忽略</strong>。</p><p>因为我们在求最大值嘛，情况三在计算<code>s1[i+1..]</code>和<code>s2[j+1..]</code>的<code>lcs</code>长度，这个长度肯定是小于等于情况二<code>s1[i..]</code>和<code>s2[j+1..]</code>中的<code>lcs</code>长度的，因为<code>s1[i+1..]</code>比<code>s1[i..]</code>短嘛，那从这里面算出的<code>lcs</code>当然也不可能更长嘛。</p><p>同理，情况三的结果肯定也小于等于情况一。<strong>说白了，情况三被情况一和情况二包含了</strong>，所以我们可以直接忽略掉情况三，完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">s1, s2</span>):</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">    <span class="comment"># 备忘录值为 -1 代表未曾计算</span></span><br><span class="line">    memo = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]  </span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 计算 s1[0..] 和 s2[0..] 的 lcs 长度</span></span><br><span class="line">    <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">s1, i, s2, j</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(s1) <span class="keyword">or</span> j == <span class="built_in">len</span>(s2):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 如果之前计算过，则直接返回备忘录中的答案</span></span><br><span class="line">    <span class="keyword">if</span> memo[i][j] != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> memo[i][j]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据 s1[i] 和 s2[j] 的情况做选择</span></span><br><span class="line">    <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 必然在 lcs 中</span></span><br><span class="line">        memo[i][j] = <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 至少有一个不在 lcs 中</span></span><br><span class="line">        memo[i][j] = <span class="built_in">max</span>(</span><br><span class="line">            dp(s1, i + <span class="number">1</span>, s2, j),</span><br><span class="line">            dp(s1, i, s2, j + <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> memo[i][j]</span><br></pre></td></tr></table></figure><p>以上思路完全就是按照我们之前的 <code>动态规划详解</code> 的框架来的，应该是很容易理解的。至于为什么要加<code>memo</code>备忘录，，这里再简单重复一下，首先抽象出我们核心<code>dp</code>函数的递归框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> j</span>):</span></span><br><span class="line">    dp(i + <span class="number">1</span>, j + <span class="number">1</span>)   <span class="comment">#1</span></span><br><span class="line">    dp(i, j + <span class="number">1</span>)       <span class="comment">#2</span></span><br><span class="line">    dp(i + <span class="number">1</span>, j)       <span class="comment">#3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你看，假设我想从<code>dp(i, j)</code>转移到<code>dp(i+1, j+1)</code>，有不止一种方式，可以直接走<code>#1</code>，也可以走<code>#2 -&gt; #3</code>，也可以走<code>#3 -&gt; #2</code>。</p><p>这就是重叠子问题，如果我们不用<code>memo</code>备忘录消除子问题，那么<code>dp(i+1, j+1)</code>就会被多次计算，这是没有必要的。</p><p>至此，最长公共子序列问题就完全解决了，用的是自顶向下带备忘录的动态规划思路。</p><p>下面，来看两道和最长公共子序列相似的两道题目。</p><blockquote><h3 id="二、字符串的删除操作"><a href="#二、字符串的删除操作" class="headerlink" title="二、字符串的删除操作"></a>二、字符串的删除操作</h3></blockquote><p>这是力扣第 583 题「两个字符串的删除操作」，看下题目：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629004432.jpg" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">s1, s2</span>):</span></span><br></pre></td></tr></table></figure><p>题目让我们计算将两个字符串变得相同的最少删除次数，那我们可以思考一下，最后这两个字符串会被删成什么样子？</p><p>删除的结果不就是它俩的最长公共子序列嘛！</p><p>那么，要计算删除的次数，就可以通过最长公共子序列的长度推导出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">s1, s2</span>):</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">    <span class="comment"># 复用前文计算 lcs 长度的函数</span></span><br><span class="line">    lcs = longestCommonSubsequence(s1, s2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> m - lcs + n - lcs;</span><br></pre></td></tr></table></figure><p><strong>完整代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.memo = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, s1, s2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">        <span class="comment"># 备忘录值为 -1 代表未曾计算</span></span><br><span class="line">        self.memo = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]  </span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 计算 s1[0..] 和 s2[0..] 的 lcs 长度</span></span><br><span class="line">        lcs = self.dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> m - lcs + n - lcs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">self, s1, i, s2, j</span>):</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(s1) <span class="keyword">or</span> j == <span class="built_in">len</span>(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 如果之前计算过，则直接返回备忘录中的答案</span></span><br><span class="line">        <span class="keyword">if</span> self.memo[i][j] != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.memo[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据 s1[i] 和 s2[j] 的情况做选择</span></span><br><span class="line">        <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">            <span class="comment"># s1[i] 和 s2[j] 必然在 lcs 中</span></span><br><span class="line">            self.memo[i][j] = <span class="number">1</span> + self.dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># s1[i] 和 s2[j] 至少有一个不在 lcs 中</span></span><br><span class="line">            self.memo[i][j] = <span class="built_in">max</span>(</span><br><span class="line">                            self.dp(s1, i + <span class="number">1</span>, s2, j),</span><br><span class="line">                            self.dp(s1, i, s2, j + <span class="number">1</span>)</span><br><span class="line">                            )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.memo[i][j]</span><br></pre></td></tr></table></figure><p>这道题就解决了！</p><blockquote><h3 id="三、最小-ASCII-删除和"><a href="#三、最小-ASCII-删除和" class="headerlink" title="三、最小 ASCII 删除和"></a>三、最小 ASCII 删除和</h3></blockquote><p>这是力扣第 712 题，看下题目：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629004602.jpg" alt=""></p><p>这道题，和上一道题非常类似，这回不问我们删除的字符个数了，问我们删除的字符的 ASCII 码加起来是多少。</p><p>那就不能直接复用计算最长公共子序列的函数了，但是可以依照之前的思路，<strong>稍微修改 base case 和状态转移部分即可直接写出解法代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumDeleteSum</span>(<span class="params">s1, s2</span>):</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">    <span class="comment"># 备忘录值为 -1 代表未曾计算</span></span><br><span class="line">memo = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，</span></span><br><span class="line"><span class="comment"># 最小的 ASCII 码之和为 dp(s1, i, s2, j)。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">s1, i, s2, j</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(s1):</span><br><span class="line">        <span class="comment"># 如果 s1 到头了，那么 s2 剩下的都得删除</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(s2)):</span><br><span class="line">            res += <span class="built_in">ord</span>(s2[j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> j == <span class="built_in">len</span>(s2):</span><br><span class="line">        <span class="comment"># 如果 s2 到头了，那么 s1 剩下的都得删除</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(s1)):</span><br><span class="line">            res += <span class="built_in">ord</span>(s1[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> memo[i][j] != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> memo[i][j]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 都是在 lcs 中的，不用删除</span></span><br><span class="line">        memo[i][j] = dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个</span></span><br><span class="line">        memo[i][j] = <span class="built_in">min</span>(</span><br><span class="line">            <span class="built_in">ord</span>(s1[i]) + dp(s1, i + <span class="number">1</span>, s2, j),</span><br><span class="line">            <span class="built_in">ord</span>(s2[j]) + dp(s1, i, s2, j + <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> memo[i][j]</span><br></pre></td></tr></table></figure><p>base case 有一定区别，计算<code>lcs</code>长度时，如果一个字符串为空，那么<code>lcs</code>长度必然是 0；但是这道题如果一个字符串为空，另一个字符串必然要被全部删除，所以需要计算另一个字符串所有字符的 ASCII 码之和。</p><p>关于状态转移，当<code>s1[i]</code>和<code>s2[j]</code>相同时不需要删除，不同时需要删除，所以可以利用<code>dp</code>函数计算两种情况，得出最优的结果。其他的大同小异，就不具体展开了。</p><p>也可以这样：思路一样：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220518.PNG" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumDeleteSum</span>(<span class="params">self, s1, s2</span>):</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (<span class="built_in">len</span>(s2) + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1) + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确定table的初始条件。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="built_in">len</span>(s2)] = dp[i+<span class="number">1</span>][<span class="built_in">len</span>(s2)] + <span class="built_in">ord</span>(s1[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[<span class="built_in">len</span>(s1)][j] = dp[<span class="built_in">len</span>(s1)][j+<span class="number">1</span>] + <span class="built_in">ord</span>(s2[j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j] + <span class="built_in">ord</span>(s1[i]),</span><br><span class="line">                                   dp[i][j+<span class="number">1</span>] + <span class="built_in">ord</span>(s2[j]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>至此，三道子序列问题就解决完了，关键在于将问题细化到字符，根据每两个字符是否相同来判断他们是否在结果子序列中，从而避免了对所有子序列进行穷举。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;动态规划之详解最长公共子序列&quot;&gt;&lt;a href=&quot;#动态规划之详解最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;动态规划之详解最长公共子序列&quot;&gt;&lt;/a&gt;动态规划之详解最长公共子序列&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文从「最长公共子序列问题」</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>00-二叉树的深度遍历——递归&amp;迭代</title>
    <link href="https://xxren8218.github.io/20210627/00-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3.html"/>
    <id>https://xxren8218.github.io/20210627/00-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3.html</id>
    <published>2021-06-27T06:22:25.000Z</published>
    <updated>2021-06-30T12:32:04.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的深度遍历——递归-amp-迭代"><a href="#二叉树的深度遍历——递归-amp-迭代" class="headerlink" title="二叉树的深度遍历——递归&amp;迭代"></a>二叉树的深度遍历——递归&amp;迭代</h2><p>读完本文，你可以去力扣拿下：</p><p>144.二叉树的前序遍历：难度  <strong>Easy</strong></p><p>145.二叉树的后序遍历：难度 <strong>Easy</strong></p><p>94.二叉树的中序遍历 ：难度 <strong>Easy</strong></p><p>本文所讲的是：二叉树的深度遍历逻辑。一般分为递归版本和非递归的版本。说到递归，很多人不禁会想到一个词：<strong>‘谈归色变’</strong>，不知道进去后怎么处理。甚至不知道怎么进去的。递归其实没那么困难。这里介绍递归三部曲：</p><ul><li>确定递归的参数和返回值——参数一般<code>头结点指针（cur）</code>,<code>返回值一般为列表</code></li><li>确定递归终止条件——if cur == None: return</li><li>单层递归的逻辑<ul><li>前序：中左右<ul><li>中：res.append(cur.val)</li><li>左：traversal(cur.left)</li><li>右：traversal(cur.right)</li></ul></li><li>后序：左右中<ul><li>左：traversal(cur.left)</li><li>右：traversal(cur.right)</li><li>中：res.append(cur.val)</li></ul></li><li>中序：左中右<ul><li>左：traversal(cur.left)</li><li>中：res.append(cur.val)</li><li>右：traversal(cur.right)</li></ul></li></ul></li></ul><blockquote><h3 id="1-二叉树的遍历（递归法）"><a href="#1-二叉树的遍历（递归法）" class="headerlink" title="1.二叉树的遍历（递归法）"></a>1.二叉树的遍历（递归法）</h3></blockquote><h4 id="1-1-二叉树的前序遍历"><a href="#1-1-二叉树的前序遍历" class="headerlink" title="1.1 二叉树的前序遍历"></a>1.1 二叉树的前序遍历</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630202346.PNG" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br></pre></td></tr></table></figure><p>首先我们需要了解什么是二叉树的前序遍历：按照访问根节点——左子树——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。</p><p>递归的解题思路很简单，这里直接写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">prev</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">            res.append(root.val)</span><br><span class="line">            prev(root.left)</span><br><span class="line">            prev(root.right)</span><br><span class="line"></span><br><span class="line">        prev(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="1-2-二叉树的后序遍历"><a href="#1-2-二叉树的后序遍历" class="headerlink" title="1.2 二叉树的后序遍历"></a>1.2 二叉树的后序遍历</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630202402.PNG" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br></pre></td></tr></table></figure><p>按照我们前面的框架直接可以写出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">            postorder(root.left)</span><br><span class="line">            postorder(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        </span><br><span class="line">        postorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="1-3-二叉树的中序遍历"><a href="#1-3-二叉树的中序遍历" class="headerlink" title="1.3 二叉树的中序遍历"></a>1.3 二叉树的中序遍历</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630202415.PNG" alt=""></p><p>按照我们前面的框架直接可以写出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line"></span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><h3 id="2-二叉树的遍历（迭代法）"><a href="#2-二叉树的遍历（迭代法）" class="headerlink" title="2. 二叉树的遍历（迭代法）"></a>2. 二叉树的遍历（迭代法）</h3></blockquote><p>我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来。</p><p>因为函数本身调用就是基于栈实现的，原则上所有的递归都可以用栈来实现。所以这里用栈来实现。</p><h4 id="2-1-二叉树的前序遍历"><a href="#2-1-二叉树的前序遍历" class="headerlink" title="2.1 二叉树的前序遍历"></a>2.1 二叉树的前序遍历</h4><p>我们先看⼀下前序遍历。<br>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放⼊栈中，然后将右孩⼦加⼊栈，再加<br>⼊左孩⼦。<br>为什么要先加⼊ 右孩⼦，再加⼊左孩⼦呢？ 因为这样出栈的时候才是中左右的顺序。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630202431.gif" alt=""></p><p>不难写出如下代码: （注意代码中空节点不⼊栈）  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span>[]</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="comment"># 从栈中弹出node节点</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断node节点是否为空</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">            <span class="comment"># 若不为空，将node节点的值加入结果res列表中</span></span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 若为空，结束本次循环（他没有左右孩子）</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将右左孩子分别添加进stack中，因为是栈,所以先处理的是左</span></span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="2-2-二叉树的后序遍历"><a href="#2-2-二叉树的后序遍历" class="headerlink" title="2.2 二叉树的后序遍历"></a>2.2 二叉树的后序遍历</h4><p>对于后序遍历而言，我们很容易看出来。</p><ul><li>前序遍历为： <strong>中左右</strong></li><li>后序遍历为：<strong>左右中</strong></li></ul><p>发现他们的特点，我们可以执行这样的操作：将前序遍历的左右调换，成为<strong>中右左</strong>了，然后调用切片反转就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span>[]</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            stack.append(node.left)    <span class="comment">## 注意</span></span><br><span class="line">            stack.append(node.right)   <span class="comment">## 注意</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]  <span class="comment">## 注意  </span></span><br></pre></td></tr></table></figure><h4 id="2-3-二叉树的中序遍历"><a href="#2-3-二叉树的中序遍历" class="headerlink" title="2.3 二叉树的中序遍历"></a>2.3 二叉树的中序遍历</h4><p>此时是不是想改⼀点前序遍历代码顺序就把中序遍历搞出来了？<strong>其实还真不⾏！</strong><br>但接下来， 再⽤迭代法写中序遍历的时候，会发现套路⼜不⼀样了，⽬前的前序遍历的逻辑⽆法直接应<br>⽤到中序遍历上。  </p><p>为了解释清楚，我说明⼀下 刚刚在迭代的过程中，其实我们有两个操作：</p><ol><li>处理：将元素放进result数组中</li><li>访问：遍历节点</li></ol><p>分析⼀下为什么刚刚写的前序遍历的代码，不能和中序遍历通⽤呢，因为前序遍历的顺序是中左右，先<br>访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码， <strong>因为要访问<br>的元素和要处理的元素顺序是⼀致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是⼆叉树顶部的节点，然后⼀层⼀层向下访问，直<br>到到达树左⾯的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理<br>顺序和访问顺序是不⼀致的。  </strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><p>动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630202638.gif" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当指针为空，且栈为空时停止</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="comment"># 若当前指针不为空，将当前访问元素加到栈内。</span></span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                <span class="comment"># 指针继续左走（左中右）,一路向左</span></span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment"># 若zcur为空，说明到达最左边了.</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 此时弹出栈顶元素——最左边的节点</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 遍历当前指针的右孩子</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>至此！迭代遍历的三种方法也已经得出了！</p><blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3></blockquote><p>我们用普通的递归的方法来实现二叉树的前序、后序和中序遍历。还用迭代的方式实现三种遍历方法。其实二叉树不仅仅有深度优先遍历（DFS）还有一种遍历方式：广度优先遍历（BFS）。后面我们会开始BFS的探索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树的深度遍历——递归-amp-迭代&quot;&gt;&lt;a href=&quot;#二叉树的深度遍历——递归-amp-迭代&quot; class=&quot;headerlink&quot; title=&quot;二叉树的深度遍历——递归&amp;amp;迭代&quot;&gt;&lt;/a&gt;二叉树的深度遍历——递归&amp;amp;迭代&lt;/h2&gt;&lt;p&gt;读完</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>23-大数据产品与互联网产品结合</title>
    <link href="https://xxren8218.github.io/20210626/23-%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BA%A7%E5%93%81%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81%E7%BB%93%E5%90%88.html"/>
    <id>https://xxren8218.github.io/20210626/23-%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BA%A7%E5%93%81%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81%E7%BB%93%E5%90%88.html</id>
    <published>2021-06-25T16:53:04.000Z</published>
    <updated>2021-06-25T16:56:01.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-大数据产品与互联网产品结合"><a href="#1-大数据产品与互联网产品结合" class="headerlink" title="1. 大数据产品与互联网产品结合"></a>1. 大数据产品与互联网产品结合</h3><ul><li>分布式系统执行任务瓶颈: 延迟高 MapReduce 几分钟 Spark几秒钟</li><li>互联网产品要求<ul><li>毫秒级响应(1秒以内完成)</li><li>需要通过大数据实现 统计分析 数据挖掘 关联推荐 用户画像</li></ul></li><li>如何将他们结合起来?</li><li>大数据平台<ul><li>整合网站应用和大数据系统之间的差异, 将应用产生的数据导入到大数据系统, 经过处理计算后再导出给应用程序使用</li></ul></li><li>互联网大数据平台架构:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626005416.png" alt=""></p><ul><li>数据采集<ul><li>App/Web 产生的数据&amp;日志同步到大数据系统</li><li>数据库同步:Sqoop  日志同步:Flume 打点: Kafka</li><li>不同数据源产生的数据质量可能差别很大<ul><li>数据库 也许可以直接用</li><li>日志 爬虫 大量的清洗,转化处理 ETL</li></ul></li></ul></li><li><p>数据处理</p><ul><li>大数据存储与计算的核心</li><li>数据同步后导入HDFS</li><li>MapReduce Hive Spark 读取数据进行计算 结果再保存到HDFS</li><li>MapReduce Hive Spark 离线计算, HDFS 离线存储<ul><li>离线计算通常针对(某一类别)全体数据, 比如 历史上所有订单</li><li>离线计算特点: 数据规模大, 运行时间长</li></ul></li><li>流式计算<ul><li>淘宝双11 每秒产生订单数 监控宣传</li><li>Storm(毫秒) SparkStreaming(秒)</li></ul></li></ul></li><li><p>数据输出与展示</p><ul><li>HDFS需要把数据导出交给应用程序, 让用户实时展示  ECharts<ul><li>淘宝卖家量子魔方</li></ul></li><li>给运营和决策层提供各种统计报告, 数据需要写入数据库<ul><li>很多运营管理人员, 上班后就会登陆后台数据系统</li></ul></li></ul></li><li>任务调度系统<ul><li>将上面三个部分整合起来</li></ul></li></ul><h3 id="2-大数据应用—数据分析"><a href="#2-大数据应用—数据分析" class="headerlink" title="2. 大数据应用—数据分析"></a>2. 大数据应用—数据分析</h3><ul><li><p>通过数据分析指标监控企业运营状态, 及时调整运营和产品策略,是大数据技术的关键价值之一</p></li><li><p>大数据平台(互联网企业)运行的绝大多数大数据计算都是关于数据分析的</p><ul><li>统计指标</li><li>关联分析,</li><li>汇总报告,</li></ul></li><li><p>运营数据是公司管理的基础</p><ul><li>了解公司目前发展的状况</li><li>数据驱动运营: 调节指标对公司进行管理</li></ul></li><li><p>运营数据的获取需要大数据平台的支持</p><ul><li>埋点采集数据</li><li>数据库,日志 三方采集数据</li><li>对数据清洗 转换 存储 </li><li>利用SQL进行数据统计 汇总 分析</li><li>得到需要的运营数据报告</li></ul></li><li><p>运营常用数据指标</p><ul><li><p>新增用户数  UG  user growth 用户增长</p><ul><li>产品增长性的关键指标</li><li>新增访问网站(新下载APP)的用户数</li></ul></li><li><p>用户留存率</p><ul><li>用户留存率 = 留存用户数 / 当期新增用户数</li><li>3日留存  5日留存 7日留存</li></ul></li><li><p>活跃用户数</p><ul><li>打开使用产品的用户</li><li>日活</li><li>月活</li><li>提升活跃是网站运营的重要目标</li></ul></li><li><p>PV Page View</p><ul><li>打开产品就算活跃</li><li>打开以后是否频繁操作就用PV衡量, 每次点击, 页面跳转都记一次PV</li></ul></li><li><p>GMV</p><ul><li>成交总金额(Gross Merchandise Volume) 电商网站统计营业额, 反应网站营收能力的重要指标</li><li>GMV相关的指标: 订单量 客单价</li></ul></li><li><p>转化率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转化率 = 有购买行为的用户数 / 总访问用户数</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-数据分析案例"><a href="#3-数据分析案例" class="headerlink" title="3. 数据分析案例"></a>3. 数据分析案例</h3><ul><li><p>背景: 某电商网站, 垂直领域领头羊, 各项指标相对稳定</p></li><li><p>运营人员发现从 8 月 15 日开始，网站的订单量连续四天明显下跌</p></li><li><p>8 月 18 号早晨发现 8 月 17 号的订单量没有恢复正常，运营人员开始尝试寻找原因</p><ul><li>是否有负面报道被扩散</li><li>是否竞争对手在做活动</li><li>是否某类商品缺货</li><li>价格异常</li></ul></li><li><p>没有找到原因, 将问题交给数据分析团队</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626005454.png" alt=""></p></li><li><p>数据分析师分析可能性</p><ul><li>新增用户出现问题</li><li>查看日活数据, 发现日活没有明显下降<ul><li>基本判断, 用户在访问网站的过程中,转化出了问题</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626005512.png" alt=""></p></li><li><p>转化过程:</p><ul><li>打开APP</li><li>搜索关键词 浏览搜索结果列表</li><li>点击商品访问详情</li><li>有购买意向开始咨询</li><li>放入购物车</li><li>支付</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626005536.png" alt=""></p></li><li><p>订单活跃转化率 = 日订单量 / 打开用户数</p></li><li><p>搜索打开转化率 = 搜索用户数 / 打开用户数</p></li><li><p>有明显降幅的是咨询详情转化率</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626005548.png" alt=""></p><ul><li>对咨询信息分类统计后发现，新用户的咨询量几乎为 0</li><li>于是将问题提交给技术部门调查，工程师查看 8 月 15 日当天发布记录,发现有消息队列SDK更新</li></ul></li></ul><p><strong>Hadoop企业应用案例之消费大数据</strong></p><p>亚马逊提前发货系统</p><p><strong>Hadoop企业案例之商业零售大数据</strong></p><p>智能推荐</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-大数据产品与互联网产品结合&quot;&gt;&lt;a href=&quot;#1-大数据产品与互联网产品结合&quot; class=&quot;headerlink&quot; title=&quot;1. 大数据产品与互联网产品结合&quot;&gt;&lt;/a&gt;1. 大数据产品与互联网产品结合&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;分布式系统执行任务瓶</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>22-hadoop概念扩展——生态与HDFS的读写等</title>
    <link href="https://xxren8218.github.io/20210626/22-hadoop%E6%A6%82%E5%BF%B5%E6%89%A9%E5%B1%95%E2%80%94%E2%80%94%E7%94%9F%E6%80%81%E4%B8%8EHDFS%E7%9A%84%E8%AF%BB%E5%86%99%E7%AD%89.html"/>
    <id>https://xxren8218.github.io/20210626/22-hadoop%E6%A6%82%E5%BF%B5%E6%89%A9%E5%B1%95%E2%80%94%E2%80%94%E7%94%9F%E6%80%81%E4%B8%8EHDFS%E7%9A%84%E8%AF%BB%E5%86%99%E7%AD%89.html</id>
    <published>2021-06-25T16:43:34.000Z</published>
    <updated>2021-06-25T16:49:17.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hadoop概念扩展"><a href="#hadoop概念扩展" class="headerlink" title="hadoop概念扩展"></a>hadoop概念扩展</h2><p>课程目标：</p><ul><li>知道hadoop生态组成</li><li>了解hdfs读写流程</li><li>说出Hadoop发行版本的选择</li></ul><h3 id="1-Hadoop生态系统"><a href="#1-Hadoop生态系统" class="headerlink" title="1. Hadoop生态系统"></a>1. Hadoop生态系统</h3><p><strong>狭义的Hadoop VS 广义的Hadoop</strong></p><ul><li><p>狭义的Hadoop:HDFS、MapReduce、YARN。</p></li><li><p>广义的Hadoop：指的是Hadoop生态系统，Hadoop生态系统是一个很庞大的概念，hadoop是其中最重要最基础的一个部分，生态系统中每一子系统只解决某一个特定的问题域（甚至可能更窄），不搞统一型的全能系统，而是小而精的多个小系统；</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004500.png" alt=""></p><p>Hive:数据仓库——操作MapReuce来操作HDFS（我们的感觉是写SQL，Hive将SQL写成MapReduce的方式。）</p><p>R:数据分析</p><p>Mahout:机器学习库</p><p>pig：脚本语言，跟Hive类似</p><p>Oozie:工作流引擎，管理作业执行顺序</p><p>Zookeeper:用户无感知，主节点挂掉选择从节点作为主的。分布式集群协调工具。数据改变的同步。</p><p>Flume:日志收集框架——将特定目录日志放到HDFS中去。</p><p>Sqoop:数据交换框架，例如：关系型数据库（MySQL、Oracle）与HDFSorHBase之间的数据交换介质。</p><p>Hbase : ——<code>列式存储</code>（MySQL为<code>行式存储</code>——连续存放）海量数据中的查询，相当于分布式文件系统中的数据库</p><p>Spark: 分布式的计算框架基于内存 ——有python的API：pyspark scala写的（java的虚拟机语言）</p><ul><li>spark core——对应MapReduce</li><li>spark sql——对应Hive</li><li>spark streaming 准实时 不算是一个标准的流式计算 对应——storm flink</li><li>spark ML spark MLlib 机器学习的库</li></ul><p>Kafka: 消息队列</p><p>Storm: 分布式的流式计算框架  不适合用python操作storm </p><p>Flink: 分布式的流式计算框架</p><p><strong>Hadoop生态系统的特点</strong></p><ul><li><p>开源、社区活跃</p></li><li><p>囊括了大数据处理的方方面面</p></li><li>成熟的生态圈</li></ul><h3 id="2-HDFS-读写流程-amp-高可用"><a href="#2-HDFS-读写流程-amp-高可用" class="headerlink" title="2. HDFS 读写流程 &amp; 高可用"></a>2. HDFS 读写流程 &amp; 高可用</h3><ul><li><p>HDFS读写流程</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004557.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004627.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004645.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004701.jpg" alt=""></p><ul><li><p>客户端向NameNode发出写文件请求。</p></li><li><p>检查是否已存在文件、检查权限。若通过检查，直接先将操作写入EditLog，并返回输出流对象。<br>（注：WAL，write ahead log，先写Log，再写内存，因为EditLog记录的是最新的HDFS客户端执行所有的写操作。如果后续真实写操作失败了，由于在真实写操作之前，操作就被写入EditLog中了，故EditLog中仍会有记录，我们不用担心后续client读不到相应的数据块，因为在第5步中DataNode收到块后会有一返回确认信息，若没写成功，发送端没收到确认信息，会一直重试，直到成功）</p></li><li><p>client端按128MB的块切分文件。</p></li><li><p>client将NameNode返回的分配的可写的DataNode列表和Data数据一同发送给最近的第一个DataNode节点，此后client端和NameNode分配的多个DataNode构成pipeline管道，client端向输出流对象中写数据。client每向第一个DataNode写入一个packet，这个packet便会直接在pipeline里传给第二个、第三个…DataNode。<br>（注：并不是写好一个块或一整个文件后才向后分发）</p></li><li><p>每个DataNode写完一个块后，会返回确认信息。<br>（注：并不是每写完一个packet后就返回确认信息，个人觉得因为packet中的每个chunk都携带校验信息，没必要每写一个就汇报一下，这样效率太慢。正确的做法是写完一个block块后，对校验信息进行汇总分析，就能得出是否有块写错的情况发生）</p></li><li><p>写完数据，关闭输输出流。</p></li><li><p>发送完成信号给NameNode。</p><p>（注：发送完成信号的时机取决于集群是强一致性还是最终一致性，强一致性则需要所有DataNode写完后才向NameNode汇报。最终一致性则其中任意一个DataNode写完后就能单独向NameNode汇报，HDFS一般情况下都是强调强一致性） </p></li></ul></li><li><p>HDFS如何实现高可用(HA)</p><ul><li>数据存储故障容错<ul><li>磁盘介质在存储过程中受环境或者老化影响,数据可能错乱</li><li>对于存储在 DataNode 上的数据块，计算并存储校验和（CheckSum)</li><li>读取数据的时候, 重新计算读取出来的数据校验和, 校验不正确抛出异常, 从其它DataNode上读取备份数据</li></ul></li><li>磁盘故障容错<ul><li>DataNode 监测到本机的某块磁盘损坏</li><li>将该块磁盘上存储的所有 BlockID 报告给 NameNode</li><li>NameNode 检查这些数据块在哪些DataNode上有备份,</li><li>通知相应DataNode, 将数据复制到其他服务器上</li></ul></li><li>DataNode故障容错<ul><li>通过心跳和NameNode保持通讯</li><li>超时未发送心跳, NameNode会认为这个DataNode已经宕机</li><li>NameNode查找这个DataNode上有哪些数据块, 以及这些数据在其它DataNode服务器上的存储情况</li><li>从其它DataNode服务器上复制数据</li></ul></li><li>NameNode故障容错<ul><li>主从热备： 必须通过zookeeper  secondary namenode，对namenode数据的备份</li><li>zookeeper配合： ①master节点选举， ②负责数据一致性的保证。（namenode变化，其余保证也要变化。）</li></ul></li></ul></li></ul><h3 id="3-Hadoop发行版的选择"><a href="#3-Hadoop发行版的选择" class="headerlink" title="3. Hadoop发行版的选择"></a>3. Hadoop发行版的选择</h3><ul><li><p>Apache Hadoop</p><ul><li>开源社区版</li><li>最新的Hadoop版本都是从Apache Hadoop发布的</li><li>Hadoop Hive Flume  版本不兼容的问题 jar包  spark scala  Java-&gt;.class-&gt;.jar -&gt;JVM</li></ul></li><li><p>CDH: Cloudera Distributed Hadoop</p><ul><li><p>Cloudera 在社区版的基础上做了一些修改</p></li><li><p><a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004732.png" alt=""></p></li><li><p>hadoop-2.6.0-cdh-5.7.0 和 Flume<strong>*</strong>-cdh5.7.0 cdh版本一致 的各个组件配合是有不会有兼容性问题</p></li><li><p>CDH版本的这些组件 没有全部开源</p></li></ul></li><li><p>HDP: Hortonworks Data Platform</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hadoop概念扩展&quot;&gt;&lt;a href=&quot;#hadoop概念扩展&quot; class=&quot;headerlink&quot; title=&quot;hadoop概念扩展&quot;&gt;&lt;/a&gt;hadoop概念扩展&lt;/h2&gt;&lt;p&gt;课程目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;知道hadoop生态组成&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>07-动态规划之子序列解题模板——最长回文子序列</title>
    <link href="https://xxren8218.github.io/20210626/07-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E8%A7%A3%E9%A2%98%E6%A8%A1%E6%9D%BF%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210626/07-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E8%A7%A3%E9%A2%98%E6%A8%A1%E6%9D%BF%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2021-06-25T16:38:51.000Z</published>
    <updated>2021-06-25T16:41:54.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子序列解题模板：最长回文子序列"><a href="#子序列解题模板：最长回文子序列" class="headerlink" title="子序列解题模板：最长回文子序列"></a>子序列解题模板：最长回文子序列</h2><p>子序列问题是常见的算法问题，而且并不好解决。</p><p>首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举都不容易，更别说求解相关的算法问题了。</p><p>而且，子序列问题很可能涉及到两个字符串，比如让你求两个字符串的 [最长公共子序列]，如果没有一定的处理经验，真的不容易想出来。所以本文就来扒一扒子序列问题的套路，<strong>其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。</strong></p><p>一般来说，这类问题都是让你求一个<strong>最长</strong>子序列，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，<strong>考察的是动态规划技巧，时间复杂度一般都是 O(n^2)</strong>。</p><p>原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着呢？</p><p>既然要用动态规划，那就要定义 dp 数组，找状态转移关系。我们说的两种思路模板，就是 dp 数组的定义思路。不同的问题可能需要不同的 dp 数组定义来解决。</p><blockquote><h3 id="一、两种思路"><a href="#一、两种思路" class="headerlink" title="一、两种思路"></a>一、两种思路</h3></blockquote><h4 id="1、第一种思路模板是一个一维的-dp-数组："><a href="#1、第一种思路模板是一个一维的-dp-数组：" class="headerlink" title="1、第一种思路模板是一个一维的 dp 数组："></a>1、第一种思路模板是一个一维的 dp 数组：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(s1 + <span class="number">1</span>)</span><br><span class="line">dp = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        dp[i] = 最值(dp[i], dp[j] + ...)</span><br></pre></td></tr></table></figure><p>举个我们写过的例子 [最长递增子序列]，在这个思路中 dp 数组的定义是：</p><p><strong>在子数组<code>array[0..i]</code>中，以<code>array[i]</code>结尾的目标子序列（最长递增子序列）的长度是<code>dp[i]</code></strong>。</p><p>为啥最长递增子序列需要这种思路呢？前文说得很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。</p><h4 id="2、第二种思路模板是一个二维的-dp-数组："><a href="#2、第二种思路模板是一个二维的-dp-数组：" class="headerlink" title="2、第二种思路模板是一个二维的 dp 数组："></a>2、第二种思路模板是一个二维的 dp 数组：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(s1 + <span class="number">1</span>)</span><br><span class="line">dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) </span><br><span class="line">            dp[i][j] = dp[i][j] + ...</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = 最值(...)</span><br></pre></td></tr></table></figure><p>这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列。本思路中 dp 数组含义又分为「只涉及一个字符串」和「涉及两个字符串」两种情况。</p><ul><li><p><strong>涉及两个字符串/数组时</strong>（比如最长公共子序列），dp 数组的含义如下：</p><ul><li><strong>在子数组<code>arr1[0..i]</code>和子数组<code>arr2[0..j]</code>中，我们要求的子序列（最长公共子序列）长度为<code>dp[i][j]</code></strong>。</li></ul></li><li><p><strong>只涉及一个字符串/数组时</strong>（比如本文要讲的最长回文子序列），dp 数组的含义如下：</p><ul><li><strong>在子数组<code>array[i..j]</code>中，我们要求的子序列（最长回文子序列）的长度为<code>dp[i][j]</code></strong>。</li></ul></li></ul><p>下面就借最长回文子序列这个问题，详解一下第二种情况下如何使用动态规划。</p><blockquote><h3 id="二、最长回文子序列"><a href="#二、最长回文子序列" class="headerlink" title="二、最长回文子序列"></a>二、最长回文子序列</h3></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004011.jpg" alt=""></p><p>我们说这个问题对 dp 数组的定义是：<strong>在子串<code>s[i..j]</code>中，最长回文子序列的长度为<code>dp[i][j]</code></strong>。一定要记住这个定义才能理解算法。</p><p>为啥这个问题要这样定义二维的 dp 数组呢？我们前文多次提到，<strong>找状态转移需要归纳思维，说白了就是如何从已知的结果推出未知的部分</strong>，这样定义容易归纳，容易发现状态转移关系。</p><p>具体来说，如果我们想求<code>dp[i][j]</code>，假设你知道了子问题<code>dp[i+1][j-1]</code>的结果（<code>s[i+1..j-1]</code>中最长回文子序列的长度），你是否能想办法算出<code>dp[i][j]</code>的值（<code>s[i..j]</code>中，最长回文子序列的长度）呢？</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004027.jpg" alt=""></p><p>可以！<strong>这取决于<code>s[i]</code>和<code>s[j]</code>的字符</strong>：</p><p><strong>如果它俩相等</strong>，那么它俩加上<code>s[i+1..j-1]</code>中的最长回文子序列就是<code>s[i..j]</code>的最长回文子序列：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004040.jpg" alt=""></p><p><strong>如果它俩不相等</strong>，说明它俩<strong>不可能同时</strong>出现在<code>s[i..j]</code>的最长回文子序列中，那么把它俩<strong>分别</strong>加入<code>s[i+1..j-1]</code>中，看看哪个子串产生的回文子序列更长即可：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004113.jpg" alt=""></p><p>以上两种情况写成代码就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">    <span class="comment"># 它俩一定在最长回文子序列中</span></span><br><span class="line">    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？</span></span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><blockquote><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3></blockquote><p>首先明确一下 base case，如果只有一个字符，显然最长回文子序列长度是 1，也就是<code>dp[i][j] = 1,(i == j)</code>。</p><p><strong>因为<code>i</code>肯定小于等于<code>j</code>，所以对于那些<code>i &gt; j</code>的位置，根本不存在什么子序列，应该初始化为 0。</strong></p><p>另外，看看刚才写的状态转移方程，想求<code>dp[i][j]</code>需要知道<code>dp[i+1][j-1]</code>，<code>dp[i+1][j]</code>，<code>dp[i][j-1]</code>这三个位置；再看看我们确定的 base case，填入 dp 数组之后是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004129.jpg" alt=""></p><p><strong>为了保证每次计算<code>dp[i][j]</code>，左、下、左下三个方向的位置已经被计算出来，只能斜着遍历或者反着遍历</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004143.jpg" alt=""></p><p>我选择反着遍历，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">s</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment"># dp 数组全部初始化为 0</span></span><br><span class="line">    [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dp[i][i] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 反着遍历保证正确的状态转移</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">                </span><br><span class="line">    <span class="comment"># 整个 s 的最长回文子串长度</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>至此，最长回文子序列的问题就解决了。</p><p>主要还是正确定义 dp 数组的含义，遇到子序列问题，首先想到两种动态规划思路，然后根据实际问题看看哪种思路容易找到状态转移关系。</p><p>另外，找到状态转移和 base case 之后，<strong>一定要观察 DP table</strong>，看看怎么遍历才能保证通过已计算出来的结果解决新的问题</p><p>有了以上思路方向，子序列问题也不过如此嘛。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;子序列解题模板：最长回文子序列&quot;&gt;&lt;a href=&quot;#子序列解题模板：最长回文子序列&quot; class=&quot;headerlink&quot; title=&quot;子序列解题模板：最长回文子序列&quot;&gt;&lt;/a&gt;子序列解题模板：最长回文子序列&lt;/h2&gt;&lt;p&gt;子序列问题是常见的算法问题，而且并不</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>06-动态规划之最长公共子序列</title>
    <link href="https://xxren8218.github.io/20210626/06-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210626/06-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2021-06-25T16:35:11.000Z</published>
    <updated>2021-06-25T16:38:20.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划之最长公共子序列"><a href="#动态规划之最长公共子序列" class="headerlink" title="动态规划之最长公共子序列"></a>动态规划之最长公共子序列</h2><p>最长公共子序列（Longest Common Subsequence，简称 LCS）是一道非常经典的面试题目，因为它的解法是典型的二维动态规划，大部分比较困难的字符串问题都和这个问题一个套路，比如说编辑距离。而且，这个算法稍加改造就可以用于解决其他问题，所以说 LCS 算法是值得掌握的。</p><p>题目就是让我们求两个字符串的 LCS 长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: str1 = <span class="string">&quot;abcde&quot;</span>, str2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出: <span class="number">3</span>  </span><br><span class="line">解释: 最长公共子序列是 <span class="string">&quot;ace&quot;</span>，它的长度是 <span class="number">3</span></span><br></pre></td></tr></table></figure><p>为啥这个问题就是动态规划来解决呢？因为子序列类型的问题，穷举出所有可能的结果都不容易，而动态规划算法做的就是穷举 + 剪枝，它俩天生一对儿。所以可以说只要涉及子序列问题，十有八九都需要动态规划来解决，往这方面考虑就对了。</p><p>下面就来手把手分析一下，这道题目如何用动态规划技巧解决。</p><blockquote><h3 id="一、动态规划思路"><a href="#一、动态规划思路" class="headerlink" title="一、动态规划思路"></a>一、动态规划思路</h3></blockquote><p><strong>第一步，一定要明确<code>dp</code>数组的含义</strong>。</p><p>对于两个字符串的动态规划问题，套路是通用的。比如说对于字符串<code>s1</code>和<code>s2</code>，一般来说都要构造一个这样的 DP table：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626003608.jpg" alt=""></p><p>为了方便理解此表，我们暂时认为索引是从 1 开始的，待会的代码中只要稍作调整即可。其中，<code>dp[i][j]</code>的含义是：对于<code>s1[1..i]</code>和<code>s2[1..j]</code>，它们的 LCS 长度是<code>dp[i][j]</code>。</p><p>比如上图的例子，<code>dp</code> 的含义就是：对于<code>&quot;ac&quot;</code>和<code>&quot;babc&quot;</code>，它们的 LCS 长度是 2。我们最终想得到的答案应该是<code>dp[3][5]</code>。</p><p><strong>第二步，定义 base case。</strong></p><p>我们专门让索引为 0 的行和列表示空串，<code>dp[0][..]</code>和<code>dp[..][0]</code>都应该初始化为 0，这就是 base case。</p><p>比如说，按照刚才 dp 数组的定义，<code>dp[0][3]=0</code>的含义是：对于字符串<code>&quot;&quot;</code>和<code>&quot;bab&quot;</code>，其 LCS 的长度为 0。因为有一个字符串是空串，它们的最长公共子序列的长度显然应该是 0。</p><p><strong>第三步，找状态转移方程。</strong></p><p>这是动态规划最难的一步，不过好在这种字符串问题的套路都差不多，权且借这道题来聊聊处理这类问题的思路。</p><p>状态转移说简单些就是做选择，比如说这个问题，是求<code>s1</code>和<code>s2</code>的最长公共子序列，不妨称这个子序列为<code>lcs</code>。那么对于<code>s1</code>和<code>s2</code>中的每个字符，有什么选择？很简单，两种选择，要么在<code>lcs</code>中，要么不在。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626003635.jpg" alt=""></p><p>这个「在」和「不在」就是选择，关键是，应该如何选择呢？这个需要动点脑筋：如果某个字符应该在<code>lcs</code>中，那么这个字符肯定同时存在于<code>s1</code>和<code>s2</code>中，因为<code>lcs</code>是最长<strong>公共</strong>子序列嘛。所以本题的思路是这样：</p><p>用两个指针<code>i</code>和<code>j</code>从后往前遍历<code>s1</code>和<code>s2</code>，如果<code>s1[i]==s2[j]</code>，那么这个字符<strong>一定在<code>lcs</code>中</strong>；否则的话，<code>s1[i]</code>和<code>s2[j]</code>这两个字符<strong>至少有一个不在<code>lcs</code>中</strong>，需要丢弃一个。先看一下递归解法，比较容易理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">str1, str2</span>) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i, j</span>):</span></span><br><span class="line">        <span class="comment"># 空的 base case</span></span><br><span class="line">        <span class="keyword">if</span> i == -<span class="number">1</span> <span class="keyword">or</span> j == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> str1[i] == str2[j]:</span><br><span class="line">            <span class="comment"># 这边找到一个 lcs 的元素，继续往前找</span></span><br><span class="line">            <span class="keyword">return</span> dp(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 谁能让 lcs 最长，就听谁的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(dp(i - <span class="number">1</span>, j), dp(i, j - <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line"> <span class="comment"># i 和 j 初始化为最后一个索引</span></span><br><span class="line">    <span class="keyword">return</span> dp(<span class="built_in">len</span>(str1) - <span class="number">1</span>, <span class="built_in">len</span>(str2) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>对于第一种情况，找到一个<code>lcs</code>中的字符，同时将<code>i, j</code>向前移动一位，并给<code>lcs</code>的长度加一；对于后者，则尝试两种情况，取更大的结果。</p><p>其实这段代码就是暴力解法，我们可以通过备忘录或者 DP table 来优化时间复杂度，比如通过前文描述的 DP table 来解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">str1, str2</span>) -&gt; int:</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2)</span><br><span class="line">    <span class="comment"># 构建 DP table 和 base case</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>) ]</span><br><span class="line">    <span class="comment"># 进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 找到一个 lcs 中的字符</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">             </span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><h3 id="二、疑难解答"><a href="#二、疑难解答" class="headerlink" title="二、疑难解答"></a>二、疑难解答</h3></blockquote><p>对于<code>s1[i]</code>和<code>s2[j]</code>不相等的情况，<strong>至少有一个</strong>字符不在<code>lcs</code>中，会不会两个字符都不在呢？比如下面这种情况</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626003731.png" alt=""></p><p>所以代码是不是应该考虑这种情况，改成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]:</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], </span><br><span class="line">                   dp[i][j-<span class="number">1</span>],</span><br><span class="line">                   dp[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>我一开始也有这种怀疑，其实可以这样改，也能得到正确答案，但是多此一举，因为<code>dp[i-1][j-1]</code>永远是三者中最小的，max 根本不可能取到它。</p><p>原因在于我们对 dp 数组的定义：对于<code>s1[1..i]</code>和<code>s2[1..j]</code>，它们的 LCS 长度是<code>dp[i][j]</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626003749.jpg" alt=""></p><p>这样一看，显然<code>dp[i-1][j-1]</code>对应的<code>lcs</code>长度不可能比前两种情况大，所以没有必要参与比较。</p><blockquote><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3></blockquote><p>对于两个字符串的动态规划问题，一般来说都是像本文一样定义 DP table，因为这样定义有一个好处，就是容易写出状态转移方程，<code>dp[i][j]</code>的状态可以通过之前的状态推导出来：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626003805.png" alt=""></p><p>找状态转移方程的方法是，思考每个状态有哪些「选择」，只要我们能用正确的逻辑做出正确的选择，算法就能够正确运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;动态规划之最长公共子序列&quot;&gt;&lt;a href=&quot;#动态规划之最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;动态规划之最长公共子序列&quot;&gt;&lt;/a&gt;动态规划之最长公共子序列&lt;/h2&gt;&lt;p&gt;最长公共子序列（Longest Common Subsequ</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>21-MapReduce原理详解</title>
    <link href="https://xxren8218.github.io/20210625/21-MapReduce%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://xxren8218.github.io/20210625/21-MapReduce%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3.html</id>
    <published>2021-06-24T16:49:11.000Z</published>
    <updated>2021-06-24T16:54:48.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MapReduce原理详解"><a href="#1-MapReduce原理详解" class="headerlink" title="1.MapReduce原理详解"></a>1.MapReduce原理详解</h3><p><strong>单机程序计算流程</strong></p><p>输入数据—-&gt;读取数据—-&gt;处理数据—-&gt;写入数据—-&gt;输出数据</p><p><strong>Hadoop计算流程</strong></p><p>input data：输入数据</p><p>InputFormat：对数据进行切分，格式化处理</p><p>map：将前面切分的数据做map处理(将数据进行分类，输出(k,v)键值对数据)</p><p>shuffle&amp;sort:将相同的数据放在一起，并对数据进行排序处理</p><p>reduce：将map输出的数据进行hash计算，对每个map数据进行统计计算</p><ul><li>hash的目的：如英文单词中y,z的单词开头比较少。再次词频统计时，少的统计完了，但是多的并没有进行统计完，少的需要等待。——hash能使得均匀的进行统计。</li></ul><p>OutputFormat：格式化输出数据</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625005045.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625005103.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625005121.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625005205.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625005240.png" alt=""></p><p>map：将数据进行处理</p><p>buffer in memory：达到80%数据时，将数据锁在内存上，将这部分输出到磁盘上</p><p>partitions：在磁盘上有很多”小的数据”，将这些数据进行归并排序。</p><p>merge on disk：将所有的”小的数据”进行合并。</p><p>reduce：不同的reduce任务，会从map中对应的任务中copy数据</p><p>​        在reduce中同样要进行merge操作</p><ul><li><p>MR慢的原因：内存和磁盘之间频繁的数据IO交换。基于当时限制，内存比较贵。</p><p>但是Spark是基于内存的计算，速度快很多。</p></li></ul><h3 id="2-MapReduce架构"><a href="#2-MapReduce架构" class="headerlink" title="2 MapReduce架构"></a>2 MapReduce架构</h3><ul><li>MapReduce架构 1.X（没有YARN之前，计算与分配都在一起。）<ul><li>JobTracker:负责接收客户作业提交，负责任务到作业节点上运行，检查作业的状态</li><li>TaskTracker：由JobTracker指派任务，定期向JobTracker汇报状态，在每一个工作节点上永远只会有一个TaskTracker</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625005406.png" alt=""></p><ul><li><p>MapReduce2.X架构</p><ul><li>ResourceManager：负责资源的管理，负责提交任务到NodeManager所在的节点运行，检查节点的状态</li><li>NodeManager：由ResourceManager指派任务，定期向ResourceManager汇报状态</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625005425.png" alt=""></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-MapReduce原理详解&quot;&gt;&lt;a href=&quot;#1-MapReduce原理详解&quot; class=&quot;headerlink&quot; title=&quot;1.MapReduce原理详解&quot;&gt;&lt;/a&gt;1.MapReduce原理详解&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;单机程序计算流程&lt;/</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>20-MapReduce实战——基于MRJob</title>
    <link href="https://xxren8218.github.io/20210625/20-MapReduce%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EMRJob.html"/>
    <id>https://xxren8218.github.io/20210625/20-MapReduce%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EMRJob.html</id>
    <published>2021-06-24T16:41:37.000Z</published>
    <updated>2021-06-24T16:43:51.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MapReduce实战"><a href="#MapReduce实战" class="headerlink" title="MapReduce实战"></a>MapReduce实战</h2><h3 id="1-利用MRJob编写和运行MapReduce代码"><a href="#1-利用MRJob编写和运行MapReduce代码" class="headerlink" title="1 利用MRJob编写和运行MapReduce代码"></a>1 利用MRJob编写和运行MapReduce代码</h3><p><strong>mrjob 简介</strong></p><ul><li>提出背景<ul><li>若要写MapReduce，一般也不会用hadoop streaming,它没有任何封装，是自己写脚本，通过指令上传。</li><li>实际上有很多步骤有优化的余地。——出现了MRJob的库</li></ul></li><li>使用python开发在Hadoop上运行的程序, mrjob是最简单的方式</li><li>mrjob程序可以在本地测试运行也可以部署到Hadoop集群上运行</li><li>如果不想成为hadoop专家, 但是需要利用Hadoop写MapReduce代码,mrJob是很好的选择</li><li>优点：<ul><li>如果涉及多个map和多个reduce，或上个MR的输出作为下一个MR的输入的话。若用hadoop-streaming，需要写多个脚本。而MRJob可以通过一个类对其进行解决。——MRStep。——应用：TOPN统计</li></ul></li></ul><p><strong>mrjob 安装</strong></p><ul><li>使用pip安装<ul><li>pip install mrjob</li></ul></li></ul><p><strong>mrjob实现WordCount</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mrjob.job <span class="keyword">import</span> MRJob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MRWordFrequencyCount</span>(<span class="params">MRJob</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span>(<span class="params">self, _, line</span>):</span></span><br><span class="line">        <span class="comment"># 得到三个生成器，需next</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;chars&quot;</span>, <span class="built_in">len</span>(line)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;words&quot;</span>, <span class="built_in">len</span>(line.split())</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;lines&quot;</span>, <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># key 相同的会走到同一个reducer中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer</span>(<span class="params">self, key, values</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> key, <span class="built_in">sum</span>(values)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    调用run以后，他会自己调用mapper,和reducer方法。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    MRWordFrequencyCount.run() </span><br></pre></td></tr></table></figure><ul><li>每个单词词频的统计。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mrjob.job <span class="keyword">import</span> MRJob</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MRWordCount</span>(<span class="params">MRJob</span>):</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 每一行从line中输入</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span>(<span class="params">self, key, line</span>):</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> line.split():</span><br><span class="line">            <span class="keyword">yield</span> word,<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># word相同的 会走到同一个reduce</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer</span>(<span class="params">self, word, counts</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> word, <span class="built_in">sum</span>(counts)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    MRWordCount.run()</span><br></pre></td></tr></table></figure><p><strong>运行WordCount代码</strong></p><p>打开命令行, 找到一篇文本文档, 敲如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python mr_word_count.py my_file.txt</span><br></pre></td></tr></table></figure><h3 id="2-运行MRJOB的不同方式"><a href="#2-运行MRJOB的不同方式" class="headerlink" title="2 运行MRJOB的不同方式"></a>2 运行MRJOB的不同方式</h3><p>1、内嵌(-r inline)方式</p><p>特点是调试方便，启动单一进程模拟任务执行状态和结果，默认(-r inline)可以省略，输出文件使用 &gt; output-file 或-o output-file，比如下面两种运行方式是等价的</p><p>python word_count.py -r inline input.txt &gt; output.txt<br>python word_count.py input.txt &gt; output.txt</p><p>2、本地(-r local)方式</p><p>用于本地模拟Hadoop调试，与内嵌(inline)方式的区别是启动了多进程执行每一个任务。如：</p><p>python word_count.py -r local input.txt &gt; output1.txt</p><p>3、Hadoop(-r hadoop)方式</p><p>用于hadoop环境，支持Hadoop运行调度控制参数，如：</p><p>1)指定Hadoop任务调度优先级(VERY_HIGH|HIGH),如：—jobconf mapreduce.job.priority=VERY_HIGH。</p><p>2)Map及Reduce任务个数限制，如：—jobconf mapreduce.map.tasks=2  —jobconf mapreduce.reduce.tasks=5</p><p><strong>python word_count.py -r hadoop hdfs:///test.txt -o  hdfs:///output </strong></p><ul><li>要求输出的hadoop不能有内容——删掉output。</li></ul><p><strong>遇到的坑——code127错误</strong></p><p>在后面加 -python-bin /miniconda2/envs/py365/bin/python就行。因为在虚拟机运行为py3.x，而本机环境为2.x！</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625004312.PNG" alt=""></p><h3 id="3-mrjob-实现-topN统计（实验）"><a href="#3-mrjob-实现-topN统计（实验）" class="headerlink" title="3 mrjob 实现 topN统计（实验）"></a>3 mrjob 实现 topN统计（实验）</h3><ul><li>上个MR的输出作为下一个MR的输入的话。MRJob.MRStep</li></ul><p>统计数据中出现次数最多的前n个数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> mrjob.job <span class="keyword">import</span> MRJob,MRStep</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopNWords</span>(<span class="params">MRJob</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span>(<span class="params">self, _, line</span>):</span></span><br><span class="line">        <span class="keyword">if</span> line.strip() != <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> line.strip().split():</span><br><span class="line">                <span class="keyword">yield</span> word,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 介于mapper和reducer之间，用于临时的将mapper输出的数据进行统计</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combiner</span>(<span class="params">self, word, counts</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> word,<span class="built_in">sum</span>(counts)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer_sum</span>(<span class="params">self, word, counts</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="literal">None</span>,(<span class="built_in">sum</span>(counts),word) </span><br><span class="line">        <span class="comment"># key为None，只有value有值。</span></span><br><span class="line"><span class="comment"># 调换位置原因——后面的取最大的N个值是按key进行取值的。</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 利用heapq将数据进行排序，将最大的2个取出</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top_n_reducer</span>(<span class="params">self,_,word_cnts</span>):</span></span><br><span class="line">        <span class="keyword">for</span> cnt,word <span class="keyword">in</span> heapq.nlargest(<span class="number">2</span>,word_cnts):</span><br><span class="line">            <span class="keyword">yield</span> word,cnt <span class="comment"># 再调换一次。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 实现steps方法用于指定自定义的mapper，comnbiner和reducer方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">steps</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 这里有两个MR。不过第二个没有mapper</span></span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            MRStep(mapper=self.mapper,</span><br><span class="line">                   combiner=self.combiner,</span><br><span class="line">                   reducer=self.reducer_sum),</span><br><span class="line">            MRStep(reducer=self.top_n_reducer)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    TopNWords.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><ul><li>本地运行实例：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625004332.PNG" alt=""></p><h3 id="4-MRJOB-文件合并"><a href="#4-MRJOB-文件合并" class="headerlink" title="4 MRJOB 文件合并"></a>4 MRJOB 文件合并</h3><p><strong>需求描述</strong></p><ul><li>两个文件合并 类似于数据库中的两张表合并</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uid uname</span><br><span class="line">01 user1 </span><br><span class="line">02 user2</span><br><span class="line">03 user3</span><br><span class="line">uid orderid order_price</span><br><span class="line">01   01     80</span><br><span class="line">01   02     90</span><br><span class="line">02   03    82</span><br><span class="line">02   04    95</span><br></pre></td></tr></table></figure><p><strong>mrjob 实现</strong></p><p>实现对两个数据表进行join操作，显示效果为每个用户的所有订单信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;01:user1&quot;&quot;01:80,02:90&quot;</span><br><span class="line">&quot;02:user2&quot;&quot;03:82,04:95&quot;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mrjob.job <span class="keyword">import</span> MRJob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserOrderJoin</span>(<span class="params">MRJob</span>):</span></span><br><span class="line">    SORT_VALUES = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 二次排序参数：http://mrjob.readthedocs.io/en/latest/job.html</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span>(<span class="params">self, _, line</span>):</span></span><br><span class="line">        fields = line.strip().split(<span class="string">&#x27;\t&#x27;</span>) <span class="comment"># 用制表符进行拆分</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(fields) == <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># user data</span></span><br><span class="line">            source = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">            user_id = fields[<span class="number">0</span>]</span><br><span class="line">            user_name = fields[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">yield</span>  user_id,[source,user_name] <span class="comment"># 01 [A,user1]</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(fields) == <span class="number">3</span>:</span><br><span class="line">            <span class="comment"># order data</span></span><br><span class="line">            source =<span class="string">&#x27;B&#x27;</span></span><br><span class="line">            user_id = fields[<span class="number">0</span>]</span><br><span class="line">            order_id = fields[<span class="number">1</span>]</span><br><span class="line">            price = fields[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">yield</span> user_id,[source,order_id,price] <span class="comment">#01 [&#x27;B&#x27;,01,80][&#x27;B&#x27;,02,90]</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer</span>(<span class="params">self,user_id,values</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        每个用户的订单列表</span></span><br><span class="line"><span class="string">        &quot;01:user1&quot;&quot;01:80,02:90&quot;</span></span><br><span class="line"><span class="string">        &quot;02:user2&quot;&quot;03:82,04:95&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param user_id:</span></span><br><span class="line"><span class="string">        :param values:[A,user1]  [&#x27;B&#x27;,01,80]</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        values = [v <span class="keyword">for</span> v <span class="keyword">in</span> values]  <span class="comment"># 加了 &quot;A&quot;&quot;&quot;B&quot;以后保证先过来的是两个元素值。</span></span><br><span class="line">          <span class="comment"># 首行SORT_VALUES = True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(values)&gt;<span class="number">1</span> :</span><br><span class="line">            user_name = values[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">            order_info = [<span class="string">&#x27;:&#x27;</span>.join([v[<span class="number">1</span>],v[<span class="number">2</span>]]) <span class="keyword">for</span> v <span class="keyword">in</span> values[<span class="number">1</span>:]] <span class="comment">#[01:80,02:90]</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="string">&#x27;:&#x27;</span>.join([user_id,user_name]),<span class="string">&#x27;,&#x27;</span>.join(order_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    UserOrderJoin.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>实现对两个数据表进行join操作，显示效果为每个用户所下订单的订单总量和累计消费金额</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;01:user1&quot;[2, 170]</span><br><span class="line">&quot;02:user2&quot;[2, 177]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mrjob.job <span class="keyword">import</span> MRJob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserOrderJoin</span>(<span class="params">MRJob</span>):</span></span><br><span class="line">    <span class="comment"># 二次排序参数：http://mrjob.readthedocs.io/en/latest/job.html</span></span><br><span class="line">    SORT_VALUES = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span>(<span class="params">self, _, line</span>):</span></span><br><span class="line">        fields = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(fields) == <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># user data</span></span><br><span class="line">            source = <span class="string">&#x27;A&#x27;</span> </span><br><span class="line">            user_id = fields[<span class="number">0</span>]</span><br><span class="line">            user_name = fields[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">yield</span>  user_id,[source,user_name]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(fields) == <span class="number">3</span>:</span><br><span class="line">            <span class="comment"># order data</span></span><br><span class="line">            source =<span class="string">&#x27;B&#x27;</span></span><br><span class="line">            user_id = fields[<span class="number">0</span>]</span><br><span class="line">            order_id = fields[<span class="number">1</span>]</span><br><span class="line">            price = fields[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">yield</span> user_id,[source,order_id,price]</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer</span>(<span class="params">self,user_id,values</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        统计每个用户的订单数量和累计消费金额</span></span><br><span class="line"><span class="string">        :param user_id:</span></span><br><span class="line"><span class="string">        :param values:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        values = [v <span class="keyword">for</span> v <span class="keyword">in</span> values]</span><br><span class="line">        user_name = <span class="literal">None</span></span><br><span class="line">        order_cnt = <span class="number">0</span></span><br><span class="line">        order_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(values)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> values:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(v) ==  <span class="number">2</span> :</span><br><span class="line">                    user_name = v[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">len</span>(v) == <span class="number">3</span>:</span><br><span class="line">                    order_cnt += <span class="number">1</span></span><br><span class="line">                    order_sum += <span class="built_in">int</span>(v[<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">&quot;:&quot;</span>.join([user_id,user_name]),(order_cnt,order_sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    UserOrderJoin().run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MapReduce实战&quot;&gt;&lt;a href=&quot;#MapReduce实战&quot; class=&quot;headerlink&quot; title=&quot;MapReduce实战&quot;&gt;&lt;/a&gt;MapReduce实战&lt;/h2&gt;&lt;h3 id=&quot;1-利用MRJob编写和运行MapReduce代码&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>05-动态规划之高楼扔鸡蛋进阶版</title>
    <link href="https://xxren8218.github.io/20210625/05-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E8%BF%9B%E9%98%B6%E7%89%88.html"/>
    <id>https://xxren8218.github.io/20210625/05-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E8%BF%9B%E9%98%B6%E7%89%88.html</id>
    <published>2021-06-24T16:36:48.000Z</published>
    <updated>2021-06-24T16:40:09.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划之高楼扔鸡蛋（进阶）"><a href="#动态规划之高楼扔鸡蛋（进阶）" class="headerlink" title="动态规划之高楼扔鸡蛋（进阶）"></a>动态规划之高楼扔鸡蛋（进阶）</h2><p>前面一篇文章的所讲的动态规划的效率不是饿很高，在力扣的用例通过率50%左右。但是是较为容易理解的动态规划解法。今天来讲两种思路，来优化一下这个问题。分别是  <code>二分查找优化</code>  和  <code>重新定义状态转移</code></p><p>二分搜索的优化思路也许是我们可以尽力尝试写出的，而修改状态转移的解法可能是不容易想到的，可以借此见识一下动态规划算法设计的玄妙，当做思维拓展。</p><blockquote><h3 id="一、二分搜索优化"><a href="#一、二分搜索优化" class="headerlink" title="一、二分搜索优化"></a>一、二分搜索优化</h3></blockquote><p>之前提到过这个解法，核心是因为状态转移方程的单调性，这里可以具体展开看看。</p><p>题目要求最坏情况下至少需要扔几次鸡蛋才能测出鸡蛋恰好摔不碎的楼层<code>F</code>。首先简述一下原始动态规划的思路：</p><p><strong>1</strong>、暴力穷举尝试在所有楼层<code>1 &lt;= i &lt;= N</code>扔鸡蛋，每次选择尝试次数<strong>最少</strong>的那一层；</p><p><strong>2</strong>、每次扔鸡蛋有两种可能，要么碎，要么没碎；</p><p><strong>3</strong>、如果鸡蛋碎了，<code>F</code>应该在第<code>i</code>层下面，否则，<code>F</code>应该在第<code>i</code>层上面；</p><p><strong>4</strong>、鸡蛋是碎了还是没碎，取决于哪种情况下尝试次数<strong>更多</strong>，因为我们想求的是最坏情况下的结果。</p><p>核心的状态转移代码是这段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前状态为 K 个鸡蛋，面对 N 层楼</span></span><br><span class="line"><span class="comment"># 返回这个状态下的最优结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">K, N</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">        <span class="comment"># 最坏情况下的最少扔鸡蛋次数</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, </span><br><span class="line">                  <span class="built_in">max</span>( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), <span class="comment"># 碎</span></span><br><span class="line">                        dp(K, N - i)      <span class="comment"># 没碎</span></span><br><span class="line">                     ) + <span class="number">1</span> <span class="comment"># 在第 i 楼扔了一次</span></span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个 for 循环就是下面这个状态转移方程的具体代码实现：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625003842.jpg" alt=""></p><p>如果能够理解这个状态转移方程，那么就很容易理解二分查找的优化思路。</p><p>首先我们根据<code>dp(K, N)</code>数组的定义（有<code>K</code>个鸡蛋面对<code>N</code>层楼，最少需要扔 dp(K, N) 次），<strong>很容易知道<code>K</code>固定时，这个函数随着<code>N</code>的增加一定是单调递增的</strong>，无论你策略多聪明，楼层增加的话，测试次数一定要增加。</p><p>那么注意<code>dp(K - 1, i - 1)</code>和<code>dp(K, N - i)</code>这两个函数，其中<code>i</code>是从 1 到<code>N</code>单增的，如果我们固定<code>K</code>和<code>N</code>，<strong>把这两个函数看做关于<code>i</code>的函数，前者随着<code>i</code>的增加应该也是单调递增的，而后者随着<code>i</code>的增加应该是单调递减的</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625003902.jpg" alt=""></p><p>这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。</p><p>二分查找的运用很广泛，形如下面这种形式的 for 循环代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> (isOK(i)):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>都很有可能可以运用二分查找来优化线性搜索的复杂度，回顾这两个<code>dp</code>函数的曲线，我们要找的最低点其实就是这种情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N)</span><br><span class="line">    <span class="keyword">if</span> dp(K - <span class="number">1</span>, i - <span class="number">1</span>) == dp(K, N - i):</span><br><span class="line">        <span class="keyword">return</span> dp(K, N - i);</span><br></pre></td></tr></table></figure><p>熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley（山谷）值嘛，可以用二分查找来快速寻找这个点的，直接看代码吧，整体的思路还是一样，只是加快了搜索速度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">self, K: <span class="built_in">int</span>, N: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line"></span><br><span class="line">    memo = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">K, N</span>):</span></span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (K, N) <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># for 1 &lt;= i &lt;= N:</span></span><br><span class="line">        <span class="comment">#     res = min(res, </span></span><br><span class="line">        <span class="comment">#             max( </span></span><br><span class="line">        <span class="comment">#                 dp(K - 1, i - 1), </span></span><br><span class="line">        <span class="comment">#                 dp(K, N - i)      </span></span><br><span class="line">        <span class="comment">#                 ) + 1 </span></span><br><span class="line">        <span class="comment">#             )</span></span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="comment"># 用二分搜索代替线性搜索</span></span><br><span class="line">        low, high = <span class="number">1</span>, N</span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            broken = dp(K - <span class="number">1</span>, mid - <span class="number">1</span>) <span class="comment"># 碎</span></span><br><span class="line">            not_broken = dp(K, N - mid) <span class="comment"># 没碎</span></span><br><span class="line">            <span class="comment"># res = min(max(碎，没碎) + 1)</span></span><br><span class="line">            <span class="keyword">if</span> broken &gt; not_broken:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">                res = <span class="built_in">min</span>(res, broken + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">                res = <span class="built_in">min</span>(res, not_broken + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p><p>函数本身的复杂度就是忽略递归部分的复杂度，这里<code>dp</code>函数中用了一个二分搜索，所以函数本身的复杂度是 O(logN)。</p><p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。</p><p>所以算法的总时间复杂度是 O(K<em>N</em>logN), 空间复杂度 O(KN)。效率上比之前的算法 O(KN^2) 要高效不少。</p><blockquote><h3 id="二、重写状态转移"><a href="#二、重写状态转移" class="headerlink" title="二、重写状态转移"></a>二、重写状态转移</h3></blockquote><p>找动态规划的状态转移本就是见仁见智，比较玄学的事情。不同的状态定义可以衍生出不同的解法，其解法和复杂程度都可能有巨大差异。这里就是一个很好的例子。</p><p>再回顾一下我们之前定义的<code>dp</code>数组含义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">k, n</span>) -&gt; int</span></span><br><span class="line"><span class="function"># 当前状态为 k 个鸡蛋，面对 n 层楼</span></span><br><span class="line"><span class="function"># 返回这个状态下最少的扔鸡蛋次数</span></span><br></pre></td></tr></table></figure><p>用 dp 数组表示的话也是一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[k][n] = m</span><br><span class="line"><span class="comment"># 当前状态为 k 个鸡蛋，面对 n 层楼</span></span><br><span class="line"><span class="comment"># 这个状态下最少的扔鸡蛋次数为 m</span></span><br></pre></td></tr></table></figure><p>按照这个定义，就是<strong>确定当前的鸡蛋个数和面对的楼层数，就知道最小扔鸡蛋次数</strong>。最终我们想要的答案就是<code>dp(K, N)</code>的结果。</p><p>这种思路下，肯定要穷举所有可能的扔法的，用二分搜索优化也只是做了「剪枝」，减小了搜索空间，但本质思路没有变，只不过是更聪明的穷举。</p><p>现在，我们稍微修改<code>dp</code>数组的定义，<strong>确定当前的鸡蛋个数和最多允许的扔鸡蛋次数，就知道能够确定<code>F</code>的最高楼层数</strong>。</p><p>有点绕口，具体来说是这个意思：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[k][m] = n</span><br><span class="line"><span class="comment"># 当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋</span></span><br><span class="line"><span class="comment"># 这个状态下，最坏情况下最多能确切测试一栋 n 层的楼</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如说 dp[1][7] = 7 表示：</span></span><br><span class="line"><span class="comment"># 现在有 1 个鸡蛋，允许你扔 7 次;</span></span><br><span class="line"><span class="comment"># 这个状态下最多给你 7 层楼，</span></span><br><span class="line"><span class="comment"># 使得你可以确定楼层 F 使得鸡蛋恰好摔不碎</span></span><br><span class="line"><span class="comment"># （一层一层线性探查嘛）</span></span><br></pre></td></tr></table></figure><p>这其实就是我们原始思路的一个「反向」版本，我们先不管这种思路的状态转移怎么写，先来思考一下这种定义之下，最终想求的答案是什么？</p><p>我们最终要求的其实是扔鸡蛋次数<code>m</code>，但是这时候<code>m</code>在状态之中而不是<code>dp</code>数组的结果，可以这样处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">K, N</span>):</span></span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> dp[K][m] &lt; N </span><br><span class="line">        m += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 状态转移...</span></span><br><span class="line">    <span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure><p>题目不是<strong>给你<code>K</code>鸡蛋，<code>N</code>层楼，让你求最坏情况下最少的测试次数<code>m</code></strong> 吗？<code>while</code>循环结束的条件是<code>dp[K][m] == N</code>，也就是<strong>给你<code>K</code>个鸡蛋，允许测试<code>m</code>次，最坏情况下最多能测试<code>N</code>层楼</strong>。</p><p>注意看这两段描述，是完全一样的！所以说这样组织代码是正确的，关键就是状态转移方程怎么找呢？还得从我们原始的思路开始讲。之前的解法配了这样图帮助大家理解状态转移思路：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625003925.jpg" alt=""></p><p>这个图描述的仅仅是某一个楼层<code>i</code>，原始解法还得线性或者二分扫描所有楼层，要求最大值、最小值。但是现在这种<code>dp</code>定义根本不需要这些了，基于下面两个事实：</p><p><strong>1、无论你在哪层楼扔鸡蛋，鸡蛋只可能摔碎或者没摔碎，碎了的话就测楼下，没碎的话就测楼上</strong>。</p><p><strong>2、无论你上楼还是下楼，总的楼层数 = 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）</strong>。</p><p>根据这个特点，可以写出下面的状态转移方程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[k][m] = dp[k][m-<span class="number">1</span>] + dp[k-<span class="number">1</span>][m-<span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong><code>dp[k][m - 1]</code>就是楼上的楼层数</strong>，因为鸡蛋个数<code>k</code>不变，也就是鸡蛋没碎，扔鸡蛋次数<code>m</code>减一；</p><p><strong><code>dp[k - 1][m - 1]</code>就是楼下的楼层数</strong>，因为鸡蛋个数<code>k</code>减一，也就是鸡蛋碎了，同时扔鸡蛋次数<code>m</code>减一。</p><p>PS：这个<code>m</code>为什么要减一而不是加一？之前定义得很清楚，这个<code>m</code>是一个允许的次数上界，而不是扔了几次。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210625003951.jpg" alt=""></p><p>至此，整个思路就完成了，只要把状态转移方程填进框架即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">K, N</span>):</span></span><br><span class="line">    <span class="comment"># m 最多不会超过 N 次（线性扫描）</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(N + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># base case:</span></span><br><span class="line">    <span class="comment"># dp[0][..] = 0</span></span><br><span class="line">    <span class="comment"># dp[..][0] = 0</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> dp[K][m] &lt; N:</span><br><span class="line">        m += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K):</span><br><span class="line">            dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><p>如果你还觉得这段代码有点难以理解，其实它就等同于这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, dp[K][m] &lt; N):</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K):</span><br><span class="line">        dp[k][m] = dp[k][m - <span class="number">1</span>] + dp[k - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>看到这种代码形式就熟悉多了吧，因为我们要求的不是<code>dp</code>数组里的值，而是某个符合条件的索引<code>m</code>，所以用<code>while</code>循环来找到这个<code>m</code>而已。</p><p>这个算法的时间复杂度是多少？很明显就是两个嵌套循环的复杂度 O(KN)。</p><p>另外注意到<code>dp[m][k]</code>转移只和左边和左上的两个状态有关，所以很容易优化成一维<code>dp</code>数组，这里就不写了。</p><blockquote><h3 id="三、进一步思考"><a href="#三、进一步思考" class="headerlink" title="三、进一步思考"></a>三、进一步思考</h3></blockquote><p>再往下就要用一些数学方法了，不具体展开，就简单提一下思路吧。</p><p>在刚才的思路之上，<strong>注意函数<code>dp(m, k)</code>是随着<code>m</code>单增的，因为鸡蛋个数<code>k</code>不变时，允许的测试次数越多，可测试的楼层就越高。</strong></p><p>这里又可以借助二分搜索算法快速逼近<code>dp[K][m] == N</code>这个终止条件，时间复杂度进一步下降为 O(KlogN)，我们可以设<code>g(k,m)</code>等于……</p><p>算了算了，打住吧。我觉得我们能够写出 O(K<em>N</em>logN) 的二分优化算法就行了，后面的这些解法呢，听个响鼓个掌就行了，把欲望限制在能力的范围之内才能拥有快乐！</p><p>不过可以肯定的是，根据二分搜索代替线性扫描 m 的取值，代码的大致框架肯定是修改穷举 m 的 for 循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把线性搜索改成二分搜索</span></span><br><span class="line"><span class="comment"># for m in range(1, dp[K][m] &lt; N):</span></span><br><span class="line">low, high = <span class="number">1</span>, N</span><br><span class="line"><span class="keyword">while</span> low &lt; high:</span><br><span class="line">    mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ... &lt; N:</span><br><span class="line">        low = ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        high = ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K):</span><br><span class="line">        <span class="comment"># 状态转移方程</span></span><br></pre></td></tr></table></figure><p>简单总结一下吧，<strong>第一个二分优化是利用了<code>dp</code>函数的单调性</strong>，用二分查找技巧快速搜索答案；<strong>第二种优化是巧妙地修改了状态转移方程</strong>，简化了求解了流程，但相应的，解题逻辑比较难以想到；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;动态规划之高楼扔鸡蛋（进阶）&quot;&gt;&lt;a href=&quot;#动态规划之高楼扔鸡蛋（进阶）&quot; class=&quot;headerlink&quot; title=&quot;动态规划之高楼扔鸡蛋（进阶）&quot;&gt;&lt;/a&gt;动态规划之高楼扔鸡蛋（进阶）&lt;/h2&gt;&lt;p&gt;前面一篇文章的所讲的动态规划的效率不是饿很高</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>19-hadoop之YARN &amp; MapReduce</title>
    <link href="https://xxren8218.github.io/20210623/19-hadoop%E4%B9%8BYARN-MapReduce.html"/>
    <id>https://xxren8218.github.io/20210623/19-hadoop%E4%B9%8BYARN-MapReduce.html</id>
    <published>2021-06-23T04:50:39.000Z</published>
    <updated>2021-06-24T16:45:55.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YARN-amp-MapReduce"><a href="#YARN-amp-MapReduce" class="headerlink" title="YARN&amp;MapReduce"></a>YARN&amp;MapReduce</h1><p>掌握目标：</p><ul><li>了解YARN概念和产生背景</li><li>了解MapReduce概念</li><li>说出YARN执行流程</li><li>说出MapReduce原理</li><li>独立完成Mrjob实现wordcount</li><li>完成提交作业到YARN上执行</li></ul><h2 id="1-资源调度框架-YARN"><a href="#1-资源调度框架-YARN" class="headerlink" title="1.资源调度框架 YARN"></a>1.资源调度框架 YARN</h2><h3 id="1-1-什么是YARN"><a href="#1-1-什么是YARN" class="headerlink" title="1.1 什么是YARN"></a>1.1 什么是YARN</h3><ul><li>Yet Another Resource Negotiator, 另一种资源协调者</li><li>通用资源管理系统</li><li>为上层应用提供统一的资源管理和调度，为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处</li></ul><h3 id="1-2-YARN产生背景"><a href="#1-2-YARN产生背景" class="headerlink" title="1.2 YARN产生背景"></a>1.2 YARN产生背景</h3><ul><li><p>通用资源管理系统</p><ul><li>Hadoop数据分布式存储（数据分块，冗余存储）</li><li>当多个MapReduce任务要用到相同的hdfs数据， 需要进行资源调度管理</li><li>Hadoop1.x时并没有YARN，MapReduce 既负责进行计算作业又处理服务器集群资源调度管理</li></ul></li><li><p>服务器集群资源调度管理和MapReduce执行过程耦合在一起带来的问题</p><ul><li><p>Hadoop早期, 技术只有Hadoop, 这个问题不明显</p></li><li><p>随着大数据技术的发展，Spark Storm … 计算框架都要用到服务器集群资源 </p></li><li><p>如果没有通用资源管理系统，只能为多个集群分别提供数据</p><ul><li>资源利用率低 运维成本高</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210623125202.png" alt=""></p></li><li><p>Yarn (Yet Another Resource Negotiator) 另一种资源调度器</p><ul><li>Mesos 大数据资源管理产品</li></ul></li></ul></li><li><p>不同计算框架可以共享同一个HDFS集群上的数据，享受整体的资源调度</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210623125235.png" alt=""></p></li></ul><h3 id="1-3-YARN的架构和执行流程"><a href="#1-3-YARN的架构和执行流程" class="headerlink" title="1.3 YARN的架构和执行流程"></a>1.3 YARN的架构和执行流程</h3><ul><li>ResourceManager: RM 资源管理器<br>​    整个集群同一时间提供服务的RM只有一个，负责集群资源的统一管理和调度<br>​    处理客户端的请求： submit, kill<br>​    监控我们的NM，一旦某个NM挂了，那么该NM上运行的任务需要告诉我们的AM来如何进行处理</li><li>NodeManager: NM 节点管理器<br>​    整个集群中有多个，负责自己本身节点资源管理和使用<br>​    定时向RM汇报本节点的资源使用情况<br>​    接收并处理来自RM的各种命令：启动Container<br>​    处理来自AM的命令</li><li>ApplicationMaster: AM<br>​    每个应用程序对应一个：MR、Spark，负责应用程序的管理<br>​    为应用程序向RM申请资源（core、memory），分配给内部task<br>​    需要与NM通信：启动/停止task，task是运行在container里面，AM也是运行在container里面</li><li>Container 容器: 封装了CPU、Memory等资源的一个容器,是一个任务运行环境的抽象</li><li>Client: 提交作业 查询作业的运行进度,杀死作业</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210623125255.png" alt=""></p><p>1，Client提交作业请求</p><p>2，ResourceManager 进程和 NodeManager 进程通信，根据集群资源，为用户程序分配第一个Container(容器)，并将 ApplicationMaster 分发到这个容器上面</p><p>3，在启动的Container中创建ApplicationMaster</p><p>4，ApplicationMaster启动后向ResourceManager注册进程,申请资源</p><p>5，ApplicationMaster申请到资源后，向对应的NodeManager申请启动Container,将要执行的程序分发到NodeManager上</p><p>6，Container启动后，执行对应的任务</p><p>7，Tast执行完毕之后，向ApplicationMaster返回结果</p><p>8，ApplicationMaster向ResourceManager汇报任务结束。 请求kill</p><h3 id="1-4-YARN环境搭建"><a href="#1-4-YARN环境搭建" class="headerlink" title="1.4 YARN环境搭建"></a>1.4 YARN环境搭建</h3><p>1）mapred-site.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><p>2）yarn-site.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><p>3) 启动YARN相关的进程<br>sbin/start-yarn.sh</p><p>4）验证<br>​    jps<br>​        ResourceManager<br>​        NodeManager<br>​    <a href="http://192,168.19.137:8088">http://192,168.19.137:8088</a></p><p>5）停止YARN相关的进程<br>​    sbin/stop-yarn.sh</p><h2 id="2-分布式处理框架-MapReduce"><a href="#2-分布式处理框架-MapReduce" class="headerlink" title="2.分布式处理框架 MapReduce"></a>2.分布式处理框架 MapReduce</h2><h3 id="2-1-什么是MapReduce"><a href="#2-1-什么是MapReduce" class="headerlink" title="2.1 什么是MapReduce"></a>2.1 什么是MapReduce</h3><ul><li>源于Google的MapReduce论文(2004年12月)</li><li>Hadoop的MapReduce是Google论文的开源实现</li><li>MapReduce优点: 海量数据离线处理&amp;易开发</li><li>MapReduce缺点: 不能实时流式计算</li></ul><h3 id="2-2-MapReduce编程模型"><a href="#2-2-MapReduce编程模型" class="headerlink" title="2.2 MapReduce编程模型"></a>2.2 MapReduce编程模型</h3><ul><li><p>MapReduce分而治之的思想</p><ul><li>数钱实例：一堆钞票，各种面值分别是多少<ul><li>单点策略<ul><li>一个人数所有的钞票，数出各种面值有多少张</li></ul></li><li>分治策略<ul><li>每个人分得一堆钞票，数出各种面值有多少张</li><li>汇总，每个人负责统计一种面值</li></ul></li><li>解决数据可以切割进行计算的应用</li></ul></li></ul></li><li><p>MapReduce编程分Map和Reduce阶段——还是过于简单了（相比于Spark,不能进行求平均操作，得自己写。）</p><ul><li>将作业拆分成Map阶段和Reduce阶段</li><li>Map阶段 Map Tasks 分：把复杂的问题分解为若干”简单的任务”</li><li>Reduce阶段: Reduce Tasks 合：reduce</li></ul></li><li><p>MapReduce编程执行步骤</p><ul><li>准备MapReduce的输入数据</li><li>准备Mapper数据，进行Mapper操作</li><li>Shuffle</li><li>Reduce处理</li><li>结果输出</li></ul></li><li><p><strong>编程模型</strong></p></li><li><p>借鉴函数式编程方式</p></li><li><p>用户只需要实现两个函数接口：</p><ul><li><p>Map(in_key,in_value)</p><p>—-&gt;(out_key,intermediate_value) list</p></li><li><p>Reduce(out_key,intermediate_value) list</p><p>—-&gt;out_value list</p></li></ul></li><li><p>Word Count 词频统计案例</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210623125322.png" alt=""></p></li></ul><h3 id="2-3-Hadoop-Streaming-实现wordcount"><a href="#2-3-Hadoop-Streaming-实现wordcount" class="headerlink" title="2.3 Hadoop Streaming 实现wordcount"></a>2.3 Hadoop Streaming 实现wordcount</h3><ul><li><p>提供了python的API，写完以后翻译成java去执行的。——此处用了虚拟环境（source activate py365）</p><ul><li>Mapper</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入为标准输入stdin</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    <span class="comment"># 删除开头和结尾的空行</span></span><br><span class="line">    line = line.strip()</span><br><span class="line">    <span class="comment"># 以默认空格分隔单词到words列表</span></span><br><span class="line">    words = line.split()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="comment"># 输出所有单词，格式为“单词 1”以便作为Reduce的输入</span></span><br><span class="line">        print(<span class="string">&quot;%s %s&quot;</span>%(word,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><ul><li>Reducer</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">current_word = <span class="literal">None</span></span><br><span class="line">current_count = <span class="number">0</span></span><br><span class="line">word = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取标准输入，即mapper.py的标准输出</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    <span class="comment"># 删除开头和结尾的空行</span></span><br><span class="line">    line = line.strip()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析mapper.py输出作为程序的输入，以tab作为分隔符</span></span><br><span class="line">    word, count = line.split()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转换count从字符型到整型</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        count = <span class="built_in">int</span>(count)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="comment"># count非数字时，忽略此行</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 要求mapper.py的输出做排序（sort）操作，以便对连续的word做判断</span></span><br><span class="line">    <span class="keyword">if</span> current_word == word:</span><br><span class="line">        current_count += count</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="comment"># 出现了一个新词</span></span><br><span class="line">        <span class="comment"># 输出当前word统计结果到标准输出</span></span><br><span class="line">        <span class="keyword">if</span> current_word :</span><br><span class="line">            print(<span class="string">&#x27;%s\t%s&#x27;</span> % (current_word, current_count))</span><br><span class="line">        <span class="comment"># 开始对新词的统计</span></span><br><span class="line">        current_count = count</span><br><span class="line">        current_word = word</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出最后一个word统计</span></span><br><span class="line"><span class="keyword">if</span> current_word == word:</span><br><span class="line">    print(<span class="string">&quot;%s\t%s&quot;</span>% (current_word, current_count))</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>本地实现</p><p>​     <code>cat xxx.txt</code>|<code>python3 map.py</code>|<code>sort|python3 red.py</code></p><p>得到最终的输出</p><p><strong>注：hadoop-streaming会主动将map的输出数据进行字典排序</strong></p></li></ul><ul><li><p>通过Hadoop Streaming 提交作业到Hadoop集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">STREAM_JAR_PATH=&quot;/root/bigdata/hadoop/share/hadoop/tools/lib/hadoop-streaming-2.9.1.jar&quot;    # hadoop streaming jar包所在位置</span><br><span class="line">INPUT_FILE_PATH_1=&quot;/The_Man_of_Property.txt&quot;  #要进行词频统计的文档在hdfs中的路径</span><br><span class="line">OUTPUT_PATH=&quot;/output&quot;                         #MR作业后结果的存放路径</span><br><span class="line"></span><br><span class="line">hadoop fs -rm -r -skipTrash $OUTPUT_PATH    #输出路径如果之前存在 先删掉否则会报错</span><br><span class="line"></span><br><span class="line">hadoop jar $STREAM_JAR_PATH \   </span><br><span class="line">-input $INPUT_FILE_PATH_1 \ # 指定输入文件位置</span><br><span class="line">-output $OUTPUT_PATH \      #指定输出结果位置</span><br><span class="line">-mapper &quot;python map.py&quot; \   #指定mapper执行的程序</span><br><span class="line">-reducer &quot;python red.py&quot; \  #指定reduce阶段执行的程序</span><br><span class="line">-file ./map.py \            #通过-file 把python源文件分发到集群的每一台机器上  </span><br><span class="line">-file ./red.py</span><br></pre></td></tr></table></figure></li><li><p>到Hadoop集群查看运行结果</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210623125354.png" alt=""></p><h3 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h3></li><li><p>对于java而言，.java编译-&gt;.class文件（多个打包）-&gt;.jar-&gt; 在JVM虚拟机上运行。对于JVM而言，.jar是其可执行文件。相当于windows的.exe。</p></li><li><p>通过hadoop-streaming-2.9.1.ja可执行文件将python的可执行文件翻译成java。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210623125413.PNG" alt=""></p><p>结果如图</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210623125427.PNG" alt=""></p><h2 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h2><p>得开启YARN才可以</p><p>也可以去YARN去看：端口号8088</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210623125443.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;YARN-amp-MapReduce&quot;&gt;&lt;a href=&quot;#YARN-amp-MapReduce&quot; class=&quot;headerlink&quot; title=&quot;YARN&amp;amp;MapReduce&quot;&gt;&lt;/a&gt;YARN&amp;amp;MapReduce&lt;/h1&gt;&lt;p&gt;掌握目标：&lt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>04-动态规划之高楼扔鸡蛋</title>
    <link href="https://xxren8218.github.io/20210622/04-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B.html"/>
    <id>https://xxren8218.github.io/20210622/04-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B.html</id>
    <published>2021-06-22T10:24:57.000Z</published>
    <updated>2021-06-22T11:26:11.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划之高楼扔鸡蛋"><a href="#动态规划之高楼扔鸡蛋" class="headerlink" title="动态规划之高楼扔鸡蛋"></a>动态规划之高楼扔鸡蛋</h2><p>今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么的。</p><p>具体的问题等会再说，但是这道题的解法技巧很多，光动态规划就好几种效率不同的思路，最后还有一种极其高效数学解法。秉承我们一贯的作风，拒绝奇技淫巧，拒绝过于诡异的技巧，因为这些技巧无法举一反三，学了不太划算。</p><p>下面就来用我们一直强调的动态规划通用思路来研究一下这道题。</p><blockquote><h3 id="一、解析题目"><a href="#一、解析题目" class="headerlink" title="一、解析题目"></a>一、解析题目</h3></blockquote><p>题目是这样：你面前有一栋从 1 到<code>N</code>共<code>N</code>层的楼，然后给你<code>K</code>个鸡蛋（<code>K</code>至少为 1）。现在确定这栋楼存在楼层<code>0 &lt;= F &lt;= N</code>，在这层楼将鸡蛋扔下去，鸡蛋<strong>恰好没摔碎</strong>（高于<code>F</code>的楼层都会碎，低于<code>F</code>的楼层都不会碎）。现在问你，<strong>最坏</strong>情况下，你<strong>至少</strong>要扔几次鸡蛋，才能<strong>确定</strong>这个楼层<code>F</code>呢？</p><p>PS：F 可以为 0，比如说鸡蛋在 1 层都能摔碎，那么 F = 0。</p><p>也就是让你找摔不碎鸡蛋的最高楼层<code>F</code>，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。</p><p>比方说<strong>现在先不管鸡蛋个数的限制</strong>，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？</p><p>最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……</p><p>以这种策略，<strong>最坏</strong>情况应该就是我试到第 7 层鸡蛋也没碎（<code>F = 7</code>），也就是我扔了 7 次鸡蛋。</p><p>现在你应该理解什么叫做「最坏情况」下了，<strong>鸡蛋破碎一定发生在搜索区间穷尽时</strong>，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。</p><p>现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。</p><p>最好的策略是使用二分查找思路，我先去第<code>(1 + 7) / 2 = 4</code>层扔一下：</p><p>如果碎了说明<code>F</code>小于 4，我就去第<code>(1 + 3) / 2 = 2</code>层试……</p><p>如果没碎说明<code>F</code>大于等于 4，我就去第<code>(5 + 7) / 2 = 6</code>层试……</p><p>以这种策略，<strong>最坏</strong>情况应该是试到第 7 层鸡蛋还没碎（<code>F = 7</code>），或者鸡蛋一直碎到第 1 层（<code>F = 0</code>）。然而无论那种最坏情况，只需要试<code>log7</code>向上取整等于 3 次，比刚才的 7 次要少，这就是所谓的<strong>至少</strong>要扔几次。</p><p>实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，<strong>现在给你了鸡蛋个数的限制<code>K</code>，直接使用二分思路就不行了</strong>。</p><p>比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层<code>F</code>了。这种情况下只能用线性扫描的方法，算法返回结果应该是 7。</p><p>有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？</p><p>很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。</p><p>如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次。</p><p>最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。</p><p>说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？</p><blockquote><h3 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="二、思路分析"></a>二、思路分析</h3></blockquote><p>对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。</p><p><strong>「状态」很明显，就是当前拥有的鸡蛋数<code>K</code>和需要测试的楼层数<code>N</code></strong>。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。</p><p><strong>「选择」其实就是去选择哪层楼扔鸡蛋</strong>。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。</p><p>现在明确了「状态」和「选择」，<strong>动态规划的基本思路就形成了</strong>：肯定是个二维的<code>dp</code>数组或者带有两个状态参数的<code>dp</code>函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新结果 ：</p><p><code>dp（）</code> 函数的含义：鸡蛋数目为k，可选楼层数为N时的最小扔鸡蛋次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line"><span class="comment"># 当前状态为 (K 个鸡蛋，N 层楼)</span></span><br><span class="line"><span class="comment"># 返回这个状态下的最优结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">K, N</span>):</span></span><br><span class="line">    res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        res = <span class="built_in">min</span>(res, 这次在第 i 层楼扔鸡蛋)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。</p><p>我们在第<code>i</code>层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。<strong>注意，这时候状态转移就来了</strong>：</p><p><strong>如果鸡蛋碎了</strong>，那么鸡蛋的个数<code>K</code>应该减一，搜索的楼层区间应该从<code>[1..N]</code>变为<code>[1..i-1]</code>共<code>i-1</code>层楼；</p><p><strong>如果鸡蛋没碎</strong>，那么鸡蛋的个数<code>K</code>不变，搜索的楼层区间应该从 <code>[1..N]</code>变为<code>[i+1..N]</code>共<code>N-i</code>层楼。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210622192232.jpg" alt=""></p><p>PS：细心的读者可能会问，在第<code>i</code>层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第<code>i</code>层楼呀？不必，因为已经包含了。开头说了 F 是可以等于 0 的，向上递归后，第<code>i</code>层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。</p><p>因为我们要求的是<strong>最坏情况</strong>下扔鸡蛋的次数，所以鸡蛋在第<code>i</code>层楼碎没碎，取决于那种情况的结果<strong>更大</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">K, N</span>):</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        <span class="comment"># 最坏情况下的最少扔鸡蛋次数</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, </span><br><span class="line">                  <span class="built_in">max</span>( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), <span class="comment"># 碎</span></span><br><span class="line">                        dp(K, N - i)      <span class="comment"># 没碎</span></span><br><span class="line">                     ) + <span class="number">1</span> <span class="comment"># 在第 i 楼扔了一次</span></span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>递归的 base case 很容易理解：当楼层数<code>N</code>等于 0 时，显然不需要扔鸡蛋；当鸡蛋数<code>K</code>为 1 时，显然只能线性扫描所有楼层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">K, N</span>):</span></span><br><span class="line">    <span class="keyword">if</span> K == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">    <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">K: <span class="built_in">int</span>, N: <span class="built_in">int</span></span>):</span></span><br><span class="line"></span><br><span class="line">    memo = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">K, N</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (K, N) <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="comment"># 穷举所有可能的选择</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            res = <span class="built_in">min</span>(res, </span><br><span class="line">                      <span class="built_in">max</span>(</span><br><span class="line">                            dp(K, N - i), </span><br><span class="line">                            dp(K - <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">                         ) + <span class="number">1</span></span><br><span class="line">                  )</span><br><span class="line">        <span class="comment"># 记入备忘录</span></span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p><p>函数本身的复杂度就是忽略递归部分的复杂度，这里<code>dp</code>函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。</p><p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。</p><p>所以算法的总时间复杂度是 O(K*N^2), 空间复杂度为子问题个数，即 O(KN)。</p><blockquote><h3 id="三、疑难解答"><a href="#三、疑难解答" class="headerlink" title="三、疑难解答"></a>三、疑难解答</h3></blockquote><p>这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录/DP table 优化，真的没啥新意。</p><p>首先，有读者可能不理解代码中为什么用一个 for 循环遍历楼层<code>[1..N]</code>，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，<strong>这只是在做一次「选择」</strong>。</p><p>比方说你有 2 个鸡蛋，面对 10 层楼，你得拿一个鸡蛋去某一层楼扔对吧？那选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于鸡蛋碎没碎，下次怎么选择不用你操心，有正确的状态转移，递归会算出每个选择的代价，我们取最优的那个就是最优解。</p><p>其实，这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 O(K<em>N</em>logN)；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。</p><p>二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，可以快速找到最小值。</p><p>我觉得吧，我们这种解法就够了：<strong>找状态，做选择</strong>，足够清晰易懂，可流程化，可举一反三。掌握这套框架学有余力的话，二分查找的优化应该可以看懂，之后的优化也就随缘吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;动态规划之高楼扔鸡蛋&quot;&gt;&lt;a href=&quot;#动态规划之高楼扔鸡蛋&quot; class=&quot;headerlink&quot; title=&quot;动态规划之高楼扔鸡蛋&quot;&gt;&lt;/a&gt;动态规划之高楼扔鸡蛋&lt;/h2&gt;&lt;p&gt;今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>18-hadoop之分布式文件系统 HDFS</title>
    <link href="https://xxren8218.github.io/20210622/18-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-HDFS.html"/>
    <id>https://xxren8218.github.io/20210622/18-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-HDFS.html</id>
    <published>2021-06-21T16:38:13.000Z</published>
    <updated>2021-06-24T16:47:54.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式文件系统-HDFS"><a href="#分布式文件系统-HDFS" class="headerlink" title="分布式文件系统 HDFS"></a>分布式文件系统 HDFS</h1><p>掌握目标：</p><ul><li>知道什么是hdfs</li><li>说出hdfs的架构</li><li>能够掌握hdfs的环境搭建</li><li>能够掌握hdfs shell的基本使用</li><li>知道hdfs shell的优缺点</li></ul><h3 id="1-HDFS的使用"><a href="#1-HDFS的使用" class="headerlink" title="1 HDFS的使用"></a>1 HDFS的使用</h3><ul><li><p>启动HDFS</p><ul><li>来到$HADOOP_HOME/sbin目录下</li><li>执行start-dfs.sh</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop00 sbin]$ ./start-dfs.sh</span><br></pre></td></tr></table></figure><ul><li>可以看到 namenode和 datanode启动的日志信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Starting namenodes on [hadoop00]</span><br><span class="line">hadoop00: starting namenode, logging to /home/hadoop/app/hadoop-2.6.0-cdh5.7.0/logs/hadoop-hadoop-namenode-hadoop00.out</span><br><span class="line">localhost: starting datanode, logging to /home/hadoop/app/hadoop-2.6.0-cdh5.7.0/logs/hadoop-hadoop-datanode-hadoop00.out</span><br><span class="line">Starting secondary namenodes [0.0.0.0]</span><br><span class="line">0.0.0.0: starting secondarynamenode, logging to /home/hadoop/app/hadoop-2.6.0-cdh5.7.0/logs/hadoop-hadoop-secondarynamenode-hadoop00.out</span><br></pre></td></tr></table></figure><ul><li>通过jps命令查看当前运行的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop00 sbin]$ jps</span><br><span class="line">4416 DataNode</span><br><span class="line">4770 Jps</span><br><span class="line">4631 SecondaryNameNode</span><br><span class="line">4251 NameNode</span><br></pre></td></tr></table></figure><ul><li>可以看到 NameNode DataNode 以及 SecondaryNameNode 说明启动成功</li></ul></li><li><p>通过可视化界面查看HDFS的运行情况</p><ul><li>通过浏览器查看 主机ip:50070端口 </li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210622004022.png" alt=""></p><ul><li>Overview界面查看整体情况</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210622004044.png" alt=""></p><ul><li>Datanodes界面查看datanode的情况</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210622004102.png" alt=""></p></li></ul><h3 id="2-HDFS-shell操作"><a href="#2-HDFS-shell操作" class="headerlink" title="2 HDFS shell操作"></a>2 HDFS shell操作</h3><ul><li><p>调用文件系统(FS)Shell命令应使用 bin/hadoop fs <args>的形式</p><ul><li><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>使用方法：hadoop fs -ls <args></p><p>如果是文件，则按照如下格式返回文件信息：<br>文件名 &lt;副本数&gt; 文件大小 修改日期 修改时间 权限 用户ID 组ID<br>如果是目录，则返回它直接子文件的一个列表，就像在Unix中一样。目录返回列表的信息如下：<br>目录名 <dir> 修改日期 修改时间 权限 用户ID 组ID<br>示例：<br>hadoop fs -ls /user/hadoop/file1 /user/hadoop/file2 hdfs://host:port/user/hadoop/dir1 /nonexistentfile<br>返回值：<br>成功返回0，失败返回-1。 </p></li><li><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>使用方法：hadoop fs -text <src> </p><p>将源文件输出为文本格式。允许的格式是zip和TextRecordInputStream。</p></li><li><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>使用方法：hadoop fs -mv URI [URI …] <dest></p><p>将文件从源路径移动到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。不允许在不同的文件系统间移动文件。<br>示例：</p><ul><li>hadoop fs -mv /user/hadoop/file1 /user/hadoop/file2</li><li>hadoop fs -mv hdfs://host:port/file1 hdfs://host:port/file2 hdfs://host:port/file3 hdfs://host:port/dir1</li></ul><p>返回值：</p><p>成功返回0，失败返回-1。</p></li><li><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>使用方法：hadoop fs -put <localsrc> … <dst></p><p>从本地文件系统中复制单个或多个源路径到目标文件系统。也支持从标准输入中读取输入写入目标文件系统。</p><ul><li>hadoop fs -put localfile /user/hadoop/hadoopfile</li><li>hadoop fs -put localfile1 localfile2 /user/hadoop/hadoopdir</li><li>hadoop fs -put localfile hdfs://host:port/hadoop/hadoopfile</li><li>hadoop fs -put - hdfs://host:port/hadoop/hadoopfile<br>从标准输入中读取输入。</li></ul><p>返回值：</p><p>成功返回0，失败返回-1。</p></li><li><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>使用方法：hadoop fs -rm URI [URI …]</p><p>删除指定的文件。只删除非空目录和文件。请参考rmr命令了解递归删除。<br>示例：</p><ul><li>hadoop fs -rm hdfs://host:port/file /user/hadoop/emptydir</li></ul><p>返回值：</p><p>成功返回0，失败返回-1。</p></li></ul></li><li><p><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html">http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html</a></p></li></ul><h3 id="3-HDFS-shell操作练习"><a href="#3-HDFS-shell操作练习" class="headerlink" title="3 HDFS shell操作练习"></a>3 HDFS shell操作练习</h3><ul><li><p>在centos 中创建 test.txt  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch test.txt</span><br></pre></td></tr></table></figure></li><li><p>在centos中为test.txt 添加文本内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi test.txt</span><br></pre></td></tr></table></figure></li><li><p>在HDFS中创建 hadoop001/test 文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir -p /hadoop001/test</span><br></pre></td></tr></table></figure></li><li><p>把text.txt文件上传到HDFS中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put test.txt /hadoop001/test/</span><br></pre></td></tr></table></figure></li><li><p>查看hdfs中 hadoop001/test/test.txt 文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -cat /hadoop001/test/test.txt</span><br></pre></td></tr></table></figure></li><li><p>将hdfs中 hadoop001/test/test.txt文件下载到centos</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -get /hadoop001/test/test.txt test.txt</span><br></pre></td></tr></table></figure></li><li><p>删除HDFS中 hadoop001/test/</p><p>hadoop fs -rm -r /hadoop001</p></li></ul><h3 id="4-HDFS设计思路"><a href="#4-HDFS设计思路" class="headerlink" title="4 HDFS设计思路"></a>4 HDFS设计思路</h3><ul><li><p>分布式文件系统的设计思路：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210622004151.png" alt=""></p></li></ul><ul><li>HDFS的设计目标<ul><li>适合运行在通用硬件(commodity hardware)上的分布式文件系统</li><li>高度容错性的系统，适合部署在廉价的机器上</li><li>HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用</li><li>容易扩展，为用户提供性能不错的文件存储服务</li></ul></li></ul><h3 id="5-HDFS架构"><a href="#5-HDFS架构" class="headerlink" title="5 HDFS架构"></a>5 HDFS架构</h3><ul><li>1个NameNode/NN(Master)  带 DataNode/DN(Slaves) (Master-Slave结构)</li><li>1个文件会被拆分成多个Block</li><li>NameNode(NN)<ul><li>负责客户端请求的响应</li><li>负责元数据（文件的名称、副本系数、Block存放的DN）的管理<ul><li>元数据 MetaData 描述数据的数据</li></ul></li><li>监控DataNode健康状况 10分钟 <code>心跳</code> 没有收到DataNode报告认为Datanode死掉了。将数据再存储一份。</li></ul></li><li>DataNode(DN)<ul><li>存储用户的文件对应的数据块(Block)</li><li>要定期向NN发送心跳信息，汇报本身及其所有的block信息，健康状况</li></ul></li><li>分布式集群NameNode和DataNode部署在不同机器上</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210622004230.jpg" alt=""></p><ul><li>HDFS优缺点<ul><li>优点<ul><li>数据冗余 硬件容错</li><li>适合存储大文件</li><li>处理流式数据</li><li>可构建在廉价机器上</li></ul></li><li>缺点<ul><li>高延迟的数据访问。——在各个机器之间通讯，延迟高。</li><li>小文件存储。即使文件大小小于128M，它也会占128M的空间。</li></ul></li></ul></li></ul><h3 id="6-HDFS环境搭建"><a href="#6-HDFS环境搭建" class="headerlink" title="6 HDFS环境搭建"></a>6 HDFS环境搭建</h3><ul><li><p>下载jdk（java development kit,） 和 hadoop 放到 ~/software目录下 然后解压到 ~/app目录下</p><ul><li>因为大数据Hadoop等是用 java 开发的，java 需要在JVM上运行，而JDK就包含了JVM（JVM：java的虚拟机）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf 压缩包名字 -C ~/app/</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line">export JAVA_HOME=/home/hadoop/app/jdk1.8.0_91</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export HADOOP_HOME=/home/hadoop/app/hadoop......</span><br><span class="line">export PATH=$HADOOP_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">保存退出后</span></span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>进入到解压后的hadoop目录 修改配置文件</p><ul><li><p>配置文件作用</p><ul><li>core-site.xml  指定hdfs的访问方式</li><li>hdfs-site.xml  指定namenode 和 datanode 的数据存储位置</li><li>mapred-site.xml 配置mapreduce</li><li>yarn-site.xml  配置yarn</li></ul></li><li><p>修改hadoop-env.sh</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd etc/hadoop</span><br><span class="line">vi hadoop-env.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">找到下面内容添加java home</span></span><br><span class="line">export_JAVA_HOME=/home/hadoop/app/jdk1.8.0_91</span><br></pre></td></tr></table></figure><ul><li>修改 core-site.xml 在 <configuration>节点中添加</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop000:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改hdfs-site.xml 在 configuration节点中添加</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/app/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/app/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改 mapred-site.xml </li><li>默认没有这个 从模板文件复制 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><p>​    在mapred-site.xml  的configuration 节点中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改yarn-site.xml configuration 节点中添加</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>来到hadoop的bin目录——格式化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hadoop namenode -format (这个命令只运行一次)</span><br></pre></td></tr></table></figure></li><li><p>启动hdfs 进入到  sbin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start-dfs.sh</span><br></pre></td></tr></table></figure></li><li><p>启动启动yarn 在sbin中</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式文件系统-HDFS&quot;&gt;&lt;a href=&quot;#分布式文件系统-HDFS&quot; class=&quot;headerlink&quot; title=&quot;分布式文件系统 HDFS&quot;&gt;&lt;/a&gt;分布式文件系统 HDFS&lt;/h1&gt;&lt;p&gt;掌握目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;知道什么是hdfs&lt;/</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>17-Hadoop概述</title>
    <link href="https://xxren8218.github.io/20210621/17-Hadoop%E6%A6%82%E8%BF%B0.html"/>
    <id>https://xxren8218.github.io/20210621/17-Hadoop%E6%A6%82%E8%BF%B0.html</id>
    <published>2021-06-21T10:21:17.000Z</published>
    <updated>2021-06-24T16:48:20.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hadoop概述"><a href="#Hadoop概述" class="headerlink" title="Hadoop概述"></a>Hadoop概述</h2><p>掌握目标：</p><ul><li>知道Hadoop的概念及发展历史</li><li>说出hadoop的核心组件</li><li>知道hadoop的优势</li></ul><h3 id="1-什么是Hadoop"><a href="#1-什么是Hadoop" class="headerlink" title="1 什么是Hadoop"></a>1 什么是Hadoop</h3><ul><li><p>Hadoop名字的由来</p><ul><li>作者：Doug cutting</li><li>Hadoop项目作者的孩子给一个棕黄色的大象样子的填充玩具的命名</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181835.png" alt=""></p></li><li><p>Hadoop的概念:</p><ul><li>Apache™ Hadoop®  是一个开源的, <strong>可靠的</strong>(reliable), <strong>可扩展</strong>的(scalable)<strong>分布式计算框架</strong><ul><li>允许使用简单的编程模型跨计算机集群分布式处理大型数据集</li><li><strong>可扩展</strong>: 从单个服务器扩展到数千台计算机，每台计算机都提供本地计算和存储</li><li><strong>可靠的</strong>: 不依靠硬件来提供高可用性(high-availability)，而是在应用层检测和处理故障，从而在计算机集群之上提供高可用服务</li></ul></li></ul></li><li><p>Hadoop能做什么?</p><ul><li><p>搭建大型数据仓库</p></li><li><p>PB级数据的存储 处理 分析 统计等业务</p><ul><li><p>搜索引擎</p></li><li><p>日志分析</p></li><li><p>数据挖掘</p></li><li><p>商业智能(Business Intelligence，简称：BI)</p></li></ul></li></ul></li></ul><pre><code>  商业智能通常被理解为将企业中现有的数据(订单、库存、交易账目、客户和供应商等数据)转化为知识，帮助企业做出明智的业务经营决策的工具。从技术层面上讲，是数据仓库、数据挖掘等技术的综合运用。</code></pre><ul><li><p>Hadoop发展史</p><ul><li><p>2003-2004年 Google发表了三篇论文</p><ul><li>GFS：Google的分布式文件系统Google File System </li><li><a href="https://en.wikipedia.org/wiki/MapReduce">MapReduce</a>: Simplified Data Processing on Large Clusters </li><li>BigTable：一个大型的分布式数据库</li></ul></li><li>2006年2月Hadoop成为Apache的独立开源项目( Doug Cutting等人实现了DFS和MapReduce机制)。</li><li>2006年4月— 标准排序(10 GB每个节点)在188个节点上运行47.9个小时。 </li><li>2008年4月— 赢得世界最快1TB数据排序在900个节点上用时209秒。 </li><li>2008年— <strong>淘宝开始投入研究基于Hadoop的系统–云梯</strong>。云梯总容量约9.3PB，共有1100台机器，每天处理18000道作业，扫描500TB数据。 </li><li>2009年3月— <strong>Cloudera推出CDH（Cloudera’s Dsitribution Including Apache Hadoop）</strong></li><li>2009年5月— Yahoo的团队使用Hadoop对1 TB的数据进行排序只花了62秒时间。 </li><li>2009年7月— <strong>Hadoop Core项目更名为Hadoop Common;</strong> </li><li>2009年7月— <strong>MapReduce和Hadoop Distributed File System (HDFS)成为Hadoop项目的独立子项目。</strong></li><li>2012年11月— Apache Hadoop 1.0 Available</li><li>2018年4月— Apache Hadoop 3.1 Available</li><li>搜索引擎时代<ul><li>有保存大量网页的需求(单机  集群)</li><li>词频统计 <strong>【word count】</strong>  <strong>【PageRank】</strong></li></ul></li><li>数据仓库时代<ul><li>FaceBook推出Hive（Hive是基于<a href="https://baike.baidu.com/item/Hadoop/3526507">Hadoop</a>的一个<a href="https://baike.baidu.com/item/数据仓库/381916">数据仓库</a>工具）</li><li>曾经进行数分析与统计时, 仅限于数据库,受数据量和计算能力的限制, 我们只能对最重要的数据进行统计和分析(决策数据,财务相关)</li><li>Hive可以在Hadoop上运行SQL操作, 可以把运行日志, 应用采集数据,数据库数据放到一起分析</li></ul></li><li>数据挖掘时代<ul><li>啤酒尿不湿</li><li>关联分析</li><li>用户画像/物品画像</li></ul></li><li>机器学习时代  广义大数据<ul><li>大数据提高数据存储能力, 为机器学习提供燃料</li><li>alpha go</li><li>siri 小爱 天猫精灵</li></ul></li></ul></li></ul><h3 id="2-Hadoop核心组件"><a href="#2-Hadoop核心组件" class="headerlink" title="2 Hadoop核心组件"></a>2 Hadoop核心组件</h3><ul><li><p>Hadoop是所有搜索引擎的共性问题的廉价解决方案</p><ul><li>如何存储持续增长的海量网页:  单节点 V.S. 分布式存储</li><li>如何对持续增长的海量网页进行排序: 超算 V.S. 分布式计算</li><li>HDFS 解决分布式存储问题</li><li>MapReduce 解决分布式计算问题</li></ul></li><li><p><strong>Hadoop Common</strong>: The common utilities that support the other Hadoop modules.(hadoop的公共组件)—（如将HDFS和MapReduce串起来）</p></li><li><strong>Hadoop Distributed File System (HDFS™)</strong>: A distributed file system that provides high-throughput access to application data.(分布式文件系统)<ul><li>源自于Google的GFS论文, 论文发表于2003年10月</li><li>HDFS是GFS的开源实现</li><li>HDFS的特点:扩展性&amp;容错性&amp;海量数量存储</li><li>将文件切分成指定大小的数据块, 并在多台机器上保存多个副本（冗余、切割）</li><li>数据切分、多副本、容错等操作对用户是透明的——系统自动给用户拆分</li></ul></li><li>下面这张图是数据块多份复制存储的示意<ul><li>图中对于文件 /users/sameerp/data/part-0，其复制备份数设置为2, 存储的BlockID分别为1、3。</li><li>Block1的两个备份存储在DataNode0和DataNode2两个服务器上</li><li>Block3的两个备份存储在DataNode4和DataNode6两个服务器上</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181916.png" alt=""></p><ul><li><p><strong>Hadoop MapReduce</strong>: A YARN-based system for parallel processing of large data sets.</p><ul><li>分布式计算框架</li><li>源于Google的MapReduce论文，论文发表于2004年12月</li><li>MapReduce是GoogleMapReduce的开源实现</li><li>MapReduce特点:扩展性&amp;容错性&amp;海量数据离线处理（得等）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181942.png" alt=""></p></li><li><p><strong>Hadoop YARN</strong>: A framework for job scheduling and cluster resource management.(资源调度系统)</p><ul><li><p>YARN: Yet Another Resource Negotiator</p></li><li><p>负责整个集群资源的管理和调度</p></li><li><p>YARN特点:扩展性&amp;容错性&amp;多框架资源统一调度</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621182008.jpg" alt=""></p></li></ul></li></ul><h3 id="3-Hadoop优势"><a href="#3-Hadoop优势" class="headerlink" title="3 Hadoop优势"></a>3 Hadoop优势</h3><ul><li>高可靠<ul><li>数据存储: 数据块多副本</li><li>数据计算: 某个节点崩溃, 会自动重新调度作业计算</li></ul></li><li>高扩展性<ul><li>存储/计算资源不够时，可以横向的线性扩展机器</li><li>一个集群中可以包含数以千计的节点</li><li>集群可以使用廉价机器，成本低</li></ul></li><li>Hadoop生态系统成熟</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hadoop概述&quot;&gt;&lt;a href=&quot;#Hadoop概述&quot; class=&quot;headerlink&quot; title=&quot;Hadoop概述&quot;&gt;&lt;/a&gt;Hadoop概述&lt;/h2&gt;&lt;p&gt;掌握目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;知道Hadoop的概念及发展历史&lt;/li&gt;
&lt;li&gt;说</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>03-动态规划之 KMP 算法详解</title>
    <link href="https://xxren8218.github.io/20210621/03-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B-KMP-%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://xxren8218.github.io/20210621/03-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B-KMP-%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html</id>
    <published>2021-06-21T10:05:59.000Z</published>
    <updated>2021-06-21T10:14:07.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划之-KMP-算法详解"><a href="#动态规划之-KMP-算法详解" class="headerlink" title="动态规划之 KMP 算法详解"></a>动态规划之 KMP 算法详解</h2><p>KMP 算法（Knuth-Morris-Pratt 算法）是一个著名的字符串匹配算法，效率很高，但是确实有点复杂。</p><p>KMP 算法比较难理解。有一些优秀的同学通过手推 KMP 算法的过程来辅助理解该算法，这是一种办法，不过本文要从逻辑层面帮助读者理解算法的原理。十行代码之间，KMP 灰飞烟灭。</p><p><strong>先在开头约定，本文用<code>pat</code>表示模式串，长度为<code>M</code>，<code>txt</code>表示文本串，长度为<code>N</code>。KMP 算法是在<code>txt</code>中查找子串<code>pat</code>，如果存在，返回这个子串的起始索引，否则返回 -1</strong>。</p><p>为什么我认为 KMP 算法就是个动态规划问题呢，等会有解释。对于动态规划，之前多次强调了要明确<code>dp</code>数组的含义，而且同一个问题可能有不止一种定义<code>dp</code>数组含义的方法，不同的定义会有不同的解法。</p><p>常见的 KMP 算法应该是，一波诡异的操作处理<code>pat</code>后形成一个一维的数组<code>next</code>，然后根据这个数组经过又一波复杂操作去匹配<code>txt</code>。时间复杂度 O(N)，空间复杂度 O(M)。其实它这个<code>next</code>数组就相当于<code>dp</code>数组，其中元素的含义跟<code>pat</code>的前缀和后缀有关，判定规则比较复杂，不太好理解。</p><p>本文则用一个<strong>二维</strong>的<code>dp</code>数组（但空间复杂度还是 O(M)），重新定义其中元素的含义，使得代码长度大大减少，可解释性大大提高。</p><p>PS：原代码使用的数组名称是<code>dfa</code>（确定有限状态机），本文还是沿用<code>dp</code>数组的名称。</p><blockquote><h3 id="一、KMP-算法概述"><a href="#一、KMP-算法概述" class="headerlink" title="一、KMP 算法概述"></a>一、KMP 算法概述</h3></blockquote><p>首先还是简单介绍一下 KMP 算法和暴力匹配算法的不同在哪里，难点在哪里，和动态规划有啥关系。</p><p>暴力的字符串匹配算法很容易写，看一下它的运行逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力匹配</span></span><br><span class="line">def search(pat, txt):(pat-&gt;string, txt-&gt;string)</span><br><span class="line">    M = <span class="built_in">len</span>(pat)</span><br><span class="line">    N = <span class="built_in">len</span>(txt)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N - M + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 记录每次匹配成功的字串的元素个数</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">if</span> pat[j] != txt[i + j]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pat 全部匹配了</span></span><br><span class="line">        <span class="keyword">if</span> (count == M): <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">    <span class="comment"># txt 中不存在 pat 子串</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>对于暴力算法，如果出现不匹配字符，同时回退<code>txt</code>和<code>pat</code>的指针，嵌套 for 循环，时间复杂度 <em>O</em>(MN)，空间复杂度<em>O</em>(1)。最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。</p><p>比如 txt = “aaacaaab” pat = “aaab”：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621180706.gif" alt=""></p><center>暴力算法</center><p>很明显，<code>pat</code>中根本没有字符 c，根本没必要回退指针<code>i</code>，暴力解法明显多做了很多不必要的操作。</p><p>KMP 算法的不同之处在于，它会花费空间来记录一些信息，在上述情况中就会显得很聪明：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621180728.gif" alt=""></p><center>KMP算法</center><p>再比如类似的 txt = “aaaaaaab” pat = “aaab”，暴力解法还会和上面那个例子一样蠢蠢地回退指针<code>i</code>，而 KMP 算法又会耍聪明：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621180744.gif" alt=""></p><center>KMP算法</center><p>因为 KMP 算法知道字符 b 之前的字符 a 都是匹配的，所以每次只需要比较字符 b 是否被匹配就行了。</p><p><strong>KMP 算法永不回退<code>txt</code>的指针<code>i</code>，不走回头路（不会重复扫描<code>txt</code>），而是借助<code>dp</code>数组中储存的信息把<code>pat</code>移到正确的位置继续匹配</strong>，时间复杂度只需 O(N)，用空间换时间，所以我认为它是一种动态规划算法。</p><p>KMP 算法的难点在于，如何计算<code>dp</code>数组中的信息？如何根据这些信息正确地移动<code>pat</code>的指针？这个就需要<strong>确定有限状态自动机</strong>来辅助了，别怕这种高大上的文学词汇，其实和动态规划的<code>dp</code>数组如出一辙，等你学会了也可以拿这个词去吓唬别人。</p><p>还有一点需要明确的是：<strong>计算这个<code>dp</code>数组，只和<code>pat</code>串有关</strong>。意思是说，只要给我个<code>pat</code>，我就能通过这个模式串计算出<code>dp</code>数组，然后你可以给我不同的<code>txt</code>，我都不怕，利用这个<code>dp</code>数组我都能在 O(N) 时间完成字符串匹配。</p><p>具体来说，比如上文举的两个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">txt1 = <span class="string">&quot;aaacaaab&quot;</span> </span><br><span class="line">pat = <span class="string">&quot;aaab&quot;</span></span><br><span class="line">txt2 = <span class="string">&quot;aaaaaaab&quot;</span> </span><br><span class="line">pat = <span class="string">&quot;aaab&quot;</span></span><br></pre></td></tr></table></figure><p>我们的<code>txt</code>不同，但是<code>pat</code>是一样的，所以 KMP 算法使用的<code>dp</code>数组是同一个。只不过对于<code>txt1</code>的下面这个即将出现的未匹配情况：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621180840.png" alt=""></p><p><code>dp</code>数组指示<code>pat</code>这样移动：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621180857.jpg" alt=""></p><p>PS：这个<code>j</code>不要理解为索引，它的含义更准确地说应该是<strong>状态</strong>（state），所以它会出现这个奇怪的位置，后文会详述。</p><p>而对于<code>txt2</code>的下面这个即将出现的未匹配情况：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621180910.jpg" alt=""></p><p><code>dp</code>数组指示<code>pat</code>这样移动：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621180932.jpg" alt=""></p><p>明白了<code>dp</code>数组只和<code>pat</code>有关，那么我们这样设计 KMP 算法就会比较漂亮：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, pat</span>):</span></span><br><span class="line">        self.pat = pat</span><br><span class="line">        <span class="comment"># 通过 pat 构建 dp 数组</span></span><br><span class="line">        <span class="comment"># 需要 O(N) 时间</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, txt</span>):</span></span><br><span class="line">        <span class="comment"># 借助 dp 数组去匹配 txt</span></span><br><span class="line">        <span class="comment"># 需要 O(N) 时间</span></span><br></pre></td></tr></table></figure><p>这样，当我们需要用同一<code>pat</code>去匹配不同<code>txt</code>时，就不需要浪费时间构造<code>dp</code>数组了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kmp = KMP(<span class="string">&quot;aaab&quot;</span>)</span><br><span class="line">pos1 = kmp.search(<span class="string">&quot;aaacaaab&quot;</span>) <span class="comment"># 4</span></span><br><span class="line">pos2 = kmp.search(<span class="string">&quot;aaaaaaab&quot;</span>) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="二、状态机概述"><a href="#二、状态机概述" class="headerlink" title="二、状态机概述"></a>二、状态机概述</h3></blockquote><p>为什么说 KMP 算法和状态机有关呢？是这样的，我们可以认为<code>pat</code>的匹配就是状态的转移。比如当 pat = “ABABC”：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621180945.jpg" alt=""></p><p>如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（<code>pat.length</code>）是终止状态。开始匹配时<code>pat</code>处于起始状态，一旦转移到终止状态，就说明在<code>txt</code>中找到了<code>pat</code>。</p><p>比如说如果当前处于状态 2，就说明字符 “AB” 被匹配：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621180959.jpg" alt=""></p><p>另外，处于某个状态时，遇到不同的字符，<code>pat</code>状态转移的行为也不同。比如说假设现在匹配到了状态 4，如果遇到字符 A 就应该转移到状态 3，遇到字符 C 就应该转移到状态 5，如果遇到字符 B 就应该转移到状态 0：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181013.jpg" alt=""></p><p>具体什么意思呢，举例解释一下。用变量<code>j</code>表示指向当前状态的指针，当前<code>pat</code>匹配到了状态 4</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181025.jpg" alt=""></p><p>如果遇到了字符 “A”，根据箭头指示，转移到状态 3 是最聪明的：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181040.jpg" alt=""></p><p>如果遇到了字符 “B”，根据箭头指示，只能转移到状态 0（一夜回到解放前）：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181054.jpg" alt=""></p><p>如果遇到了字符 “C”，根据箭头指示，应该转移到终止状态 5，这也就意味着匹配完成：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181109.jpg" alt=""></p><p>当然了，还可能遇到其他字符，比如 Z，但是显然应该转移到起始状态 0，因为<code>pat</code>中根本都没有字符 Z：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181128.jpg" alt=""></p><p>这里为了清晰起见，我们画状态图时就把其他字符转移到状态 0 的箭头省略，只画<code>pat</code>中出现的字符的状态转移：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181141.jpg" alt=""></p><p>KMP 算法最关键的步骤就是构造这个状态转移图。<strong>要确定状态转移的行为，得明确两个变量，一个是当前的匹配状态，另一个是遇到的字符</strong>；确定了这两个变量后，就可以知道这个情况下应该转移到哪个状态。</p><p>下面看一下 KMP 算法根据这幅状态转移图匹配字符串<code>txt</code>的过程：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181156.gif" alt=""></p><p><strong>请记住这个 GIF 的匹配过程，这就是 KMP 算法的核心逻辑</strong>！</p><p>为了描述状态转移图，我们定义一个二维 dp 数组，它的含义如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dp[j][c] = <span class="built_in">next</span></span><br><span class="line"><span class="number">0</span> &lt;= j &lt; M，代表当前的状态</span><br><span class="line"><span class="number">0</span> &lt;= c &lt; <span class="number">256</span>，代表遇到的字符（ASCII 码）</span><br><span class="line"><span class="number">0</span> &lt;= <span class="built_in">next</span> &lt;= M，代表下一个状态</span><br><span class="line"></span><br><span class="line">dp[<span class="number">4</span>][<span class="string">&#x27;A&#x27;</span>] = <span class="number">3</span> 表示：</span><br><span class="line">当前是状态 <span class="number">4</span>，如果遇到字符 A，</span><br><span class="line">pat 应该转移到状态 <span class="number">3</span></span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>][<span class="string">&#x27;B&#x27;</span>] = <span class="number">2</span> 表示：</span><br><span class="line">当前是状态 <span class="number">1</span>，如果遇到字符 B，</span><br><span class="line">pat 应该转移到状态  <span class="number">2</span></span><br></pre></td></tr></table></figure><p>根据我们这个 dp 数组的定义和刚才状态转移的过程，我们可以先写出 KMP 算法的 search 函数代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">String txt</span>):</span></span><br><span class="line">    M = <span class="built_in">len</span>(pat)</span><br><span class="line">    N = <span class="built_in">len</span>(txt)</span><br><span class="line">    <span class="comment"># pat 的初始态为 0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="comment"># 当前是状态 j，遇到字符 txt[i]，</span></span><br><span class="line">        <span class="comment"># pat 应该转移到哪个状态？</span></span><br><span class="line">        j = dp[j][<span class="built_in">ord</span>(txt[i])]</span><br><span class="line">        <span class="comment"># 如果达到终止态，返回匹配开头的索引</span></span><br><span class="line">        <span class="keyword">if</span> j == M: <span class="keyword">return</span> i - M + <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 没到达终止态，匹配失败</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>注意：python的内置函数ord(“a”) 输出字符串的ASCII编码</li><li>python的内置函数chr(67) 输出ASCII编码对应的字符串</li></ul><p>到这里，应该还是很好理解的吧，<code>dp</code>数组就是我们刚才画的那幅状态转移图，如果不清楚的话回去看下 GIF 的算法演进过程。</p><p>下面讲解：如何通过<code>pat</code>构建这个<code>dp</code>数组？</p><blockquote><h3 id="三、构建状态转移图"><a href="#三、构建状态转移图" class="headerlink" title="三、构建状态转移图"></a>三、构建状态转移图</h3></blockquote><p>回想刚才说的：<strong>要确定状态转移的行为，必须明确两个变量，一个是当前的匹配状态，另一个是遇到的字符</strong>，而且我们已经根据这个逻辑确定了<code>dp</code>数组的含义，那么构造<code>dp</code>数组的框架就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= j &lt; M: <span class="comment"># 状态</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">0</span> &lt;= c &lt; <span class="number">256</span>: <span class="comment"># 字符</span></span><br><span class="line">        dp[j][c] = <span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>这个 next 状态应该怎么求呢？显然，<strong>如果遇到的字符<code>c</code>和<code>pat[j]</code>匹配的话</strong>，状态就应该向前推进一个，也就是说<code>next = j + 1</code>，我们不妨称这种情况为<strong>状态推进</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181226.jpg" alt=""></p><p><strong>如果遇到的字符<code>c</code>和<code>pat[j]</code>不匹配的话</strong>，状态就要回退（或者原地不动），我们不妨称这种情况为<strong>状态重启</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181239.jpg" alt=""></p><p>那么，如何得知在哪个状态重启呢？解答这个问题之前，我们再定义一个名字：<strong>影子状态</strong>（我编的名字），用变量<code>X</code>表示。<strong>所谓影子状态，就是和当前状态具有相同的前缀</strong>。比如下面这种情况：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181254.jpg" alt=""></p><p>当前状态<code>j = 4</code>，其影子状态为<code>X = 2</code>，它们都有相同的前缀 “AB”。因为状态<code>X</code>和状态<code>j</code>存在相同的前缀，所以当状态<code>j</code>准备进行状态重启的时候（遇到的字符<code>c</code>和<code>pat[j]</code>不匹配），可以通过<code>X</code>的状态转移图来获得<strong>最近的重启位置</strong>。</p><p>比如说刚才的情况，如果状态<code>j</code>遇到一个字符 “A”，应该转移到哪里呢？首先状态 4 只有遇到 “C” 才能推进状态，遇到 “A” 显然只能进行状态重启。<strong>状态<code>j</code>会把这个字符委托给状态<code>X</code>处理，也就是<code>dp[j][&#39;A&#39;] = dp[X][&#39;A&#39;]</code></strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181306.jpg" alt=""></p><p>为什么这样可以呢？因为：既然<code>j</code>这边已经确定字符 “A” 无法推进状态，<strong>只能回退</strong>，而且 KMP 算法就是要<strong>尽可能少的回退</strong>，以免多余的计算。那么<code>j</code>就可以去问问和自己具有相同前缀的<code>X</code>，如果<code>X</code>遇见 “A” 可以进行「状态推进」，那就转移过去，因为这样回退最少：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181317.gif" alt=""></p><p>当然，如果遇到的字符是 “B”，状态<code>X</code>也不能进行「状态推进」，只能回退，<code>j</code>只要跟着<code>X</code>指引的方向回退就行了：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181335.jpg" alt=""></p><p>你也许会问，这个<code>X</code>怎么知道遇到字符 “B” 要回退到状态 0 呢？因为<code>X</code>永远跟在<code>j</code>的身后，状态<code>X</code>如何转移，在之前就已经算出来了。动态规划算法不就是利用过去的结果解决现在的问题吗？</p><p>这样，我们就可以细化一下刚才的框架代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> c == <span class="built_in">ord</span>(pat[j]):</span><br><span class="line">            <span class="comment"># 状态推进</span></span><br><span class="line">            dp[j][c] = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 状态重启</span></span><br><span class="line">            <span class="comment"># 委托 X 计算重启位置</span></span><br><span class="line">            dp[j][c] = dp[X][c]</span><br></pre></td></tr></table></figure><blockquote><h3 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h3><ul><li>注意python如何生成二维矩阵</li></ul></blockquote><p>如果之前的内容你都能理解，恭喜你，现在就剩下一个问题：影子状态<code>X</code>是如何得到的呢？下面先直接看完整代码吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, pat</span>):</span></span><br><span class="line">        self.pat = pat</span><br><span class="line">        M = <span class="built_in">len</span>(pat)</span><br><span class="line">        <span class="comment"># dp[状态][字符] = 下个状态</span></span><br><span class="line">        self.dp = [[<span class="number">0</span>] * <span class="number">256</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M)]</span><br><span class="line">        <span class="comment">######################</span></span><br><span class="line">        <span class="comment">#     二维矩阵的生成    #</span></span><br><span class="line">        <span class="comment">#      M 行 256 列    #      </span></span><br><span class="line">        <span class="comment">######################</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        self.dp[<span class="number">0</span>][<span class="built_in">ord</span>(pat[<span class="number">0</span>])] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 影子状态 X 初始为 0</span></span><br><span class="line">        X = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 当前状态 j 从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, M):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">ord</span>(pat[j]) == c:</span><br><span class="line">                    self.dp[j][c] = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.dp[j][c] = self.dp[X][c]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新影子状态</span></span><br><span class="line">            X = self.dp[X][<span class="built_in">ord</span>(pat[j])]</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>先解释一下这一行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="built_in">ord</span>(pat[<span class="number">0</span>])] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这行代码是 base case，只有遇到 pat[0] 这个字符才能使状态从 0 转移到 1，遇到其它字符的话还是停留在状态 0。</p><p>影子状态<code>X</code>是先初始化为 0，然后随着<code>j</code>的前进而不断更新的。下面看看到底应该<strong>如何更新影子状态<code>X</code></strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, M)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># 更新影子状态</span></span><br><span class="line">    <span class="comment"># 当前是状态 X，遇到字符 pat[j],</span></span><br><span class="line">    <span class="comment"># pat 应该转移到哪个状态？</span></span><br><span class="line">    X = dp[X][<span class="built_in">ord</span>(pat[J])]</span><br></pre></td></tr></table></figure><p>更新<code>X</code>其实和<code>search</code>函数中更新状态<code>j</code>的过程是非常相似的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    <span class="comment"># 当前是状态 j，遇到字符 txt[i]，</span></span><br><span class="line">    <span class="comment"># pat 应该转移到哪个状态？</span></span><br><span class="line">    j = dp[j][<span class="built_in">ord</span>(txt[i])]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>其中的原理非常微妙</strong>，注意代码中 for 循环的变量初始值，可以这样理解：后者是在<code>txt</code>中匹配<code>pat</code>，前者是在<code>pat</code>中匹配<code>pat[1:]</code>，状态<code>X</code>总是落后状态<code>j</code>一个状态，与<code>j</code>具有最长的相同前缀。所以我把<code>X</code>比喻为影子状态，似乎也有一点贴切。</p><p>另外，构建 dp 数组是根据 base case<code>dp[0][..]</code>向后推演。这就是我认为 KMP 算法就是一种动态规划算法的原因。</p><p>下面来看一下状态转移图的完整构造过程，你就能理解状态<code>X</code>作用之精妙了：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210621181353.gif" alt=""></p><p>至此，KMP 算法就已经再无奥妙可言了！看下 KMP 算法的完整代码吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, pat</span>):</span></span><br><span class="line">        self.pat = pat</span><br><span class="line">        M = <span class="built_in">len</span>(pat)</span><br><span class="line">        <span class="comment"># dp[状态][字符] = 下个状态</span></span><br><span class="line">        self.dp = [[<span class="number">0</span>] * <span class="number">256</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M)]</span><br><span class="line">        <span class="comment">######################</span></span><br><span class="line">        <span class="comment">#     二维矩阵的生成    #</span></span><br><span class="line">        <span class="comment">#      M 行 256 列    #</span></span><br><span class="line">        <span class="comment">######################</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        self.dp[<span class="number">0</span>][<span class="built_in">ord</span>(pat[<span class="number">0</span>])] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 影子状态 X 初始为 0</span></span><br><span class="line">        X = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 当前状态 j 从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, M):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">ord</span>(pat[j]) == c:</span><br><span class="line">                    self.dp[j][c] = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.dp[j][c] = self.dp[X][c]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新影子状态</span></span><br><span class="line">            X = self.dp[X][<span class="built_in">ord</span>(pat[j])]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, txt</span>):</span></span><br><span class="line">        M = <span class="built_in">len</span>(self.pat)</span><br><span class="line">        N = <span class="built_in">len</span>(txt)</span><br><span class="line">        <span class="comment"># pat 的初始态为 0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 当前是状态 j，遇到字符 txt[i]，</span></span><br><span class="line">            <span class="comment"># pat 应该转移到哪个状态？</span></span><br><span class="line">            j = self.dp[j][<span class="built_in">ord</span>(txt[i])]</span><br><span class="line">            <span class="comment"># 如果达到终止态，返回匹配开头的索引</span></span><br><span class="line">            <span class="keyword">if</span> j == M: <span class="keyword">return</span> i - M + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 没到达终止态，匹配失败</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>经过之前的详细举例讲解，你应该可以理解这段代码的含义了，当然你也可以把 KMP 算法写成一个函数。核心代码也就是两个函数中 for 循环的部分，数一下有超过十行吗？</p><blockquote><h3 id="五、最后总结"><a href="#五、最后总结" class="headerlink" title="五、最后总结"></a>五、最后总结</h3></blockquote><p>传统的 KMP 算法是使用一个一维数组<code>next</code>记录前缀信息，而本文是使用一个二维数组<code>dp</code>以状态转移的角度解决字符匹配问题，但是空间复杂度仍然是 O(256M) = O(M)。</p><p>在<code>pat</code>匹配<code>txt</code>的过程中，只要明确了「<strong>当前处在哪个状态</strong>」和「<strong>遇到的字符是什么</strong>」这两个问题，就可以确定应该转移到哪个状态（推进或回退）。</p><p>对于一个模式串<code>pat</code>，其总共就有 M 个状态，对于 ASCII 字符，总共不会超过 256 种。所以我们就构造一个数组<code>dp[M][256]</code>来包含所有情况，并且明确<code>dp</code>数组的含义：</p><p><strong><code>dp[j][c] = next</code>表示，当前是状态<code>j</code>，遇到了字符<code>c</code>，应该转移到状态<code>next</code>。</strong></p><p>明确了其含义，就可以很容易写出 search 函数的代码。</p><p>对于如何构建这个<code>dp</code>数组，需要一个辅助状态<code>X</code>，它永远比当前状态<code>j</code>落后一个状态，拥有和<code>j</code>最长的相同前缀，我们给它起了个名字叫「影子状态」。</p><p>在构建当前状态<code>j</code>的转移方向时，只有字符<code>pat[j]</code>才能使状态推进（<code>dp[j][pat[j]] = j+1</code>）；而对于其他字符只能进行状态回退，应该去请教影子状态<code>X</code>应该回退到哪里（<code>dp[j][other] = dp[X][other]</code>，其中<code>other</code>是除了<code>pat[j]</code>之外所有字符）。</p><p>对于影子状态<code>X</code>，我们把它初始化为 0，并且随着<code>j</code>的前进进行更新，更新的方式和 search 过程更新<code>j</code>的过程非常相似（<code>X = dp[X][pat[j]]</code>）。</p><p>KMP 算法也就是动态规划的思路，是按照一套框架来的，无非就是描述问题逻辑，明确<code>dp</code>数组含义，定义 base case 这点破事。</p><p>希望这篇文章能让大家对动态规划有更深的理解，并摆脱被 KMP 算法支配的恐惧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;动态规划之-KMP-算法详解&quot;&gt;&lt;a href=&quot;#动态规划之-KMP-算法详解&quot; class=&quot;headerlink&quot; title=&quot;动态规划之 KMP 算法详解&quot;&gt;&lt;/a&gt;动态规划之 KMP 算法详解&lt;/h2&gt;&lt;p&gt;KMP 算法（Knuth-Morris-Pr</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer（五十六）：删除排序链表中重复的结点—2</title>
    <link href="https://xxren8218.github.io/20210617/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%E2%80%942.html"/>
    <id>https://xxren8218.github.io/20210617/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%E2%80%942.html</id>
    <published>2021-06-17T10:04:34.000Z</published>
    <updated>2021-06-17T10:05:39.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h1><p>在一个排序的[链表)中，存在重复的结点，请删除该[链表]中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;3-&gt;4-&gt;5。</p><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h1><p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p><p>具体地，我们从指针cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 cur 与 cur.next 对应的元素相同，那么我们就将 cur.next 从链表中移除；否则说明链表中已经不存在其它与 cur 对应的元素相同的节点，因此可以将 cur 指向 cur.next。</p><p>当遍历完整个链表之后，我们返回链表的头节点即可。</p><p><strong>细节</strong></p><p>当我们遍历到链表的最后一个节点时，cur.next 为空节点，如果不加以判断，访问 cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h1&gt;&lt;p&gt;在一个排序的[链表)中，存在重复的结点，请删除该[链表]中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&amp;g</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="链表" scheme="https://xxren8218.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
