<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-08-08T14:58:46.466Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>05-两两交换链表中的节点</title>
    <link href="https://xxren8218.github.io/20210808/05-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html"/>
    <id>https://xxren8218.github.io/20210808/05-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</id>
    <published>2021-08-08T14:57:21.000Z</published>
    <updated>2021-08-08T14:58:46.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225747.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目正常模拟就可以了。</p><p>建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。</p><p>接下来就是交换相邻两个元素了，<strong>此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序</strong></p><p>初始时，cur指向虚拟头结点，然后进行如下三步：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225801.png" alt=""></p><p>操作之后，链表如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225816.png" alt=""></p><p>看这个可能就更直观一些了：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225830.png" alt=""></p><p>对应的代码实现如下： （注释中详细和如上图中的三步做对应）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head) <span class="comment"># 设置一个虚拟头结点</span></span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>: </span><br><span class="line">            tmp = cur.<span class="built_in">next</span> <span class="comment"># 记录临时节点</span></span><br><span class="line">            tmp1 = cur.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># 记录临时节点</span></span><br><span class="line">            </span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>          <span class="comment"># 步骤一</span></span><br><span class="line">            cur.<span class="built_in">next</span>.<span class="built_in">next</span> = tmp               <span class="comment"># 步骤二</span></span><br><span class="line">            cur.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = tmp1         <span class="comment"># 步骤三</span></span><br><span class="line">            </span><br><span class="line">            cur = cur.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># cur移动两位，准备下一轮交换</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;两两交换链表中的节点&quot;&gt;&lt;/a&gt;两两交换链表中的节点&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>04-反转链表(双指针)</title>
    <link href="https://xxren8218.github.io/20210808/04-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88.html"/>
    <id>https://xxren8218.github.io/20210808/04-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%8F%8C%E6%8C%87%E9%92%88.html</id>
    <published>2021-08-08T14:54:25.000Z</published>
    <updated>2021-08-08T14:57:06.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反转链表-双指针"><a href="#反转链表-双指针" class="headerlink" title="反转链表(双指针)"></a>反转链表(双指针)</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225449.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。</p><p>其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表，如图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225507.png" alt=""></p><p>之前链表的头节点是元素1， 反转之后头结点就是元素5 ，这里并没有添加或者删除节点，仅仅是改表next指针的方向。</p><p>那么接下来看一看是如何反转呢？</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225632.gif" alt=""></p><p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p><p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p><p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p><p>接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。</p><p>最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。</p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 创建一个临时变量来存储cur后面的值</span></span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            <span class="comment"># 向前递推</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。</p><p>关键是初始化的地方，可能有的同学会不理解， 可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。</p><p>具体可以看代码（已经详细注释），<strong>双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">pre, cur</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> pre</span><br><span class="line">            <span class="comment"># 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span></span><br><span class="line">        <span class="comment"># pre = cur</span></span><br><span class="line">            <span class="comment"># cur = temp</span></span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> reverse(cur, tmp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">None</span>, head)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;反转链表-双指针&quot;&gt;&lt;a href=&quot;#反转链表-双指针&quot; class=&quot;headerlink&quot; title=&quot;反转链表(双指针)&quot;&gt;&lt;/a&gt;反转链表(双指针)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>03-设计链表</title>
    <link href="https://xxren8218.github.io/20210808/03-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html"/>
    <id>https://xxren8218.github.io/20210808/03-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html</id>
    <published>2021-08-08T14:52:07.000Z</published>
    <updated>2021-08-08T14:53:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225307.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>删除链表节点：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225325.png" alt=""></p><p>添加链表节点：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225342.png" alt=""></p><p>这道题目设计链表的五个接口：</p><ul><li>获取链表第index个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第index个节点前面插入一个节点</li><li>删除链表的第index个节点</li></ul><p>可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目</p><p><strong>链表操作的两种方式：</strong></p><ol><li>直接使用原来的链表来进行操作。</li><li>设置一个虚拟头结点在进行操作。</li></ol><p>下面采用的设置一个虚拟头结点（这样更方便一些，大家看代码就会感受出来）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__head = Node(<span class="number">0</span>) <span class="comment"># 添加虚拟头节点</span></span><br><span class="line">        self.__count = <span class="number">0</span>      <span class="comment"># 添加计数</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= index &lt; self.__count:</span><br><span class="line">            node = self.__head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):   <span class="comment"># 添加虚拟头节点此处需要加1</span></span><br><span class="line">                node = node.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 超出范围</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>, val)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(self.__count, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span>(<span class="params">self, index, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 判断范围</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>: index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> index &gt; self.__count: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行计数加一</span></span><br><span class="line">        self.__count += <span class="number">1</span></span><br><span class="line">        new_node = Node(val)</span><br><span class="line"></span><br><span class="line">        pre_node, cur_node = <span class="literal">None</span>, self.__head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">            pre_node, cur_node = cur_node, cur_node.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加新的节点</span></span><br><span class="line">        pre_node.<span class="built_in">next</span> = new_node</span><br><span class="line">        new_node.<span class="built_in">next</span> = cur_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 判断指标的对错</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= index &lt; self.__count:</span><br><span class="line">            <span class="comment"># 计数减一</span></span><br><span class="line">            self.__count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            pre_node, cur_node = <span class="literal">None</span>, self.__head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">                pre_node, cur_node = cur_node, cur_node.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 删除指定元素</span></span><br><span class="line">            pre_node.<span class="built_in">next</span>, cur_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span>, <span class="literal">None</span> </span><br><span class="line">        <span class="comment"># 超出范围</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计链表&quot;&gt;&lt;a href=&quot;#设计链表&quot; class=&quot;headerlink&quot; title=&quot;设计链表&quot;&gt;&lt;/a&gt;设计链表&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>02-移除链表元素(虚拟头结点)</title>
    <link href="https://xxren8218.github.io/20210808/02-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-%E8%99%9A%E6%8B%9F%E5%A4%B4%E7%BB%93%E7%82%B9.html"/>
    <id>https://xxren8218.github.io/20210808/02-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-%E8%99%9A%E6%8B%9F%E5%A4%B4%E7%BB%93%E7%82%B9.html</id>
    <published>2021-08-08T14:49:24.000Z</published>
    <updated>2021-08-08T14:51:50.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移除链表元素-虚拟头节点"><a href="#移除链表元素-虚拟头节点" class="headerlink" title="移除链表元素(虚拟头节点)"></a>移除链表元素(虚拟头节点)</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224948.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里以链表 1 4 2 4 来举例，移除元素4。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225006.png" alt=""></p><p>清理节点内存之后如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225024.png" alt=""></p><p><strong>如果使用java ，python的话就不用手动管理内存了。</strong></p><p>这种情况下的移除操作，就是让节点next指针直接指向下下一个节点就可以了，</p><p>那么因为单链表的特殊性，只能指向下一个节点，刚刚删除的是链表的中第二个，和第四个节点，那么如果删除的是头结点又该怎么办呢？</p><p>这里就涉及如下链表操作的两种方式：</p><ul><li><strong>直接使用原来的链表来进行删除操作。</strong></li><li><strong>设置一个虚拟头结点在进行删除操作。</strong></li></ul><p>来看第一种操作：直接使用原来的链表来进行移除。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225040.png" alt=""></p><p>移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p><p>所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225103.png" alt=""></p><p>依然别忘将原头结点从内存中删掉。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225119.png" alt=""></p><p>这样移除了一个头结点，是不是发现，在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。</p><p>那么可不可以 以一种统一的逻辑来移除 链表的节点呢。</p><p>其实<strong>可以设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p><p>来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808225134.png" alt=""></p><p>这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。</p><p>这样是不是就可以使用和移除链表其他节点的方式统一了呢？</p><p>来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。</p><p>最后呢在题目中，return 头结点的时候，别忘了 <code>return dummyNode.next</code>， 这才是新的头结点</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)  <span class="comment"># 添加一个虚拟头节点</span></span><br><span class="line">        cur = dummy_head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span>.val == val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>    <span class="comment"># 删除cur.next节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;移除链表元素-虚拟头节点&quot;&gt;&lt;a href=&quot;#移除链表元素-虚拟头节点&quot; class=&quot;headerlink&quot; title=&quot;移除链表元素(虚拟头节点)&quot;&gt;&lt;/a&gt;移除链表元素(虚拟头节点)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdeli</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>01-链表基础</title>
    <link href="https://xxren8218.github.io/20210808/01-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80.html"/>
    <id>https://xxren8218.github.io/20210808/01-%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-08-08T14:46:27.000Z</published>
    <updated>2021-08-08T14:49:09.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表基础"><a href="#链表基础" class="headerlink" title="链表基础"></a>链表基础</h2><p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点是又两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p><p>链接的入口点称为列表的头结点也就是head。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224657.png" alt=""></p><h3 id="1-链表的类型"><a href="#1-链表的类型" class="headerlink" title="1.链表的类型"></a>1.链表的类型</h3><p>接下来说一下链表的几种类型:</p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>刚刚说的就是单链表。</p><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>单链表中的节点只能指向节点的下一个节点。</p><p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p><p>双链表 既可以向前查询也可以向后查询。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224715.png" alt=""></p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表，顾名思义，就是链表首尾相连。</p><p>循环链表可以用来解决约瑟夫环问题。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224732.png" alt=""></p><h3 id="2-链表的存储方式"><a href="#2-链表的存储方式" class="headerlink" title="2.链表的存储方式"></a>2.链表的存储方式</h3><p>了解完链表的类型，再来说一说链表在内存中的存储方式。</p><p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p><p>链表是通过指针域的指针链接在内存中各个节点。</p><p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224748.png" alt=""></p><p>这个链表起始节点为2， 终止节点为7， 各个节点分布在内存个不同地址空间上，通过指针串联在一起。</p><h3 id="3-链表的定义"><a href="#3-链表的定义" class="headerlink" title="3.链表的定义"></a>3.链表的定义</h3><p>接下来说一说链表的定义。</p><p>链表节点的定义，很多同学在面试的时候都写不好。</p><p>这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p><p>而在面试的时候，一旦要自己手写链表，就写的错漏百出。</p><p>这里我给出python的定义链表节点方式，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;单链表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># cur游标，用来移动遍历节点</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># count记录数量</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        print(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表头部添加元素，头插法&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.<span class="built_in">next</span> = self.__head</span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;链表尾部添加元素, 尾插法&quot;&quot;&quot;</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.__head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, pos, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;指定位置添加元素</span></span><br><span class="line"><span class="string">        :param  pos 从0开始</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()-<span class="number">1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self.__head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos-<span class="number">1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 当循环退出后，pre指向pos-1位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除节点&quot;&quot;&quot;</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 先判断此结点是否是头节点</span></span><br><span class="line">                <span class="comment"># 头节点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.__head:</span><br><span class="line">                    self.__head = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ll = SingleLinkList()</span><br><span class="line">    print(ll.is_empty())</span><br><span class="line">    print(ll.length())</span><br><span class="line"></span><br><span class="line">    ll.append(<span class="number">1</span>)</span><br><span class="line">    print(ll.is_empty())</span><br><span class="line">    print(ll.length())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ll.append(<span class="number">2</span>)</span><br><span class="line">    ll.add(<span class="number">8</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.append(<span class="number">4</span>)</span><br><span class="line">    ll.append(<span class="number">5</span>)</span><br><span class="line">    ll.append(<span class="number">6</span>)</span><br><span class="line">    <span class="comment"># 8 1 2 3 4 5 6</span></span><br><span class="line">    ll.insert(-<span class="number">1</span>, <span class="number">9</span>) <span class="comment"># 9 8 1 23456</span></span><br><span class="line">    ll.travel()</span><br><span class="line">    ll.insert(<span class="number">3</span>, <span class="number">100</span>) <span class="comment"># 9 8 1 100 2 3456</span></span><br><span class="line">    ll.travel()</span><br><span class="line">    ll.insert(<span class="number">10</span>, <span class="number">200</span>) <span class="comment"># 9 8 1 100 23456 200</span></span><br><span class="line">    ll.travel()</span><br><span class="line">    ll.remove(<span class="number">100</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    ll.remove(<span class="number">9</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    ll.remove(<span class="number">200</span>)</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure><h3 id="4-链表的操作"><a href="#4-链表的操作" class="headerlink" title="4.链表的操作"></a>4.链表的操作</h3><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>删除D节点，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224811.png" alt=""></p><p>只要将C节点的next指针 指向E节点就可以了。</p><p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p><p>Java、Python，就有自己的内存回收机制，不用自己手动释放了。</p><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224826.png" alt=""></p><p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>再把链表的特性和数组的特性进行一个对比，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808224845.png" alt=""></p><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p><p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链表基础&quot;&gt;&lt;a href=&quot;#链表基础&quot; class=&quot;headerlink&quot; title=&quot;链表基础&quot;&gt;&lt;/a&gt;链表基础&lt;/h2&gt;&lt;p&gt;什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点是又两部分组成，一个是数据域一个是指针域（存放指向下一个节点的</summary>
      
    
    
    
    <category term="链表" scheme="https://xxren8218.github.io/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>06-螺旋矩阵问题</title>
    <link href="https://xxren8218.github.io/20210808/06-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210808/06-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98.html</id>
    <published>2021-08-07T16:13:14.000Z</published>
    <updated>2021-08-07T16:15:30.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001350.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目可以说在面试中出现频率较高的题目，<strong>本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</strong></p><p>要如何画出这个螺旋排列的正方形矩阵呢？</p><p>相信很多同学刚开始做这种题目的时候，上来就是一波判断猛如虎。</p><p>结果运行的时候各种问题，然后开始各种修修补补，最后发现改了这里哪里有问题，改了那里这里又跑不起来了。</p><p>大家还记得我们在这篇文章【二分查找】中讲解了二分法，提到如果要写出正确的二分法一定要坚持<strong>循环不变量原则</strong>。</p><p>而求解本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开的原则，来画一圈，大家看一下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001421.png" alt=""></p><p>这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。</p><p>这也是坚持了每条边左闭右开的原则。</p><p>一些同学做这道题目之所以一直写不好，代码越写越乱。</p><p>就是因为在画每一条边的时候，一会左开又闭，一会左闭右闭，一会又来左闭右开，岂能不乱。</p><p>代码如下，已经详细注释了每一步的目的，可以看出while循环里判断的情况是很多的，代码里处理的原则也是统一的左闭右开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right, up, down = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n -<span class="number">1</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化矩阵  n x n 的矩阵</span></span><br><span class="line">        matrix = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">            <span class="comment"># 从左到右</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                matrix[up][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上到下</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down + <span class="number">1</span>):</span><br><span class="line">                matrix[i][right] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从右到左</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                matrix[down][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从下到上</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                matrix[i][left] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001437.PNG" alt=""></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和上面的思路一样，不过这次不是给矩阵赋值而已。</p><ul><li>注意这里有个坑：这里不是方阵了，即m和n不一定一样。所以，需要添加一个判断。（更进去while的时候满足条件。通过第一步和第二步后不一定满足条件。）<ul><li>在第三步和第四步，需要额外添加判断。</li></ul></li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        left, right, up, down = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, m - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">            <span class="comment"># 从左往右</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[up][i])</span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上往下</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从右往左</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> up &lt;= down:</span><br><span class="line">                    res.append(matrix[down][i])</span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从下往上</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                    res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>由此可以得到螺旋打印的一个框架（无论是方阵与否）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right, up, down = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n -<span class="number">1</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化矩阵  n x n 的矩阵</span></span><br><span class="line">        matrix = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">            <span class="comment"># 从左到右</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                matrix[up][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上到下</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down + <span class="number">1</span>):</span><br><span class="line">                matrix[i][right] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从右到左</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> up &lt;= down:                   <span class="comment">##############</span></span><br><span class="line">                    matrix[down][i] = num</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从下到上</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> left &lt;= right:                <span class="comment">##############</span></span><br><span class="line">                    matrix[i][left] = num</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001512.PNG" alt=""></p><p>一样套路，这里就不写了。注意特殊情况的判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这三道题，我们总结出了顺时针打印矩阵的模板，以后按照模板写就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;螺旋矩阵II&quot;&gt;&lt;a href=&quot;#螺旋矩阵II&quot; class=&quot;headerlink&quot; title=&quot;螺旋矩阵II&quot;&gt;&lt;/a&gt;螺旋矩阵II&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>05-长度最小的子数组</title>
    <link href="https://xxren8218.github.io/20210808/05-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html"/>
    <id>https://xxren8218.github.io/20210808/05-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html</id>
    <published>2021-08-07T16:11:12.000Z</published>
    <updated>2021-08-07T16:12:55.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="长度最小值的子数组"><a href="#长度最小值的子数组" class="headerlink" title="长度最小值的子数组"></a>长度最小值的子数组</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001139.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p><p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001207.png" alt=""></p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, target, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        Sum = <span class="number">0</span>             <span class="comment"># 定义子数组的和</span></span><br><span class="line">        index = <span class="number">0</span>           <span class="comment"># 定义子数组的初始位置</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 定义子数组的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            Sum += nums[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> Sum &gt;= target:</span><br><span class="line">                res = <span class="built_in">min</span>(res, i - index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 重新选取子数组的范围</span></span><br><span class="line">                Sum -= nums[index]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><p><strong>为什么时间复杂度是O(n)</strong>。</p><p>不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;长度最小值的子数组&quot;&gt;&lt;a href=&quot;#长度最小值的子数组&quot; class=&quot;headerlink&quot; title=&quot;长度最小值的子数组&quot;&gt;&lt;/a&gt;长度最小值的子数组&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxre</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>04-有序数组的平方</title>
    <link href="https://xxren8218.github.io/20210808/04-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html"/>
    <id>https://xxren8218.github.io/20210808/04-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html</id>
    <published>2021-08-07T16:09:36.000Z</published>
    <updated>2021-08-07T16:10:57.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001038.PNG" alt=""></p><h3 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h3><p>直接写个lambda匿名函数将其按照绝对值排序，而后将每个元素变为二倍即可</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort(key = <span class="keyword">lambda</span> x: <span class="built_in">abs</span>(x))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] *= nums[i] </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h3 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h3><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>如动画所示：</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        i, j, k = <span class="number">0</span>, n - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">        ans = [-<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            lm = nums[i] ** <span class="number">2</span></span><br><span class="line">            rm = nums[j] ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> lm &gt; rm:</span><br><span class="line">                ans[k] = lm</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[k] = rm</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>这里还是说一下，大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。</strong></p><p>做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，</p><p>一样的代码多提交几次可能就击败百分之百了…..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有序数组的平方&quot;&gt;&lt;a href=&quot;#有序数组的平方&quot; class=&quot;headerlink&quot; title=&quot;有序数组的平方&quot;&gt;&lt;/a&gt;有序数组的平方&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>03-移除元素</title>
    <link href="https://xxren8218.github.io/20210808/03-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html"/>
    <id>https://xxren8218.github.io/20210808/03-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html</id>
    <published>2021-08-07T16:03:37.000Z</published>
    <updated>2021-08-07T16:09:17.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000407.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000429.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有的同学可能说了，多余的元素，删掉不就得了。</p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != val:</span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;移除元素&quot;&gt;&lt;a href=&quot;#移除元素&quot; class=&quot;headerlink&quot; title=&quot;移除元素&quot;&gt;&lt;/a&gt;移除元素&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>02-二分查找</title>
    <link href="https://xxren8218.github.io/20210808/02-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"/>
    <id>https://xxren8218.github.io/20210808/02-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</id>
    <published>2021-08-07T16:01:14.000Z</published>
    <updated>2021-08-07T16:02:39.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000143.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><p>下面我用这两种区间的定义分别讲解两种不同的二分写法。</p><h4 id="二分法第一种写法"><a href="#二分法第一种写法" class="headerlink" title="二分法第一种写法"></a>二分法第一种写法</h4><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p>例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000200.PNG" alt=""></p><p>代码如下：（详细注释）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>    <span class="comment"># 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:              <span class="comment"># 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            middle = (left + right) // <span class="number">2</span>  <span class="comment"># 防止溢出 等同于(left + right)//2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &lt; target:    </span><br><span class="line">                left = middle + <span class="number">1</span>         <span class="comment"># target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle - <span class="number">1</span>        <span class="comment"># target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">                <span class="keyword">return</span> middle             <span class="comment"># 数组中找到目标值，直接返回下标</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>                         <span class="comment"># 未找到目标值</span></span><br></pre></td></tr></table></figure><h4 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h4><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><p>在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（<strong>注意和方法一的区别</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000221.PNG" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left,right = <span class="number">0</span>, <span class="built_in">len</span>(nums)   <span class="comment"># 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:         <span class="comment"># 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:  </span><br><span class="line">                left = mid + <span class="number">1</span>        <span class="comment"># target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid         <span class="comment"># target 在左区间，在[left, middle)中</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> mid          <span class="comment"># 数组中找到目标值，直接返回下标 ###########注意</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>                   <span class="comment"># 未找到目标值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二分法是非常重要的基础算法，为什么很多同学对于二分法都是<strong>一看就会，一写就废</strong>？</p><p>其实主要就是对区间的定义没有理解清楚，在循环中没有始终坚持根据查找区间的定义来做边界处理。</p><p>区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。</p><p>本篇根据两种常见的区间定义，给出了两种二分法的写法，每一个边界为什么这么处理，都根据区间的定义做了详细介绍。</p><p>更多关于二分查找的技巧，<a href="https://xxren8218.github.io/20210615/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html">二分查找详解</a>里面有讲解寻找左边界和寻找右边界的二分查找的方法。</p><h3 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left,right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:        以使用 &lt;</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:  </span><br><span class="line">                left = mid + <span class="number">1</span>        </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid               <span class="comment">########</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                right = mid               <span class="comment">########</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left                       <span class="comment">########</span></span><br></pre></td></tr></table></figure><h3 id="寻找右侧边界的二分搜索"><a href="#寻找右侧边界的二分搜索" class="headerlink" title="寻找右侧边界的二分搜索"></a>寻找右侧边界的二分搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left,right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:        以使用 &lt;</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:  </span><br><span class="line">                left = mid + <span class="number">1</span>        </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid               <span class="comment">########</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                left = mid + <span class="number">1</span>            <span class="comment">########</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>                   <span class="comment">########           </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>01-数组基础</title>
    <link href="https://xxren8218.github.io/20210807/01-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80.html"/>
    <id>https://xxren8218.github.io/20210807/01-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-08-07T15:56:43.000Z</published>
    <updated>2021-08-07T15:58:06.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h2><p>数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力</p><p>也就是说，想法很简单，但实现起来 可能就不是那么回事了。</p><p>首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题</p><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p><p>举一个字符数组的例子，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235716.PNG" alt=""></p><p>需要两点注意的是</p><ul><li><strong>数组下标都是从0开始的。</strong></li><li><strong>数组内存空间的地址是连续的</strong></li></ul><p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p><p>例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235734.PNG" alt=""></p><p>那么二维数组直接上图，大家应该就知道怎么回事了</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235755.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组基础&quot;&gt;&lt;a href=&quot;#数组基础&quot; class=&quot;headerlink&quot; title=&quot;数组基础&quot;&gt;&lt;/a&gt;数组基础&lt;/h2&gt;&lt;p&gt;数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力&lt;/p&gt;
&lt;p&gt;也就是说，想</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>19-监控二叉树</title>
    <link href="https://xxren8218.github.io/20210807/19-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://xxren8218.github.io/20210807/19-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html</id>
    <published>2021-08-07T15:54:02.000Z</published>
    <updated>2021-08-07T15:56:22.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235445.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目首先要想，如何放置，才能让摄像头最小的呢？</p><p>从题目中示例，其实可以得到启发，<strong>我们发现题目示例中的摄像头都没有放在叶子节点上！</strong></p><p>这是很重要的一个线索，摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。</p><p>所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。</p><p>那么有同学可能问了，为什么不从头结点开始看起呢，为啥要从叶子节点看呢？</p><p>因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。</p><p><strong>所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</strong></p><p>局部最优推出全局最优，找不出反例，那么就按照贪心来！</p><p>此时，大体思路就是从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点。</p><p>此时这道题目还有两个难点：</p><ol><li>二叉树的遍历</li><li>如何隔两个节点放一个摄像头</li></ol><h4 id="确定遍历顺序"><a href="#确定遍历顺序" class="headerlink" title="确定遍历顺序"></a>确定遍历顺序</h4><p>在二叉树中如何从低向上推导呢？</p><p>可以使用后序遍历也就是左右中的顺序，这样就可以在回溯的过程中从下到上进行推导了。</p><p>后序遍历代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">cur</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 空节点，该节点有覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (终止条件) <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    left = traversal(cur-&gt;left);    # 左</span><br><span class="line">    right = traversal(cur-&gt;right);  # 右</span><br><span class="line"></span><br><span class="line">    逻辑处理                         <span class="comment"># 中</span></span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p><strong>注意在以上代码中我们取了左孩子的返回值，右孩子的返回值，即left 和 right， 以后推导中间节点的状态</strong></p><h4 id="如何隔两个节点放一个摄像头"><a href="#如何隔两个节点放一个摄像头" class="headerlink" title="如何隔两个节点放一个摄像头"></a>如何隔两个节点放一个摄像头</h4><p>此时需要状态转移的公式，大家不要和动态的状态转移公式混到一起，本题状态转移没有择优的过程，就是单纯的状态转移！</p><p>来看看这个状态应该如何转移，先来看看每个节点可能有几种状态：</p><p>有如下三种：</p><ul><li>该节点无覆盖</li><li>本节点有摄像头</li><li>本节点有覆盖</li></ul><p>我们分别有三个数字来表示：</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><p>大家应该找不出第四个节点的状态了。</p><p><strong>一些同学可能会想有没有第四种状态：本节点无摄像头，其实无摄像头就是 无覆盖 或者 有覆盖的状态，所以一共还是三个状态。</strong></p><p><strong>因为在遍历树的过程中，就会遇到空节点，那么问题来了，空节点究竟是哪一种状态呢？ 空节点表示无覆盖？ 表示有摄像头？还是有覆盖呢？</strong></p><p>回归本质，为了让摄像头数量最少，我们要尽量让叶子节点的父节点安装摄像头，这样才能摄像头的数量最少。</p><p>那么空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。</p><p><strong>所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了</strong></p><p>接下来就是递推关系。</p><p>那么递归的终止条件应该是遇到了空节点，此时应该返回2（有覆盖），原因上面已经解释过了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空节点，该节点有覆盖</span></span><br><span class="line"><span class="keyword">if</span> cur == <span class="literal">None</span>: <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>递归的函数，以及终止条件已经确定了，再来看单层逻辑处理。</p><p>主要有如下四类情况：</p><ul><li>情况1：左右节点都有覆盖</li></ul><p>左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235509.png" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左右节点都有覆盖</span></span><br><span class="line"><span class="keyword">if</span> left == <span class="number">2</span> <span class="keyword">and</span> right == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>情况2：左右节点至少有一个无覆盖的情况</li></ul><p>如果是以下情况，则中间节点（父节点）应该放摄像头：</p><p>left == 0 and right == 0 左右节点无覆盖 left == 1 and right == 0 左节点有摄像头，右节点无覆盖 left == 0 and right == 1 左节点有无覆盖，右节点摄像头 left == 0 and right == 2 左节点无覆盖，右节点覆盖 left == 2 and right == 0 左节点覆盖，右节点无覆盖</p><p>这个不难理解，毕竟有一个孩子没有覆盖，父节点就应该放摄像头。</p><p>此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span>:</span><br><span class="line">    result += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>情况3：左右节点至少有一个有摄像头</li></ul><p>如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）</p><p>left == 1 and right == 2 左节点有摄像头，右节点有覆盖 left == 2 and right == 1 左节点有覆盖，右节点有摄像头 left == 1 and right == 1 左右节点都有摄像头</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> left == <span class="number">1</span> <span class="keyword">or</span> right == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>从这个代码中，可以看出，如果left == 1, right == 0 怎么办？其实这种条件在情况2中已经判断过了</strong>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235526.png" alt=""></p><p>这种情况也是大多数同学容易迷惑的情况。</p><ul><li>情况4：头结点没有覆盖</li></ul><p>以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235546.png" alt=""></p><p>所以递归结束之后，还要判断根节点，如果没有覆盖，result++，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> traversal(root) == <span class="number">0</span>: <span class="comment"># root 无覆盖</span></span><br><span class="line">    result += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>以上四种情况我们分析完了，代码也差不多了，整体代码如下：</p><p>（<strong>以下我的代码注释很详细，为了把情况说清楚，特别把每种情况列出来。</strong>）</p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCameraCover</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 情况4</span></span><br><span class="line">        <span class="keyword">if</span> self.trversal(root) == <span class="number">0</span>:  <span class="comment"># root 无覆盖</span></span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trversal</span>(<span class="params">self, cur</span>):</span></span><br><span class="line">        <span class="comment"># 空节点，该节点有覆盖</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        left = self.trversal(cur.left)     <span class="comment"># 左</span></span><br><span class="line">        right = self.trversal(cur.right)   <span class="comment"># 右</span></span><br><span class="line">                                           <span class="comment"># 中</span></span><br><span class="line">        <span class="comment"># 情况1</span></span><br><span class="line">        <span class="comment"># 左右节点都有覆盖</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">2</span> <span class="keyword">and</span> right == <span class="number">2</span>:       </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况2</span></span><br><span class="line">        <span class="comment"># left == 0 and right == 0 左右节点无覆盖</span></span><br><span class="line">        <span class="comment"># left == 1 and right == 0 左节点有摄像头，右节点无覆盖</span></span><br><span class="line">        <span class="comment"># left == 0 and right == 1 左节点有无覆盖，右节点摄像头</span></span><br><span class="line">        <span class="comment"># left == 0 and right == 2 左节点无覆盖，右节点覆盖</span></span><br><span class="line">        <span class="comment"># left == 2 and right == 0 左节点覆盖，右节点无覆盖</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span>:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况3</span></span><br><span class="line">        <span class="comment"># left == 1 and right == 2 左节点有摄像头，右节点有覆盖</span></span><br><span class="line">        <span class="comment"># left == 2 and right == 1 左节点有覆盖，右节点有摄像头</span></span><br><span class="line">        <span class="comment"># left == 1 and right == 1 左右节点都有摄像头</span></span><br><span class="line">        <span class="comment"># 其他情况前段代码均已覆盖</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="number">1</span> <span class="keyword">or</span> right == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个 return -1 逻辑不会走到这里。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的难点首先是要想到贪心的思路，然后就是遍历和状态推导。</p><p>在二叉树上进行状态推导，其实难度就上了一个台阶了，需要对二叉树的操作非常娴熟。</p><p>这道题目是名副其实的hard，大家感受感受，哈哈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;监控二叉树&quot;&gt;&lt;a href=&quot;#监控二叉树&quot; class=&quot;headerlink&quot; title=&quot;监控二叉树&quot;&gt;&lt;/a&gt;监控二叉树&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>18_买卖股票的最佳时机含手续费</title>
    <link href="https://xxren8218.github.io/20210806/18-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html"/>
    <id>https://xxren8218.github.io/20210806/18-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html</id>
    <published>2021-08-05T16:05:52.000Z</published>
    <updated>2021-08-05T16:06:29.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000616.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题相对于【买卖股票的最佳时机II】，多添加了一个条件就是手续费。</p><p>在【买卖股票的最佳时机II】中使用贪心策略不用关心具体什么时候买卖，只要收集每天的正利润，最后稳稳的就是最大利润了。</p><p>而本题有了手续费，就要关系什么时候买卖了，因为计算所获得利润，需要考虑买卖利润可能不足以手续费的情况。</p><p>如果使用贪心策略，就是最低值买，最高值（如果算上手续费还盈利）就卖。</p><p>此时无非就是要找到两个点，买入日期，和卖出日期。</p><ul><li>买入日期：其实很好想，遇到更低点就记录一下。</li><li>卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。</li></ul><p>所以我们在做收获利润操作的时候其实有三种情况：</p><ul><li>情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润。</li><li>情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。</li><li>情况三：不作操作，保持原有状态（买入，卖出，不买不卖）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices, fee</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :type fee: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        minPrice = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 情况二，相当于买入</span></span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; minPrice: minPrice = prices[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况三，相当于保持原有状态</span></span><br><span class="line">            <span class="keyword">elif</span> prices[i] &gt;= minPrice <span class="keyword">and</span> prices[i] &lt;= minPrice + fee:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += prices[i] - minPrice -fee</span><br><span class="line">                minPrice = prices[i] - fee    <span class="comment"># 情况一，这一步很关键。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题贪心的思路其实是比较难的，动态规划才是常规做法，但也算是给大家拓展一下思路，感受一下贪心的魅力。</p><p>后期我们在讲解 股票问题系列的时候，会用动规的方式把股票问题穿个线。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;买卖股票的最佳时机含手续费&quot;&gt;&lt;a href=&quot;#买卖股票的最佳时机含手续费&quot; class=&quot;headerlink&quot; title=&quot;买卖股票的最佳时机含手续费&quot;&gt;&lt;/a&gt;买卖股票的最佳时机含手续费&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsde</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>17_单调递增的数字</title>
    <link href="https://xxren8218.github.io/20210806/17-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://xxren8218.github.io/20210806/17-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html</id>
    <published>2021-08-05T16:04:59.000Z</published>
    <updated>2021-08-05T16:05:39.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000527.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。</p><p>例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]-1，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p><p>这一点如果想清楚了，这道题就好办了。</p><p><strong>局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]-1，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数</strong>。</p><p><strong>全局最优：得到小于等于N的最大单调递增的整数</strong>。</p><p><strong>但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9</strong>。</p><p>此时是从前向后遍历还是从后向前遍历呢？</p><p>从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。</p><p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p><p><strong>所以从前后向遍历会改变已经遍历过的结果！</strong></p><p>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p><p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingDigits</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 先转化为单个数字的列表</span></span><br><span class="line">        a = <span class="built_in">list</span>(<span class="built_in">str</span>(n))</span><br><span class="line">        <span class="comment"># 倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 若前一个值大于后一个值，前一个值减一，后面的值为9</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(a[i]) &lt; <span class="built_in">int</span>(a[i - <span class="number">1</span>]):</span><br><span class="line">                a[i - <span class="number">1</span>] = <span class="built_in">str</span>(<span class="built_in">int</span>(a[i - <span class="number">1</span>]) - <span class="number">1</span>)</span><br><span class="line">                a[i:] = <span class="string">&quot;9&quot;</span> * (<span class="built_in">len</span>(a) - i)</span><br><span class="line">        <span class="comment"># 返回的时候再次进行拼接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(a))</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题只要想清楚个例，例如98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]减一，strNum[i]赋值9，这样这个整数就是89。就可以很自然想到对应的贪心解法了。</p><p>想到了贪心，还要考虑遍历顺序，只有从后向前遍历才能重复利用上次比较的结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单调递增的数字&quot;&gt;&lt;a href=&quot;#单调递增的数字&quot; class=&quot;headerlink&quot; title=&quot;单调递增的数字&quot;&gt;&lt;/a&gt;单调递增的数字&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>16_合并区间</title>
    <link href="https://xxren8218.github.io/20210806/16-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html"/>
    <id>https://xxren8218.github.io/20210806/16-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html</id>
    <published>2021-08-05T16:03:42.000Z</published>
    <updated>2021-08-05T16:04:43.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000413.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大家应该都感觉到了，此题一定要排序，那么按照左边界排序，还是右边界排序呢？</p><p>都可以！</p><p>那么我按照左边界排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。</p><p>局部最优可以推出全局最优，找不出反例，试试贪心。</p><p>那有同学问了，本来不就应该合并最大右边界么，这和贪心有啥关系？</p><p>有时候贪心就是常识！哈哈</p><p>按照左边界从小到大排序之后，如果 <code>intervals[i][0] &lt; intervals[i - 1][1]</code> 即intervals[i]左边界 &lt; intervals[i - 1]右边界，则一定有重复，因为intervals[i]的左边界一定是大于等于intervals[i - 1]的左边界。</p><p>即：intervals[i]的左边界在intervals[i - 1]左边界和右边界的范围内，那么一定有重复！</p><p>这么说有点抽象，看图：（<strong>注意图中区间都是按照左边界排序之后了</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000430.png" alt=""></p><p>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？</p><p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了。如果没有合并就把原区间加入到result数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type intervals: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(intervals) == <span class="number">0</span>: <span class="keyword">return</span> intervals</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 先进行排序</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先添加一个元素。</span></span><br><span class="line">        res.append(intervals[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行循环</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(intervals)):</span><br><span class="line">            last = res[-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 若满足前一个end大于后一个的start，一定有重叠。更新右边界。</span></span><br><span class="line">            <span class="keyword">if</span> last[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]:</span><br><span class="line">                res[-<span class="number">1</span>] = [last[<span class="number">0</span>], <span class="built_in">max</span>(last[<span class="number">1</span>], intervals[i][<span class="number">1</span>])]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(intervals[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于贪心算法，很多同学都是：<strong>如果能凭常识直接做出来，就会感觉不到自己用了贪心, 一旦第一直觉想不出来, 可能就一直想不出来了</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;合并区间&quot;&gt;&lt;a href=&quot;#合并区间&quot; class=&quot;headerlink&quot; title=&quot;合并区间&quot;&gt;&lt;/a&gt;合并区间&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>15_划分字母区间</title>
    <link href="https://xxren8218.github.io/20210806/15-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html"/>
    <id>https://xxren8218.github.io/20210806/15-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html</id>
    <published>2021-08-05T16:02:01.000Z</published>
    <updated>2021-08-05T16:03:09.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000231.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一想到分割字符串就想到了回溯，但本题其实不用回溯去暴力搜索。</p><p>题目要求同一字母最多出现在一个片段中，那么如何把同一个字母的都圈在同一个区间里呢？</p><p>如果没有接触过这种题目的话，还挺有难度的。</p><p>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p><p>可以分为如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000248.png" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 先建立字母表</span></span><br><span class="line">        <span class="built_in">hash</span> = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不断更新迭代字母表的最大索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="built_in">hash</span>[<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] = i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化left, right, result</span></span><br><span class="line">        left, right, result = <span class="number">0</span>, <span class="number">0</span>, []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对每个字母替换并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            right = <span class="built_in">max</span>(right, <span class="built_in">hash</span>[<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)])</span><br><span class="line">            <span class="keyword">if</span> i == right:</span><br><span class="line">                result.append(right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">                <span class="comment"># 初始化left</span></span><br><span class="line">                left = right + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;划分字母区间&quot;&gt;&lt;a href=&quot;#划分字母区间&quot; class=&quot;headerlink&quot; title=&quot;划分字母区间&quot;&gt;&lt;/a&gt;划分字母区间&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>14_无重叠区间</title>
    <link href="https://xxren8218.github.io/20210806/14-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html"/>
    <id>https://xxren8218.github.io/20210806/14-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html</id>
    <published>2021-08-05T16:00:37.000Z</published>
    <updated>2021-08-05T16:01:44.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000100.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>相信很多同学看到这道题目都冥冥之中感觉要排序，但是究竟是按照右边界排序，还是按照左边界排序呢？</strong></p><p>这其实是一个难点！</p><p>按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大，所以从左向右遍历，优先选右边界小的。</p><p>按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历。</p><p>如果按照左边界排序，还从左向右遍历的话，其实也可以，逻辑会有所不同。</p><p>一些同学做这道题目可能真的去模拟去重复区间的行为，这是比较麻烦的，还要去删除区间。</p><p>题目只是要求移除区间的个数，没有必要去真实的模拟删除区间！</p><p><strong>我来按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>此时问题就是要求非交叉区间的最大个数。</p><p>右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。</p><p>局部最优推出全局最优，试试贪心！</p><p>这里记录非交叉区间的个数还是有技巧的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000123.png" alt=""></p><p>区间，1，2，3，4，5，6都按照右边界排好序。</p><p>每次取非交叉区间的时候，都是可右边界最小的来做分割点（这样留给下一个区间的空间就越大），所以第一条分割线就是区间1结束的位置。</p><p>接下来就是找大于区间1结束位置的区间，是从区间4开始。<strong>那有同学问了为什么不从区间5开始？别忘已经是按照右边界排序的了</strong>。</p><p>区间4结束之后，在找到区间6，所以一共记录非交叉区间的个数是三个。</p><p>总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span>(<span class="params">self, intervals</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type intervals: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        count = <span class="number">1</span>  <span class="comment"># 记录非交叉区间的个数</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        end = intervals[<span class="number">0</span>][<span class="number">1</span>] <span class="comment"># 记录区间分割点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> end &lt;= intervals[i][<span class="number">0</span>]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                end = intervals[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - count</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题我认为难度级别可以算是hard级别的！</p><p>总结如下难点：</p><ul><li>难点一：一看题就有感觉需要排序，但究竟怎么排序，按左边界排还是右边界排。</li><li>难点二：排完序之后如何遍历，如果没有分析好遍历顺序，那么排序就没有意义了。</li><li>难点三：直接求重复的区间是复杂的，转而求最大非重复区间个数。</li><li>难点四：求最大非重复区间个数时，需要一个分割点来做标记。</li></ul><p><strong>这四个难点都不好想，但任何一个没想到位，这道题就解不了</strong>。</p><p>一些录友可能看网上的题解代码很简单，照葫芦画瓢稀里糊涂的就过了，但是其题解可能并没有把问题难点讲清楚，然后自己再没有钻研的话，那么一道贪心经典区间问题就这么浪费掉了。</p><p>贪心就是这样，代码有时候很简单（不是指代码短，而是逻辑简单），但想法是真的难！</p><p>这和动态规划还不一样，动规的代码有个递推公式，可能就看不懂了，而贪心往往是直白的代码，但想法读不懂，哈哈。</p><p><strong>所以我把本题的难点也一一列出，帮大家不仅代码看的懂，想法也理解的透彻！</strong></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>本题其实和【用最少数量的箭引爆气球】非常像，弓箭的数量就相当于是非交叉区间的数量，只要把弓箭那道题目代码里射爆气球的判断条件加个等号（认为[0，1][1，2]不是相邻区间），然后用总区间数减去弓箭数量 就是要移除的区间数量了。</p><p>把【用最少数量的箭引爆气球】代码稍做修改，就可以AC本题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无重叠区间&quot;&gt;&lt;a href=&quot;#无重叠区间&quot; class=&quot;headerlink&quot; title=&quot;无重叠区间&quot;&gt;&lt;/a&gt;无重叠区间&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>13_使用最少数量的箭引爆气球</title>
    <link href="https://xxren8218.github.io/20210805/13-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html"/>
    <id>https://xxren8218.github.io/20210805/13-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html</id>
    <published>2021-08-05T15:57:11.000Z</published>
    <updated>2021-08-05T15:58:30.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用最少数量的箭引爆气球"><a href="#使用最少数量的箭引爆气球" class="headerlink" title="使用最少数量的箭引爆气球"></a>使用最少数量的箭引爆气球</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210805235747.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如何使用最少的弓箭呢？</p><p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？</p><p>尝试一下举反例，发现没有这种情况。</p><p>那么就试一试贪心吧！</p><p><strong>局部最优：</strong>当气球出现重叠，一起射，所用弓箭最少。</p><p><strong>全局最优</strong>：把所有气球射爆所用弓箭最少。</p><p><strong>算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？</strong></p><p>如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。</p><p>但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remote气球，只要记录一下箭的数量就可以了。</p><p>以上为思考过程，已经确定下来使用贪心了，那么开始解题。</p><p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。</p><p>那么按照气球起始位置排序，还是按照气球终止位置排序呢？</p><p>其实都可以！只不过对应的遍历顺序不同，我就按照气球的起始位置排序了。</p><p>既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。</p><p>从前向后遍历遇到重叠的气球了怎么办？</p><p><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。</p><p>以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210805235806.png" alt=""></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，气球3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(points) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 进行排序</span></span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(points)):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果后一个区间的start大于前一个区间的end，那么需要一支箭。注意不能是&gt;=，题目说的是挨在一起也会爆。</span></span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 否则的话需要更新最小右区间，来尽可能确保下一次判断得start在此区间内。</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(nlogn)，因为有一个快排</li><li>空间复杂度O(1)</li></ul><p>可以看出代码并不复杂。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>注意题目中说的是：满足 xstart ≤ x ≤ xend，则该气球会被引爆。那么说明两个气球挨在一起不重叠也可以一起射爆，</p><p>所以代码中 <code>if (points[i][0] &gt; points[i - 1][1])</code> 不能是&gt;=</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题目贪心的思路很简单也很直接，就是重复的一起射了，但本题我认为是有难度的。</p><p>就算思路都想好了，模拟射气球的过程，很多同学真的要去模拟了，实时把气球从数组中移走，这么写的话就复杂了。</p><p>而且寻找重复的气球，寻找重叠气球最小右边界，其实都有代码技巧。</p><p>贪心题目有时候就是这样，看起来很简单，思路很直接，但是一写代码就感觉贼复杂无从下手。</p><p>这里其实是需要代码功底的，那代码功底怎么练？</p><p><strong>多看多写多总结！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用最少数量的箭引爆气球&quot;&gt;&lt;a href=&quot;#使用最少数量的箭引爆气球&quot; class=&quot;headerlink&quot; title=&quot;使用最少数量的箭引爆气球&quot;&gt;&lt;/a&gt;使用最少数量的箭引爆气球&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>12_根据身高重建队列</title>
    <link href="https://xxren8218.github.io/20210805/12-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210805/12-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html</id>
    <published>2021-08-05T15:52:06.000Z</published>
    <updated>2021-08-05T15:56:46.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210805235611.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后在按照另一个维度重新排列。</p><p>其实如果大家认真做了【 分发糖果】，就会发现和此题有点点的像。</p><p>在【分发糖果】就强调过一次，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</p><p><strong>如果两个维度一起考虑一定会顾此失彼</strong>。</p><p>对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还先按照k排序呢？</p><p>如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p><p>那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。</p><p><strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p><p>那么只需要按照k为下标重新插入队列就可以了，为什么呢？</p><p>以图中{5,2} 为例：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210805235630.png" alt=""></p><p>按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。</p><p>所以在按照身高从大到小排序后：</p><p><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong></p><p><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p><p>局部最优可推出全局最优，找不出反例，那就试试贪心。</p><p>排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]</p><p>插入的过程： 插入[7,0]：[[7,0]] 插入[7,1]：[[7,0],[7,1]] 插入[6,1]：[[7,0],[6,1],[7,1]] 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]] 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]] 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p><p>此时就按照题目的要求完成了重新排列。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type people: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 按照第一个索引的倒序，第二个索引的顺序排列peple列表 people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span></span><br><span class="line">        <span class="comment"># [[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]</span></span><br><span class="line">        people.sort(key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        queeue = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 直接在新的队列里面插入第二个索引位置即可。</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            queeue.insert(p[<span class="number">1</span>], p)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> queeue</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于出现两个维度一起考虑的情况，我们已经做过两道题目了，另一道就是【分发糖果】。</p><p><strong>其技巧都是确定一边然后贪心另一边，两边一起考虑，就会顾此失彼</strong>。</p><p>这道题目可以说比【分发糖果】难不少，其贪心的策略也是比较巧妙。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;根据身高重建队列&quot;&gt;&lt;a href=&quot;#根据身高重建队列&quot; class=&quot;headerlink&quot; title=&quot;根据身高重建队列&quot;&gt;&lt;/a&gt;根据身高重建队列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren821</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>11_柠檬水找零</title>
    <link href="https://xxren8218.github.io/20210805/11-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html"/>
    <id>https://xxren8218.github.io/20210805/11-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html</id>
    <published>2021-08-05T15:50:54.000Z</published>
    <updated>2021-08-05T15:51:50.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210805235134.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目刚一看，可能会有点懵，这要怎么找零才能保证完整全部账单的找零呢？</p><p><strong>但仔细一琢磨就会发现，可供我们做判断的空间非常少！</strong></p><p>只需要维护三种金额的数量，5，10和20。</p><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li></ul><p>此时大家就发现 情况一，情况二，都是固定策略，都不用我们来做分析了，而唯一不确定的其实在情况三。</p><p>而情况三逻辑也不复杂甚至感觉纯模拟就可以了，其实情况三这里是有贪心的。</p><p>账单是20的情况，为什么要优先消耗一个10和一个5呢？</p><p><strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p><p>所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。</p><p>局部最优可以推出全局最优，并找不出反例，那么就试试贪心算法！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span>(<span class="params">self, bills</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type bills: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 定义三张钱的个数</span></span><br><span class="line">        five, ten, twenty = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> bill <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="comment"># 情况1</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">5</span>:</span><br><span class="line">                five += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况2</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> five &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                five -= <span class="number">1</span></span><br><span class="line">                ten += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 情况3</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">20</span>:</span><br><span class="line">                <span class="keyword">if</span> ten &gt; <span class="number">0</span> <span class="keyword">and</span> five &gt; <span class="number">0</span>:</span><br><span class="line">                    five -= <span class="number">1</span></span><br><span class="line">                    ten -= <span class="number">1</span></span><br><span class="line">                    twenty += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> five &gt;= <span class="number">3</span>:</span><br><span class="line">                    five -= <span class="number">3</span></span><br><span class="line">                    twenty += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>咋眼一看好像很复杂，分析清楚之后，会发现逻辑其实非常固定。</p><p>这道题目可以告诉大家，遇到感觉没有思路的题目，可以静下心来把能遇到的情况分析一下，只要分析到具体情况了，一下子就豁然开朗了。</p><p>如果一直陷入想从整体上寻找找零方案，就会把自己陷进去，各种情况一交叉，只会越想越复杂了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;柠檬水找零&quot;&gt;&lt;a href=&quot;#柠檬水找零&quot; class=&quot;headerlink&quot; title=&quot;柠檬水找零&quot;&gt;&lt;/a&gt;柠檬水找零&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
