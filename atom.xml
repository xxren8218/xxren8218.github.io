<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-08-05T15:52:06.536Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>12_根据身高重建队列</title>
    <link href="https://xxren8218.github.io/20210805/12-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210805/12-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html</id>
    <published>2021-08-05T15:52:06.000Z</published>
    <updated>2021-08-05T15:52:06.536Z</updated>
    
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>11_柠檬水找零</title>
    <link href="https://xxren8218.github.io/20210805/11-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html"/>
    <id>https://xxren8218.github.io/20210805/11-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html</id>
    <published>2021-08-05T15:50:54.000Z</published>
    <updated>2021-08-05T15:51:50.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210805235134.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目刚一看，可能会有点懵，这要怎么找零才能保证完整全部账单的找零呢？</p><p><strong>但仔细一琢磨就会发现，可供我们做判断的空间非常少！</strong></p><p>只需要维护三种金额的数量，5，10和20。</p><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li></ul><p>此时大家就发现 情况一，情况二，都是固定策略，都不用我们来做分析了，而唯一不确定的其实在情况三。</p><p>而情况三逻辑也不复杂甚至感觉纯模拟就可以了，其实情况三这里是有贪心的。</p><p>账单是20的情况，为什么要优先消耗一个10和一个5呢？</p><p><strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p><p>所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。</p><p>局部最优可以推出全局最优，并找不出反例，那么就试试贪心算法！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span>(<span class="params">self, bills</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type bills: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 定义三张钱的个数</span></span><br><span class="line">        five, ten, twenty = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> bill <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="comment"># 情况1</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">5</span>:</span><br><span class="line">                five += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况2</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> five &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                five -= <span class="number">1</span></span><br><span class="line">                ten += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 情况3</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">20</span>:</span><br><span class="line">                <span class="keyword">if</span> ten &gt; <span class="number">0</span> <span class="keyword">and</span> five &gt; <span class="number">0</span>:</span><br><span class="line">                    five -= <span class="number">1</span></span><br><span class="line">                    ten -= <span class="number">1</span></span><br><span class="line">                    twenty += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> five &gt;= <span class="number">3</span>:</span><br><span class="line">                    five -= <span class="number">3</span></span><br><span class="line">                    twenty += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>咋眼一看好像很复杂，分析清楚之后，会发现逻辑其实非常固定。</p><p>这道题目可以告诉大家，遇到感觉没有思路的题目，可以静下心来把能遇到的情况分析一下，只要分析到具体情况了，一下子就豁然开朗了。</p><p>如果一直陷入想从整体上寻找找零方案，就会把自己陷进去，各种情况一交叉，只会越想越复杂了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;柠檬水找零&quot;&gt;&lt;a href=&quot;#柠檬水找零&quot; class=&quot;headerlink&quot; title=&quot;柠檬水找零&quot;&gt;&lt;/a&gt;柠檬水找零&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>11-爬楼梯</title>
    <link href="https://xxren8218.github.io/20210730/11-%E7%88%AC%E6%A5%BC%E6%A2%AF.html"/>
    <id>https://xxren8218.github.io/20210730/11-%E7%88%AC%E6%A5%BC%E6%A2%AF.html</id>
    <published>2021-07-30T15:11:53.000Z</published>
    <updated>2021-07-30T15:12:57.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730231221.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。</p><p>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。</p><p>那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。</p><p>所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。</p><p>我们来分析一下，动规五部曲：</p><p>定义一个一维数组来记录不同楼层的状态</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p><ol><li>确定递推公式</li></ol><p>如果可以推出dp[i]呢？</p><p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p><p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p><p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p><p>所以dp[i] = dp[i - 1] + dp[i - 2] 。</p><p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。</p><p>这体现出确定dp数组以及下标的含义的重要性！</p><ol><li>dp数组如何初始化</li></ol><p>在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。</p><p>那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。</p><p>例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。</p><p>但总有点牵强的成分。</p><p>那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.</p><p><strong>其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1</strong>。</p><p>从dp数组定义的角度上来说，dp[0] = 0 也能说得通。</p><p>需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。</p><p>所以本题其实就不应该讨论dp[0]的初始化！</p><p>我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。</p><p>所以我的原则是：不考虑dp[0]如果初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。</p><ol><li>确定遍历顺序</li></ol><p>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p><ol><li>举例推导dp数组</li></ol><p>举例当n为5的时候，dp table（dp数组）应该是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730231240.png" alt=""></p><p>如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。</p><p><strong>此时大家应该发现了，这不就是斐波那契数列么！</strong></p><p>唯一的区别是，没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义！</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>当然依然也可以，优化一下空间复杂度，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">0</span>] </span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> = dp[<span class="number">0</span>] + dp[<span class="number">1</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>]</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>后面将讲解的很多动规的题目其实都是当前状态依赖前两个，或者前三个状态，都可以做空间上的优化，<strong>但我个人认为面试中能写出版本一就够了哈，清晰明了，如果面试官要求进一步优化空间的话，我们再去优化</strong>。</p><p>因为版本一才能体现出动规的思想精髓，递推的状态变化。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。</p><p>这又有难度了，这其实是一个完全背包问题，但力扣上没有这种题目，所以后续在讲解背包问题的时候，今天这道题还会拿从背包问题的角度上来再讲一遍。</p><p>这里我先给出实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>): <span class="comment"># 把m换成2，就可以AC爬楼梯这道题</span></span><br><span class="line">                <span class="keyword">if</span> i - j &gt;= <span class="number">0</span>: </span><br><span class="line">             dp[i] += dp[i - j]</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p>代码中m表示最多可以爬m个台阶。</p><p><strong>以上代码不能运行哈，我主要是为了体现只要把m换成2，粘过去，就可以AC爬楼梯这道题，不信你就粘一下试试，哈哈</strong>。</p><p><strong>此时我就发现一个绝佳的大厂面试题</strong>，第一道题就是单纯的爬楼梯，然后看候选人的代码实现，如果把dp[0]的定义成1了，就可以发难了，为什么dp[0]一定要初始化为1，此时可能候选人就要强行给dp[0]应该是1找各种理由。那这就是一个考察点了，对dp[i]的定义理解的不深入。</p><p>然后可以继续发难，如果一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。这道题目leetcode上并没有原题，绝对是考察候选人算法能力的绝佳好题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题目和斐波那契数列基本是一样的，但是会发现本题相比它多了，为什么呢？</p><p>关键是 斐波那契数列 描述就已经把动规五部曲里的递归公式和如何初始化都给出来了，剩下几部曲也自然而然的推出来了。</p><p>而本题，就需要逐个分析了，大家现在应该初步感受出动规五部曲了。</p><p>简单题是用来掌握方法论的，例如昨天斐波那契的题目够简单了吧，但昨天和今天可以使用一套方法分析出来的，这就是方法论！</p><p>所以不要轻视简单题，那种凭感觉就刷过去了，其实和没掌握区别不大，只有掌握方法论并说清一二三，才能触类旁通，举一反三哈！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;爬楼梯&quot;&gt;&lt;a href=&quot;#爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;爬楼梯&quot;&gt;&lt;/a&gt;爬楼梯&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>10-斐波那契数列</title>
    <link href="https://xxren8218.github.io/20210730/10-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210730/10-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html</id>
    <published>2021-07-30T15:09:00.000Z</published>
    <updated>2021-07-30T15:11:34.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730230621.png" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>斐波那契数列大家应该非常熟悉不过了，非常适合作为动规第一道题目来练练手。</p><p>因为这道题目比较简单，可能一些同学并不需要做什么分析，直接顺手一写就过了。</p><p>通过这道题目让大家可以初步认识到，按照动规五部曲是如何解题的。</p><p>对于动规，如果没有方法论的话，可能简单题目可以顺手一写就过，难一点就不知道如何下手了。</p><p>所以我总结的动规五部曲，是要用来贯穿整个动态规划系列的，就像之前讲过【二叉树的递归三部曲】，【回溯法的回溯三部曲】一样。后面慢慢大家就会体会到，动规五部曲方法的重要性。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动规五部曲：</p><p>这里我们要用一个一维dp数组来保存递归的结果</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol><li>确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]</strong></p><ol><li>dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><ol><li>确定遍历顺序</li></ol><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2]中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 特殊值排除</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">        <span class="comment"># 构建数组（表）</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 确定遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>当然可以发现，我们只需要维护两个数值就可以了，不需要记录整个序列。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">        <span class="comment"># 构建数组（表）</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="number">2</span></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 确定遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> = dp[<span class="number">0</span>] + dp[<span class="number">1</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>]</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">sum</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>本题还可以使用递归解法来做</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> self.fib(n - <span class="number">1</span>) + self.fib(n - <span class="number">2</span>)   </span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(2^n)</li><li>空间复杂度：O(n) 算上了编程语言中实现递归的系统栈所占空间</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>斐波那契数列这道题目是非常基础的题目，我在后面的动态规划的讲解中将会多次提到斐波那契数列！</p><p>这里我严格按照动规五部曲来分析了这道题目，一些分析步骤可能同学感觉没有必要搞的这么复杂，代码其实上来就可以撸出来。</p><p>但我还是强调一下，简单题是用来掌握方法论的，动规五部曲将在接下来的动态规划讲解中发挥重要作用，敬请期待！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>09-再识动态规划</title>
    <link href="https://xxren8218.github.io/20210730/09-%E5%86%8D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html"/>
    <id>https://xxren8218.github.io/20210730/09-%E5%86%8D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html</id>
    <published>2021-07-30T15:07:54.000Z</published>
    <updated>2021-07-30T15:08:40.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="再识动态规划"><a href="#再识动态规划" class="headerlink" title="再识动态规划"></a>再识动态规划</h2><h3 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h3><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的，</p><p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p><p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p><p>所以贪心解决不了动态规划的问题。</p><p><strong>其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了</strong>。</p><p>而且很多讲解动态规划的文章都会讲最优子结构啊和重叠子问题啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。</p><p>大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。</p><p>上述提到的背包问题，后序会详细讲解。</p><h3 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h3><p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。</p><p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中</strong>。</p><p>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</p><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？</p><p><strong>因为一些情况是递推公式决定了dp数组要如何初始化！</strong></p><p>后面的讲解中我都是围绕着这五点来进行讲解。</p><p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p><p>其实 确定递推公式 仅仅是解题里的一步而已！</p><p>一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p><p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p><h3 id="动态规划应该如何debug"><a href="#动态规划应该如何debug" class="headerlink" title="动态规划应该如何debug"></a>动态规划应该如何debug</h3><p>相信动规的题目，很大部分同学都是这样做的。</p><p>看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递归公式，遍历顺序，处于一种黑盒的理解状态。</p><p>写动规题目，代码出问题很正常！</p><p><strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><p>一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。</p><p>这是一个很不好的习惯！</p><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。</p><p>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p><p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了</strong>。</p><p>这也是我为什么在动规五步曲里强调推导dp数组的重要性。</p><p>发出这样的问题之前，其实可以自己先思考这三个问题：</p><ul><li>这道题目我举例推导状态转移公式了么？</li><li>我打印dp数组的日志了么？</li><li>打印出来了dp数组和我想的一样么？</li></ul><p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。</p><p>然后在问问题，目的性就很强了。</p><p>所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何debug。</p><p>动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。</p><p>在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的01背包，leetcode上的题目都是01背包的应用，而没有纯01背包的问题，那么就需要在把对应的理论知识讲解一下。</p><p>大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。</p><p>这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;再识动态规划&quot;&gt;&lt;a href=&quot;#再识动态规划&quot; class=&quot;headerlink&quot; title=&quot;再识动态规划&quot;&gt;&lt;/a&gt;再识动态规划&lt;/h2&gt;&lt;h3 id=&quot;什么是动态规划&quot;&gt;&lt;a href=&quot;#什么是动态规划&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>10-分发糖果</title>
    <link href="https://xxren8218.github.io/20210730/10-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html"/>
    <id>https://xxren8218.github.io/20210730/10-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html</id>
    <published>2021-07-30T15:02:58.000Z</published>
    <updated>2021-07-30T15:07:04.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730230415.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p><p>此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p><p>局部最优可以推出全局最优。</p><p>如果ratings[i] &gt; ratings[i - 1] 那么[i]的糖 一定要比[i - 1]的糖多一个，所以贪心：candyVec[i] = candyVec[i - 1] + 1</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从前向后</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(ratings)):</span><br><span class="line">    <span class="keyword">if</span> ratings[i] &gt; ratings[i - <span class="number">1</span>]:</span><br><span class="line">        candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730230453.png" alt=""></p><p>再确定左孩子大于右孩子的情况（从后向前遍历）</p><p>遍历顺序这里有同学可能会有疑问，为什么不能从前向后遍历呢？</p><p>因为如果从前向后遍历，根据 ratings[i + 1] 来确定 ratings[i] 对应的糖果，那么每次都不能利用上前一次的比较结果了。</p><p><strong>所以确定左孩子大于右孩子的情况一定要从后向前遍历！</strong></p><p>如果 ratings[i] &gt; ratings[i + 1]，此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量）。</p><p>那么又要贪心了，局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量即大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p><p>局部最优可以推出全局最优。</p><p>所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730230621.png" alt=""></p><p>所以该过程代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从后向前</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ratings) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> ratings[i] &gt; ratings[i + <span class="number">1</span>]:</span><br><span class="line">        candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self, ratings</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type ratings: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        candyVec = [<span class="number">1</span>] * <span class="built_in">len</span>(ratings)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从前到后</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(ratings)):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i - <span class="number">1</span>]:</span><br><span class="line">                candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从后往前</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ratings) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i + <span class="number">1</span>]:</span><br><span class="line">                candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(candyVec)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这在leetcode上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p><p>那么本题我采用了两次贪心的策略：</p><ul><li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li><li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li></ul><p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分发糖果&quot;&gt;&lt;a href=&quot;#分发糖果&quot; class=&quot;headerlink&quot; title=&quot;分发糖果&quot;&gt;&lt;/a&gt;分发糖果&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>09-加油站</title>
    <link href="https://xxren8218.github.io/20210729/09-%E5%8A%A0%E6%B2%B9%E7%AB%99.html"/>
    <id>https://xxren8218.github.io/20210729/09-%E5%8A%A0%E6%B2%B9%E7%AB%99.html</id>
    <published>2021-07-29T11:11:43.000Z</published>
    <updated>2021-07-29T11:12:41.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210729191220.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="一、暴力解法"><a href="#一、暴力解法" class="headerlink" title="一、暴力解法"></a>一、暴力解法</h3><p>暴力的方法很明显就是O(n^2)的，遍历每一个加油站为起点的情况，模拟一圈。</p><p>如果跑了一圈，中途没有断油，而且最后油量大于等于0，说明这个起点是ok的。</p><p>暴力的方法思路比较简单，但代码写起来也不是很容易，关键是要模拟跑一圈的过程。</p><p><strong>「for循环适合模拟从头到尾的遍历，而while循环适合模拟环形遍历，要善于使用while！」</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span>(<span class="params">self, gas, cost</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cost)):</span><br><span class="line">            rest = gas[i] - cost[i]         <span class="comment"># 记录剩余油量</span></span><br><span class="line">            index = (i + <span class="number">1</span>) % <span class="built_in">len</span>(cost)     </span><br><span class="line">            <span class="keyword">while</span> rest &gt; <span class="number">0</span> <span class="keyword">and</span> index != i:  <span class="comment"># 模拟以i为起点行驶一圈</span></span><br><span class="line">                rest += gas[index] - cost[index]</span><br><span class="line">                index = (index + <span class="number">1</span>) % <span class="built_in">len</span>(cost)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> rest &gt;= <span class="number">0</span> <span class="keyword">and</span> index == i: <span class="keyword">return</span> i  <span class="comment"># 如果以i为起点跑一圈，剩余油量&gt;=0，返回该起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(n)</li></ul><p>暴力解法在leetcode上提交也可以过。2000多ms</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>直接从全局进行贪心选择，情况如下：</p><ul><li>情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</li><li>情况二：rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。</li><li>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span>(<span class="params">self, gas, cost</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curSum = <span class="number">0</span></span><br><span class="line">        <span class="built_in">min</span> = <span class="built_in">float</span>(<span class="string">&quot;INF&quot;</span>) <span class="comment"># 油箱里面油量的最小值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            rest = gas[i] - cost[i]</span><br><span class="line">            curSum += rest</span><br><span class="line">            <span class="keyword">if</span> curSum &lt; <span class="built_in">min</span>:</span><br><span class="line">                <span class="built_in">min</span> = curSum</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> curSum &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span> <span class="comment"># 情况1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">min</span> &gt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span>     <span class="comment"># 情况2</span></span><br><span class="line">                                 <span class="comment"># 情况3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            rest = gas[i] - cost[i]</span><br><span class="line">            <span class="built_in">min</span> += rest</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">min</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于本题首先给出了暴力解法，暴力解法模拟跑一圈的过程其实比较考验代码技巧的，要对while使用的很熟练。</p><p>然后给出了贪心算法，对于贪心方法，其实我认为就是一种直接从全局选取最优的模拟操作，思路还是好巧妙的，值得学习一下。</p><p>对于第二种贪心方法，才真正体现出贪心的精髓，用局部最优可以推出全局最优，进而求得起始位置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;加油站&quot;&gt;&lt;a href=&quot;#加油站&quot; class=&quot;headerlink&quot; title=&quot;加油站&quot;&gt;&lt;/a&gt;加油站&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>08-K次取反后最大的数组和</title>
    <link href="https://xxren8218.github.io/20210727/08-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html"/>
    <id>https://xxren8218.github.io/20210727/08-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html</id>
    <published>2021-07-27T14:43:50.000Z</published>
    <updated>2021-07-27T14:44:27.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="K次取反后最大化的数组和"><a href="#K次取反后最大化的数组和" class="headerlink" title="K次取反后最大化的数组和"></a>K次取反后最大化的数组和</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210727224414.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题思路其实比较好想了，如何可以让 数组和 最大呢？</p><p>贪心的思路，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。</p><p>局部最优可以推出全局最优。</p><p>那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。</p><p>那么又是一个贪心：局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。</p><p>虽然这道题目大家做的时候，可能都不会去想什么贪心算法，一鼓作气，就AC了。</p><p><strong>「我这里其实是为了给大家展现出来 经常被大家忽略的贪心思路，这么一道简单题，就用了两次贪心！」</strong></p><p>那么本题的解题步骤为：</p><ul><li>第一步：将数组按照绝对值大小从大到小排序，<strong>「注意要按照绝对值的大小」</strong></li><li>第二步：从前向后遍历，遇到负数将其变为正数，同时K-1</li><li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li><li>第四步：求和</li></ul><p>对应代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestSumAfterKNegations</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1.按绝对值从大到小排序</span></span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums, key=<span class="built_in">abs</span>, reverse=<span class="literal">True</span>) <span class="comment"># 将nums按绝对值从大到小排列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.从前向后遍历，遇到负数将其变为正数，同时K-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span> <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                nums[i] *= -<span class="number">1</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3.如果K还大于0，那么反复转变数值最小的元素，将K用完</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            nums[-<span class="number">1</span>] *= -<span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4.求和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>贪心的题目如果简单起来，会让人简单到开始怀疑：本来不就应该这么做么？这也算是算法？我认为这不是贪心？</p><p>本题其实很简单，不会贪心算法的同学都可以做出来，但是我还是全程用贪心的思路来讲解。</p><p>因为贪心的思考方式一定要有！</p><p><strong>「如果没有贪心的思考方式（局部最优，全局最优），很容易陷入贪心简单题凭感觉做，贪心难题直接不会做，其实这样就锻炼不了贪心的思考方式了」</strong>。</p><p>所以明知道是贪心简单题，也要靠贪心的思考方式来解题，这样对培养解题感觉很有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;K次取反后最大化的数组和&quot;&gt;&lt;a href=&quot;#K次取反后最大化的数组和&quot; class=&quot;headerlink&quot; title=&quot;K次取反后最大化的数组和&quot;&gt;&lt;/a&gt;K次取反后最大化的数组和&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>07-跳跃游戏II</title>
    <link href="https://xxren8218.github.io/20210727/07-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html"/>
    <id>https://xxren8218.github.io/20210727/07-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html</id>
    <published>2021-07-27T14:41:50.000Z</published>
    <updated>2021-07-27T14:43:34.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210727224227.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题相对于【跳跃游戏】还是难了不少。</p><p>但思路是相似的，还是要看最大覆盖范围。</p><p>本题要计算最小步数，那么就要想清楚什么时候步数才一定要加一呢？</p><p>贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。</p><p>思路虽然是这样，但在写代码的时候还不能真的就能跳多远跳远，那样就不知道下一步最远能跳到哪里了。</p><p><strong>「所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！」</strong></p><p><strong>「这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖」</strong>。</p><p>如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210727224242.jpg" alt=""></p><p><strong>「图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！（不用管具体怎么跳，反正一定可以跳到）」</strong></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>从图中可以看出来，就是移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。</p><p>这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时</p><ul><li>如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。</li><li>如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。</li></ul><p>代码如下：（详细注释）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        curDistance = <span class="number">0</span>                                        <span class="comment"># 当前覆盖的最远距离下标</span></span><br><span class="line">        ans = <span class="number">0</span>                                                <span class="comment"># 记录走的最大步数 </span></span><br><span class="line">        nextDistance = <span class="number">0</span>                                       <span class="comment"># 下一步覆盖的最远距离下标 </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):                             </span><br><span class="line">            nextDistance = <span class="built_in">max</span>(nums[i] + i, nextDistance)      <span class="comment"># 更新下一步覆盖最远距离下标</span></span><br><span class="line">            <span class="keyword">if</span> i == curDistance:                               <span class="comment"># 遇到当前覆盖最远距离下标</span></span><br><span class="line">                <span class="keyword">if</span> curDistance != <span class="built_in">len</span>(nums) - <span class="number">1</span>:               <span class="comment"># 如果当前覆盖最远距离下标不是终点</span></span><br><span class="line">                    ans += <span class="number">1</span>                                   <span class="comment"># 需要走下一步</span></span><br><span class="line">                    curDistance = nextDistance                 <span class="comment"># 更新当前覆盖最远距离下标（相当于加油了）</span></span><br><span class="line">                    <span class="keyword">if</span> nextDistance &gt;= <span class="built_in">len</span>(nums) - <span class="number">1</span>:          <span class="comment"># 下一步的覆盖范围已经可以达到终点，结束循环</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:                                          <span class="comment"># 当前覆盖最远距离下标是集合终点，不用做ans+1操作了，直接结束</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>依然是贪心，思路和方法一差不多，代码可以简洁一些。</p><p><strong>「针对于方法一的特殊情况，可以统一处理」</strong>，即：移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。</p><p>想要达到这样的效果，只要让移动下标，最大只能移动到len(nums) - 2的地方就可以了。</p><p>因为当移动下标指向len(nums) - 2时：</p><ul><li>如果移动下标等于当前覆盖最大距离下标， 需要再走一步（即ans++），因为最后一步一定是可以到的终点。（题目假设总是可以到达数组的最后一个位置），如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210727224300.png" alt=""></p><ul><li>如果移动下标不等于当前覆盖最大距离下标，说明当前覆盖最远距离就可以直接达到终点了，不需要再走一步。如图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210727224314.jpg" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span>             </span><br><span class="line">        curDistance = <span class="number">0</span>                                   <span class="comment"># 当前覆盖的最远距离下标</span></span><br><span class="line">        ans = <span class="number">0</span>                                           <span class="comment"># 记录走的最大步数 </span></span><br><span class="line">        nextDistance = <span class="number">0</span>                                  <span class="comment"># 下一步覆盖的最远距离下标 </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):                    <span class="comment"># 注意这里是len(nums) - 1，这是关键所在</span></span><br><span class="line">            nextDistance = <span class="built_in">max</span>(nums[i] + i, nextDistance) <span class="comment"># 更新下一步覆盖的最远距离下标</span></span><br><span class="line">            <span class="keyword">if</span> i == curDistance:                          <span class="comment"># 遇到当前覆盖的最远距离下标</span></span><br><span class="line">                curDistance = nextDistance                <span class="comment"># 更新当前覆盖的最远距离下标</span></span><br><span class="line">                ans += <span class="number">1</span>                                  <span class="comment"># 需要走下一步</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>可以看出版本二的代码相对于版本一简化了不少！</p><p>其精髓在于控制移动下标i只移动到nums.size() - 2的位置，所以移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不用考虑别的了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>相信大家可以发现，这道题目相当于【跳跃游戏】难了不止一点。</p><p>但代码又十分简单，贪心就是这么巧妙。</p><p>理解本题的关键在于：<strong>「以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点」</strong>，这个范围内最小步数一定可以跳到，不用管具体是怎么跳的，不纠结于一步究竟跳一个单位还是两个单位。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;跳跃游戏II&quot;&gt;&lt;a href=&quot;#跳跃游戏II&quot; class=&quot;headerlink&quot; title=&quot;跳跃游戏II&quot;&gt;&lt;/a&gt;跳跃游戏II&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>06-跳跃游戏</title>
    <link href="https://xxren8218.github.io/20210726/06-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html"/>
    <id>https://xxren8218.github.io/20210726/06-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html</id>
    <published>2021-07-26T10:53:46.000Z</published>
    <updated>2021-07-26T10:55:38.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210726185416.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>刚看到本题一开始可能想：当前位置元素如果是3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？</p><p>其实跳几步无所谓，关键在于可跳的覆盖范围！</p><p>不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。</p><p>这个范围内，别管是怎么跳的，反正一定可以跳过来。</p><p><strong>「那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！」</strong></p><p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p><p><strong>「贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点」</strong>。</p><p>局部最优推出全局最优，找不出反例，试试贪心！</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210726185520.png" alt=""></p><p>i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让i继续移动下去。</p><p>而cover每次只取 max(该元素数值补充后的范围, cover本身范围)。</p><p>如果cover大于等于了终点下标，直接return true就可以了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 只有一个元素肯定能到。</span></span><br><span class="line">        cover, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)         </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):              <span class="comment"># 遍历每个下标</span></span><br><span class="line">            <span class="keyword">if</span> i &lt;= cover:              <span class="comment"># 如果i在cover的覆盖范围内，才能往后走。</span></span><br><span class="line">                cover = <span class="built_in">max</span>(i + nums[i], cover)</span><br><span class="line">                <span class="keyword">if</span> cover &gt;= n - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题目关键点在于：不用拘泥于每次究竟跳跳几步，而是看覆盖范围，覆盖范围内已经是可以跳过来的，不用管是怎么跳的。</p><p>大家可以看出思路想出来了，代码还是非常简单的。</p><p>一些同学可能感觉，我在讲贪心系列的时候，题目和题目之间貌似没有什么联系？</p><p><strong>是真的就是没什么联系，因为贪心无套路！</strong> 没有个整体的贪心框架解决一些列问题，只能是接触各种类型的题目锻炼自己的贪心思维！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;跳跃游戏&quot;&gt;&lt;a href=&quot;#跳跃游戏&quot; class=&quot;headerlink&quot; title=&quot;跳跃游戏&quot;&gt;&lt;/a&gt;跳跃游戏&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>05-买卖股票的最佳时机II</title>
    <link href="https://xxren8218.github.io/20210726/05-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html"/>
    <id>https://xxren8218.github.io/20210726/05-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html</id>
    <published>2021-07-26T10:52:10.000Z</published>
    <updated>2021-07-26T10:53:31.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210726185251.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题首先要清楚两点：</p><ul><li>只有一只股票！</li><li>当前只有买股票或者买股票的操作</li></ul><p>想获得利润至少要两天为一个交易单元。</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>这道题目可能我们只会想，选一个低的买入，在选个高的卖，在选一个低的买入…..循环反复。</p><p><strong>「如果想到其实最终利润是可以分解的，那么本题就很容易了！」</strong></p><p>如果分解呢？</p><p>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。</p><p>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p><p><strong>「此时就是把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！」</strong></p><p>那么根据prices可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210726185315.png" alt=""></p><p>一些同学陷入：第一天怎么就没有利润呢，第一天到底算不算的困惑中。</p><p>第一天当然没有利润，至少要第二天才会有利润，所以利润的序列比股票序列少一天！</p><p>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>「收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间」</strong>。</p><p>那么只收集正利润就是贪心所贪的地方！</p><p><strong>「局部最优：收集每天的正利润，全局最优：求得最大利润」</strong>。</p><p>局部最优可以推出全局最优，找不出反例，试一试贪心！</p><p>最终代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            result += <span class="built_in">max</span>(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>) <span class="comment"># 取后一天比前一天的差大于零的结果即可。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 时间复杂度O(n)</span></span><br><span class="line"><span class="comment"># 空间复杂度O(1</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>股票问题其实是一个系列的，属于动态规划的范畴，因为目前在讲解贪心系列，所以股票问题会在之后的动态规划系列中详细讲解。</p><p><strong>「有时候，贪心往往比动态规划更巧妙，更好用，所以别小看了贪心算法」</strong>。</p><p><strong>「本题中理解利润拆分是关键点！」</strong> 不要整块的去看，而是把整体利润拆为每天的利润。</p><p>一旦想到这里了，很自然就会想到贪心了，即：只收集每天的正利润，最后稳稳的就是最大利润了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;买卖股票的最佳时机II&quot;&gt;&lt;a href=&quot;#买卖股票的最佳时机II&quot; class=&quot;headerlink&quot; title=&quot;买卖股票的最佳时机II&quot;&gt;&lt;/a&gt;买卖股票的最佳时机II&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>04-最大子序和</title>
    <link href="https://xxren8218.github.io/20210726/04-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html"/>
    <id>https://xxren8218.github.io/20210726/04-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html</id>
    <published>2021-07-26T10:50:58.000Z</published>
    <updated>2021-07-26T10:51:52.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210726185133.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>暴力解法的思路，第一层for 就是设置起始位置，第二层for循环遍历数组寻找最大值</p><p>时间复杂度：O(n^2) 空间复杂度：O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = -<span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)): <span class="comment"># 设置起始位置</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):       <span class="comment"># 每次从起始位置i开始遍历寻找最大值</span></span><br><span class="line">                count += nums[j]</span><br><span class="line">                <span class="keyword">if</span> count &gt; result:</span><br><span class="line">                    result = count</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>以上暴力的解法python6000ms勉强可以过，其他语言就不确定了。</p><h3 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h3><p><strong>「贪心贪的是哪里呢？」</strong></p><p>如果 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！</p><p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p>全局最优：选取最大“连续和”</p><p><strong>「局部最优的情况下，并记录最大的“连续和”，可以推出全局最优」</strong>。</p><p>从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。</p><p><strong>「这相当于是暴力解法中的不断调整最大子序和区间的起始位置」</strong>。</p><p><strong>「那有同学问了，区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？」</strong></p><p>区间的终止位置，其实就是如果count取到最大值了，及时记录下来了。例如如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> count &gt; result: result = count</span><br></pre></td></tr></table></figure><p><strong>「这样相当于是用result记录最大子序和区间和（变相的算是调整了终止位置）」</strong>。</p><p>红色的起始位置就是贪心每次取count为正数的时候，开始一个区间的统计。</p><p>那么不难写出如下python代码（关键地方已经注释）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = -<span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)): <span class="comment"># 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">            count += nums[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count &gt; result: result = count  <span class="comment"># 更新结果。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">0</span>: count = <span class="number">0</span>  <span class="comment"># 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><p>当然题目没有说如果数组为空，应该返回什么，所以数组为空的话返回啥都可以了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的贪心思路其实并不好想，这也进一步验证了，别看贪心理论很直白，有时候看似是常识，但贪心的题目一点都不简单！</p><p>后续将介绍的贪心题目都挺难的，哈哈，所以贪心很有意思，别小看贪心！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最大子序和&quot;&gt;&lt;a href=&quot;#最大子序和&quot; class=&quot;headerlink&quot; title=&quot;最大子序和&quot;&gt;&lt;/a&gt;最大子序和&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>03-摆动序列</title>
    <link href="https://xxren8218.github.io/20210725/03-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210725/03-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html</id>
    <published>2021-07-25T13:36:43.000Z</published>
    <updated>2021-07-25T13:37:44.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210725213704.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>相信这么一说吓退不少同学，这要求最大摆动序列又可以修改数组，这得如何修改呢？</p><p>来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？</p><p>用示例二来举例，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210725213719.png" alt=""></p><p><strong>「局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值」</strong>。</p><p><strong>「整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列」</strong>。</p><p>局部最优推出全局最优，并举不出反例，那么试试贪心！</p><p>（为方便表述，以下说的峰值都是指局部峰值）</p><p><strong>「实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）」</strong></p><p><strong>「这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点」</strong>。</p><p>本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。</p><p>例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</p><p>所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210725213731.png" alt=""></p><p>针对以上情形，result初始为1（默认最右面有一个峰值），此时curDiff &gt; 0 and preDiff &lt;= 0，那么result += 1（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        curDiff = <span class="number">0</span>            <span class="comment"># 当前一对差值</span></span><br><span class="line">        preDiff = <span class="number">0</span>            <span class="comment"># 前一对差值</span></span><br><span class="line">        result = <span class="number">1</span>             <span class="comment"># 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            curDiff = nums[i] - nums[i - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 有峰值的地方进行记录</span></span><br><span class="line">            <span class="keyword">if</span> curDiff &gt; <span class="number">0</span> <span class="keyword">and</span> preDiff &lt;= <span class="number">0</span> <span class="keyword">or</span> curDiff &lt; <span class="number">0</span> <span class="keyword">and</span> preDiff &gt;= <span class="number">0</span>:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                preDiff = curDiff</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>「贪心的题目说简单有的时候就是常识，说难就难在都不知道该怎么用贪心」</strong>。</p><p>本题大家如果要去模拟删除元素达到最长摆动子序列的过程，那指定绕里面去了，一时半会拔不出来。</p><p>而这道题目有什么技巧说一下子能想到贪心么？</p><p>其实也没有，类似的题目做过了就会想到。</p><p>此时大家就应该了解了：<strong>保持区间波动，只需要把单调区间上的元素移除就可以了。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摆动序列&quot;&gt;&lt;a href=&quot;#摆动序列&quot; class=&quot;headerlink&quot; title=&quot;摆动序列&quot;&gt;&lt;/a&gt;摆动序列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>02-分发饼干</title>
    <link href="https://xxren8218.github.io/20210725/02-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html"/>
    <id>https://xxren8218.github.io/20210725/02-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html</id>
    <published>2021-07-25T13:35:32.000Z</published>
    <updated>2021-07-25T13:36:24.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210725213559.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了了满足更多的小孩，就不要造成饼干尺寸的浪费。</p><p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p><p><strong>「这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩」</strong>。</p><p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p><p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210725213613.jpg" alt=""></p><p>这个例子可以看出饼干9只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type g: List[int]</span></span><br><span class="line"><span class="string">        :type s: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 分别排序孩子和饼干的列表</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 饼干的索引</span></span><br><span class="line">        index = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历孩子列表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(g) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 若饼干能满足孩子的胃口，结果加一。</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= <span class="number">0</span> <span class="keyword">and</span> s[index] &gt;= g[i]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment">######################</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">######################</span></span><br></pre></td></tr></table></figure><p>从代码中可以看出我用了一个index来控制饼干数组的遍历，遍历饼干并没有再起一个for循环，而是采用自减的方式，这也是常用的技巧。</p><p>有的同学看到要遍历两个数组，就想到用两个for循环，那样逻辑其实就复杂了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题是贪心很好的一道入门题目，思路还是比较容易想到的。</p><p>文中详细介绍了思考的过程，<strong>「想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，并想不出反例，那么就试一试贪心」</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分发饼干&quot;&gt;&lt;a href=&quot;#分发饼干&quot; class=&quot;headerlink&quot; title=&quot;分发饼干&quot;&gt;&lt;/a&gt;分发饼干&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>01-认识贪心算法</title>
    <link href="https://xxren8218.github.io/20210725/01-%E8%AE%A4%E8%AF%86%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html"/>
    <id>https://xxren8218.github.io/20210725/01-%E8%AE%A4%E8%AF%86%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</id>
    <published>2021-07-25T13:34:46.000Z</published>
    <updated>2021-07-25T13:35:20.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识贪心算法"><a href="#认识贪心算法" class="headerlink" title="认识贪心算法"></a>认识贪心算法</h2><h3 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="什么是贪心"></a>什么是贪心</h3><p><strong>「贪心的本质是选择每一阶段的局部最优，从而达到全局最优」</strong>。</p><p>这么说有点抽象，来举一个例子：</p><p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p><p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p><p>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p><p>再举一个例子如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。</p><h3 id="贪心的套路（什么时候用贪心）"><a href="#贪心的套路（什么时候用贪心）" class="headerlink" title="贪心的套路（什么时候用贪心）"></a>贪心的套路（什么时候用贪心）</h3><p>很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看就看出来是贪心。</p><p><strong>「说实话贪心算法并没有固定的套路」</strong>。</p><p>所以唯一的难点就是如何通过局部最优，推出整体最优。</p><p>那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？</p><p><strong>「不好意思，也没有！」</strong> 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。</p><p>有同学问了如何验证可不可以用贪心算法呢？</p><p><strong>「最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧」</strong>。</p><p>可有有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。</p><p>一般数学证明有如下两种方法：</p><ul><li>数学归纳法</li><li>反证法</li></ul><p>看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。</p><p><strong>「面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了」</strong>。</p><p>举一个不太恰当的例子：我要用一下1+1 = 2，但我要先证明1+1 为什么等于2。严谨是严谨了，但没必要。</p><p>虽然这个例子很极端，但可以表达这么个意思：<strong>「刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心」</strong>。</p><p><strong>「例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！」</strong></p><p>所以这也是为什么很多同学通过（accept）了贪心的题目，但都不知道自己用了贪心算法，<strong>「因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！」</strong></p><h3 id="贪心一般解题步骤"><a href="#贪心一般解题步骤" class="headerlink" title="贪心一般解题步骤"></a>贪心一般解题步骤</h3><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><p>其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪心的题目往往还和其他方面的知识混在一起。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇给出了什么是贪心以及大家关心的贪心算法固定套路。</p><p><strong>不好意思了，贪心没有套路，说白了就是常识性推导加上举反例。</strong></p><p>最后给出贪心的一般解题步骤，大家可以发现这个解题步骤也是比较抽象的，不像是二叉树，回溯算法，给出了那么具体的解题套路和模板。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;认识贪心算法&quot;&gt;&lt;a href=&quot;#认识贪心算法&quot; class=&quot;headerlink&quot; title=&quot;认识贪心算法&quot;&gt;&lt;/a&gt;认识贪心算法&lt;/h2&gt;&lt;h3 id=&quot;什么是贪心&quot;&gt;&lt;a href=&quot;#什么是贪心&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>17-解数独</title>
    <link href="https://xxren8218.github.io/20210723/17-%E8%A7%A3%E6%95%B0%E7%8B%AC.html"/>
    <id>https://xxren8218.github.io/20210723/17-%E8%A7%A3%E6%95%B0%E7%8B%AC.html</id>
    <published>2021-07-23T10:57:04.000Z</published>
    <updated>2021-07-23T10:58:34.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185733.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185747.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>棋盘搜索问题可以使用回溯法暴力搜索，只不过这次我们要做的是<strong>「二维递归\</strong>」*<em>*</em>。</p><p>怎么做<strong>二维递归</strong>呢？</p><p>大家已经跟着「代码随想录」刷过了如下回溯法题目，例如【组合】【分割】【子集】【排列】其实这些题目都是<strong>一维递归</strong>。</p><p>【N皇后问题】是因为每一行每一列只放一个皇后，只需要一层for循环遍历一行，递归来来遍历列，然后一行一列确定皇后的唯一位置。</p><p>本题就不一样了，<strong>「本题中棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更宽更深」</strong>。</p><p>因为这个树形结构太大了，我抽取一部分，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185801.png" alt=""></p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数以及参数</li></ul><p><strong>「递归函数的返回值需要是bool类型，为什么呢？」</strong></p><p>因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值，这一点在【N皇后】中已经介绍过了，一样的道理。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">board</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。</p><p><strong>「不用终止条件会不会死循环？」</strong></p><p>递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！</p><p><strong>「那么有没有永远填不满的情况呢？」</strong></p><p>这个问题我在递归单层搜索逻辑里在来讲！</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185801.png" alt=""></p><p>在树形图中可以看出我们需要的是一个<strong>二维递归</strong>（也就是两个for循环嵌套着递归）</p><p><strong>「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」</strong></p><p>代码如下：（<strong>「详细看注释」</strong>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">board</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):                <span class="comment"># 遍历行</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):         <span class="comment"># 遍历列</span></span><br><span class="line">        <span class="keyword">if</span> board[i][j] != <span class="string">&quot;.&quot;</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):              <span class="comment"># (i, j) 这个位置放k是否合适</span></span><br><span class="line">            <span class="keyword">if</span> isValid(i, j, k, board):</span><br><span class="line">                    board[i][j] = <span class="built_in">str</span>(k)       <span class="comment"># 放置k</span></span><br><span class="line">                    <span class="keyword">if</span> backtrack(board): <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 如果找到合适一组立刻返回</span></span><br><span class="line">                    board[i][j] = <span class="string">&quot;.&quot;</span>          <span class="comment"># 回溯，撤销k</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>                       <span class="comment"># 9个数都试完了，都不行，那么就返回False</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span>                            <span class="comment"># 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br></pre></td></tr></table></figure><p><strong>「注意这里return False的地方，这里放return False 是有讲究的」</strong>。</p><p>因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！</p><p>那么会直接返回， <strong>「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」</strong></p><h3 id="判断棋盘是否合法"><a href="#判断棋盘是否合法" class="headerlink" title="判断棋盘是否合法"></a>判断棋盘是否合法</h3><p>判断棋盘是否合法有如下三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>9宫格里是否重复</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">row, col, val, board</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):                       <span class="comment"># 判断行里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> board[row][i] == <span class="built_in">str</span>(val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):                       <span class="comment"># 判断列里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> board[j][col] == <span class="built_in">str</span>(val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    startRow = (row // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    startcol = (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startRow,startRow + <span class="number">3</span>):   <span class="comment"># 判断9方格里是否重复</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(startcol,startcol + <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="built_in">str</span>(val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>最后整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span>(<span class="params">self, board</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">board</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):                  <span class="comment"># 遍历行</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):           <span class="comment"># 遍历列</span></span><br><span class="line">                    <span class="keyword">if</span> board[i][j] != <span class="string">&quot;.&quot;</span>: <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):                <span class="comment"># (i, j) 这个位置放k是否合适</span></span><br><span class="line">                        <span class="keyword">if</span> isValid(i, j, k, board):</span><br><span class="line">                            board[i][j] = <span class="built_in">str</span>(k)         <span class="comment"># 放置k</span></span><br><span class="line">                            <span class="keyword">if</span> backtrack(board): <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 如果找到合适一组立刻返回</span></span><br><span class="line">                            board[i][j] = <span class="string">&quot;.&quot;</span>            <span class="comment"># 回溯，撤销k</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span>                         <span class="comment"># 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>                                  <span class="comment"># 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">row, col, val, board</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):                           <span class="comment"># 判断行里是否重复</span></span><br><span class="line">                <span class="keyword">if</span> board[row][i] == <span class="built_in">str</span>(val):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):                           <span class="comment"># 判断列里是否重复</span></span><br><span class="line">                <span class="keyword">if</span> board[j][col] == <span class="built_in">str</span>(val):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            startRow = (row // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">            startcol = (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startRow,startRow + <span class="number">3</span>):       <span class="comment"># 判断9方格里是否重复</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(startcol,startcol + <span class="number">3</span>):</span><br><span class="line">                    <span class="keyword">if</span> board[i][j] == <span class="built_in">str</span>(val):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        backtrack(board)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解数独可以说是非常难的题目了，如果还一直停留在单层递归的逻辑中，这道题目可以让大家瞬间崩溃。</p><p>所以我在开篇就提到了<strong>【二维递归】</strong>。</p><p><strong>「这样，解数独这么难的问题，也被我们攻克了」</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;解数独&quot;&gt;&lt;a href=&quot;#解数独&quot; class=&quot;headerlink&quot; title=&quot;解数独&quot;&gt;&lt;/a&gt;解数独&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>16-N皇后</title>
    <link href="https://xxren8218.github.io/20210723/16-N%E7%9A%87%E5%90%8E.html"/>
    <id>https://xxren8218.github.io/20210723/16-N%E7%9A%87%E5%90%8E.html</id>
    <published>2021-07-23T10:55:46.000Z</published>
    <updated>2021-07-23T10:56:48.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185615.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>都知道n皇后问题是回溯算法解决的经典问题，但是用回溯解决多了组合、切割、子集、排列问题之后，遇到这种二维矩阵还会有点不知所措。</p><p>首先来看一下皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p><p>下面我用一个3 * 3 的棋牌，将搜索过程抽象为一颗树，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185629.jpg" alt=""></p><p>从图中，可以看出，二维矩阵中矩阵的高就是这颗树的高度，矩阵的宽就是树型结构中每一个节点的宽度。</p><p>那么我们用皇后们的约束条件，来回溯搜索这颗树，<strong>「只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了」</strong>。</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><p>按照我总结的如下回溯模板，我们来依次分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">参数</span>)：</span></span><br><span class="line"><span class="function">    <span class="title">if</span> 终止条件:</span></span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）:</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表)  <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure><ul><li>递归函数参数</li></ul><p>我依然是定义全局变量二维数组result来记录最终结果。</p><p>参数n是棋牌的大小，然后用row来记录当前遍历到棋盘的第几层了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">chessboard = [[<span class="string">&quot;.&quot;</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">n, row, chessboard</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>在如下树形结构中：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185629.jpg" alt=""></p><p>可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果走到最后一行，说明已经找到一个解</span></span><br><span class="line"><span class="keyword">if</span> row == n:</span><br><span class="line">    <span class="comment"># 注意不能直接加进去，注意格式，需要再处理一下</span></span><br><span class="line">    <span class="comment"># result.append(chessboard)</span></span><br><span class="line">    <span class="keyword">if</span> row == n:</span><br><span class="line">        temp_res = []</span><br><span class="line">       <span class="keyword">for</span> temp <span class="keyword">in</span> chessboard:</span><br><span class="line">            temp_str = <span class="string">&quot;&quot;</span>.join(temp)</span><br><span class="line">            temp_res.append(temp_str)</span><br><span class="line">            </span><br><span class="line">        result.append(temp_res)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>单层搜索的逻辑</li></ul><p><strong>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</strong></p><p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">    <span class="keyword">if</span> isValid(row, col, chessboard, n):      <span class="comment"># 验证合法就可以放</span></span><br><span class="line">        chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>            <span class="comment"># 放置皇后</span></span><br><span class="line">        backtracking(n, row + <span class="number">1</span>, chessboard)</span><br><span class="line">        chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>            <span class="comment"># 回溯，撤销皇后</span></span><br></pre></td></tr></table></figure><ul><li>验证棋牌是否合法</li></ul><p>按照如下标准去重：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线 （45度和135度角）</li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, row, col, chessboard</span>):</span></span><br><span class="line">    <span class="comment"># 判断同一列是否冲突</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">        <span class="keyword">if</span> chessboard[i][col] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断45度是否冲突</span></span><br><span class="line">    i = row - <span class="number">1</span></span><br><span class="line">    j = col - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> chessboard[i][j] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 判断135度是否冲突</span></span><br><span class="line">    i = row - <span class="number">1</span></span><br><span class="line">    j = col + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(chessboard):</span><br><span class="line">        <span class="keyword">if</span> chessboard[i][j] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>在这份代码中，细心的同学可以发现为什么没有在同行进行检查呢？</p><p>因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p><p>那么按照这个模板不难写出如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n: <span class="keyword">return</span> []</span><br><span class="line">        chessboard = [[<span class="string">&quot;.&quot;</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        self.backtracking(n, <span class="number">0</span>, chessboard)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, n, row, chessboard</span>):</span></span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            temp_res = []</span><br><span class="line">            <span class="keyword">for</span> temp <span class="keyword">in</span> chessboard:</span><br><span class="line">                temp_str = <span class="string">&quot;&quot;</span>.join(temp)</span><br><span class="line">                temp_res.append(temp_str)</span><br><span class="line">            </span><br><span class="line">            self.result.append(temp_res)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> self.isValid(row, col, chessboard):</span><br><span class="line">                chessboard[row][col] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">                self.backtracking(n, row + <span class="number">1</span>, chessboard)</span><br><span class="line">                chessboard[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, row, col, chessboard</span>):</span></span><br><span class="line">        <span class="comment"># 判断同一列是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">if</span> chessboard[i][col] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断45度是否冲突</span></span><br><span class="line">        i = row - <span class="number">1</span></span><br><span class="line">        j = col - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> chessboard[i][j] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断135度是否冲突</span></span><br><span class="line">        i = row - <span class="number">1</span></span><br><span class="line">        j = col + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(chessboard):</span><br><span class="line">            <span class="keyword">if</span> chessboard[i][j] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是我们解决棋盘问题的第一道题目。</p><p>如果从来没有接触过N皇后问题的同学看着这样的题会感觉无从下手，可能知道要用回溯法，但也不知道该怎么去搜。</p><p><strong>「这里我明确给出了棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度，这样就可以套进回溯法的模板里了」</strong>。</p><p>大家可以在仔细体会体会！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;N皇后&quot;&gt;&lt;a href=&quot;#N皇后&quot; class=&quot;headerlink&quot; title=&quot;N皇后&quot;&gt;&lt;/a&gt;N皇后&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>15-重新安排行程</title>
    <link href="https://xxren8218.github.io/20210723/15-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html"/>
    <id>https://xxren8218.github.io/20210723/15-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html</id>
    <published>2021-07-23T10:53:43.000Z</published>
    <updated>2021-07-23T10:55:30.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185421.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185434.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目还是很难的，之前我们用回溯法解决了如下问题：【组合】【分割】【子集】【排列】问题。</p><p>直觉上来看 这道题和回溯法没有什么关系，更像是图论中的深度优先搜索。</p><p>实际上确实是深搜，但这是深搜中使用了回溯的例子，在查找路径的时候，如果不回溯，怎么能查到目标路径呢。</p><p>所以我倾向于说本题应该使用回溯法，那么我也用回溯法的思路来讲解本题，其实深搜一般都使用了回溯法的思路。</p><p><strong>「这里就是先给大家拓展一下，原来回溯法还可以这么玩！」</strong></p><p><strong>「这道题目有几个难点：」</strong></p><ol><li>一个行程中，如果航班处理不好容易变成一个圈，成为死循环</li><li>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</li><li>使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？</li><li>搜索的过程中，如何遍历一个机场所对应的所有机场。</li></ol><p>针对以上问题我来逐一解答！</p><h3 id="如何理解死循环"><a href="#如何理解死循环" class="headerlink" title="如何理解死循环"></a>如何理解死循环</h3><p>对于死循环，我来举一个有重复机场的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185449.jpg" alt=""></p><p>为什么要举这个例子呢，就是告诉大家，出发机场和到达机场也会重复的，<strong>「如果在解题的过程中没有对集合元素处理好，就会死循环。」</strong></p><h3 id="该记录映射关系"><a href="#该记录映射关系" class="headerlink" title="该记录映射关系"></a>该记录映射关系</h3><p>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</p><p>一个机场映射多个机场，机场之间要靠字母序排列，一个机场映射多个机场，可以使用 {‘JFK’: [‘SFO’, ‘ATL’], ‘SFO’: [‘ATL’], ‘ATL’: [‘JFK’, ‘SFO’]})</p><p><strong>「再说一下为什么一定要增删元素呢，正如开篇我给出的图中所示，出发机场和到达机场是会重复的，搜索的过程没及时删除目的机场就会死循环。」</strong></p><p>使用tickets_dict = defaultdict(list)来方便为不存在key的字典赋值为列表。</p><p>from collections import defaultdict</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>这道题目我使用回溯法，那么下面按照我总结的回溯模板来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">参数</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）:</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表) <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure><p>本题以输入：[[“JFK”, “KUL”], [“JFK”, “NRT”], [“NRT”, “JFK”]为例，抽象为树形结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185501.png" alt=""></p><p>开始回溯三部曲讲解：</p><ul><li>递归函数参数</li></ul><p>在讲解映射关系的时候，已经讲过了，用tickets_dict记录各个航班&lt;出发航班，[到达航班1，到达航班2…]&gt;信息，对其进行变量的传递。</p><p>代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;“出发航班”：[到达航班1，到达航班2...]&#125;</span></span><br><span class="line"></span><br><span class="line">tickets_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> tickets:</span><br><span class="line">    tickets_dict[item[<span class="number">0</span>]].append(item[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">def backtracking(tickets,start_point, tickets_dic): -&gt; 返回bool类型数据</span><br></pre></td></tr></table></figure><p><strong>「注意函数返回值是bool！」</strong></p><p>我们之前讲解回溯算法的时候，一般函数返回值都是None，这次为什么是bool呢？</p><p>因为我们只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185517.png" alt=""></p><p>所以找到了这个叶子节点了直接返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> tickets_dict:</span><br><span class="line">    <span class="comment"># 必须及时删除，避免出现死循环</span></span><br><span class="line">    end_point = tickets_dict[start_point].pop(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    path.append(end_point)</span><br><span class="line">    <span class="comment"># 只要找到一个就可以返回了</span></span><br><span class="line">    <span class="keyword">if</span> backtracking(tickets, end_point, tickets_dict):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    path.pop()</span><br><span class="line">    tickets_dict[start_point].append(end_point)</span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>拿题目中的示例为例，输入: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]] ，这是有4个航班，那么只要找出一种行程，行程里的机场个数是5就可以了。</p><p>所以终止条件是：我们回溯遍历的过程中，遇到的机场个数，如果达到了（航班数量+1），那么我们就找到了一个行程，把所有航班串在一起了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(result) == <span class="built_in">len</span>(tickets) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>已经看习惯回溯法代码的同学，到叶子节点了习惯性的想要收集结果，但发现并不需要，本题的path就是记录路径的（就一条），在如下单层搜索的逻辑中result就添加元素了。</p><ul><li>单层搜索的逻辑</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必须及时删除，避免出现死循环</span></span><br><span class="line">end_point = tickets_dict[start_point].pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">path.append(end_point)</span><br><span class="line"><span class="comment"># 只要找到一个就可以返回了</span></span><br><span class="line"><span class="keyword">if</span> backtracking(tickets, end_point, tickets_dict):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">path.pop()</span><br><span class="line">tickets_dict[start_point].append(end_point)</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path = [<span class="string">&quot;JFK&quot;</span>] </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span>(<span class="params">self, tickets</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type tickets: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        tickets_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="comment">#############################</span></span><br><span class="line">        <span class="comment"># 它的其他功能与dict相同，但会为一个不存在的键提供默认值，</span></span><br><span class="line">        <span class="comment">#############################</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> tickets:</span><br><span class="line">            tickets_dict[item[<span class="number">0</span>]].append(item[<span class="number">1</span>])</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        tickets_dict里面的内容是这样的</span></span><br><span class="line"><span class="string">         &#123;&#x27;JFK&#x27;: [&#x27;SFO&#x27;, &#x27;ATL&#x27;], &#x27;SFO&#x27;: [&#x27;ATL&#x27;], &#x27;ATL&#x27;: [&#x27;JFK&#x27;, &#x27;SFO&#x27;]&#125;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        self.backtracking(tickets, <span class="string">&quot;JFK&quot;</span>, tickets_dict)</span><br><span class="line">        <span class="keyword">return</span> self.path</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, tickets, start_point, tickets_dict</span>):</span></span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == <span class="built_in">len</span>(tickets) + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        tickets_dict[start_point].sort()</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> tickets_dict[start_point]:</span><br><span class="line">            <span class="comment"># 必须及时删除，避免出现死循环</span></span><br><span class="line">            end_point = tickets_dict[start_point].pop(<span class="number">0</span>)</span><br><span class="line">            self.path.append(end_point)</span><br><span class="line">            <span class="comment"># 只要找到一个就可以返回了</span></span><br><span class="line">            <span class="keyword">if</span> self.backtracking(tickets, end_point, tickets_dict):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            self.path.pop()</span><br><span class="line">            tickets_dict[start_point].append(end_point)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题其实可以算是一道hard的题目了，关于本题的难点我在文中已经列出了。</p><p><strong>「如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上」</strong>。</p><p>本题其实是一道深度优先搜索的题目，但是我完全使用回溯法的思路来讲解这道题题目，<strong>「算是给大家拓展一下思维方式，其实深搜和回溯也是分不开的，毕竟最终都是用递归」</strong>。</p><p>如果最终代码，发现照着回溯法模板画的话好像也能画出来，但难就难如何知道可以使用回溯，以及如何套进去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重新安排行程&quot;&gt;&lt;a href=&quot;#重新安排行程&quot; class=&quot;headerlink&quot; title=&quot;重新安排行程&quot;&gt;&lt;/a&gt;重新安排行程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>14-全排列二</title>
    <link href="https://xxren8218.github.io/20210723/14-%E5%85%A8%E6%8E%92%E5%88%97%E4%BA%8C.html"/>
    <id>https://xxren8218.github.io/20210723/14-%E5%85%A8%E6%8E%92%E5%88%97%E4%BA%8C.html</id>
    <published>2021-07-23T10:51:37.000Z</published>
    <updated>2021-07-23T10:53:23.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全排列二"><a href="#全排列二" class="headerlink" title="全排列二"></a>全排列二</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185221.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目和【排列问题】<strong>「给定一个可包含重复数字的序列」</strong>，要返回<strong>「所有不重复的全排列」</strong>。</p><p>这里又涉及到去重了。</p><p>在【求组合总和（三）】 、【求子集问题（二）】我们分别详细讲解了组合问题和子集问题如何去重。</p><p>那么排列问题其实也是一样的套路。</p><p><strong>「还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了」</strong>。</p><p>我以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185235.png" alt=""></p><p>图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。</p><p><strong>「一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果」</strong>。</p><p>在【排列问题】已经详解讲解了排列问题的写法，【求组合总和（三）】 、【求子集问题（二）】详细讲解的去重的写法，所以这次我就不用回溯三部曲分析了，直接给出代码，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path = []</span><br><span class="line">        self.result = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        self.backtracking(nums, used)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, nums, used</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            self.result.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> used[i] == <span class="literal">False</span>:</span><br><span class="line">                self.path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                self.backtracking(nums, used)</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line">                self.path.pop()</span><br></pre></td></tr></table></figure><p>大家发现，去重最为关键的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>: </span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p><strong>「如果改成 <code>used[i - 1] == true</code>， 也是正确的!」</strong>，去重代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">True</span> </span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用<code>used[i - 1] == False</code>，如果要对树枝前一位去重用<code>used[i - 1] == True</code>。</p><p><strong>「对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！」</strong></p><p>这么说是不是有点抽象？</p><p>来来来，我就用输入: [1,1,1] 来举一个例子。</p><p>树层上去重(used[i - 1] == False)，的树形结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185252.png" alt=""></p><p>树枝上去重（used[i - 1] == True）的树型结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185308.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题其实还是用了我们之前讲过的去重思路，但有意思的是，去重的代码中，这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>: </span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>和这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">True</span>: </span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>都是可以的，这也是很多同学做这道题目困惑的地方，知道<code>used[i - 1] == False</code>也行而<code>used[i - 1] == True</code>也行，但是就想不明白为啥。</p><p>所以我通过举[1,1,1]的例子，把这两个去重的逻辑分别抽象成树形结构，大家可以一目了然：为什么两种写法都可以以及哪一种效率更高！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;全排列二&quot;&gt;&lt;a href=&quot;#全排列二&quot; class=&quot;headerlink&quot; title=&quot;全排列二&quot;&gt;&lt;/a&gt;全排列二&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>13-全排列</title>
    <link href="https://xxren8218.github.io/20210722/13-%E5%85%A8%E6%8E%92%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210722/13-%E5%85%A8%E6%8E%92%E5%88%97.html</id>
    <published>2021-07-22T10:59:03.000Z</published>
    <updated>2021-07-22T11:00:00.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185925.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>此时我们已经学习了【组合问题】【切割问题】和【子集问题】，接下来看一看排列问题。</p><p>相信这个排列问题就算是让你用for循环暴力把结果搜索出来，这个暴力也不是很好写。</p><p>为什么回溯法是暴力搜索，效率这么低，还要用它？这就是原因。</p><p><strong>「因为一些问题能暴力搜出来就已经很不错了！」</strong></p><p>我以[1,2,3]为例，抽象成树形结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185941.png" alt=""></p><h2 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h2><ul><li>递归函数参数</li></ul><p><strong>「首先排列是有序的，也就是说[1,2] 和[2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方」</strong>。</p><p>可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。</p><p>但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185941.png" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">path = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span> (<span class="params">nums, used</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185941.png" alt=""></p><p>可以看出叶子节点，就是收割结果的地方。</p><p>那么什么时候，算是到达叶子节点呢？</p><p>当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时说明找到了一组</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">    result.append(path)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>单层搜索的逻辑</li></ul><p>这里和【组合问题】【切割问题】和【子集问题】最大的不同就是for循环里不用startIndex了。</p><p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p><p><strong>「而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次」</strong>。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">if</span> used[i] == <span class="literal">True</span>: </span><br><span class="line">        <span class="keyword">continue</span>               <span class="comment"># path里已经收录的元素，直接跳过</span></span><br><span class="line">    used[i] = <span class="literal">True</span></span><br><span class="line">    path.append(nums[i])</span><br><span class="line">    backtracking(nums, used)</span><br><span class="line">    path.pop()</span><br><span class="line">    used[i] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path = []</span><br><span class="line">        self.result = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        self.backtracking(nums, used)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, nums, used</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            self.result.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> used[i] == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            self.backtracking(nums, used)</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>大家此时可以感受出排列问题的不同：</p><ul><li>每层都是从0开始搜索而不是startIndex</li><li>需要used数组记录path里都放了哪些元素了</li></ul><p>排列问题是回溯算法解决的经典题目，大家可以好好体会体会。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;全排列&quot;&gt;&lt;a href=&quot;#全排列&quot; class=&quot;headerlink&quot; title=&quot;全排列&quot;&gt;&lt;/a&gt;全排列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
