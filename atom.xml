<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-08-07T16:15:30.659Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>06-螺旋矩阵问题</title>
    <link href="https://xxren8218.github.io/20210808/06-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210808/06-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98.html</id>
    <published>2021-08-07T16:13:14.000Z</published>
    <updated>2021-08-07T16:15:30.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001350.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目可以说在面试中出现频率较高的题目，<strong>本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</strong></p><p>要如何画出这个螺旋排列的正方形矩阵呢？</p><p>相信很多同学刚开始做这种题目的时候，上来就是一波判断猛如虎。</p><p>结果运行的时候各种问题，然后开始各种修修补补，最后发现改了这里哪里有问题，改了那里这里又跑不起来了。</p><p>大家还记得我们在这篇文章【二分查找】中讲解了二分法，提到如果要写出正确的二分法一定要坚持<strong>循环不变量原则</strong>。</p><p>而求解本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开的原则，来画一圈，大家看一下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001421.png" alt=""></p><p>这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。</p><p>这也是坚持了每条边左闭右开的原则。</p><p>一些同学做这道题目之所以一直写不好，代码越写越乱。</p><p>就是因为在画每一条边的时候，一会左开又闭，一会左闭右闭，一会又来左闭右开，岂能不乱。</p><p>代码如下，已经详细注释了每一步的目的，可以看出while循环里判断的情况是很多的，代码里处理的原则也是统一的左闭右开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right, up, down = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n -<span class="number">1</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化矩阵  n x n 的矩阵</span></span><br><span class="line">        matrix = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">            <span class="comment"># 从左到右</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                matrix[up][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上到下</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down + <span class="number">1</span>):</span><br><span class="line">                matrix[i][right] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从右到左</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                matrix[down][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从下到上</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                matrix[i][left] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001437.PNG" alt=""></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和上面的思路一样，不过这次不是给矩阵赋值而已。</p><ul><li>注意这里有个坑：这里不是方阵了，即m和n不一定一样。所以，需要添加一个判断。（更进去while的时候满足条件。通过第一步和第二步后不一定满足条件。）<ul><li>在第三步和第四步，需要额外添加判断。</li></ul></li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        left, right, up, down = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, m - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">            <span class="comment"># 从左往右</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[up][i])</span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上往下</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从右往左</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> up &lt;= down:</span><br><span class="line">                    res.append(matrix[down][i])</span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从下往上</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                    res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>由此可以得到螺旋打印的一个框架（无论是方阵与否）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right, up, down = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n -<span class="number">1</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化矩阵  n x n 的矩阵</span></span><br><span class="line">        matrix = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">            <span class="comment"># 从左到右</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                matrix[up][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上到下</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down + <span class="number">1</span>):</span><br><span class="line">                matrix[i][right] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从右到左</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> up &lt;= down:                   <span class="comment">##############</span></span><br><span class="line">                    matrix[down][i] = num</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从下到上</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> left &lt;= right:                <span class="comment">##############</span></span><br><span class="line">                    matrix[i][left] = num</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001512.PNG" alt=""></p><p>一样套路，这里就不写了。注意特殊情况的判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这三道题，我们总结出了顺时针打印矩阵的模板，以后按照模板写就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;螺旋矩阵II&quot;&gt;&lt;a href=&quot;#螺旋矩阵II&quot; class=&quot;headerlink&quot; title=&quot;螺旋矩阵II&quot;&gt;&lt;/a&gt;螺旋矩阵II&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>05-长度最小的子数组</title>
    <link href="https://xxren8218.github.io/20210808/05-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html"/>
    <id>https://xxren8218.github.io/20210808/05-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html</id>
    <published>2021-08-07T16:11:12.000Z</published>
    <updated>2021-08-07T16:12:55.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="长度最小值的子数组"><a href="#长度最小值的子数组" class="headerlink" title="长度最小值的子数组"></a>长度最小值的子数组</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001139.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p><p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001207.png" alt=""></p><p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, target, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        Sum = <span class="number">0</span>             <span class="comment"># 定义子数组的和</span></span><br><span class="line">        index = <span class="number">0</span>           <span class="comment"># 定义子数组的初始位置</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 定义子数组的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            Sum += nums[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> Sum &gt;= target:</span><br><span class="line">                res = <span class="built_in">min</span>(res, i - index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 重新选取子数组的范围</span></span><br><span class="line">                Sum -= nums[index]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><p><strong>为什么时间复杂度是O(n)</strong>。</p><p>不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是$O(n)$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;长度最小值的子数组&quot;&gt;&lt;a href=&quot;#长度最小值的子数组&quot; class=&quot;headerlink&quot; title=&quot;长度最小值的子数组&quot;&gt;&lt;/a&gt;长度最小值的子数组&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxre</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>04-有序数组的平方</title>
    <link href="https://xxren8218.github.io/20210808/04-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html"/>
    <id>https://xxren8218.github.io/20210808/04-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html</id>
    <published>2021-08-07T16:09:36.000Z</published>
    <updated>2021-08-07T16:10:57.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808001038.PNG" alt=""></p><h3 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h3><p>直接写个lambda匿名函数将其按照绝对值排序，而后将每个元素变为二倍即可</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort(key = <span class="keyword">lambda</span> x: <span class="built_in">abs</span>(x))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] *= nums[i] </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h3 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h3><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>如动画所示：</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        i, j, k = <span class="number">0</span>, n - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">        ans = [-<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            lm = nums[i] ** <span class="number">2</span></span><br><span class="line">            rm = nums[j] ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> lm &gt; rm:</span><br><span class="line">                ans[k] = lm</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[k] = rm</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>这里还是说一下，大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。</strong></p><p>做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，</p><p>一样的代码多提交几次可能就击败百分之百了…..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有序数组的平方&quot;&gt;&lt;a href=&quot;#有序数组的平方&quot; class=&quot;headerlink&quot; title=&quot;有序数组的平方&quot;&gt;&lt;/a&gt;有序数组的平方&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>03-移除元素</title>
    <link href="https://xxren8218.github.io/20210808/03-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html"/>
    <id>https://xxren8218.github.io/20210808/03-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html</id>
    <published>2021-08-07T16:03:37.000Z</published>
    <updated>2021-08-07T16:09:17.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000407.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000429.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有的同学可能说了，多余的元素，删掉不就得了。</p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != val:</span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;移除元素&quot;&gt;&lt;a href=&quot;#移除元素&quot; class=&quot;headerlink&quot; title=&quot;移除元素&quot;&gt;&lt;/a&gt;移除元素&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>02-二分查找</title>
    <link href="https://xxren8218.github.io/20210808/02-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"/>
    <id>https://xxren8218.github.io/20210808/02-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</id>
    <published>2021-08-07T16:01:14.000Z</published>
    <updated>2021-08-07T16:02:39.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000143.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><p>下面我用这两种区间的定义分别讲解两种不同的二分写法。</p><h4 id="二分法第一种写法"><a href="#二分法第一种写法" class="headerlink" title="二分法第一种写法"></a>二分法第一种写法</h4><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p>例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000200.PNG" alt=""></p><p>代码如下：（详细注释）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>    <span class="comment"># 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:              <span class="comment"># 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            middle = (left + right) // <span class="number">2</span>  <span class="comment"># 防止溢出 等同于(left + right)//2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &lt; target:    </span><br><span class="line">                left = middle + <span class="number">1</span>         <span class="comment"># target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle - <span class="number">1</span>        <span class="comment"># target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">                <span class="keyword">return</span> middle             <span class="comment"># 数组中找到目标值，直接返回下标</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>                         <span class="comment"># 未找到目标值</span></span><br></pre></td></tr></table></figure><h4 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h4><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><p>在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（<strong>注意和方法一的区别</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210808000221.PNG" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left,right = <span class="number">0</span>, <span class="built_in">len</span>(nums)   <span class="comment"># 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:         <span class="comment"># 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:  </span><br><span class="line">                left = mid + <span class="number">1</span>        <span class="comment"># target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid         <span class="comment"># target 在左区间，在[left, middle)中</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> mid          <span class="comment"># 数组中找到目标值，直接返回下标 ###########注意</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>                   <span class="comment"># 未找到目标值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二分法是非常重要的基础算法，为什么很多同学对于二分法都是<strong>一看就会，一写就废</strong>？</p><p>其实主要就是对区间的定义没有理解清楚，在循环中没有始终坚持根据查找区间的定义来做边界处理。</p><p>区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。</p><p>本篇根据两种常见的区间定义，给出了两种二分法的写法，每一个边界为什么这么处理，都根据区间的定义做了详细介绍。</p><p>更多关于二分查找的技巧，<a href="https://xxren8218.github.io/20210615/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html">二分查找详解</a>里面有讲解寻找左边界和寻找右边界的二分查找的方法。</p><h3 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left,right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:        以使用 &lt;</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:  </span><br><span class="line">                left = mid + <span class="number">1</span>        </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid               <span class="comment">########</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                right = mid               <span class="comment">########</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left                       <span class="comment">########</span></span><br></pre></td></tr></table></figure><h3 id="寻找右侧边界的二分搜索"><a href="#寻找右侧边界的二分搜索" class="headerlink" title="寻找右侧边界的二分搜索"></a>寻找右侧边界的二分搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left,right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:        以使用 &lt;</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:  </span><br><span class="line">                left = mid + <span class="number">1</span>        </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid               <span class="comment">########</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                left = mid + <span class="number">1</span>            <span class="comment">########</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>                   <span class="comment">########           </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>01-数组基础</title>
    <link href="https://xxren8218.github.io/20210807/01-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80.html"/>
    <id>https://xxren8218.github.io/20210807/01-%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-08-07T15:56:43.000Z</published>
    <updated>2021-08-07T15:58:06.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h2><p>数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力</p><p>也就是说，想法很简单，但实现起来 可能就不是那么回事了。</p><p>首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题</p><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p><p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p><p>举一个字符数组的例子，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235716.PNG" alt=""></p><p>需要两点注意的是</p><ul><li><strong>数组下标都是从0开始的。</strong></li><li><strong>数组内存空间的地址是连续的</strong></li></ul><p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p><p>例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235734.PNG" alt=""></p><p>那么二维数组直接上图，大家应该就知道怎么回事了</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235755.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组基础&quot;&gt;&lt;a href=&quot;#数组基础&quot; class=&quot;headerlink&quot; title=&quot;数组基础&quot;&gt;&lt;/a&gt;数组基础&lt;/h2&gt;&lt;p&gt;数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力&lt;/p&gt;
&lt;p&gt;也就是说，想</summary>
      
    
    
    
    <category term="数组" scheme="https://xxren8218.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>19-监控二叉树</title>
    <link href="https://xxren8218.github.io/20210807/19-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://xxren8218.github.io/20210807/19-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html</id>
    <published>2021-08-07T15:54:02.000Z</published>
    <updated>2021-08-07T15:56:22.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235445.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目首先要想，如何放置，才能让摄像头最小的呢？</p><p>从题目中示例，其实可以得到启发，<strong>我们发现题目示例中的摄像头都没有放在叶子节点上！</strong></p><p>这是很重要的一个线索，摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。</p><p>所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。</p><p>那么有同学可能问了，为什么不从头结点开始看起呢，为啥要从叶子节点看呢？</p><p>因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。</p><p><strong>所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</strong></p><p>局部最优推出全局最优，找不出反例，那么就按照贪心来！</p><p>此时，大体思路就是从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点。</p><p>此时这道题目还有两个难点：</p><ol><li>二叉树的遍历</li><li>如何隔两个节点放一个摄像头</li></ol><h4 id="确定遍历顺序"><a href="#确定遍历顺序" class="headerlink" title="确定遍历顺序"></a>确定遍历顺序</h4><p>在二叉树中如何从低向上推导呢？</p><p>可以使用后序遍历也就是左右中的顺序，这样就可以在回溯的过程中从下到上进行推导了。</p><p>后序遍历代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">cur</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 空节点，该节点有覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (终止条件) <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    left = traversal(cur-&gt;left);    # 左</span><br><span class="line">    right = traversal(cur-&gt;right);  # 右</span><br><span class="line"></span><br><span class="line">    逻辑处理                         <span class="comment"># 中</span></span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p><strong>注意在以上代码中我们取了左孩子的返回值，右孩子的返回值，即left 和 right， 以后推导中间节点的状态</strong></p><h4 id="如何隔两个节点放一个摄像头"><a href="#如何隔两个节点放一个摄像头" class="headerlink" title="如何隔两个节点放一个摄像头"></a>如何隔两个节点放一个摄像头</h4><p>此时需要状态转移的公式，大家不要和动态的状态转移公式混到一起，本题状态转移没有择优的过程，就是单纯的状态转移！</p><p>来看看这个状态应该如何转移，先来看看每个节点可能有几种状态：</p><p>有如下三种：</p><ul><li>该节点无覆盖</li><li>本节点有摄像头</li><li>本节点有覆盖</li></ul><p>我们分别有三个数字来表示：</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><p>大家应该找不出第四个节点的状态了。</p><p><strong>一些同学可能会想有没有第四种状态：本节点无摄像头，其实无摄像头就是 无覆盖 或者 有覆盖的状态，所以一共还是三个状态。</strong></p><p><strong>因为在遍历树的过程中，就会遇到空节点，那么问题来了，空节点究竟是哪一种状态呢？ 空节点表示无覆盖？ 表示有摄像头？还是有覆盖呢？</strong></p><p>回归本质，为了让摄像头数量最少，我们要尽量让叶子节点的父节点安装摄像头，这样才能摄像头的数量最少。</p><p>那么空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。</p><p><strong>所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了</strong></p><p>接下来就是递推关系。</p><p>那么递归的终止条件应该是遇到了空节点，此时应该返回2（有覆盖），原因上面已经解释过了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空节点，该节点有覆盖</span></span><br><span class="line"><span class="keyword">if</span> cur == <span class="literal">None</span>: <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>递归的函数，以及终止条件已经确定了，再来看单层逻辑处理。</p><p>主要有如下四类情况：</p><ul><li>情况1：左右节点都有覆盖</li></ul><p>左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235509.png" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左右节点都有覆盖</span></span><br><span class="line"><span class="keyword">if</span> left == <span class="number">2</span> <span class="keyword">and</span> right == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>情况2：左右节点至少有一个无覆盖的情况</li></ul><p>如果是以下情况，则中间节点（父节点）应该放摄像头：</p><p>left == 0 and right == 0 左右节点无覆盖 left == 1 and right == 0 左节点有摄像头，右节点无覆盖 left == 0 and right == 1 左节点有无覆盖，右节点摄像头 left == 0 and right == 2 左节点无覆盖，右节点覆盖 left == 2 and right == 0 左节点覆盖，右节点无覆盖</p><p>这个不难理解，毕竟有一个孩子没有覆盖，父节点就应该放摄像头。</p><p>此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span>:</span><br><span class="line">    result += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>情况3：左右节点至少有一个有摄像头</li></ul><p>如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）</p><p>left == 1 and right == 2 左节点有摄像头，右节点有覆盖 left == 2 and right == 1 左节点有覆盖，右节点有摄像头 left == 1 and right == 1 左右节点都有摄像头</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> left == <span class="number">1</span> <span class="keyword">or</span> right == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>从这个代码中，可以看出，如果left == 1, right == 0 怎么办？其实这种条件在情况2中已经判断过了</strong>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235526.png" alt=""></p><p>这种情况也是大多数同学容易迷惑的情况。</p><ul><li>情况4：头结点没有覆盖</li></ul><p>以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210807235546.png" alt=""></p><p>所以递归结束之后，还要判断根节点，如果没有覆盖，result++，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> traversal(root) == <span class="number">0</span>: <span class="comment"># root 无覆盖</span></span><br><span class="line">    result += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>以上四种情况我们分析完了，代码也差不多了，整体代码如下：</p><p>（<strong>以下我的代码注释很详细，为了把情况说清楚，特别把每种情况列出来。</strong>）</p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCameraCover</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 情况4</span></span><br><span class="line">        <span class="keyword">if</span> self.trversal(root) == <span class="number">0</span>:  <span class="comment"># root 无覆盖</span></span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trversal</span>(<span class="params">self, cur</span>):</span></span><br><span class="line">        <span class="comment"># 空节点，该节点有覆盖</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        left = self.trversal(cur.left)     <span class="comment"># 左</span></span><br><span class="line">        right = self.trversal(cur.right)   <span class="comment"># 右</span></span><br><span class="line">                                           <span class="comment"># 中</span></span><br><span class="line">        <span class="comment"># 情况1</span></span><br><span class="line">        <span class="comment"># 左右节点都有覆盖</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">2</span> <span class="keyword">and</span> right == <span class="number">2</span>:       </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况2</span></span><br><span class="line">        <span class="comment"># left == 0 and right == 0 左右节点无覆盖</span></span><br><span class="line">        <span class="comment"># left == 1 and right == 0 左节点有摄像头，右节点无覆盖</span></span><br><span class="line">        <span class="comment"># left == 0 and right == 1 左节点有无覆盖，右节点摄像头</span></span><br><span class="line">        <span class="comment"># left == 0 and right == 2 左节点无覆盖，右节点覆盖</span></span><br><span class="line">        <span class="comment"># left == 2 and right == 0 左节点覆盖，右节点无覆盖</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span>:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况3</span></span><br><span class="line">        <span class="comment"># left == 1 and right == 2 左节点有摄像头，右节点有覆盖</span></span><br><span class="line">        <span class="comment"># left == 2 and right == 1 左节点有覆盖，右节点有摄像头</span></span><br><span class="line">        <span class="comment"># left == 1 and right == 1 左右节点都有摄像头</span></span><br><span class="line">        <span class="comment"># 其他情况前段代码均已覆盖</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="number">1</span> <span class="keyword">or</span> right == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个 return -1 逻辑不会走到这里。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题的难点首先是要想到贪心的思路，然后就是遍历和状态推导。</p><p>在二叉树上进行状态推导，其实难度就上了一个台阶了，需要对二叉树的操作非常娴熟。</p><p>这道题目是名副其实的hard，大家感受感受，哈哈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;监控二叉树&quot;&gt;&lt;a href=&quot;#监控二叉树&quot; class=&quot;headerlink&quot; title=&quot;监控二叉树&quot;&gt;&lt;/a&gt;监控二叉树&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>18_买卖股票的最佳时机含手续费</title>
    <link href="https://xxren8218.github.io/20210806/18-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html"/>
    <id>https://xxren8218.github.io/20210806/18-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html</id>
    <published>2021-08-05T16:05:52.000Z</published>
    <updated>2021-08-05T16:06:29.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000616.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题相对于【买卖股票的最佳时机II】，多添加了一个条件就是手续费。</p><p>在【买卖股票的最佳时机II】中使用贪心策略不用关心具体什么时候买卖，只要收集每天的正利润，最后稳稳的就是最大利润了。</p><p>而本题有了手续费，就要关系什么时候买卖了，因为计算所获得利润，需要考虑买卖利润可能不足以手续费的情况。</p><p>如果使用贪心策略，就是最低值买，最高值（如果算上手续费还盈利）就卖。</p><p>此时无非就是要找到两个点，买入日期，和卖出日期。</p><ul><li>买入日期：其实很好想，遇到更低点就记录一下。</li><li>卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。</li></ul><p>所以我们在做收获利润操作的时候其实有三种情况：</p><ul><li>情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润。</li><li>情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。</li><li>情况三：不作操作，保持原有状态（买入，卖出，不买不卖）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices, fee</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :type fee: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        minPrice = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 情况二，相当于买入</span></span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; minPrice: minPrice = prices[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况三，相当于保持原有状态</span></span><br><span class="line">            <span class="keyword">elif</span> prices[i] &gt;= minPrice <span class="keyword">and</span> prices[i] &lt;= minPrice + fee:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += prices[i] - minPrice -fee</span><br><span class="line">                minPrice = prices[i] - fee    <span class="comment"># 情况一，这一步很关键。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题贪心的思路其实是比较难的，动态规划才是常规做法，但也算是给大家拓展一下思路，感受一下贪心的魅力。</p><p>后期我们在讲解 股票问题系列的时候，会用动规的方式把股票问题穿个线。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;买卖股票的最佳时机含手续费&quot;&gt;&lt;a href=&quot;#买卖股票的最佳时机含手续费&quot; class=&quot;headerlink&quot; title=&quot;买卖股票的最佳时机含手续费&quot;&gt;&lt;/a&gt;买卖股票的最佳时机含手续费&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsde</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>17_单调递增的数字</title>
    <link href="https://xxren8218.github.io/20210806/17-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://xxren8218.github.io/20210806/17-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html</id>
    <published>2021-08-05T16:04:59.000Z</published>
    <updated>2021-08-05T16:05:39.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000527.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。</p><p>例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]-1，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p><p>这一点如果想清楚了，这道题就好办了。</p><p><strong>局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]-1，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数</strong>。</p><p><strong>全局最优：得到小于等于N的最大单调递增的整数</strong>。</p><p><strong>但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9</strong>。</p><p>此时是从前向后遍历还是从后向前遍历呢？</p><p>从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。</p><p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p><p><strong>所以从前后向遍历会改变已经遍历过的结果！</strong></p><p>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p><p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingDigits</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 先转化为单个数字的列表</span></span><br><span class="line">        a = <span class="built_in">list</span>(<span class="built_in">str</span>(n))</span><br><span class="line">        <span class="comment"># 倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 若前一个值大于后一个值，前一个值减一，后面的值为9</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(a[i]) &lt; <span class="built_in">int</span>(a[i - <span class="number">1</span>]):</span><br><span class="line">                a[i - <span class="number">1</span>] = <span class="built_in">str</span>(<span class="built_in">int</span>(a[i - <span class="number">1</span>]) - <span class="number">1</span>)</span><br><span class="line">                a[i:] = <span class="string">&quot;9&quot;</span> * (<span class="built_in">len</span>(a) - i)</span><br><span class="line">        <span class="comment"># 返回的时候再次进行拼接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(a))</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题只要想清楚个例，例如98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]减一，strNum[i]赋值9，这样这个整数就是89。就可以很自然想到对应的贪心解法了。</p><p>想到了贪心，还要考虑遍历顺序，只有从后向前遍历才能重复利用上次比较的结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单调递增的数字&quot;&gt;&lt;a href=&quot;#单调递增的数字&quot; class=&quot;headerlink&quot; title=&quot;单调递增的数字&quot;&gt;&lt;/a&gt;单调递增的数字&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>16_合并区间</title>
    <link href="https://xxren8218.github.io/20210806/16-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html"/>
    <id>https://xxren8218.github.io/20210806/16-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html</id>
    <published>2021-08-05T16:03:42.000Z</published>
    <updated>2021-08-05T16:04:43.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000413.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大家应该都感觉到了，此题一定要排序，那么按照左边界排序，还是右边界排序呢？</p><p>都可以！</p><p>那么我按照左边界排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。</p><p>局部最优可以推出全局最优，找不出反例，试试贪心。</p><p>那有同学问了，本来不就应该合并最大右边界么，这和贪心有啥关系？</p><p>有时候贪心就是常识！哈哈</p><p>按照左边界从小到大排序之后，如果 <code>intervals[i][0] &lt; intervals[i - 1][1]</code> 即intervals[i]左边界 &lt; intervals[i - 1]右边界，则一定有重复，因为intervals[i]的左边界一定是大于等于intervals[i - 1]的左边界。</p><p>即：intervals[i]的左边界在intervals[i - 1]左边界和右边界的范围内，那么一定有重复！</p><p>这么说有点抽象，看图：（<strong>注意图中区间都是按照左边界排序之后了</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000430.png" alt=""></p><p>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？</p><p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了。如果没有合并就把原区间加入到result数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type intervals: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(intervals) == <span class="number">0</span>: <span class="keyword">return</span> intervals</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 先进行排序</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先添加一个元素。</span></span><br><span class="line">        res.append(intervals[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行循环</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(intervals)):</span><br><span class="line">            last = res[-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 若满足前一个end大于后一个的start，一定有重叠。更新右边界。</span></span><br><span class="line">            <span class="keyword">if</span> last[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]:</span><br><span class="line">                res[-<span class="number">1</span>] = [last[<span class="number">0</span>], <span class="built_in">max</span>(last[<span class="number">1</span>], intervals[i][<span class="number">1</span>])]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(intervals[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于贪心算法，很多同学都是：<strong>如果能凭常识直接做出来，就会感觉不到自己用了贪心, 一旦第一直觉想不出来, 可能就一直想不出来了</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;合并区间&quot;&gt;&lt;a href=&quot;#合并区间&quot; class=&quot;headerlink&quot; title=&quot;合并区间&quot;&gt;&lt;/a&gt;合并区间&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>15_划分字母区间</title>
    <link href="https://xxren8218.github.io/20210806/15-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html"/>
    <id>https://xxren8218.github.io/20210806/15-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html</id>
    <published>2021-08-05T16:02:01.000Z</published>
    <updated>2021-08-05T16:03:09.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000231.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一想到分割字符串就想到了回溯，但本题其实不用回溯去暴力搜索。</p><p>题目要求同一字母最多出现在一个片段中，那么如何把同一个字母的都圈在同一个区间里呢？</p><p>如果没有接触过这种题目的话，还挺有难度的。</p><p>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p><p>可以分为如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000248.png" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 先建立字母表</span></span><br><span class="line">        <span class="built_in">hash</span> = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不断更新迭代字母表的最大索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="built_in">hash</span>[<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] = i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化left, right, result</span></span><br><span class="line">        left, right, result = <span class="number">0</span>, <span class="number">0</span>, []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对每个字母替换并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            right = <span class="built_in">max</span>(right, <span class="built_in">hash</span>[<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)])</span><br><span class="line">            <span class="keyword">if</span> i == right:</span><br><span class="line">                result.append(right - left + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">                <span class="comment"># 初始化left</span></span><br><span class="line">                left = right + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;划分字母区间&quot;&gt;&lt;a href=&quot;#划分字母区间&quot; class=&quot;headerlink&quot; title=&quot;划分字母区间&quot;&gt;&lt;/a&gt;划分字母区间&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>14_无重叠区间</title>
    <link href="https://xxren8218.github.io/20210806/14-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html"/>
    <id>https://xxren8218.github.io/20210806/14-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html</id>
    <published>2021-08-05T16:00:37.000Z</published>
    <updated>2021-08-05T16:01:44.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000100.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>相信很多同学看到这道题目都冥冥之中感觉要排序，但是究竟是按照右边界排序，还是按照左边界排序呢？</strong></p><p>这其实是一个难点！</p><p>按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大，所以从左向右遍历，优先选右边界小的。</p><p>按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历。</p><p>如果按照左边界排序，还从左向右遍历的话，其实也可以，逻辑会有所不同。</p><p>一些同学做这道题目可能真的去模拟去重复区间的行为，这是比较麻烦的，还要去删除区间。</p><p>题目只是要求移除区间的个数，没有必要去真实的模拟删除区间！</p><p><strong>我来按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>此时问题就是要求非交叉区间的最大个数。</p><p>右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。</p><p>局部最优推出全局最优，试试贪心！</p><p>这里记录非交叉区间的个数还是有技巧的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210806000123.png" alt=""></p><p>区间，1，2，3，4，5，6都按照右边界排好序。</p><p>每次取非交叉区间的时候，都是可右边界最小的来做分割点（这样留给下一个区间的空间就越大），所以第一条分割线就是区间1结束的位置。</p><p>接下来就是找大于区间1结束位置的区间，是从区间4开始。<strong>那有同学问了为什么不从区间5开始？别忘已经是按照右边界排序的了</strong>。</p><p>区间4结束之后，在找到区间6，所以一共记录非交叉区间的个数是三个。</p><p>总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span>(<span class="params">self, intervals</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type intervals: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        count = <span class="number">1</span>  <span class="comment"># 记录非交叉区间的个数</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        end = intervals[<span class="number">0</span>][<span class="number">1</span>] <span class="comment"># 记录区间分割点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> end &lt;= intervals[i][<span class="number">0</span>]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                end = intervals[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - count</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题我认为难度级别可以算是hard级别的！</p><p>总结如下难点：</p><ul><li>难点一：一看题就有感觉需要排序，但究竟怎么排序，按左边界排还是右边界排。</li><li>难点二：排完序之后如何遍历，如果没有分析好遍历顺序，那么排序就没有意义了。</li><li>难点三：直接求重复的区间是复杂的，转而求最大非重复区间个数。</li><li>难点四：求最大非重复区间个数时，需要一个分割点来做标记。</li></ul><p><strong>这四个难点都不好想，但任何一个没想到位，这道题就解不了</strong>。</p><p>一些录友可能看网上的题解代码很简单，照葫芦画瓢稀里糊涂的就过了，但是其题解可能并没有把问题难点讲清楚，然后自己再没有钻研的话，那么一道贪心经典区间问题就这么浪费掉了。</p><p>贪心就是这样，代码有时候很简单（不是指代码短，而是逻辑简单），但想法是真的难！</p><p>这和动态规划还不一样，动规的代码有个递推公式，可能就看不懂了，而贪心往往是直白的代码，但想法读不懂，哈哈。</p><p><strong>所以我把本题的难点也一一列出，帮大家不仅代码看的懂，想法也理解的透彻！</strong></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>本题其实和【用最少数量的箭引爆气球】非常像，弓箭的数量就相当于是非交叉区间的数量，只要把弓箭那道题目代码里射爆气球的判断条件加个等号（认为[0，1][1，2]不是相邻区间），然后用总区间数减去弓箭数量 就是要移除的区间数量了。</p><p>把【用最少数量的箭引爆气球】代码稍做修改，就可以AC本题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无重叠区间&quot;&gt;&lt;a href=&quot;#无重叠区间&quot; class=&quot;headerlink&quot; title=&quot;无重叠区间&quot;&gt;&lt;/a&gt;无重叠区间&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>13_使用最少数量的箭引爆气球</title>
    <link href="https://xxren8218.github.io/20210805/13-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html"/>
    <id>https://xxren8218.github.io/20210805/13-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html</id>
    <published>2021-08-05T15:57:11.000Z</published>
    <updated>2021-08-05T15:58:30.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用最少数量的箭引爆气球"><a href="#使用最少数量的箭引爆气球" class="headerlink" title="使用最少数量的箭引爆气球"></a>使用最少数量的箭引爆气球</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210805235747.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如何使用最少的弓箭呢？</p><p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？</p><p>尝试一下举反例，发现没有这种情况。</p><p>那么就试一试贪心吧！</p><p><strong>局部最优：</strong>当气球出现重叠，一起射，所用弓箭最少。</p><p><strong>全局最优</strong>：把所有气球射爆所用弓箭最少。</p><p><strong>算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？</strong></p><p>如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。</p><p>但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remote气球，只要记录一下箭的数量就可以了。</p><p>以上为思考过程，已经确定下来使用贪心了，那么开始解题。</p><p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。</p><p>那么按照气球起始位置排序，还是按照气球终止位置排序呢？</p><p>其实都可以！只不过对应的遍历顺序不同，我就按照气球的起始位置排序了。</p><p>既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。</p><p>从前向后遍历遇到重叠的气球了怎么办？</p><p><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。</p><p>以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210805235806.png" alt=""></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，气球3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(points) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 进行排序</span></span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(points)):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果后一个区间的start大于前一个区间的end，那么需要一支箭。注意不能是&gt;=，题目说的是挨在一起也会爆。</span></span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 否则的话需要更新最小右区间，来尽可能确保下一次判断得start在此区间内。</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(nlogn)，因为有一个快排</li><li>空间复杂度O(1)</li></ul><p>可以看出代码并不复杂。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>注意题目中说的是：满足 xstart ≤ x ≤ xend，则该气球会被引爆。那么说明两个气球挨在一起不重叠也可以一起射爆，</p><p>所以代码中 <code>if (points[i][0] &gt; points[i - 1][1])</code> 不能是&gt;=</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题目贪心的思路很简单也很直接，就是重复的一起射了，但本题我认为是有难度的。</p><p>就算思路都想好了，模拟射气球的过程，很多同学真的要去模拟了，实时把气球从数组中移走，这么写的话就复杂了。</p><p>而且寻找重复的气球，寻找重叠气球最小右边界，其实都有代码技巧。</p><p>贪心题目有时候就是这样，看起来很简单，思路很直接，但是一写代码就感觉贼复杂无从下手。</p><p>这里其实是需要代码功底的，那代码功底怎么练？</p><p><strong>多看多写多总结！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用最少数量的箭引爆气球&quot;&gt;&lt;a href=&quot;#使用最少数量的箭引爆气球&quot; class=&quot;headerlink&quot; title=&quot;使用最少数量的箭引爆气球&quot;&gt;&lt;/a&gt;使用最少数量的箭引爆气球&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>12_根据身高重建队列</title>
    <link href="https://xxren8218.github.io/20210805/12-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210805/12-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html</id>
    <published>2021-08-05T15:52:06.000Z</published>
    <updated>2021-08-05T15:56:46.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210805235611.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后在按照另一个维度重新排列。</p><p>其实如果大家认真做了【 分发糖果】，就会发现和此题有点点的像。</p><p>在【分发糖果】就强调过一次，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</p><p><strong>如果两个维度一起考虑一定会顾此失彼</strong>。</p><p>对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还先按照k排序呢？</p><p>如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p><p>那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。</p><p><strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p><p>那么只需要按照k为下标重新插入队列就可以了，为什么呢？</p><p>以图中{5,2} 为例：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210805235630.png" alt=""></p><p>按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。</p><p>所以在按照身高从大到小排序后：</p><p><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong></p><p><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p><p>局部最优可推出全局最优，找不出反例，那就试试贪心。</p><p>排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]</p><p>插入的过程： 插入[7,0]：[[7,0]] 插入[7,1]：[[7,0],[7,1]] 插入[6,1]：[[7,0],[6,1],[7,1]] 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]] 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]] 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p><p>此时就按照题目的要求完成了重新排列。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type people: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 按照第一个索引的倒序，第二个索引的顺序排列peple列表 people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span></span><br><span class="line">        <span class="comment"># [[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]</span></span><br><span class="line">        people.sort(key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        queeue = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 直接在新的队列里面插入第二个索引位置即可。</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            queeue.insert(p[<span class="number">1</span>], p)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> queeue</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于出现两个维度一起考虑的情况，我们已经做过两道题目了，另一道就是【分发糖果】。</p><p><strong>其技巧都是确定一边然后贪心另一边，两边一起考虑，就会顾此失彼</strong>。</p><p>这道题目可以说比【分发糖果】难不少，其贪心的策略也是比较巧妙。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;根据身高重建队列&quot;&gt;&lt;a href=&quot;#根据身高重建队列&quot; class=&quot;headerlink&quot; title=&quot;根据身高重建队列&quot;&gt;&lt;/a&gt;根据身高重建队列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren821</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>11_柠檬水找零</title>
    <link href="https://xxren8218.github.io/20210805/11-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html"/>
    <id>https://xxren8218.github.io/20210805/11-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html</id>
    <published>2021-08-05T15:50:54.000Z</published>
    <updated>2021-08-05T15:51:50.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210805235134.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目刚一看，可能会有点懵，这要怎么找零才能保证完整全部账单的找零呢？</p><p><strong>但仔细一琢磨就会发现，可供我们做判断的空间非常少！</strong></p><p>只需要维护三种金额的数量，5，10和20。</p><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li></ul><p>此时大家就发现 情况一，情况二，都是固定策略，都不用我们来做分析了，而唯一不确定的其实在情况三。</p><p>而情况三逻辑也不复杂甚至感觉纯模拟就可以了，其实情况三这里是有贪心的。</p><p>账单是20的情况，为什么要优先消耗一个10和一个5呢？</p><p><strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p><p>所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。</p><p>局部最优可以推出全局最优，并找不出反例，那么就试试贪心算法！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span>(<span class="params">self, bills</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type bills: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 定义三张钱的个数</span></span><br><span class="line">        five, ten, twenty = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> bill <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="comment"># 情况1</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">5</span>:</span><br><span class="line">                five += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况2</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> five &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                five -= <span class="number">1</span></span><br><span class="line">                ten += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 情况3</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">20</span>:</span><br><span class="line">                <span class="keyword">if</span> ten &gt; <span class="number">0</span> <span class="keyword">and</span> five &gt; <span class="number">0</span>:</span><br><span class="line">                    five -= <span class="number">1</span></span><br><span class="line">                    ten -= <span class="number">1</span></span><br><span class="line">                    twenty += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> five &gt;= <span class="number">3</span>:</span><br><span class="line">                    five -= <span class="number">3</span></span><br><span class="line">                    twenty += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>咋眼一看好像很复杂，分析清楚之后，会发现逻辑其实非常固定。</p><p>这道题目可以告诉大家，遇到感觉没有思路的题目，可以静下心来把能遇到的情况分析一下，只要分析到具体情况了，一下子就豁然开朗了。</p><p>如果一直陷入想从整体上寻找找零方案，就会把自己陷进去，各种情况一交叉，只会越想越复杂了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;柠檬水找零&quot;&gt;&lt;a href=&quot;#柠檬水找零&quot; class=&quot;headerlink&quot; title=&quot;柠檬水找零&quot;&gt;&lt;/a&gt;柠檬水找零&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>11-爬楼梯</title>
    <link href="https://xxren8218.github.io/20210730/11-%E7%88%AC%E6%A5%BC%E6%A2%AF.html"/>
    <id>https://xxren8218.github.io/20210730/11-%E7%88%AC%E6%A5%BC%E6%A2%AF.html</id>
    <published>2021-07-30T15:11:53.000Z</published>
    <updated>2021-07-30T15:12:57.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730231221.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。</p><p>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。</p><p>那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。</p><p>所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。</p><p>我们来分析一下，动规五部曲：</p><p>定义一个一维数组来记录不同楼层的状态</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p><ol><li>确定递推公式</li></ol><p>如果可以推出dp[i]呢？</p><p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p><p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p><p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p><p>所以dp[i] = dp[i - 1] + dp[i - 2] 。</p><p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。</p><p>这体现出确定dp数组以及下标的含义的重要性！</p><ol><li>dp数组如何初始化</li></ol><p>在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。</p><p>那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。</p><p>例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。</p><p>但总有点牵强的成分。</p><p>那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.</p><p><strong>其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1</strong>。</p><p>从dp数组定义的角度上来说，dp[0] = 0 也能说得通。</p><p>需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。</p><p>所以本题其实就不应该讨论dp[0]的初始化！</p><p>我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。</p><p>所以我的原则是：不考虑dp[0]如果初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。</p><ol><li>确定遍历顺序</li></ol><p>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p><ol><li>举例推导dp数组</li></ol><p>举例当n为5的时候，dp table（dp数组）应该是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730231240.png" alt=""></p><p>如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。</p><p><strong>此时大家应该发现了，这不就是斐波那契数列么！</strong></p><p>唯一的区别是，没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义！</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>当然依然也可以，优化一下空间复杂度，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">0</span>] </span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> = dp[<span class="number">0</span>] + dp[<span class="number">1</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>]</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>后面将讲解的很多动规的题目其实都是当前状态依赖前两个，或者前三个状态，都可以做空间上的优化，<strong>但我个人认为面试中能写出版本一就够了哈，清晰明了，如果面试官要求进一步优化空间的话，我们再去优化</strong>。</p><p>因为版本一才能体现出动规的思想精髓，递推的状态变化。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。</p><p>这又有难度了，这其实是一个完全背包问题，但力扣上没有这种题目，所以后续在讲解背包问题的时候，今天这道题还会拿从背包问题的角度上来再讲一遍。</p><p>这里我先给出实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>): <span class="comment"># 把m换成2，就可以AC爬楼梯这道题</span></span><br><span class="line">                <span class="keyword">if</span> i - j &gt;= <span class="number">0</span>: </span><br><span class="line">             dp[i] += dp[i - j]</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p>代码中m表示最多可以爬m个台阶。</p><p><strong>以上代码不能运行哈，我主要是为了体现只要把m换成2，粘过去，就可以AC爬楼梯这道题，不信你就粘一下试试，哈哈</strong>。</p><p><strong>此时我就发现一个绝佳的大厂面试题</strong>，第一道题就是单纯的爬楼梯，然后看候选人的代码实现，如果把dp[0]的定义成1了，就可以发难了，为什么dp[0]一定要初始化为1，此时可能候选人就要强行给dp[0]应该是1找各种理由。那这就是一个考察点了，对dp[i]的定义理解的不深入。</p><p>然后可以继续发难，如果一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。这道题目leetcode上并没有原题，绝对是考察候选人算法能力的绝佳好题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题目和斐波那契数列基本是一样的，但是会发现本题相比它多了，为什么呢？</p><p>关键是 斐波那契数列 描述就已经把动规五部曲里的递归公式和如何初始化都给出来了，剩下几部曲也自然而然的推出来了。</p><p>而本题，就需要逐个分析了，大家现在应该初步感受出动规五部曲了。</p><p>简单题是用来掌握方法论的，例如昨天斐波那契的题目够简单了吧，但昨天和今天可以使用一套方法分析出来的，这就是方法论！</p><p>所以不要轻视简单题，那种凭感觉就刷过去了，其实和没掌握区别不大，只有掌握方法论并说清一二三，才能触类旁通，举一反三哈！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;爬楼梯&quot;&gt;&lt;a href=&quot;#爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;爬楼梯&quot;&gt;&lt;/a&gt;爬楼梯&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>10-斐波那契数列</title>
    <link href="https://xxren8218.github.io/20210730/10-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210730/10-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html</id>
    <published>2021-07-30T15:09:00.000Z</published>
    <updated>2021-07-30T15:11:34.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730230621.png" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>斐波那契数列大家应该非常熟悉不过了，非常适合作为动规第一道题目来练练手。</p><p>因为这道题目比较简单，可能一些同学并不需要做什么分析，直接顺手一写就过了。</p><p>通过这道题目让大家可以初步认识到，按照动规五部曲是如何解题的。</p><p>对于动规，如果没有方法论的话，可能简单题目可以顺手一写就过，难一点就不知道如何下手了。</p><p>所以我总结的动规五部曲，是要用来贯穿整个动态规划系列的，就像之前讲过【二叉树的递归三部曲】，【回溯法的回溯三部曲】一样。后面慢慢大家就会体会到，动规五部曲方法的重要性。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动规五部曲：</p><p>这里我们要用一个一维dp数组来保存递归的结果</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol><li>确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]</strong></p><ol><li>dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><ol><li>确定遍历顺序</li></ol><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2]中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 特殊值排除</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">        <span class="comment"># 构建数组（表）</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 确定遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>当然可以发现，我们只需要维护两个数值就可以了，不需要记录整个序列。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">        <span class="comment"># 构建数组（表）</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="number">2</span></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 确定遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> = dp[<span class="number">0</span>] + dp[<span class="number">1</span>]</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>]</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">sum</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>本题还可以使用递归解法来做</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> self.fib(n - <span class="number">1</span>) + self.fib(n - <span class="number">2</span>)   </span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(2^n)</li><li>空间复杂度：O(n) 算上了编程语言中实现递归的系统栈所占空间</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>斐波那契数列这道题目是非常基础的题目，我在后面的动态规划的讲解中将会多次提到斐波那契数列！</p><p>这里我严格按照动规五部曲来分析了这道题目，一些分析步骤可能同学感觉没有必要搞的这么复杂，代码其实上来就可以撸出来。</p><p>但我还是强调一下，简单题是用来掌握方法论的，动规五部曲将在接下来的动态规划讲解中发挥重要作用，敬请期待！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>09-再识动态规划</title>
    <link href="https://xxren8218.github.io/20210730/09-%E5%86%8D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html"/>
    <id>https://xxren8218.github.io/20210730/09-%E5%86%8D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html</id>
    <published>2021-07-30T15:07:54.000Z</published>
    <updated>2021-07-30T15:08:40.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="再识动态规划"><a href="#再识动态规划" class="headerlink" title="再识动态规划"></a>再识动态规划</h2><h3 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h3><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的，</p><p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p><p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p><p>所以贪心解决不了动态规划的问题。</p><p><strong>其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了</strong>。</p><p>而且很多讲解动态规划的文章都会讲最优子结构啊和重叠子问题啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。</p><p>大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。</p><p>上述提到的背包问题，后序会详细讲解。</p><h3 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h3><p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。</p><p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中</strong>。</p><p>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</p><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？</p><p><strong>因为一些情况是递推公式决定了dp数组要如何初始化！</strong></p><p>后面的讲解中我都是围绕着这五点来进行讲解。</p><p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p><p>其实 确定递推公式 仅仅是解题里的一步而已！</p><p>一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p><p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p><h3 id="动态规划应该如何debug"><a href="#动态规划应该如何debug" class="headerlink" title="动态规划应该如何debug"></a>动态规划应该如何debug</h3><p>相信动规的题目，很大部分同学都是这样做的。</p><p>看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递归公式，遍历顺序，处于一种黑盒的理解状态。</p><p>写动规题目，代码出问题很正常！</p><p><strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><p>一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。</p><p>这是一个很不好的习惯！</p><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。</p><p>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p><p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了</strong>。</p><p>这也是我为什么在动规五步曲里强调推导dp数组的重要性。</p><p>发出这样的问题之前，其实可以自己先思考这三个问题：</p><ul><li>这道题目我举例推导状态转移公式了么？</li><li>我打印dp数组的日志了么？</li><li>打印出来了dp数组和我想的一样么？</li></ul><p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。</p><p>然后在问问题，目的性就很强了。</p><p>所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何debug。</p><p>动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。</p><p>在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的01背包，leetcode上的题目都是01背包的应用，而没有纯01背包的问题，那么就需要在把对应的理论知识讲解一下。</p><p>大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。</p><p>这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;再识动态规划&quot;&gt;&lt;a href=&quot;#再识动态规划&quot; class=&quot;headerlink&quot; title=&quot;再识动态规划&quot;&gt;&lt;/a&gt;再识动态规划&lt;/h2&gt;&lt;h3 id=&quot;什么是动态规划&quot;&gt;&lt;a href=&quot;#什么是动态规划&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>10-分发糖果</title>
    <link href="https://xxren8218.github.io/20210730/10-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html"/>
    <id>https://xxren8218.github.io/20210730/10-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html</id>
    <published>2021-07-30T15:02:58.000Z</published>
    <updated>2021-07-30T15:07:04.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730230415.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p><p>此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p><p>局部最优可以推出全局最优。</p><p>如果ratings[i] &gt; ratings[i - 1] 那么[i]的糖 一定要比[i - 1]的糖多一个，所以贪心：candyVec[i] = candyVec[i - 1] + 1</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从前向后</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(ratings)):</span><br><span class="line">    <span class="keyword">if</span> ratings[i] &gt; ratings[i - <span class="number">1</span>]:</span><br><span class="line">        candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730230453.png" alt=""></p><p>再确定左孩子大于右孩子的情况（从后向前遍历）</p><p>遍历顺序这里有同学可能会有疑问，为什么不能从前向后遍历呢？</p><p>因为如果从前向后遍历，根据 ratings[i + 1] 来确定 ratings[i] 对应的糖果，那么每次都不能利用上前一次的比较结果了。</p><p><strong>所以确定左孩子大于右孩子的情况一定要从后向前遍历！</strong></p><p>如果 ratings[i] &gt; ratings[i + 1]，此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量）。</p><p>那么又要贪心了，局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量即大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p><p>局部最优可以推出全局最优。</p><p>所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210730230621.png" alt=""></p><p>所以该过程代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从后向前</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ratings) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> ratings[i] &gt; ratings[i + <span class="number">1</span>]:</span><br><span class="line">        candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self, ratings</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type ratings: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        candyVec = [<span class="number">1</span>] * <span class="built_in">len</span>(ratings)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从前到后</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(ratings)):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i - <span class="number">1</span>]:</span><br><span class="line">                candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从后往前</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ratings) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i + <span class="number">1</span>]:</span><br><span class="line">                candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(candyVec)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这在leetcode上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p><p>那么本题我采用了两次贪心的策略：</p><ul><li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li><li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li></ul><p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分发糖果&quot;&gt;&lt;a href=&quot;#分发糖果&quot; class=&quot;headerlink&quot; title=&quot;分发糖果&quot;&gt;&lt;/a&gt;分发糖果&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>09-加油站</title>
    <link href="https://xxren8218.github.io/20210729/09-%E5%8A%A0%E6%B2%B9%E7%AB%99.html"/>
    <id>https://xxren8218.github.io/20210729/09-%E5%8A%A0%E6%B2%B9%E7%AB%99.html</id>
    <published>2021-07-29T11:11:43.000Z</published>
    <updated>2021-07-29T11:12:41.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210729191220.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="一、暴力解法"><a href="#一、暴力解法" class="headerlink" title="一、暴力解法"></a>一、暴力解法</h3><p>暴力的方法很明显就是O(n^2)的，遍历每一个加油站为起点的情况，模拟一圈。</p><p>如果跑了一圈，中途没有断油，而且最后油量大于等于0，说明这个起点是ok的。</p><p>暴力的方法思路比较简单，但代码写起来也不是很容易，关键是要模拟跑一圈的过程。</p><p><strong>「for循环适合模拟从头到尾的遍历，而while循环适合模拟环形遍历，要善于使用while！」</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span>(<span class="params">self, gas, cost</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cost)):</span><br><span class="line">            rest = gas[i] - cost[i]         <span class="comment"># 记录剩余油量</span></span><br><span class="line">            index = (i + <span class="number">1</span>) % <span class="built_in">len</span>(cost)     </span><br><span class="line">            <span class="keyword">while</span> rest &gt; <span class="number">0</span> <span class="keyword">and</span> index != i:  <span class="comment"># 模拟以i为起点行驶一圈</span></span><br><span class="line">                rest += gas[index] - cost[index]</span><br><span class="line">                index = (index + <span class="number">1</span>) % <span class="built_in">len</span>(cost)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> rest &gt;= <span class="number">0</span> <span class="keyword">and</span> index == i: <span class="keyword">return</span> i  <span class="comment"># 如果以i为起点跑一圈，剩余油量&gt;=0，返回该起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(n)</li></ul><p>暴力解法在leetcode上提交也可以过。2000多ms</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>直接从全局进行贪心选择，情况如下：</p><ul><li>情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</li><li>情况二：rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。</li><li>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span>(<span class="params">self, gas, cost</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curSum = <span class="number">0</span></span><br><span class="line">        <span class="built_in">min</span> = <span class="built_in">float</span>(<span class="string">&quot;INF&quot;</span>) <span class="comment"># 油箱里面油量的最小值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            rest = gas[i] - cost[i]</span><br><span class="line">            curSum += rest</span><br><span class="line">            <span class="keyword">if</span> curSum &lt; <span class="built_in">min</span>:</span><br><span class="line">                <span class="built_in">min</span> = curSum</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> curSum &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span> <span class="comment"># 情况1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">min</span> &gt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span>     <span class="comment"># 情况2</span></span><br><span class="line">                                 <span class="comment"># 情况3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            rest = gas[i] - cost[i]</span><br><span class="line">            <span class="built_in">min</span> += rest</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">min</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于本题首先给出了暴力解法，暴力解法模拟跑一圈的过程其实比较考验代码技巧的，要对while使用的很熟练。</p><p>然后给出了贪心算法，对于贪心方法，其实我认为就是一种直接从全局选取最优的模拟操作，思路还是好巧妙的，值得学习一下。</p><p>对于第二种贪心方法，才真正体现出贪心的精髓，用局部最优可以推出全局最优，进而求得起始位置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;加油站&quot;&gt;&lt;a href=&quot;#加油站&quot; class=&quot;headerlink&quot; title=&quot;加油站&quot;&gt;&lt;/a&gt;加油站&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
