<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-05-25T16:59:30.782Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时间序列——ARIMA模型参数的选择</title>
    <link href="https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94ARIMA%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9.html"/>
    <id>https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94ARIMA%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9.html</id>
    <published>2021-05-25T16:57:08.000Z</published>
    <updated>2021-05-25T16:59:30.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARIMA的模型参数选择"><a href="#ARIMA的模型参数选择" class="headerlink" title="ARIMA的模型参数选择"></a>ARIMA的模型参数选择</h2><ul><li><p>AIC（赤池信息准则）</p></li><li><p>BIC（贝叶斯信息准则）</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">%load_ext autoreload</span><br><span class="line">%autoreload <span class="number">2</span></span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format=<span class="string">&#x27;retina&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, division, print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># TSA from Statsmodels</span></span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> statsmodels.formula.api <span class="keyword">as</span> smf</span><br><span class="line"><span class="keyword">import</span> statsmodels.tsa.api <span class="keyword">as</span> smt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display and Plotting</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x: <span class="string">&#x27;%.5f&#x27;</span> % x) <span class="comment"># pandas</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">5</span>, suppress=<span class="literal">True</span>) <span class="comment"># numpy</span></span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_columns&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># seaborn plotting style</span></span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&#x27;ticks&#x27;</span>, context=<span class="string">&#x27;poster&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filename_ts = <span class="string">&#x27;data/series1.csv&#x27;</span></span><br><span class="line">ts_df = pd.read_csv(filename_ts, index_col=<span class="number">0</span>, parse_dates=[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">n_sample = ts_df.shape[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ts_df.shape)</span><br><span class="line">print(ts_df.head())</span><br></pre></td></tr></table></figure><pre><code>(120, 1)              value2006-06-01  0.215072006-07-01  1.142252006-08-01  0.080772006-09-01 -0.739522006-10-01  0.53552</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a training sample and testing sample before analyzing the series</span></span><br><span class="line"></span><br><span class="line">n_train=<span class="built_in">int</span>(<span class="number">0.95</span>*n_sample)+<span class="number">1</span></span><br><span class="line">n_forecast=n_sample-n_train</span><br><span class="line"><span class="comment">#ts_df</span></span><br><span class="line">ts_train = ts_df.iloc[:n_train][<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">ts_test = ts_df.iloc[n_train:][<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">print(ts_train.shape)</span><br><span class="line">print(ts_test.shape)</span><br><span class="line">print(<span class="string">&quot;Training Series:&quot;</span>, <span class="string">&quot;\n&quot;</span>, ts_train.tail(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Testing Series:&quot;</span>, <span class="string">&quot;\n&quot;</span>, ts_test.head())</span><br></pre></td></tr></table></figure><pre><code>(115,)(5,)Training Series:  2015-08-01    0.603712015-09-01   -1.273722015-10-01   -0.932842015-11-01    0.085522015-12-01    1.20534Name: value, dtype: float64 Testing Series:  2016-01-01    2.164112016-02-01    0.952262016-03-01    0.364852016-04-01   -2.264872016-05-01   -2.38168Name: value, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tsplot</span>(<span class="params">y, lags=<span class="literal">None</span>, title=<span class="string">&#x27;&#x27;</span>, figsize=(<span class="params"><span class="number">14</span>, <span class="number">8</span></span>)</span>):</span></span><br><span class="line">    </span><br><span class="line">    fig = plt.figure(figsize=figsize)</span><br><span class="line">    layout = (<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ts_ax   = plt.subplot2grid(layout, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    hist_ax = plt.subplot2grid(layout, (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    acf_ax  = plt.subplot2grid(layout, (<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    pacf_ax = plt.subplot2grid(layout, (<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    y.plot(ax=ts_ax)</span><br><span class="line">    ts_ax.set_title(title)</span><br><span class="line">    y.plot(ax=hist_ax, kind=<span class="string">&#x27;hist&#x27;</span>, bins=<span class="number">25</span>)</span><br><span class="line">    hist_ax.set_title(<span class="string">&#x27;Histogram&#x27;</span>)</span><br><span class="line">    smt.graphics.plot_acf(y, lags=lags, ax=acf_ax)</span><br><span class="line">    smt.graphics.plot_pacf(y, lags=lags, ax=pacf_ax)</span><br><span class="line">    [ax.set_xlim(<span class="number">0</span>) <span class="keyword">for</span> ax <span class="keyword">in</span> [acf_ax, pacf_ax]]</span><br><span class="line">    sns.despine()</span><br><span class="line">    fig.tight_layout()</span><br><span class="line">    <span class="keyword">return</span> ts_ax, acf_ax, pacf_ax</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsplot(ts_train, title=<span class="string">&#x27;A Given Training Series&#x27;</span>, lags=<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005846.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Model Estimation</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit the model</span></span><br><span class="line">arima200 = sm.tsa.SARIMAX(ts_train, order=(<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>))  <span class="comment"># order 表示ARIMA模型的指定的参数 p, d，q</span></span><br><span class="line">model_results = arima200.fit()</span><br></pre></td></tr></table></figure><h3 id="有了不同的参数都满足如何选取呢？"><a href="#有了不同的参数都满足如何选取呢？" class="headerlink" title="有了不同的参数都满足如何选取呢？"></a>有了不同的参数都满足如何选取呢？</h3><ul><li><p>选取最简单的模型</p></li><li><p>AIC（赤池信息准则）</p></li><li><p>BIC（贝叶斯信息准则）</p></li></ul><p><strong>越小越好</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">p_min = <span class="number">0</span></span><br><span class="line">d_min = <span class="number">0</span></span><br><span class="line">q_min = <span class="number">0</span></span><br><span class="line">p_max = <span class="number">4</span></span><br><span class="line">d_max = <span class="number">0</span></span><br><span class="line">q_max = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a DataFrame to store the results</span></span><br><span class="line">results_bic = pd.DataFrame(index=[<span class="string">&#x27;AR&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p_min,p_max+<span class="number">1</span>)],</span><br><span class="line">                           columns=[<span class="string">&#x27;MA&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q_min,q_max+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p,d,q <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(p_min,p_max+<span class="number">1</span>),</span><br><span class="line">                               <span class="built_in">range</span>(d_min,d_max+<span class="number">1</span>),</span><br><span class="line">                               <span class="built_in">range</span>(q_min,q_max+<span class="number">1</span>)):</span><br><span class="line">    <span class="keyword">if</span> p==<span class="number">0</span> <span class="keyword">and</span> d==<span class="number">0</span> <span class="keyword">and</span> q==<span class="number">0</span>:</span><br><span class="line">        results_bic.loc[<span class="string">&#x27;AR&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(p), <span class="string">&#x27;MA&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(q)] = np.nan</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        model = sm.tsa.SARIMAX(ts_train, order=(p, d, q),</span><br><span class="line">                               <span class="comment">#enforce_stationarity=False,</span></span><br><span class="line">                               <span class="comment">#enforce_invertibility=False,</span></span><br><span class="line">                              )</span><br><span class="line">        results = model.fit()</span><br><span class="line">        results_bic.loc[<span class="string">&#x27;AR&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(p), <span class="string">&#x27;MA&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(q)] = results.bic</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">results_bic = results_bic[results_bic.columns].astype(<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">ax = sns.heatmap(results_bic,</span><br><span class="line">                 mask=results_bic.isnull(),</span><br><span class="line">                 ax=ax,</span><br><span class="line">                 annot=<span class="literal">True</span>,</span><br><span class="line">                 fmt=<span class="string">&#x27;.2f&#x27;</span>,</span><br><span class="line">                 );</span><br><span class="line">ax.set_title(<span class="string">&#x27;BIC&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005904.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Alternative model selection method, limited to only searching AR and MA parameters</span></span><br><span class="line"></span><br><span class="line">train_results = sm.tsa.arma_order_select_ic(ts_train, ic=[<span class="string">&#x27;aic&#x27;</span>, <span class="string">&#x27;bic&#x27;</span>], trend=<span class="string">&#x27;nc&#x27;</span>, max_ar=<span class="number">4</span>, max_ma=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;AIC&#x27;</span>, train_results.aic_min_order)</span><br><span class="line">print(<span class="string">&#x27;BIC&#x27;</span>, train_results.bic_min_order)</span><br></pre></td></tr></table></figure><pre><code>AIC (4, 2)BIC (1, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 残差分析 正态分布 QQ图线性</span></span><br><span class="line">model_results.plot_diagnostics(figsize=(<span class="number">16</span>, <span class="number">12</span>));</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005917.png" alt=""></p><p>QQ 图若是直线，则是正态分布。符合要求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ARIMA的模型参数选择&quot;&gt;&lt;a href=&quot;#ARIMA的模型参数选择&quot; class=&quot;headerlink&quot; title=&quot;ARIMA的模型参数选择&quot;&gt;&lt;/a&gt;ARIMA的模型参数选择&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AIC（赤池信息准则）&lt;/p&gt;
&lt;/li&gt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>时间序列——ARIMA的一些概念</title>
    <link href="https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94ARIMA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5.html"/>
    <id>https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94ARIMA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5.html</id>
    <published>2021-05-25T16:51:04.000Z</published>
    <updated>2021-05-25T16:54:41.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARIMA模型的一些概念"><a href="#ARIMA模型的一些概念" class="headerlink" title="ARIMA模型的一些概念"></a>ARIMA模型的一些概念</h2><ul><li>差分</li><li>ACF 自相关函数</li><li>PACF 偏自相关函数</li></ul><p><strong>需要用到statsmodels模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">%load_ext autoreload</span><br><span class="line">%autoreload <span class="number">2</span></span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format=<span class="string">&#x27;retina&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, division, print_function</span><br><span class="line"><span class="comment"># http://www.lfd.uci.edu/~gohlke/pythonlibs/#xgboost  # 很多可以装的python库</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># # Remote Data Access</span></span><br><span class="line"><span class="comment"># import pandas_datareader.data as web</span></span><br><span class="line"><span class="comment"># import datetime</span></span><br><span class="line"><span class="comment"># # reference: https://pandas-datareader.readthedocs.io/en/latest/remote_data.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TSA from Statsmodels</span></span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> statsmodels.formula.api <span class="keyword">as</span> smf</span><br><span class="line"><span class="keyword">import</span> statsmodels.tsa.api <span class="keyword">as</span> smt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display and Plotting</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x: <span class="string">&#x27;%.5f&#x27;</span> % x) <span class="comment"># pandas</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">5</span>, suppress=<span class="literal">True</span>) <span class="comment"># numpy</span></span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_columns&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># seaborn plotting style</span></span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&#x27;ticks&#x27;</span>, context=<span class="string">&#x27;poster&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>The autoreload extension is already loaded. To reload it, use:  %reload_ext autoreload</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Read the data</span></span><br><span class="line"><span class="comment">#美国消费者信心指数</span></span><br><span class="line">Sentiment = <span class="string">&#x27;data/sentiment.csv&#x27;</span></span><br><span class="line">Sentiment = pd.read_csv(Sentiment, index_col=<span class="number">0</span>, parse_dates=[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sentiment.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>UMCSENT</th>    </tr>    <tr>      <th>DATE</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>2000-01-01</th>      <td>112.00000</td>    </tr>    <tr>      <th>2000-02-01</th>      <td>111.30000</td>    </tr>    <tr>      <th>2000-03-01</th>      <td>107.10000</td>    </tr>    <tr>      <th>2000-04-01</th>      <td>109.20000</td>    </tr>    <tr>      <th>2000-05-01</th>      <td>110.70000</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Select the series from 2005 - 2016</span></span><br><span class="line">sentiment_short = Sentiment.loc[<span class="string">&#x27;2005&#x27;</span>:<span class="string">&#x27;2016&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentiment_short.plot(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">plt.legend(bbox_to_anchor=(<span class="number">1.25</span>, <span class="number">0.5</span>))</span><br><span class="line">plt.title(<span class="string">&quot;Consumer Sentiment&quot;</span>)</span><br><span class="line">sns.despine()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005235.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentiment_short[<span class="string">&#x27;diff_1&#x27;</span>] = sentiment_short[<span class="string">&#x27;UMCSENT&#x27;</span>].diff(<span class="number">1</span>) <span class="comment"># 做一个是时间间隔算差分值</span></span><br><span class="line"></span><br><span class="line">sentiment_short[<span class="string">&#x27;diff_2&#x27;</span>] = sentiment_short[<span class="string">&#x27;diff_1&#x27;</span>].diff(<span class="number">1</span>) <span class="comment"># 对一阶差分的基础上进行算差分，得到二阶差分。</span></span><br><span class="line"></span><br><span class="line">sentiment_short.plot(subplots=<span class="literal">True</span>, figsize=(<span class="number">18</span>, <span class="number">12</span>))</span><br></pre></td></tr></table></figure><pre><code>array([&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000001D9383BACF8&gt;,       &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000001D939FAB6A0&gt;,       &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000001D93A139B70&gt;], dtype=object)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005300.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> sentiment_short[<span class="string">&#x27;diff_2&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> sentiment_short[<span class="string">&#x27;diff_1&#x27;</span>]</span><br><span class="line">sentiment_short.head()</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(sentiment_short))</span><br></pre></td></tr></table></figure><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">211</span>)</span><br><span class="line">fig = sm.graphics.tsa.plot_acf(sentiment_short, lags=<span class="number">20</span>,ax=ax1)</span><br><span class="line">ax1.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">fig.tight_layout();</span><br><span class="line"></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">212</span>)</span><br><span class="line">fig = sm.graphics.tsa.plot_pacf(sentiment_short, lags=<span class="number">20</span>, ax=ax2)</span><br><span class="line">ax2.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">fig.tight_layout();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005319.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 散点图也可以表示</span></span><br><span class="line"></span><br><span class="line">lags=<span class="number">9</span></span><br><span class="line"></span><br><span class="line">ncols=<span class="number">3</span></span><br><span class="line">nrows=<span class="built_in">int</span>(np.ceil(lags/ncols))</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=ncols, nrows=nrows, figsize=(<span class="number">4</span>*ncols, <span class="number">4</span>*nrows))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, lag <span class="keyword">in</span> <span class="built_in">zip</span>(axes.flat, np.arange(<span class="number">1</span>,lags+<span class="number">1</span>, <span class="number">1</span>)):</span><br><span class="line">    lag_str = <span class="string">&#x27;t-&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(lag)</span><br><span class="line">    X = (pd.concat([sentiment_short, sentiment_short.shift(-lag)], axis=<span class="number">1</span>,</span><br><span class="line">                   keys=[<span class="string">&#x27;y&#x27;</span>] + [lag_str]).dropna())</span><br><span class="line"></span><br><span class="line">    X.plot(ax=ax, kind=<span class="string">&#x27;scatter&#x27;</span>, y=<span class="string">&#x27;y&#x27;</span>, x=lag_str);</span><br><span class="line">    corr = X.corr().as_matrix()[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">    ax.set_title(<span class="string">&#x27;Lag: &#123;&#125; (corr=&#123;:.2f&#125;)&#x27;</span>.<span class="built_in">format</span>(lag_str, corr));</span><br><span class="line">    ax.set_aspect(<span class="string">&#x27;equal&#x27;</span>);</span><br><span class="line">    sns.despine();</span><br><span class="line"></span><br><span class="line">fig.tight_layout();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005340.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更直观一些</span></span><br><span class="line"><span class="comment"># 模板——只需要把自己的数据放进来，就可进行分析。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tsplot</span>(<span class="params">y, lags=<span class="literal">None</span>, title=<span class="string">&#x27;&#x27;</span>, figsize=(<span class="params"><span class="number">14</span>, <span class="number">8</span></span>)</span>):</span></span><br><span class="line">   </span><br><span class="line">    fig = plt.figure(figsize=figsize)</span><br><span class="line">    layout = (<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ts_ax   = plt.subplot2grid(layout, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    hist_ax = plt.subplot2grid(layout, (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    acf_ax  = plt.subplot2grid(layout, (<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    pacf_ax = plt.subplot2grid(layout, (<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    y.plot(ax=ts_ax)</span><br><span class="line">    ts_ax.set_title(title)</span><br><span class="line">    y.plot(ax=hist_ax, kind=<span class="string">&#x27;hist&#x27;</span>, bins=<span class="number">25</span>)</span><br><span class="line">    hist_ax.set_title(<span class="string">&#x27;Histogram&#x27;</span>)</span><br><span class="line">    smt.graphics.plot_acf(y, lags=lags, ax=acf_ax)</span><br><span class="line">    smt.graphics.plot_pacf(y, lags=lags, ax=pacf_ax)</span><br><span class="line">    [ax.set_xlim(<span class="number">0</span>) <span class="keyword">for</span> ax <span class="keyword">in</span> [acf_ax, pacf_ax]]</span><br><span class="line">    sns.despine()</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    <span class="keyword">return</span> ts_ax, acf_ax, pacf_ax</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsplot(sentiment_short, title=<span class="string">&#x27;Consumer Sentiment&#x27;</span>, lags=<span class="number">36</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005359.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ARIMA模型的一些概念&quot;&gt;&lt;a href=&quot;#ARIMA模型的一些概念&quot; class=&quot;headerlink&quot; title=&quot;ARIMA模型的一些概念&quot;&gt;&lt;/a&gt;ARIMA模型的一些概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;差分&lt;/li&gt;
&lt;li&gt;ACF 自相关函数&lt;/l</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>时间序列——pandas的滑动窗口</title>
    <link href="https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.html"/>
    <id>https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.html</id>
    <published>2021-05-25T16:49:14.000Z</published>
    <updated>2021-05-25T16:55:27.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pandas滑动窗口"><a href="#pandas滑动窗口" class="headerlink" title="pandas滑动窗口"></a>pandas滑动窗口</h3><ul><li>进行预测单独拿某一天的值不合理，可以用一个滑动窗口，取一个平均值，比较平稳。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline </span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.Series(np.random.randn(<span class="number">600</span>), index = pd.date_range(<span class="string">&#x27;7/1/2021&#x27;</span>, freq = <span class="string">&#x27;D&#x27;</span>, periods = <span class="number">600</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure><pre><code>2021-07-01   -1.5072342021-07-02    1.4607542021-07-03   -0.0921462021-07-04    2.4869302021-07-05    1.214179Freq: D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = df.rolling(window = <span class="number">10</span>) <span class="comment"># 滑动窗口的大小。默认从左边开始滑动。</span></span><br><span class="line">r</span><br></pre></td></tr></table></figure><pre><code>Rolling [window=10,center=False,axis=0]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r.max, r.median, r.std, r.skew, r.sum, r.var</span></span><br><span class="line">print(r.mean()) <span class="comment"># 小于窗口长度不会计算！为NaN</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>2021-07-01         NaN2021-07-02         NaN2021-07-03         NaN2021-07-04         NaN2021-07-05         NaN2021-07-06         NaN2021-07-07         NaN2021-07-08         NaN2021-07-09         NaN2021-07-10    0.4131762021-07-11    0.4896582021-07-12    0.3425022021-07-28   -0.1628612021-07-29   -0.2144422021-07-30   -0.257007                ...   2023-02-17    0.2890902023-02-18   -0.0495742023-02-19   -0.0959742023-02-20   -0.226629Freq: D, Length: 600, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">df.plot(style=<span class="string">&#x27;r--&#x27;</span>)</span><br><span class="line">df.rolling(window=<span class="number">10</span>).mean().plot(style=<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x1bafae87630&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005000.png" alt=""></p><p><strong>可以看到滑动窗口的平均值更平稳一些</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pandas滑动窗口&quot;&gt;&lt;a href=&quot;#pandas滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;pandas滑动窗口&quot;&gt;&lt;/a&gt;pandas滑动窗口&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;进行预测单独拿某一天的值不合理，可以用一个滑动窗口，取一个平均值</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>时间序列——pandas的数据重采样</title>
    <link href="https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8D%E9%87%87%E6%A0%B7.html"/>
    <id>https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8D%E9%87%87%E6%A0%B7.html</id>
    <published>2021-05-25T16:48:15.000Z</published>
    <updated>2021-05-25T16:48:52.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pandas数据重采样"><a href="#pandas数据重采样" class="headerlink" title="pandas数据重采样"></a>pandas数据重采样</h3><ul><li>时间数据由一个频率转换到另一个频率</li><li>降采样</li><li>升采样</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">&#x27;1/1/2011&#x27;</span>, periods=<span class="number">90</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line">ts.head()</span><br></pre></td></tr></table></figure><pre><code>2011-01-01   -1.0255622011-01-02    0.4108952011-01-03    0.6603112011-01-04    0.7102932011-01-05    0.444985Freq: D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.resample(<span class="string">&#x27;M&#x27;</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><pre><code>2011-01-31    2.5101022011-02-28    0.5832092011-03-31    2.749411Freq: M, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.resample(<span class="string">&#x27;3D&#x27;</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0456432011-01-04   -2.2552062011-01-07    0.5711422011-01-10    0.8350322011-01-13   -0.3967662011-01-16   -1.1562532011-01-19   -1.2868842011-01-22    2.8839522011-01-25    1.5669082011-01-28    1.4355632011-01-31    0.3115652011-02-03   -2.5412352011-02-06    0.3170752011-02-09    1.5988772011-02-12   -1.9505092011-02-15    2.9283122011-02-18   -0.7337152011-02-21    1.6748172011-02-24   -2.0788722011-02-27    2.1723202011-03-02   -2.0221042011-03-05   -0.0703562011-03-08    1.2766712011-03-11   -2.8351322011-03-14   -1.3841132011-03-17    1.5175652011-03-20   -0.5504062011-03-23    0.7734302011-03-26    2.2443192011-03-29    2.951082Freq: 3D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">day3Ts = ts.resample(<span class="string">&#x27;3D&#x27;</span>).mean()</span><br><span class="line">day3Ts</span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0152142011-01-04   -0.7517352011-01-07    0.1903812011-01-10    0.2783442011-01-13   -0.1322552011-01-16   -0.3854182011-01-19   -0.4289612011-01-22    0.9613172011-01-25    0.5223032011-01-28    0.4785212011-01-31    0.1038552011-02-03   -0.8470782011-02-06    0.1056922011-02-09    0.5329592011-02-12   -0.6501702011-02-15    0.9761042011-02-18   -0.2445722011-02-21    0.5582722011-02-24   -0.6929572011-02-27    0.7241072011-03-02   -0.6740352011-03-05   -0.0234522011-03-08    0.4255572011-03-11   -0.9450442011-03-14   -0.4613712011-03-17    0.5058552011-03-20   -0.1834692011-03-23    0.2578102011-03-26    0.7481062011-03-29    0.983694Freq: 3D, dtype: float64</code></pre><h3 id="降采样容易，但是升采样就有些难度了。"><a href="#降采样容易，但是升采样就有些难度了。" class="headerlink" title="降采样容易，但是升采样就有些难度了。"></a>降采样容易，但是升采样就有些难度了。</h3><ul><li>将上面的3天的数据变成1天统计的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(day3Ts.resample(<span class="string">&#x27;D&#x27;</span>).asfreq()) </span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0152142011-01-02         NaN2011-01-03         NaN2011-01-04   -0.7517352011-01-05         NaN2011-01-06         NaN2011-01-07    0.1903812011-01-08         NaN2011-01-09         NaN2011-01-10    0.2783442011-01-11         NaN2011-01-12         NaN2011-01-13   -0.1322552011-01-14         NaN2011-01-15         NaN2011-01-16   -0.3854182011-01-17         NaN2011-01-18         NaN2011-01-19   -0.4289612011-01-20         NaN2011-01-21         NaN2011-01-22    0.9613172011-01-23         NaN2011-01-24         NaN2011-01-25    0.5223032011-01-26         NaN2011-01-27         NaN2011-01-28    0.4785212011-01-29         NaN2011-01-30         NaN                ...   2011-02-28         NaN2011-03-01         NaN2011-03-02   -0.6740352011-03-03         NaN2011-03-04         NaN2011-03-05   -0.0234522011-03-06         NaN2011-03-07         NaN2011-03-08    0.4255572011-03-09         NaN2011-03-10         NaN2011-03-11   -0.9450442011-03-12         NaN2011-03-13         NaN2011-03-14   -0.4613712011-03-15         NaN2011-03-16         NaN2011-03-17    0.5058552011-03-18         NaN2011-03-19         NaN2011-03-20   -0.1834692011-03-21         NaN2011-03-22         NaN2011-03-23    0.2578102011-03-24         NaN2011-03-25         NaN2011-03-26    0.7481062011-03-27         NaN2011-03-28         NaN2011-03-29    0.983694Freq: D, Length: 88, dtype: float64</code></pre><h3 id="插值方法："><a href="#插值方法：" class="headerlink" title="插值方法："></a>插值方法：</h3><ul><li>ffill 空值取前面的值</li><li>bfill 空值取后面的值</li><li>interpolate 线性取值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">day3Ts.resample(<span class="string">&#x27;D&#x27;</span>).ffill(<span class="number">1</span>) <span class="comment"># 按照前面的数据进行插值</span></span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0152142011-01-02    0.0152142011-01-03         NaN2011-01-04   -0.7517352011-01-05   -0.7517352011-01-06         NaN2011-01-07    0.1903812011-01-08    0.1903812011-01-09         NaN2011-01-10    0.2783442011-01-11    0.2783442011-01-12         NaN2011-01-13   -0.1322552011-01-14   -0.1322552011-01-15         NaN2011-01-16   -0.3854182011-01-17   -0.3854182011-01-18         NaN2011-01-19   -0.4289612011-01-20   -0.4289612011-01-21         NaN2011-01-22    0.9613172011-01-23    0.9613172011-01-24         NaN2011-01-25    0.5223032011-01-26    0.5223032011-01-27         NaN2011-01-28    0.4785212011-01-29    0.4785212011-01-30         NaN                ...   2011-02-28    0.7241072011-03-01         NaN2011-03-02   -0.6740352011-03-03   -0.6740352011-03-04         NaN2011-03-05   -0.0234522011-03-06   -0.0234522011-03-07         NaN2011-03-08    0.4255572011-03-09    0.4255572011-03-10         NaN2011-03-11   -0.9450442011-03-12   -0.9450442011-03-13         NaN2011-03-14   -0.4613712011-03-15   -0.4613712011-03-16         NaN2011-03-17    0.5058552011-03-18    0.5058552011-03-19         NaN2011-03-20   -0.1834692011-03-21   -0.1834692011-03-22         NaN2011-03-23    0.2578102011-03-24    0.2578102011-03-25         NaN2011-03-26    0.7481062011-03-27    0.7481062011-03-28         NaN2011-03-29    0.983694Freq: D, Length: 88, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">day3Ts.resample(<span class="string">&#x27;D&#x27;</span>).bfill(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0152142011-01-02         NaN2011-01-03   -0.7517352011-01-04   -0.7517352011-01-05         NaN2011-01-06    0.1903812011-01-07    0.1903812011-01-08         NaN2011-01-09    0.2783442011-01-10    0.2783442011-01-11         NaN2011-01-12   -0.1322552011-01-13   -0.1322552011-01-14         NaN2011-01-15   -0.3854182011-01-16   -0.3854182011-01-17         NaN2011-01-18   -0.4289612011-01-19   -0.4289612011-01-20         NaN2011-01-21    0.9613172011-01-22    0.9613172011-01-23         NaN2011-01-24    0.5223032011-01-25    0.5223032011-01-26         NaN2011-01-27    0.4785212011-01-28    0.4785212011-01-29         NaN2011-01-30    0.103855                ...   2011-02-28         NaN2011-03-01   -0.6740352011-03-02   -0.6740352011-03-03         NaN2011-03-04   -0.0234522011-03-05   -0.0234522011-03-06         NaN2011-03-07    0.4255572011-03-08    0.4255572011-03-09         NaN2011-03-10   -0.9450442011-03-11   -0.9450442011-03-12         NaN2011-03-13   -0.4613712011-03-14   -0.4613712011-03-15         NaN2011-03-16    0.5058552011-03-17    0.5058552011-03-18         NaN2011-03-19   -0.1834692011-03-20   -0.1834692011-03-21         NaN2011-03-22    0.2578102011-03-23    0.2578102011-03-24         NaN2011-03-25    0.7481062011-03-26    0.7481062011-03-27         NaN2011-03-28    0.9836942011-03-29    0.983694Freq: D, Length: 88, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">day3Ts.resample(<span class="string">&#x27;D&#x27;</span>).interpolate(<span class="string">&#x27;linear&#x27;</span>) <span class="comment"># 1和4有数据，连城线，在对应点取值。</span></span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0152142011-01-02   -0.2404352011-01-03   -0.4960852011-01-04   -0.7517352011-01-05   -0.4376972011-01-06   -0.1236582011-01-07    0.1903812011-01-08    0.2197022011-01-09    0.2490232011-01-10    0.2783442011-01-11    0.1414782011-01-12    0.0046112011-01-13   -0.1322552011-01-14   -0.2166432011-01-15   -0.3010302011-01-16   -0.3854182011-01-17   -0.3999322011-01-18   -0.4144472011-01-19   -0.4289612011-01-20    0.0344652011-01-21    0.4978912011-01-22    0.9613172011-01-23    0.8149792011-01-24    0.6686412011-01-25    0.5223032011-01-26    0.5077092011-01-27    0.4931152011-01-28    0.4785212011-01-29    0.3536322011-01-30    0.228744                ...   2011-02-28    0.2580602011-03-01   -0.2079882011-03-02   -0.6740352011-03-03   -0.4571742011-03-04   -0.2403132011-03-05   -0.0234522011-03-06    0.1262182011-03-07    0.2758872011-03-08    0.4255572011-03-09   -0.0313102011-03-10   -0.4881772011-03-11   -0.9450442011-03-12   -0.7838202011-03-13   -0.6225952011-03-14   -0.4613712011-03-15   -0.1389622011-03-16    0.1834462011-03-17    0.5058552011-03-18    0.2760802011-03-19    0.0463062011-03-20   -0.1834692011-03-21   -0.0363762011-03-22    0.1107172011-03-23    0.2578102011-03-24    0.4212422011-03-25    0.5846742011-03-26    0.7481062011-03-27    0.8266362011-03-28    0.9051652011-03-29    0.983694Freq: D, Length: 88, dtype: float64</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pandas数据重采样&quot;&gt;&lt;a href=&quot;#pandas数据重采样&quot; class=&quot;headerlink&quot; title=&quot;pandas数据重采样&quot;&gt;&lt;/a&gt;pandas数据重采样&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;时间数据由一个频率转换到另一个频率&lt;/li&gt;
&lt;li&gt;降</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>时间序列——pandas生成时间序列</title>
    <link href="https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%94%9F%E6%88%90%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%94%9F%E6%88%90%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97.html</id>
    <published>2021-05-25T16:46:08.000Z</published>
    <updated>2021-05-25T16:56:35.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pandas生成时间序列"><a href="#pandas生成时间序列" class="headerlink" title="pandas生成时间序列"></a>pandas生成时间序列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime <span class="keyword">as</span> dt</span><br></pre></td></tr></table></figure><h3 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h3><ul><li>时间戳（timestamp）具体到时间点</li><li>固定周期（period）</li><li>时间间隔（interval）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005603.png" alt=""></p><h3 id="date-range"><a href="#date-range" class="headerlink" title="date_range"></a>date_range</h3><ul><li>可以指定开始时间与周期</li><li>H：小时</li><li>D：天</li><li>M：月</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TIMES # 2021 Jul 1 7/1/2021 1/7/2021 2021-07-01 2021/07/01都可以</span></span><br><span class="line">rng = pd.date_range(<span class="string">&#x27;2021-07-01&#x27;</span>, periods = <span class="number">10</span>, freq = <span class="string">&#x27;3D&#x27;</span>)</span><br><span class="line">rng</span><br></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2021-07-01&#39;, &#39;2021-07-04&#39;, &#39;2021-07-07&#39;, &#39;2021-07-10&#39;,               &#39;2021-07-13&#39;, &#39;2021-07-16&#39;, &#39;2021-07-19&#39;, &#39;2021-07-22&#39;,               &#39;2021-07-25&#39;, &#39;2021-07-28&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;3D&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time=pd.Series(np.random.randn(<span class="number">20</span>),</span><br><span class="line">           index=pd.date_range(dt(<span class="number">2021</span>,<span class="number">1</span>,<span class="number">1</span>),periods=<span class="number">20</span>))</span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure><pre><code>2021-01-01    0.6083582021-01-02   -0.4024342021-01-03   -1.9176162021-01-04    1.5689362021-01-05   -0.6681692021-01-06   -0.1480382021-01-07   -0.3934292021-01-08    0.0520602021-01-09   -0.0747322021-01-10    1.4574572021-01-11   -0.1068782021-01-12    0.3405052021-01-13    0.6947552021-01-14    0.2615712021-01-15    0.2310212021-01-16   -0.4546392021-01-17   -0.3137792021-01-18    0.3115802021-01-19   -1.3759622021-01-20    1.450409Freq: D, dtype: float64</code></pre><h3 id="truncate过滤"><a href="#truncate过滤" class="headerlink" title="truncate过滤"></a>truncate过滤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.truncate(before=<span class="string">&#x27;2021-1-10&#x27;</span>) <span class="comment"># 之前的都没有了</span></span><br></pre></td></tr></table></figure><pre><code>2021-01-10    1.4574572021-01-11   -0.1068782021-01-12    0.3405052021-01-13    0.6947552021-01-14    0.2615712021-01-15    0.2310212021-01-16   -0.4546392021-01-17   -0.3137792021-01-18    0.3115802021-01-19   -1.3759622021-01-20    1.450409Freq: D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.truncate(after=<span class="string">&#x27;2021-1-10&#x27;</span>) <span class="comment"># 之后的都没了</span></span><br></pre></td></tr></table></figure><pre><code>2021-01-01    0.6083582021-01-02   -0.4024342021-01-03   -1.9176162021-01-04    1.5689362021-01-05   -0.6681692021-01-06   -0.1480382021-01-07   -0.3934292021-01-08    0.0520602021-01-09   -0.0747322021-01-10    1.457457Freq: D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(time[<span class="string">&#x27;2021-01-15&#x27;</span>])</span><br></pre></td></tr></table></figure><pre><code>0.2310208242057297</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(time[<span class="string">&#x27;2021-01-15&#x27;</span>:<span class="string">&#x27;2021-01-20&#x27;</span>])</span><br></pre></td></tr></table></figure><pre><code>2021-01-15    0.2310212021-01-16   -0.4546392021-01-17   -0.3137792021-01-18    0.3115802021-01-19   -1.3759622021-01-20    1.450409Freq: D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data=pd.date_range(<span class="string">&#x27;2020-01-01&#x27;</span>,<span class="string">&#x27;2021-01-01&#x27;</span>,freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2020-01-31&#39;, &#39;2020-02-29&#39;, &#39;2020-03-31&#39;, &#39;2020-04-30&#39;,               &#39;2020-05-31&#39;, &#39;2020-06-30&#39;, &#39;2020-07-31&#39;, &#39;2020-08-31&#39;,               &#39;2020-09-30&#39;, &#39;2020-10-31&#39;, &#39;2020-11-30&#39;, &#39;2020-12-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005622.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间戳</span></span><br><span class="line">pd.Timestamp(<span class="string">&#x27;2021-07-10&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2021-07-10 00:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以指定更多细节</span></span><br><span class="line">pd.Timestamp(<span class="string">&#x27;2021-07-10 10&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2021-07-10 10:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Timestamp(<span class="string">&#x27;2021-07-10 10:15&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2021-07-10 10:15:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How much detail can you add?</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = pd.Timestamp(<span class="string">&#x27;2021-07-10 10:15&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间区间</span></span><br><span class="line">pd.Period(<span class="string">&#x27;2021-01&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Period(&#39;2021-01&#39;, &#39;M&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Period(<span class="string">&#x27;2021-01-01&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Period(&#39;2021-01-01&#39;, &#39;D&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TIME OFFSETS 对时间的加减！</span></span><br><span class="line">pd.Timedelta(<span class="string">&#x27;1 day&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timedelta(&#39;1 days 00:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Period(<span class="string">&#x27;2021-01-01 10:10&#x27;</span>) + pd.Timedelta(<span class="string">&#x27;1 day&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Period(&#39;2021-01-02 10:10&#39;, &#39;T&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Timestamp(<span class="string">&#x27;2021-01-01 10:10&#x27;</span>) + pd.Timedelta(<span class="string">&#x27;1 day&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2021-01-02 10:10:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Timestamp(<span class="string">&#x27;2021-01-01 10:10&#x27;</span>) + pd.Timedelta(<span class="string">&#x27;15 ns&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2021-01-01 10:10:00.000000015&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = pd.period_range(<span class="string">&#x27;2021-01-01 10:10&#x27;</span>, freq = <span class="string">&#x27;25H&#x27;</span>, periods = <span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = pd.period_range(<span class="string">&#x27;2021-01-01 10:10&#x27;</span>, freq = <span class="string">&#x27;1D1H&#x27;</span>, periods = <span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1</span><br></pre></td></tr></table></figure><pre><code>PeriodIndex([&#39;2021-01-01 10:00&#39;, &#39;2021-01-02 11:00&#39;, &#39;2021-01-03 12:00&#39;,             &#39;2021-01-04 13:00&#39;, &#39;2021-01-05 14:00&#39;, &#39;2021-01-06 15:00&#39;,             &#39;2021-01-07 16:00&#39;, &#39;2021-01-08 17:00&#39;, &#39;2021-01-09 18:00&#39;,             &#39;2021-01-10 19:00&#39;],            dtype=&#39;period[25H]&#39;, freq=&#39;25H&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2</span><br></pre></td></tr></table></figure><pre><code>PeriodIndex([&#39;2021-01-01 10:00&#39;, &#39;2021-01-02 11:00&#39;, &#39;2021-01-03 12:00&#39;,             &#39;2021-01-04 13:00&#39;, &#39;2021-01-05 14:00&#39;, &#39;2021-01-06 15:00&#39;,             &#39;2021-01-07 16:00&#39;, &#39;2021-01-08 17:00&#39;, &#39;2021-01-09 18:00&#39;,             &#39;2021-01-10 19:00&#39;],            dtype=&#39;period[25H]&#39;, freq=&#39;25H&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定索引</span></span><br><span class="line">rng = pd.date_range(<span class="string">&#x27;2016 Jul 1&#x27;</span>, periods = <span class="number">10</span>, freq = <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">rng</span><br><span class="line">pd.Series(<span class="built_in">range</span>(<span class="built_in">len</span>(rng)), index = rng)</span><br></pre></td></tr></table></figure><pre><code>2016-07-01    02016-07-02    12016-07-03    22016-07-04    32016-07-05    42016-07-06    52016-07-07    62016-07-08    72016-07-09    82016-07-10    9Freq: D, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">periods = [pd.Period(<span class="string">&#x27;2021-01&#x27;</span>), pd.Period(<span class="string">&#x27;2021-02&#x27;</span>), pd.Period(<span class="string">&#x27;2021-03&#x27;</span>)]</span><br><span class="line">ts = pd.Series(np.random.randn(<span class="built_in">len</span>(periods)), index = periods)</span><br><span class="line">ts</span><br></pre></td></tr></table></figure><pre><code>2021-01    0.9974222021-02    2.0062482021-03    0.606481Freq: M, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(ts.index)</span><br></pre></td></tr></table></figure><pre><code>pandas.core.indexes.period.PeriodIndex</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间戳和时间周期可以转换</span></span><br><span class="line">ts = pd.Series(<span class="built_in">range</span>(<span class="number">10</span>), pd.date_range(<span class="string">&#x27;07-10-21 8:00&#x27;</span>, periods = <span class="number">10</span>, freq = <span class="string">&#x27;H&#x27;</span>))</span><br><span class="line">ts</span><br></pre></td></tr></table></figure><pre><code>2021-07-10 08:00:00    02021-07-10 09:00:00    12021-07-10 10:00:00    22021-07-10 11:00:00    32021-07-10 12:00:00    42021-07-10 13:00:00    52021-07-10 14:00:00    62021-07-10 15:00:00    72021-07-10 16:00:00    82021-07-10 17:00:00    9Freq: H, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ts_period = ts.to_period()</span><br><span class="line">ts_period</span><br></pre></td></tr></table></figure><pre><code>2021-07-10 08:00    02021-07-10 09:00    12021-07-10 10:00    22021-07-10 11:00    32021-07-10 12:00    42021-07-10 13:00    52021-07-10 14:00    62021-07-10 15:00    72021-07-10 16:00    82021-07-10 17:00    9Freq: H, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts_period[<span class="string">&#x27;2021-07-10 08:30&#x27;</span>:<span class="string">&#x27;2021-07-10 11:45&#x27;</span>]  <span class="comment"># 时间周期包括8:00</span></span><br></pre></td></tr></table></figure><pre><code>2021-07-10 08:00    02021-07-10 09:00    12021-07-10 10:00    22021-07-10 11:00    3Freq: H, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts[<span class="string">&#x27;2021-07-10 08:30&#x27;</span>:<span class="string">&#x27;2021-07-10 11:45&#x27;</span>]   <span class="comment"># 时间戳不包活8:00</span></span><br></pre></td></tr></table></figure><pre><code>2021-07-10 09:00:00    12021-07-10 10:00:00    22021-07-10 11:00:00    3Freq: H, dtype: int32</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pandas生成时间序列&quot;&gt;&lt;a href=&quot;#pandas生成时间序列&quot; class=&quot;headerlink&quot; title=&quot;pandas生成时间序列&quot;&gt;&lt;/a&gt;pandas生成时间序列&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>支持向量机</title>
    <link href="https://xxren8218.github.io/20210525/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html"/>
    <id>https://xxren8218.github.io/20210525/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html</id>
    <published>2021-05-25T10:42:17.000Z</published>
    <updated>2021-05-25T10:49:25.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="支持向量机（SVM）"><a href="#支持向量机（SVM）" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h1><ul><li>低纬不可分的东西转化为高纬可分割的东西</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"></span><br><span class="line"><span class="comment"># use seaborn plotting defaults</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns; sns.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><h3 id="支持向量基本原理"><a href="#支持向量基本原理" class="headerlink" title="支持向量基本原理"></a>支持向量基本原理</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184326.png" alt=""></p><p>如何解决这个线性不可分问题呢？咱们给它映射到高维来试试</p><p>$z=x^2+y^2$. </p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机来点数据</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">50</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">0.60</span>)  <span class="comment"># cluster_std=0.60 簇的离散程度。越小，越集中，越好分类</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1ba274e1ac8&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184358.png" alt=""></p><p>随便的画几条分割线，哪个好来这？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xfit = np.linspace(-<span class="number">1</span>, <span class="number">3.5</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">0.6</span>], [<span class="number">2.1</span>], <span class="string">&#x27;x&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, markeredgewidth=<span class="number">2</span>, markersize=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m, b <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0.65</span>), (<span class="number">0.5</span>, <span class="number">1.6</span>), (-<span class="number">0.2</span>, <span class="number">2.9</span>)]:</span><br><span class="line">    plt.plot(xfit, m * xfit + b, <span class="string">&#x27;-k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">1</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184415.png" alt=""></p><h2 id="Support-Vector-Machines-最小化-雷区"><a href="#Support-Vector-Machines-最小化-雷区" class="headerlink" title="Support Vector Machines: 最小化 雷区"></a>Support Vector Machines: 最小化 <em>雷区</em></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xfit = np.linspace(-<span class="number">1</span>, <span class="number">3.5</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m, b, d <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0.65</span>, <span class="number">0.33</span>), (<span class="number">0.5</span>, <span class="number">1.6</span>, <span class="number">0.55</span>), (-<span class="number">0.2</span>, <span class="number">2.9</span>, <span class="number">0.2</span>)]:</span><br><span class="line">    yfit = m * xfit + b</span><br><span class="line">    plt.plot(xfit, yfit, <span class="string">&#x27;-k&#x27;</span>)</span><br><span class="line">    plt.fill_between(xfit, yfit - d, yfit + d, edgecolor=<span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">                     color=<span class="string">&#x27;#AAAAAA&#x27;</span>, alpha=<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">1</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184433.png" alt=""></p><h3 id="训练一个基本的SVM"><a href="#训练一个基本的SVM" class="headerlink" title="训练一个基本的SVM"></a>训练一个基本的SVM</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC <span class="comment"># &quot;Support vector classifier&quot;</span></span><br><span class="line">model = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">model.fit(X, y)</span><br></pre></td></tr></table></figure><pre><code>SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,  decision_function_shape=None, degree=3, gamma=&#39;auto&#39;, kernel=&#39;linear&#39;,  max_iter=-1, probability=False, random_state=None, shrinking=True,  tol=0.001, verbose=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘图函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_svc_decision_function</span>(<span class="params">model, ax=<span class="literal">None</span>, plot_support=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Plot the decision function for a 2D SVC&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ax = plt.gca()</span><br><span class="line">    xlim = ax.get_xlim()</span><br><span class="line">    ylim = ax.get_ylim()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># create grid to evaluate model</span></span><br><span class="line">    x = np.linspace(xlim[<span class="number">0</span>], xlim[<span class="number">1</span>], <span class="number">30</span>)</span><br><span class="line">    y = np.linspace(ylim[<span class="number">0</span>], ylim[<span class="number">1</span>], <span class="number">30</span>)</span><br><span class="line">    Y, X = np.meshgrid(y, x)</span><br><span class="line">    xy = np.vstack([X.ravel(), Y.ravel()]).T</span><br><span class="line">    P = model.decision_function(xy).reshape(X.shape)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plot decision boundary and margins</span></span><br><span class="line">    ax.contour(X, Y, P, colors=<span class="string">&#x27;k&#x27;</span>,</span><br><span class="line">               levels=[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], alpha=<span class="number">0.5</span>,</span><br><span class="line">               linestyles=[<span class="string">&#x27;--&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;--&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plot support vectors</span></span><br><span class="line">    <span class="keyword">if</span> plot_support:</span><br><span class="line">        ax.scatter(model.support_vectors_[:, <span class="number">0</span>],</span><br><span class="line">                   model.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">                   s=<span class="number">300</span>, linewidth=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    ax.set_xlim(xlim)</span><br><span class="line">    ax.set_ylim(ylim)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plot_svc_decision_function(model);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184519.png" alt=""></p><ul><li><p>这条线就是我们希望得到的决策边界啦</p></li><li><p>观察发现有3个点做了特殊的标记，它们恰好都是边界上的点</p></li><li><p>它们就是我们的<em>support vectors</em>（支持向量）</p></li><li><p>在Scikit-Learn中, 它们存储在这个位置 <code>support_vectors_</code>（一个属性）</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.support_vectors_</span><br></pre></td></tr></table></figure><pre><code>array([[ 0.44359863,  3.11530945],       [ 2.33812285,  3.43116792],       [ 2.06156753,  1.96918596]])</code></pre><ul><li><p>观察可以发现，只需要支持向量我们就可以把模型构建出来</p></li><li><p>接下来我们尝试一下，用不同多的数据点，看看效果会不会发生变化</p></li><li><p>分别使用60个和120个数据点</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_svm</span>(<span class="params">N=<span class="number">10</span>, ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    X, y = make_blobs(n_samples=<span class="number">200</span>, centers=<span class="number">2</span>,</span><br><span class="line">                      random_state=<span class="number">0</span>, cluster_std=<span class="number">0.60</span>)</span><br><span class="line">    X = X[:N]</span><br><span class="line">    y = y[:N]</span><br><span class="line">    model = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>, C=<span class="number">1E10</span>)</span><br><span class="line">    model.fit(X, y)</span><br><span class="line">    </span><br><span class="line">    ax = ax <span class="keyword">or</span> plt.gca()</span><br><span class="line">    ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    ax.set_xlim(-<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    plot_svc_decision_function(model, ax)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">6</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.0625</span>, right=<span class="number">0.95</span>, wspace=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">for</span> axi, N <span class="keyword">in</span> <span class="built_in">zip</span>(ax, [<span class="number">60</span>, <span class="number">120</span>]):</span><br><span class="line">    plot_svm(N, axi)</span><br><span class="line">    axi.set_title(<span class="string">&#x27;N = &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(N))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184545.png" alt=""></p><ul><li>左边是60个点的结果，右边的是120个点的结果</li><li>观察发现，只要支持向量没变，其他的数据怎么加无所谓！</li></ul><h3 id="引入核函数的SVM"><a href="#引入核函数的SVM" class="headerlink" title="引入核函数的SVM"></a>引入核函数的SVM</h3><ul><li>首先我们先用线性的核来看一下在下面这样比较难的数据集上还能分了吗？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_circles</span><br><span class="line">X, y = make_circles(<span class="number">100</span>, factor=<span class="number">.1</span>, noise=<span class="number">.1</span>)</span><br><span class="line"></span><br><span class="line">clf = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>).fit(X, y)</span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plot_svc_decision_function(clf, plot_support=<span class="literal">False</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184607.png" alt=""></p><ul><li><p>坏菜喽，分不了了，那咋办呢？试试高维核变换吧！</p></li><li><p>We can visualize this extra data dimension using a three-dimensional plot:</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入了新的维度r</span></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line">r = np.exp(-(X ** <span class="number">2</span>).<span class="built_in">sum</span>(<span class="number">1</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_3D</span>(<span class="params">elev=<span class="number">30</span>, azim=<span class="number">30</span>, X=X, y=y</span>):</span></span><br><span class="line">    ax = plt.subplot(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">    ax.scatter3D(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], r, c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    ax.view_init(elev=elev, azim=azim)</span><br><span class="line">    ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    ax.set_zlabel(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plot_3D(elev=<span class="number">45</span>, azim=<span class="number">45</span>, X=X, y=y)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184628.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入径向基函数（高斯核函数或者RBF核函数都一样）</span></span><br><span class="line">clf = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, C=<span class="number">1E6</span>)</span><br><span class="line">clf.fit(X, y)</span><br></pre></td></tr></table></figure><pre><code>SVC(C=1000000.0, cache_size=200, class_weight=None, coef0=0.0,  decision_function_shape=None, degree=3, gamma=&#39;auto&#39;, kernel=&#39;rbf&#39;,  max_iter=-1, probability=False, random_state=None, shrinking=True,  tol=0.001, verbose=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这回牛逼了！</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plot_svc_decision_function(clf)</span><br><span class="line">plt.scatter(clf.support_vectors_[:, <span class="number">0</span>], clf.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">            s=<span class="number">300</span>, lw=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184658.png" alt=""></p><p>使用这种核支持向量机，我们学习一个合适的非线性决策边界。这种核变换策略在机器学习中经常被使用！</p><h3 id="调节SVM参数-Soft-Margin问题"><a href="#调节SVM参数-Soft-Margin问题" class="headerlink" title="调节SVM参数: Soft Margin问题"></a>调节SVM参数: Soft Margin问题</h3><h3 id="调节C参数"><a href="#调节C参数" class="headerlink" title="调节C参数"></a>调节C参数</h3><ul><li>当C趋近于无穷大时：意味着分类严格不能有错误</li><li>当C趋近于很小的时：意味着可以有更大的错误容忍</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">0.8</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184713.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">6</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.0625</span>, right=<span class="number">0.95</span>, wspace=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> axi, C <span class="keyword">in</span> <span class="built_in">zip</span>(ax, [<span class="number">10.0</span>, <span class="number">0.1</span>]):  <span class="comment"># 两个C参数 10.0和0.1</span></span><br><span class="line">    model = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>, C=C).fit(X, y)</span><br><span class="line">    axi.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    plot_svc_decision_function(model, axi)</span><br><span class="line">    axi.scatter(model.support_vectors_[:, <span class="number">0</span>],</span><br><span class="line">                model.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">                s=<span class="number">300</span>, lw=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    axi.set_title(<span class="string">&#x27;C = &#123;0:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(C), size=<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184732.png" alt=""></p><ul><li>左边的泛化能力小。</li><li>右边的泛化能力强一点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">1.1</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">6</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.0625</span>, right=<span class="number">0.95</span>, wspace=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> axi, gamma <span class="keyword">in</span> <span class="built_in">zip</span>(ax, [<span class="number">10.0</span>, <span class="number">0.1</span>]):</span><br><span class="line">    model = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, gamma=gamma).fit(X, y)  <span class="comment"># gamma越高模型越复杂。返还能力越弱。</span></span><br><span class="line">    axi.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    plot_svc_decision_function(model, axi)</span><br><span class="line">    axi.scatter(model.support_vectors_[:, <span class="number">0</span>],</span><br><span class="line">                model.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">                s=<span class="number">300</span>, lw=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    axi.set_title(<span class="string">&#x27;gamma = &#123;0:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(gamma), size=<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184758.png" alt=""></p><ul><li>越复杂的边界泛化能力越低。</li></ul><h2 id="Example-Face-Recognition"><a href="#Example-Face-Recognition" class="headerlink" title="Example: Face Recognition"></a>Example: Face Recognition</h2><p>As an example of support vector machines in action, let’s take a look at the facial recognition problem.<br>We will use the Labeled Faces in the Wild dataset, which consists of several thousand collated photos of various public figures.<br>A fetcher for the dataset is built into Scikit-Learn:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line">faces = fetch_lfw_people(min_faces_per_person=<span class="number">60</span>)</span><br><span class="line">print(faces.target_names)</span><br><span class="line">print(faces.images.shape)</span><br></pre></td></tr></table></figure><pre><code>[&#39;Ariel Sharon&#39; &#39;Colin Powell&#39; &#39;Donald Rumsfeld&#39; &#39;George W Bush&#39; &#39;Gerhard Schroeder&#39; &#39;Hugo Chavez&#39; &#39;Junichiro Koizumi&#39; &#39;Tony Blair&#39;](1348, 62, 47)</code></pre><p>Let’s plot a few of these faces to see what we’re working with:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i, axi <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.flat):</span><br><span class="line">    axi.imshow(faces.images[i], cmap=<span class="string">&#x27;bone&#x27;</span>)</span><br><span class="line">    axi.<span class="built_in">set</span>(xticks=[], yticks=[],</span><br><span class="line">            xlabel=faces.target_names[faces.target[i]])</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184821.png" alt=""></p><ul><li>每个图的大小是 [62×47] </li><li>在这里我们就把每一个像素点当成了一个特征，但是这样特征太多了，用PCA降维一下吧！</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="comment">#from sklearn.decomposition import RandomizedPCA</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"></span><br><span class="line">pca = PCA(n_components=<span class="number">150</span>, whiten=<span class="literal">True</span>, random_state=<span class="number">42</span>)</span><br><span class="line">svc = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, class_weight=<span class="string">&#x27;balanced&#x27;</span>)</span><br><span class="line">model = make_pipeline(pca, svc)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain, Xtest, ytrain, ytest = train_test_split(faces.data, faces.target,</span><br><span class="line">                                                random_state=<span class="number">40</span>)</span><br></pre></td></tr></table></figure><p>使用grid search cross-validation来选择我们的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">param_grid = &#123;<span class="string">&#x27;svc__C&#x27;</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">              <span class="string">&#x27;svc__gamma&#x27;</span>: [<span class="number">0.0001</span>, <span class="number">0.0005</span>, <span class="number">0.001</span>]&#125;</span><br><span class="line">grid = GridSearchCV(model, param_grid)</span><br><span class="line"></span><br><span class="line">%time grid.fit(Xtrain, ytrain)</span><br><span class="line">print(grid.best_params_)</span><br></pre></td></tr></table></figure><pre><code>Wall time: 51.5 s&#123;&#39;svc__C&#39;: 5, &#39;svc__gamma&#39;: 0.001&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = grid.best_estimator_</span><br><span class="line">yfit = model.predict(Xtest)</span><br><span class="line">yfit.shape</span><br></pre></td></tr></table></figure><pre><code>(337,)</code></pre><p>看看咋样吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> i, axi <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.flat):</span><br><span class="line">    axi.imshow(Xtest[i].reshape(<span class="number">62</span>, <span class="number">47</span>), cmap=<span class="string">&#x27;bone&#x27;</span>)</span><br><span class="line">    axi.<span class="built_in">set</span>(xticks=[], yticks=[])</span><br><span class="line">    axi.set_ylabel(faces.target_names[yfit[i]].split()[-<span class="number">1</span>],</span><br><span class="line">                   color=<span class="string">&#x27;black&#x27;</span> <span class="keyword">if</span> yfit[i] == ytest[i] <span class="keyword">else</span> <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">fig.suptitle(<span class="string">&#x27;Predicted Names; Incorrect Labels in Red&#x27;</span>, size=<span class="number">14</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184837.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line">print(classification_report(ytest, yfit,</span><br><span class="line">                            target_names=faces.target_names))</span><br></pre></td></tr></table></figure><pre><code>                   precision    recall  f1-score   support     Ariel Sharon       0.50      0.50      0.50        16     Colin Powell       0.69      0.81      0.75        54  Donald Rumsfeld       0.83      0.85      0.84        34    George W Bush       0.94      0.88      0.91       136Gerhard Schroeder       0.72      0.85      0.78        27      Hugo Chavez       0.81      0.72      0.76        18Junichiro Koizumi       0.87      0.87      0.87        15       Tony Blair       0.85      0.76      0.80        37      avg / total       0.83      0.82      0.82       337</code></pre><ul><li>精度(precision) = 正确预测的个数(TP)/被预测正确的个数(TP+FP)</li><li>召回率(recall)=正确预测的个数(TP)/预测个数(TP+FN)</li><li>F1 = 2<em>精度</em>召回率/(精度+召回率)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">mat = confusion_matrix(ytest, yfit)</span><br><span class="line">sns.heatmap(mat.T, square=<span class="literal">True</span>, annot=<span class="literal">True</span>, fmt=<span class="string">&#x27;d&#x27;</span>, cbar=<span class="literal">False</span>,</span><br><span class="line">            xticklabels=faces.target_names,</span><br><span class="line">            yticklabels=faces.target_names)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;true label&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;predicted label&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184906.png" alt=""></p><ul><li>这样显示出来能帮助我们查看哪些人更容易弄混</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;支持向量机（SVM）&quot;&gt;&lt;a href=&quot;#支持向量机（SVM）&quot; class=&quot;headerlink&quot; title=&quot;支持向量机（SVM）&quot;&gt;&lt;/a&gt;支持向量机（SVM）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;低纬不可分的东西转化为高纬可分割的东西&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三十二）：把数组排成最小的数</title>
    <link href="https://xxren8218.github.io/20210525/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210525/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html</id>
    <published>2021-05-25T10:40:41.000Z</published>
    <updated>2021-05-25T10:41:45.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>遇到这个题，全排列当然可以做，但是时间复杂度为O(n!)。在这里我们自己定义一个规则，对拼接后的字符串进行比较。</p><p>排序规则如下</p><ul><li>若ab &gt; ba 则 a 大于 b，</li><li>若ab &lt; ba 则 a 小于 b，</li><li>若ab = ba 则 a 等于 b；</li></ul><p>根据上述规则，我们需要先将数字转换成字符串再进行比较，因为需要串起来进行比较。比较完之后，按顺序输出即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        compare = <span class="keyword">lambda</span> a,b:cmp(<span class="built_in">str</span>(a)+<span class="built_in">str</span>(b),<span class="built_in">str</span>(b)+<span class="built_in">str</span>(a))   <span class="comment"># 注意 lambda 匿名函数的使用。python2中sorted（可迭代对象,key,cmp）的使用,以及为什么要比较字符串。</span></span><br><span class="line">        li = <span class="built_in">sorted</span>(numbers, cmp=compare)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> li)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="字符串" scheme="https://xxren8218.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="排序" scheme="https://xxren8218.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="内置函数" scheme="https://xxren8218.github.io/tags/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三十）：连续子数组的最大和</title>
    <link href="https://xxren8218.github.io/20210525/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.html"/>
    <id>https://xxren8218.github.io/20210525/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.html</id>
    <published>2021-05-25T10:38:01.000Z</published>
    <updated>2021-05-25T10:40:21.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。(子向量的长度至少是1)</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525183934.PNG" alt=""></p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="built_in">max</span> = nums[<span class="number">0</span>]</span><br><span class="line">        cur = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> cur &lt; <span class="number">0</span>:</span><br><span class="line">                cur = i</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                cur += i</span><br><span class="line">            <span class="keyword">if</span> cur &gt; <span class="built_in">max</span>:</span><br><span class="line">                <span class="built_in">max</span> = cur</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span></span><br></pre></td></tr></table></figure><h2 id="思路二——动态规划"><a href="#思路二——动态规划" class="headerlink" title="思路二——动态规划"></a>思路二——动态规划</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525183958.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184006.PNG" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># dp[i]表示以num[i]结尾的最大的连续子数和</span></span><br><span class="line">        dp = [<span class="number">0</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 初始值</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 找出元素关系式</span></span><br><span class="line">            <span class="keyword">if</span> dp[i-<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp) </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。&lt;/p&gt;
&lt;p&gt;要求时间复杂度为O(n</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="动态规划" scheme="https://xxren8218.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（二十八）：数组中出现次数超过一半的数字</title>
    <link href="https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.html</id>
    <published>2021-05-24T10:51:43.000Z</published>
    <updated>2021-05-24T10:53:48.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0</p><h2 id="2-思路一——暴力解法"><a href="#2-思路一——暴力解法" class="headerlink" title="2.思路一——暴力解法"></a>2.思路一——暴力解法</h2><p>循环遍历所有的数字，调用方法count()，与数组的个数的1/2进行比较即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> numbers.count(i)&gt;<span class="built_in">len</span>(numbers)//<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><p>上述解法在力扣超时。有别的解法，<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524185306.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524185313.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524185318.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524185325.PNG" alt=""></p><h2 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        vote = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> vote == <span class="number">0</span>: x = num</span><br><span class="line">            <span class="keyword">if</span> num == x:</span><br><span class="line">                vote += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vote -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        hashable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> hashable:</span><br><span class="line">                hashable[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashable[num] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashable[num] &gt; <span class="built_in">len</span>(nums) / <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://xxren8218.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="辅助素组" scheme="https://xxren8218.github.io/tags/%E8%BE%85%E5%8A%A9%E7%B4%A0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十三）：调整数组顺序使奇数位于偶数前面</title>
    <link href="https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html"/>
    <id>https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html</id>
    <published>2021-05-24T10:49:25.000Z</published>
    <updated>2021-05-24T10:50:50.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h2 id="2-思路一——辅助数组"><a href="#2-思路一——辅助数组" class="headerlink" title="2.思路一——辅助数组"></a>2.思路一——辅助数组</h2><p>对数组中的数字进行遍历，判断奇偶，分别放在两个辅助列表中，最后将两个辅助列表合并即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span>(<span class="params">self , array</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        odd = []</span><br><span class="line">        even = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">            <span class="keyword">if</span> array[i] % <span class="number">2</span>: <span class="comment"># 1 为True, 0 为 False</span></span><br><span class="line">                odd.append(array[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                even.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> odd + even</span><br></pre></td></tr></table></figure><h2 id="别的思路：——首尾双指针"><a href="#别的思路：——首尾双指针" class="headerlink" title="别的思路：——首尾双指针"></a>别的思路：——首尾双指针</h2><ul><li>首尾双指针<br>定义头指针 left ，尾指针 right .<br>left 一直往右移，直到它指向的值为偶数<br>right 一直往左移， 直到它指向的值为奇数<br>交换 nums[left] 和 nums[right] .<br>重复上述操作，直到 left==right .</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> nums[left] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> nums[right] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h2 id="思路三——快慢双指针"><a href="#思路三——快慢双指针" class="headerlink" title="思路三——快慢双指针"></a>思路三——快慢双指针</h2><p>定义快慢双指针 fast 和 low ，fast 在前， low 在后 .<br>fast的作用是向前搜索奇数位置，low的作用是指向下一个奇数应当存放的位置<br>fast向前移动，当它搜索到奇数时，将它和 nums[low] 交换，此时 low 向前移动一个位置 .<br>重复上述操作，直到 fast 指向数组末尾 .</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        low, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                nums[low], nums[fast] = nums[fast], nums[low]</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="快慢指针" scheme="https://xxren8218.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（六）：旋转数组的最小数字</title>
    <link href="https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html"/>
    <id>https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html</id>
    <published>2021-05-24T10:46:50.000Z</published>
    <updated>2021-05-24T10:51:12.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 </p><p>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 </p><p>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 </p><p>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。    </p><h2 id="2-思路一：线性查找O-n"><a href="#2-思路一：线性查找O-n" class="headerlink" title="2.思路一：线性查找O(n)"></a>2.思路一：线性查找O(n)</h2><p>直接调用min()方法即可，时间复杂度O(n)</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(numbers)</span><br></pre></td></tr></table></figure><h2 id="思路二：二分查找O（logn）"><a href="#思路二：二分查找O（logn）" class="headerlink" title="思路二：二分查找O（logn）"></a>思路二：二分查找O（logn）</h2><ul><li>排序数组的查找问题首先考虑使用 二分法 解决，其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> 。<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524184757.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524184822.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524184837.PNG" alt=""></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            m = (i + j) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[m] &gt; numbers[j]:i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[m] &lt; numbers[j]: j = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[i]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 &lt;/p&gt;
&lt;p&gt;输入一个非递减排序的数组的一个旋转，输出</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="二分法" scheme="https://xxren8218.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（一）：二维数组（排序数组）中的查找</title>
    <link href="https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%88%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%89%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html"/>
    <id>https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%88%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%89%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html</id>
    <published>2021-05-24T10:44:43.000Z</published>
    <updated>2021-05-24T10:46:10.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p><p>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="2-思路一：暴力解法"><a href="#2-思路一：暴力解法" class="headerlink" title="2.思路一：暴力解法"></a>2.思路一：暴力解法</h2><p>依次遍历整个数组的每一个元素，如果存在返回True,否则返回False</p><ul><li>复杂度分析</li></ul><p>时间复杂度：O(nm)。二维数组中的每个元素都被遍历，因此时间复杂度为二维数组的大小。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span>(<span class="params">self, matrix, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> target == matrix[i][j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="思路二：线性查找"><a href="#思路二：线性查找" class="headerlink" title="思路二：线性查找"></a>思路二：线性查找</h2><p>首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；</p><p>如果该数字大于要查找的数组，剔除这个数字所在的列；</p><p>如果该数字小于要查找的数字，剔除这个数字所在的行。</p><p>也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p><ul><li>复杂度分析<br>时间复杂度：O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span>(<span class="params">self, matrix, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>]) </span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        col = cols - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] == target:<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][col] &gt; target:col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。&lt;/p&gt;
&lt;p&gt;请完成一个函数，输</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="查找" scheme="https://xxren8218.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十一）：二进制中1的个数</title>
    <link href="https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html</id>
    <published>2021-05-20T11:19:52.000Z</published>
    <updated>2021-05-20T11:23:18.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个二进制数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>先与1进行与运算，若为1，则该位为1，再判断前一位。</p><p>前一位的判断直接可以使用位运算 &gt;&gt; 向右移动一位。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += n &amp; <span class="number">1</span> <span class="comment"># 等价于 if n &amp; 1 == 1: res +=1，但是前一种判断次数更少。 </span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>将二进制转化为字符串，直接进行进行调用方法count</p><pre><code>- 由于输入的二进制比如1011，计算机不会将其对待为 0b1011,而是认为是一千零一十一，所以先转为二进制</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">bin</span>(n)).count(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路三-巧用-n-amp-n-1"><a href="#思路三-巧用-n-amp-n-1" class="headerlink" title="思路三 巧用 n&amp;(n-1)"></a>思路三 巧用 n&amp;(n-1)</h2><h2 id="此处若输入一个整数呢？注意消除负数位的影响。"><a href="#此处若输入一个整数呢？注意消除负数位的影响。" class="headerlink" title="此处若输入一个整数呢？注意消除负数位的影响。"></a>此处若输入一个整数呢？注意消除负数位的影响。</h2><div style="color: red;overflow: scroll;">如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</div><div style="color: red;overflow: scroll;">举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。    - 在Python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机是以补码存在的，往右移，符号位不变，符号位1往右移，最终可能会出现全1的情况，导致死循环。与0xffffffff相与，就可以消除负数的影响。</div><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: n = n &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= n-<span class="number">1</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个二进制数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;h2 id=&quot;2-思路&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串" scheme="https://xxren8218.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="位运算" scheme="https://xxren8218.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十二）：数值的整数次方</title>
    <link href="https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html"/>
    <id>https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html</id>
    <published>2021-05-20T11:09:11.000Z</published>
    <updated>2021-05-20T11:19:14.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个double类型的浮点数x和int类型的整数n。求x的n次方。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>正常思路是：</p><ul><li>若n&gt;0: x<em>x</em>x<em>…</em>x,一共乘n次</li><li>若n&lt;0: 1/x<em>x</em>x<em>…</em>x,一共乘n次。</li><li>若n=0：返回零，但是代码在力扣超时。时间复杂度O（n）<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = x</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &lt; n-<span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &lt; -n-<span class="number">1</span>:</span><br><span class="line">                    res *= x</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/res</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="下面介绍快速幂的方法——时间复杂度O（logn）"><a href="#下面介绍快速幂的方法——时间复杂度O（logn）" class="headerlink" title="下面介绍快速幂的方法——时间复杂度O（logn）"></a>下面介绍快速幂的方法——时间复杂度O（logn）</h2><ul><li>指数减半，底数平方的方法。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如13，我们可以转换成1101，则X<strong>13就等于x</strong>1101b,然后展开，如图一<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191438.JPG" alt=""><br>同样我们也将所给的数字进行转化。如图二<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191508.JPG" alt=""><br>当bi=0，其数值为0<br>当bi=1，值为x的2<strong>i次方，如图三<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191524.JPG" alt=""><br>我们可以发现x</strong>i的规律就是从右向左看，后一个数字都是前一个数字的平方。如图、五<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191541.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191556.JPG" alt=""><br>所以：采用循环<br>我们可以将n与1进行与运算，看当前位数为0与否：</p><ul><li>不为零时候（为1），则结果 res * x</li><li>为零时候，则给结果不变<br>而后进行位运算右移动，移动以后的 x*= x<br>当n&lt;0, 我们可以令 x = 1/x, n = -n，则可以用同样的方法进行计算。<br>当x=0,分母不能为0，直接返回0<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191636.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191705.JPG" alt=""><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            x,n = <span class="number">1</span>/x, -n</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">            x *= x</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;给定一个double类型的浮点数x和int类型的整数n。求x的n次方。&lt;/p&gt;
&lt;h2 id=&quot;2-思路&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="https://xxren8218.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="快速幂" scheme="https://xxren8218.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十九）：顺时针打印矩阵</title>
    <link href="https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.html"/>
    <id>https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.html</id>
    <published>2021-05-20T11:05:09.000Z</published>
    <updated>2021-05-24T10:58:33.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520190659.PNG" alt=""><br>则依次打印出数组：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>可以发现，顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。<br>定义四个变量来确定边界。top、bottom、right、left。——注意他们范围的确定。<br>然后进行循环判断即可。具体如图。——注意循环终止条件。<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520190718.JPG" alt=""></p><p><strong>注意：</strong></p><ul><li>对于range(a,b)，反向的话用range(b,a,-1)即可!(逗号)</li></ul><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> matrix == []: <span class="keyword">return</span> []</span><br><span class="line">        top = <span class="number">0</span></span><br><span class="line">        bottom = <span class="built_in">len</span>(matrix)-<span class="number">1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(matrix[<span class="number">0</span>])-<span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># →</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; bottom:<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ↓</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left:<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ←</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[bottom][i])</span><br><span class="line">            bottom -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> bottom &lt; top:<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ↑</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：&lt;br&gt;&lt;img src=&quot;https</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="多指针" scheme="https://xxren8218.github.io/tags/%E5%A4%9A%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统——协同过滤&amp;隐语义模型</title>
    <link href="https://xxren8218.github.io/20210520/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4-%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B.html"/>
    <id>https://xxren8218.github.io/20210520/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4-%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B.html</id>
    <published>2021-05-19T16:47:00.000Z</published>
    <updated>2021-05-20T11:03:56.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推荐系统——协同过滤—-gt-基于统计方法"><a href="#推荐系统——协同过滤—-gt-基于统计方法" class="headerlink" title="推荐系统——协同过滤—&gt;基于统计方法"></a>推荐系统——协同过滤—&gt;基于统计方法</h2><h3 id="本节需要用到-scikit-surprise-库"><a href="#本节需要用到-scikit-surprise-库" class="headerlink" title="本节需要用到 scikit-surprise 库"></a>本节需要用到 scikit-surprise 库</h3><ul><li>pip install surprise 进行安装（需要C++编译环境）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> KNNBasic,SVD <span class="comment"># KNNBasic最基础的协同过滤算法（可以基于用户或者物品） SVD是基于矩阵分解的！</span></span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> Dataset <span class="comment"># Dataset默认的数据库进行练习。基础的电影的数据。（下方网址）</span></span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> evaluate, print_perf</span><br><span class="line"><span class="comment"># http://surprise.readthedocs.io/en/stable/index.html</span></span><br><span class="line"><span class="comment"># http://files.grouplens.org/datasets/movielens/ml-100k-README.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the movielens-100k dataset (download it if needed),</span></span><br><span class="line"><span class="comment"># and split it into 3 folds for cross-validation.</span></span><br><span class="line">data = Dataset.load_builtin(<span class="string">&#x27;ml-100k&#x27;</span>) <span class="comment"># 拿到内置的数据集</span></span><br><span class="line">data.split(n_folds=<span class="number">3</span>)  <span class="comment"># 进行交叉验证的折数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We&#x27;ll use the famous KNNBasic algorithm.</span></span><br><span class="line">algo = KNNBasic()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Evaluate performances of our algorithm on the dataset.</span></span><br><span class="line">perf = evaluate(algo, data, measures=[<span class="string">&#x27;RMSE&#x27;</span>, <span class="string">&#x27;MAE&#x27;</span>])  </span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"><span class="comment"># 之前的基本是 fit 这里不一样，可以自己指定三个参数（算法名字，数据，评估方法）</span></span><br><span class="line"><span class="comment"># 这里制定了均方误差和绝对误差</span></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line">print_perf(perf)</span><br></pre></td></tr></table></figure><pre><code>Evaluating RMSE, MAE of algorithm KNNBasic.------------Fold 1Computing the msd similarity matrix...Done computing similarity matrix.RMSE: 0.9876MAE:  0.7807------------Fold 2Computing the msd similarity matrix...Done computing similarity matrix.RMSE: 0.9871MAE:  0.7796------------Fold 3Computing the msd similarity matrix...Done computing similarity matrix.RMSE: 0.9902MAE:  0.7818------------------------Mean RMSE: 0.9883Mean MAE : 0.7807------------------------        Fold 1  Fold 2  Fold 3  Mean    MAE     0.7807  0.7796  0.7818  0.7807  RMSE    0.9876  0.9871  0.9902  0.9883  </code></pre><h2 id="推荐系统——进行矩阵分解求解（隐语义模型）—-gt-基于模型"><a href="#推荐系统——进行矩阵分解求解（隐语义模型）—-gt-基于模型" class="headerlink" title="推荐系统——进行矩阵分解求解（隐语义模型）—&gt;基于模型"></a>推荐系统——进行矩阵分解求解（隐语义模型）—&gt;基于模型</h2><ul><li>需要进行迭代求解，需要传一些参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> GridSearch</span><br><span class="line"></span><br><span class="line">param_grid = &#123;<span class="string">&#x27;n_epochs&#x27;</span>: [<span class="number">5</span>, <span class="number">10</span>], <span class="string">&#x27;lr_all&#x27;</span>: [<span class="number">0.002</span>, <span class="number">0.005</span>],</span><br><span class="line">              <span class="string">&#x27;reg_all&#x27;</span>: [<span class="number">0.4</span>, <span class="number">0.6</span>]&#125;</span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line"><span class="comment"># 指定了三个值，迭代次数，学习率，正则化的强度</span></span><br><span class="line"><span class="comment"># 做其8种组合。</span></span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line">grid_search = GridSearch(SVD, param_grid, measures=[<span class="string">&#x27;RMSE&#x27;</span>, <span class="string">&#x27;FCP&#x27;</span>]) <span class="comment"># SVD 矩阵分解！</span></span><br><span class="line">data = Dataset.load_builtin(<span class="string">&#x27;ml-100k&#x27;</span>)</span><br><span class="line">data.split(n_folds=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">grid_search.evaluate(data)</span><br></pre></td></tr></table></figure><pre><code>------------Parameters combination 1 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9972Mean FCP : 0.6843------------------------Parameters combination 2 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9734Mean FCP : 0.6946------------------------Parameters combination 3 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9777Mean FCP : 0.6926------------------------Parameters combination 4 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9635Mean FCP : 0.6987------------------------Parameters combination 5 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 1.0029Mean FCP : 0.6875------------------------Parameters combination 6 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 0.9820Mean FCP : 0.6953------------------------Parameters combination 7 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 0.9860Mean FCP : 0.6943------------------------Parameters combination 8 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 0.9733Mean FCP : 0.6991------------</code></pre><p><strong>GridSearch会帮我们存一些函数值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># best RMSE score</span></span><br><span class="line">print(grid_search.best_score[<span class="string">&#x27;RMSE&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># combination of parameters that gave the best RMSE score</span></span><br><span class="line">print(grid_search.best_params[<span class="string">&#x27;RMSE&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># best FCP score</span></span><br><span class="line">print(grid_search.best_score[<span class="string">&#x27;FCP&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># combination of parameters that gave the best FCP score</span></span><br><span class="line">print(grid_search.best_params[<span class="string">&#x27;FCP&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>0.963501988854&#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.4&#125;0.699084153002&#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.6&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line"></span><br><span class="line">results_df = pd.DataFrame.from_dict(grid_search.cv_results) </span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line"><span class="comment"># pd.DataFrame.from_dict可以传字典进行数据查看</span></span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line">results_df</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>FCP</th>      <th>RMSE</th>      <th>lr_all</th>      <th>n_epochs</th>      <th>params</th>      <th>scores</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.684266</td>      <td>0.997160</td>      <td>0.002</td>      <td>5</td>      <td>{'lr_all': 0.002, 'n_epochs': 5, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.997160189649, 'FCP': 0.684266412476}</td>    </tr>    <tr>      <th>1</th>      <td>0.694552</td>      <td>0.973383</td>      <td>0.005</td>      <td>5</td>      <td>{'lr_all': 0.005, 'n_epochs': 5, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.973383132387, 'FCP': 0.694551932996}</td>    </tr>    <tr>      <th>2</th>      <td>0.692616</td>      <td>0.977697</td>      <td>0.002</td>      <td>10</td>      <td>{'lr_all': 0.002, 'n_epochs': 10, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.977696629511, 'FCP': 0.692615513155}</td>    </tr>    <tr>      <th>3</th>      <td>0.698722</td>      <td>0.963502</td>      <td>0.005</td>      <td>10</td>      <td>{'lr_all': 0.005, 'n_epochs': 10, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.963501988854, 'FCP': 0.698721750945}</td>    </tr>    <tr>      <th>4</th>      <td>0.687482</td>      <td>1.002855</td>      <td>0.002</td>      <td>5</td>      <td>{'lr_all': 0.002, 'n_epochs': 5, 'reg_all': 0.6}</td>      <td>{'RMSE': 1.00285516237, 'FCP': 0.687481665759}</td>    </tr>    <tr>      <th>5</th>      <td>0.695337</td>      <td>0.982047</td>      <td>0.005</td>      <td>5</td>      <td>{'lr_all': 0.005, 'n_epochs': 5, 'reg_all': 0.6}</td>      <td>{'RMSE': 0.98204676013, 'FCP': 0.695337489535}</td>    </tr>    <tr>      <th>6</th>      <td>0.694338</td>      <td>0.985981</td>      <td>0.002</td>      <td>10</td>      <td>{'lr_all': 0.002, 'n_epochs': 10, 'reg_all': 0.6}</td>      <td>{'RMSE': 0.985980855401, 'FCP': 0.694337564062}</td>    </tr>    <tr>      <th>7</th>      <td>0.699084</td>      <td>0.973282</td>      <td>0.005</td>      <td>10</td>      <td>{'lr_all': 0.005, 'n_epochs': 10, 'reg_all': 0.6}</td>      <td>{'RMSE': 0.973281870802, 'FCP': 0.699084153002}</td>    </tr>  </tbody></table></div><h3 id="模型搭建出来了，用它来推荐东西！"><a href="#模型搭建出来了，用它来推荐东西！" class="headerlink" title="模型搭建出来了，用它来推荐东西！"></a>模型搭建出来了，用它来推荐东西！</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> (absolute_import, division, print_function,</span><br><span class="line">                        unicode_literals)</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> KNNBaseline</span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_item_names</span>():</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot;把电影的名字做成了id的映射&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    file_name = (<span class="string">&#x27;./ml-100k/u.item&#x27;</span>)</span><br><span class="line">    rid_to_name = &#123;&#125;</span><br><span class="line">    name_to_rid = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> io.<span class="built_in">open</span>(file_name, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            line = line.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">            rid_to_name[line[<span class="number">0</span>]] = line[<span class="number">1</span>]</span><br><span class="line">            name_to_rid[line[<span class="number">1</span>]] = line[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rid_to_name, name_to_rid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.导入数据</span></span><br><span class="line">data = Dataset.load_builtin(<span class="string">&#x27;ml-100k&#x27;</span>)</span><br><span class="line"><span class="comment"># 2.数据是一行的，将其转换成矩阵（稀疏的）</span></span><br><span class="line">trainset = data.build_full_trainset()</span><br><span class="line"><span class="comment"># 3.指定相似度的方法——此处用了皮尔孙，指定了基于物品的相似度。</span></span><br><span class="line">sim_options = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;pearson_baseline&#x27;</span>, <span class="string">&#x27;user_based&#x27;</span>: <span class="literal">False</span>&#125;</span><br><span class="line">algo = KNNBaseline(sim_options=sim_options)</span><br><span class="line">algo.train(trainset)</span><br></pre></td></tr></table></figure><pre><code>Estimating biases using als...Computing the pearson_baseline similarity matrix...Done computing similarity matrix.</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rid_to_name, name_to_rid = read_item_names()</span><br><span class="line"></span><br><span class="line">toy_story_raw_id = name_to_rid[<span class="string">&#x27;Now and Then (1995)&#x27;</span>]</span><br><span class="line"><span class="comment"># 直接传电影名字不行，因为传的是id，先对其进行id的转换。</span></span><br><span class="line"></span><br><span class="line">toy_story_raw_id <span class="comment"># 在数据的id</span></span><br></pre></td></tr></table></figure><pre><code>&#39;1053&#39;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toy_story_inner_id = algo.trainset.to_inner_iid(toy_story_raw_id)</span><br><span class="line">toy_story_inner_id <span class="comment"># 在实际计算的(矩阵的)id</span></span><br></pre></td></tr></table></figure><pre><code>961</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toy_story_neighbors = algo.get_neighbors(toy_story_inner_id, k=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 找出最接近的10个电影id</span></span><br><span class="line">toy_story_neighbors</span><br></pre></td></tr></table></figure><pre><code>[291, 82, 366, 528, 179, 101, 556, 310, 431, 543]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">toy_story_neighbors = (algo.trainset.to_raw_iid(inner_id)</span><br><span class="line">                       <span class="keyword">for</span> inner_id <span class="keyword">in</span> toy_story_neighbors)</span><br><span class="line">toy_story_neighbors = (rid_to_name[rid]</span><br><span class="line">                       <span class="keyword">for</span> rid <span class="keyword">in</span> toy_story_neighbors)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(<span class="string">&#x27;The 10 nearest neighbors of Toy Story are:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> movie <span class="keyword">in</span> toy_story_neighbors:</span><br><span class="line">    print(movie)</span><br></pre></td></tr></table></figure><pre><code>The 10 nearest neighbors of Toy Story are:While You Were Sleeping (1995)Batman (1989)Dave (1993)Mrs. Doubtfire (1993)Groundhog Day (1993)Raiders of the Lost Ark (1981)Maverick (1994)French Kiss (1995)Stand by Me (1986)Net, The (1995)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;推荐系统——协同过滤—-gt-基于统计方法&quot;&gt;&lt;a href=&quot;#推荐系统——协同过滤—-gt-基于统计方法&quot; class=&quot;headerlink&quot; title=&quot;推荐系统——协同过滤—&amp;gt;基于统计方法&quot;&gt;&lt;/a&gt;推荐系统——协同过滤—&amp;gt;基于统计方法&lt;/</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>EM算法应用——GMM聚类</title>
    <link href="https://xxren8218.github.io/20210519/EM%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94GMM%E8%81%9A%E7%B1%BB.html"/>
    <id>https://xxren8218.github.io/20210519/EM%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94GMM%E8%81%9A%E7%B1%BB.html</id>
    <published>2021-05-18T16:55:06.000Z</published>
    <updated>2021-05-18T17:02:03.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GMM实例"><a href="#GMM实例" class="headerlink" title="GMM实例"></a>GMM实例</h1><ul><li>桥东西两个地方摆放了共享单车。统计使用共享单车的数量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv (<span class="string">&#x27;Fremont.csv&#x27;</span>, index_col=<span class="string">&#x27;Date&#x27;</span>, parse_dates=<span class="literal">True</span>)</span><br><span class="line">data.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Fremont Bridge West Sidewalk</th>      <th>Fremont Bridge East Sidewalk</th>    </tr>    <tr>      <th>Date</th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>2012-10-03 00:00:00</th>      <td>4.0</td>      <td>9.0</td>    </tr>    <tr>      <th>2012-10-03 01:00:00</th>      <td>4.0</td>      <td>6.0</td>    </tr>    <tr>      <th>2012-10-03 02:00:00</th>      <td>1.0</td>      <td>1.0</td>    </tr>    <tr>      <th>2012-10-03 03:00:00</th>      <td>2.0</td>      <td>3.0</td>    </tr>    <tr>      <th>2012-10-03 04:00:00</th>      <td>6.0</td>      <td>1.0</td>    </tr>  </tbody></table></div><h2 id="Visualizing-the-Dataset"><a href="#Visualizing-the-Dataset" class="headerlink" title="Visualizing the Dataset"></a>Visualizing the Dataset</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">data.plot();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010149.png" alt=""></p><p>可以看到数据太密集，因为是以小时为单位创建的，</p><ul><li>数据重采样，按周进行计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">data.resample(<span class="string">&#x27;w&#x27;</span>).<span class="built_in">sum</span>().plot(); <span class="comment"># 时间序列化</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010134.png" alt=""></p><p>可以看到东西边差别不大。<br>采用滑动窗口进行可视化——当前365天数据的总和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.resample(<span class="string">&#x27;D&#x27;</span>).<span class="built_in">sum</span>().rolling(<span class="number">365</span>).<span class="built_in">sum</span>().plot();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010117.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data.groupby(data.index.time).mean().plot();</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>)</span><br></pre></td></tr></table></figure><pre><code>(array([     0.,  10000.,  20000.,  30000.,  40000.,  50000.,  60000.,         70000.,  80000.,  90000.]), &lt;a list of 10 Text xticklabel objects&gt;)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010104.png" alt=""></p><ul><li>蓝线和绿线满足不同分布规则。</li><li>隐变量有两个。桥东和桥西。</li></ul><p>做GMM模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pivot table</span></span><br><span class="line">data.columns =[<span class="string">&#x27;West&#x27;</span>, <span class="string">&#x27;East&#x27;</span>]</span><br><span class="line">data [<span class="string">&#x27;Total&#x27;</span>] =data[<span class="string">&#x27;West&#x27;</span>]+data[<span class="string">&#x27;East&#x27;</span>]</span><br><span class="line">pivoted = data.pivot_table(<span class="string">&#x27;Total&#x27;</span>, index=data.index.time, columns=data.index.date) <span class="comment"># 做一个透视表</span></span><br><span class="line">pivoted.iloc[:<span class="number">5</span>,:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>2012-10-03</th>      <th>2012-10-04</th>      <th>2012-10-05</th>      <th>2012-10-06</th>      <th>2012-10-07</th>    </tr>  </thead>  <tbody>    <tr>      <th>00:00:00</th>      <td>13.0</td>      <td>18.0</td>      <td>11.0</td>      <td>15.0</td>      <td>11.0</td>    </tr>    <tr>      <th>01:00:00</th>      <td>10.0</td>      <td>3.0</td>      <td>8.0</td>      <td>15.0</td>      <td>17.0</td>    </tr>    <tr>      <th>02:00:00</th>      <td>2.0</td>      <td>9.0</td>      <td>7.0</td>      <td>9.0</td>      <td>3.0</td>    </tr>    <tr>      <th>03:00:00</th>      <td>5.0</td>      <td>3.0</td>      <td>4.0</td>      <td>3.0</td>      <td>6.0</td>    </tr>    <tr>      <th>04:00:00</th>      <td>7.0</td>      <td>8.0</td>      <td>9.0</td>      <td>5.0</td>      <td>3.0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pivoted.plot(legend=<span class="literal">False</span>, alpha =<span class="number">0.01</span>);</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>)</span><br></pre></td></tr></table></figure><pre><code>(array([     0.,  10000.,  20000.,  30000.,  40000.,  50000.,  60000.,         70000.,  80000.,  90000.]), &lt;a list of 10 Text xticklabel objects&gt;)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010042.png" alt=""></p><p><strong>可以看到有两种分布，能否用GMM进行聚类任务，然后分开呢？</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pivoted.shape</span><br></pre></td></tr></table></figure><pre><code>(24, 1763)</code></pre><p><strong>样本数24，特征数1763不合适</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = pivoted.fillna(<span class="number">0</span>).T.values</span><br><span class="line">X.shape</span><br></pre></td></tr></table></figure><pre><code>(1763, 24)</code></pre><p><strong>然后拿它GMM进行聚类的任务</strong></p><ul><li>拿到了1763个数据，以及它每天24小时的数据，我们想做个聚类，看他是东还是西。</li></ul><p>为了方便演示，将图像画在2D空间——进行PCA的降维</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">X2 = PCA(<span class="number">2</span>).fit_transform(X)</span><br><span class="line">X2.shape</span><br></pre></td></tr></table></figure><pre><code>(1763, 2)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X2[:,<span class="number">0</span>],X2[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1b92c86a630&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010015.png" alt=""></p><p><strong>PCA降维以后数据特征不存在具体物理意义、但是空间意义还在</strong></p><p>然后进行聚类分析：</p><ul><li>GMM聚类与KMEANS有些类似，因为kmeans需要知道K点个数。而此处需要知道隐变量的个数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line">gmm =GaussianMixture(<span class="number">2</span>)</span><br><span class="line">gmm.fit(X)</span><br><span class="line">labels = gmm.predict_proba(X) <span class="comment"># 得到的是概率值，即每一个样本属于（第一个类别【分布】的可能性，第二个类别【分布】的可能性）</span></span><br><span class="line">labels</span><br></pre></td></tr></table></figure><pre><code>array([[  1.00000000e+000,   4.27200703e-157],       [  1.00000000e+000,   2.97606604e-125],       [  1.00000000e+000,   1.00461289e-101],       ...,        [  2.50152395e-030,   1.00000000e+000],       [  2.49747986e-025,   1.00000000e+000],       [  1.00000000e+000,   1.79108465e-301]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">labels = gmm.predict(X) <span class="comment"># 得到的是概类别的标签</span></span><br><span class="line">labels</span><br></pre></td></tr></table></figure><pre><code>array([0, 0, 0, ..., 1, 1, 0], dtype=int64)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X2[:,<span class="number">0</span>],X2[:,<span class="number">1</span>], c=labels, cmap=<span class="string">&#x27;rainbow&#x27;</span>) </span><br><span class="line"><span class="comment">#plt.colorbar()</span></span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1b92cdd0f98&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005957.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize =(<span class="number">14</span>, <span class="number">6</span>))</span><br><span class="line">                      </span><br><span class="line">pivoted.T[labels == <span class="number">0</span>].T.plot(legend =<span class="literal">False</span>, alpha =<span class="number">0.1</span>, ax=ax[<span class="number">0</span>])  <span class="comment"># 进行数据的还原，显示数据的样子</span></span><br><span class="line">pivoted.T[labels == <span class="number">1</span>].T.plot(legend =<span class="literal">False</span>, alpha =<span class="number">0.1</span>, ax=ax[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].set_title (<span class="string">&#x27;Purple Cluster&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>].set_title (<span class="string">&#x27;Red Cluster&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.text.Text at 0x1b932208b38&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005941.png" alt=""></p><p><strong>来看看GMM和KMEANS的差异吧！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line">X, y_true = make_blobs(n_samples=<span class="number">800</span>, centers=<span class="number">4</span>, random_state=<span class="number">11</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005926.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">4</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">y_kmeans = kmeans.predict(X)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_kmeans, s=<span class="number">50</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">centers = kmeans.cluster_centers_</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005911.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line">gmm = GaussianMixture(n_components=<span class="number">4</span>).fit(X)</span><br><span class="line">labels = gmm.predict(X)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=labels, s=<span class="number">40</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005856.png" alt=""></p><p><strong>GMM和KMEANS在规则数据上基本一样！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">13</span>)</span><br><span class="line">X_stretched = np.dot(X, rng.randn(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">4</span>, random_state=<span class="number">1</span>)</span><br><span class="line">kmeans.fit(X_stretched)</span><br><span class="line">y_kmeans = kmeans.predict(X_stretched)</span><br><span class="line">plt.scatter(X_stretched[:, <span class="number">0</span>], X_stretched[:, <span class="number">1</span>], c=y_kmeans, s=<span class="number">50</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">centers = kmeans.cluster_centers_</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005837.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gmm = GaussianMixture(n_components=<span class="number">4</span>)        </span><br><span class="line">gmm.fit(X_stretched)</span><br><span class="line">y_gmm = gmm.predict(X_stretched)</span><br><span class="line">plt.scatter(X_stretched[:, <span class="number">0</span>], X_stretched[:, <span class="number">1</span>], c=y_gmm, s=<span class="number">50</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1b932008208&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005822.png" alt=""></p><p><strong> GMM比KMEANS好！ </strong></p><h2 id="所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好"><a href="#所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好" class="headerlink" title="所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好"></a>所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GMM实例&quot;&gt;&lt;a href=&quot;#GMM实例&quot; class=&quot;headerlink&quot; title=&quot;GMM实例&quot;&gt;&lt;/a&gt;GMM实例&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;桥东西两个地方摆放了共享单车。统计使用共享单车的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>力扣（一）：两数之和</title>
    <link href="https://xxren8218.github.io/20210518/%E5%8A%9B%E6%89%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html"/>
    <id>https://xxren8218.github.io/20210518/%E5%8A%9B%E6%89%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</id>
    <published>2021-05-18T10:00:40.000Z</published>
    <updated>2021-05-18T10:01:48.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h2 id="2-思路1"><a href="#2-思路1" class="headerlink" title="2.思路1"></a>2.思路1</h2><p>方法一：暴力枚举<br>思路及算法</p><p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p><p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>方法二：哈希表<br>思路及算法</p><p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。</p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums): </span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（二十）：包含min函数的栈</title>
    <link href="https://xxren8218.github.io/20210517/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.html"/>
    <id>https://xxren8218.github.io/20210517/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.html</id>
    <published>2021-05-17T10:05:38.000Z</published>
    <updated>2021-05-17T10:08:06.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>定义栈的数据结构，请在类型中实现一个能够得到栈最小元素的min函数。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>使用两个stack，一个为数据栈，另一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。</p><p>若加入的元素比辅助栈的栈顶元素小，则再辅助栈增加该元素，否则，增加辅助栈的栈顶元素。</p><p>Data = [1,2,-2,3,-4,6]<br>Min = [1,1,-2,-2,-4,-4]</p><p>在Data出栈的时候，同时将Data和Min出栈即可。</p><p>获得栈顶元素的时候：直接返回数据栈的栈顶元素。</p><p>栈最小元素：直接返回辅助栈的栈顶元素。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.Data = []</span><br><span class="line">        self.Min = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.Data.append(node)</span><br><span class="line">        <span class="keyword">if</span> self.Min:</span><br><span class="line">            <span class="keyword">if</span> self.Min[-<span class="number">1</span>] &gt; node:</span><br><span class="line">                self.Min.append(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.Min.append(self.Min[-<span class="number">1</span>])   <span class="comment">#保证Data出栈的时候Min也是出栈的，且最小数字不会改变。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Min.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.Min.pop()</span><br><span class="line">        <span class="keyword">return</span> self.Data.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Data[-<span class="number">1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.Min == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Min[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="还有一种思路——使用单调栈。"><a href="#还有一种思路——使用单调栈。" class="headerlink" title="还有一种思路——使用单调栈。"></a>还有一种思路——使用单调栈。</h2><p>入栈的时候：首先往空的数据栈里压入数字3，显然现在3是最小值，我们也把最小值压入辅助栈。接下来往数据栈里压入数字4。<br>由于4大于之前的最小值，因此我们只要入数据栈，不压入辅助栈。</p><p>出栈的时候：当数据栈和辅助栈的栈顶元素相同的时候，辅助栈的栈顶元素出栈。否则，数据栈的栈顶元素出栈。</p><p>Data = [1,2,-2,3,-4,6]<br>Min = [1,-2,-4]</p><p><strong>这个与上个不同的是：Data出栈时候需要判断是否为Min的栈顶元素,若是，则需要同时出栈。上面的方法不需要判断，只需要同时出栈</strong></p><p>获得栈顶元素的时候：直接返回数据栈的栈顶元素。</p><p>栈最小元素：直接返回辅助栈的栈顶元素。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.Data = []</span><br><span class="line">        self.Min = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.Data.append(x)</span><br><span class="line">        <span class="keyword">if</span> self.Min:</span><br><span class="line">            <span class="keyword">if</span> self.Min[-<span class="number">1</span>] &gt;= x:</span><br><span class="line">                self.Min.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Min.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.Data[-<span class="number">1</span>] == self.Min[-<span class="number">1</span>]: self.Min.pop()</span><br><span class="line">        self.Data.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Data[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.Min == []:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Min[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;定义栈的数据结构，请在类型中实现一个能够得到栈最小元素的min函数。&lt;/p&gt;
&lt;h2 id=&quot;2-思路&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="辅助栈" scheme="https://xxren8218.github.io/tags/%E8%BE%85%E5%8A%A9%E6%A0%88/"/>
    
    <category term="栈" scheme="https://xxren8218.github.io/tags/%E6%A0%88/"/>
    
    <category term="单调栈" scheme="https://xxren8218.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>降维算法——PCA(主成分分析)</title>
    <link href="https://xxren8218.github.io/20210515/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94PCA-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.html"/>
    <id>https://xxren8218.github.io/20210515/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94PCA-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.html</id>
    <published>2021-05-15T06:31:02.000Z</published>
    <updated>2021-05-15T06:39:58.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="鸢尾花数据集的降维——PCA"><a href="#鸢尾花数据集的降维——PCA" class="headerlink" title="鸢尾花数据集的降维——PCA"></a>鸢尾花数据集的降维——PCA</h1><ul><li>PCA的降维是不依赖标签（分类的），而是依赖样本的方差（协方差）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;iris.data&#x27;</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>5.1</th>      <th>3.5</th>      <th>1.4</th>      <th>0.2</th>      <th>Iris-setosa</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>4.9</td>      <td>3.0</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>1</th>      <td>4.7</td>      <td>3.2</td>      <td>1.3</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>2</th>      <td>4.6</td>      <td>3.1</td>      <td>1.5</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>3</th>      <td>5.0</td>      <td>3.6</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>4</th>      <td>5.4</td>      <td>3.9</td>      <td>1.7</td>      <td>0.4</td>      <td>Iris-setosa</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.columns=[<span class="string">&#x27;sepal_len&#x27;</span>, <span class="string">&#x27;sepal_wid&#x27;</span>, <span class="string">&#x27;petal_len&#x27;</span>, <span class="string">&#x27;petal_wid&#x27;</span>, <span class="string">&#x27;class&#x27;</span>]</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>sepal_len</th>      <th>sepal_wid</th>      <th>petal_len</th>      <th>petal_wid</th>      <th>class</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>4.9</td>      <td>3.0</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>1</th>      <td>4.7</td>      <td>3.2</td>      <td>1.3</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>2</th>      <td>4.6</td>      <td>3.1</td>      <td>1.5</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>3</th>      <td>5.0</td>      <td>3.6</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>4</th>      <td>5.4</td>      <td>3.9</td>      <td>1.7</td>      <td>0.4</td>      <td>Iris-setosa</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># split data table into data X and class labels y</span></span><br><span class="line"></span><br><span class="line">X = df.ix[:,<span class="number">0</span>:<span class="number">4</span>].values</span><br><span class="line">y = df.ix[:,<span class="number">4</span>].values</span><br></pre></td></tr></table></figure><p><strong> 数据的可视化 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">label_dict = &#123;<span class="number">1</span>: <span class="string">&#x27;Iris-Setosa&#x27;</span>,</span><br><span class="line">              <span class="number">2</span>: <span class="string">&#x27;Iris-Versicolor&#x27;</span>,</span><br><span class="line">              <span class="number">3</span>: <span class="string">&#x27;Iris-Virgnica&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">feature_dict = &#123;<span class="number">0</span>: <span class="string">&#x27;sepal length [cm]&#x27;</span>,</span><br><span class="line">                <span class="number">1</span>: <span class="string">&#x27;sepal width [cm]&#x27;</span>,</span><br><span class="line">                <span class="number">2</span>: <span class="string">&#x27;petal length [cm]&#x27;</span>,</span><br><span class="line">                <span class="number">3</span>: <span class="string">&#x27;petal width [cm]&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> cnt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, cnt+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> lab <span class="keyword">in</span> (<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>):</span><br><span class="line">        plt.hist(X[y==lab, cnt],</span><br><span class="line">                     label=lab,</span><br><span class="line">                     bins=<span class="number">10</span>,</span><br><span class="line">                     alpha=<span class="number">0.3</span>,)</span><br><span class="line">    plt.xlabel(feature_dict[cnt])</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>, fontsize=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143327.png" alt=""></p><p><strong> 一般要先进行数据的标准化，归一化，或正态化的预处理 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">X_std = StandardScaler().fit_transform(X)</span><br><span class="line"><span class="built_in">print</span> (X_std)</span><br></pre></td></tr></table></figure><pre><code>[[-1.1483555  -0.11805969 -1.35396443 -1.32506301] [-1.3905423   0.34485856 -1.41098555 -1.32506301] [-1.51163569  0.11339944 -1.29694332 -1.32506301] [-1.02726211  1.27069504 -1.35396443 -1.32506301] [-0.54288852  1.9650724  -1.18290109 -1.0614657 ] [-1.51163569  0.8077768  -1.35396443 -1.19326436] [-1.02726211  0.8077768  -1.29694332 -1.32506301] [-1.75382249 -0.34951881 -1.35396443 -1.32506301] [-1.1483555   0.11339944 -1.29694332 -1.45686167] [-0.54288852  1.50215416 -1.29694332 -1.32506301] [-1.2694489   0.8077768  -1.23992221 -1.32506301] [-1.2694489  -0.11805969 -1.35396443 -1.45686167] [-1.87491588 -0.11805969 -1.52502777 -1.45686167] [-0.05851493  2.19653152 -1.46800666 -1.32506301] ... [-0.54288852  1.9650724  -1.41098555 -1.0614657 ] [-0.90616871  1.03923592 -1.35396443 -1.19326436] [-0.17960833  1.73361328 -1.18290109 -1.19326436] [-0.90616871  1.73361328 -1.29694332 -1.19326436] [ 1.15241904  0.34485856  1.21198569  1.4427088 ] [ 1.03132564  0.57631768  1.09794346  1.70630611] [ 1.03132564 -0.11805969  0.81283789  1.4427088 ] [ 0.54695205 -1.27535529  0.69879566  0.91551417] [ 0.78913885 -0.11805969  0.81283789  1.04731282] [ 0.42585866  0.8077768   0.92688012  1.4427088 ] [ 0.06257847 -0.11805969  0.75581678  0.78371551]]</code></pre><p><strong> 手撕协方差 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean_vec = np.mean(X_std, axis=<span class="number">0</span>)</span><br><span class="line">cov_mat = (X_std - mean_vec).T.dot((X_std - mean_vec)) / (X_std.shape[<span class="number">0</span>]-<span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;Covariance matrix \n%s&#x27;</span> %cov_mat)</span><br></pre></td></tr></table></figure><pre><code>Covariance matrix [[ 1.00675676 -0.10448539  0.87716999  0.82249094] [-0.10448539  1.00675676 -0.41802325 -0.35310295] [ 0.87716999 -0.41802325  1.00675676  0.96881642] [ 0.82249094 -0.35310295  0.96881642  1.00675676]]</code></pre><p><strong> 直接可以在numpy中调用cov（）,协方差函数 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;NumPy covariance matrix: \n%s&#x27;</span> %np.cov(X_std.T))</span><br></pre></td></tr></table></figure><pre><code>NumPy covariance matrix: [[ 1.00675676 -0.10448539  0.87716999  0.82249094] [-0.10448539  1.00675676 -0.41802325 -0.35310295] [ 0.87716999 -0.41802325  1.00675676  0.96881642] [ 0.82249094 -0.35310295  0.96881642  1.00675676]]</code></pre><p>可以看到对角线上的都为1，因为自身与自身的协方差肯定是1</p><ul><li>标准化以后是1。——相关系数。</li><li>没有标准化的数据，仅仅是方差。</li></ul><h3 id="计算协方差矩阵的特征值和特征向量"><a href="#计算协方差矩阵的特征值和特征向量" class="headerlink" title="计算协方差矩阵的特征值和特征向量"></a>计算协方差矩阵的特征值和特征向量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cov_mat = np.cov(X_std.T)</span><br><span class="line"></span><br><span class="line">eig_vals, eig_vecs = np.linalg.eig(cov_mat)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Eigenvectors \n%s&#x27;</span> %eig_vecs)</span><br><span class="line">print(<span class="string">&#x27;\nEigenvalues \n%s&#x27;</span> %eig_vals)</span><br></pre></td></tr></table></figure><pre><code>Eigenvectors [[ 0.52308496 -0.36956962 -0.72154279  0.26301409] [-0.25956935 -0.92681168  0.2411952  -0.12437342] [ 0.58184289 -0.01912775  0.13962963 -0.80099722] [ 0.56609604 -0.06381646  0.63380158  0.52321917]]Eigenvalues [ 2.92442837  0.93215233  0.14946373  0.02098259]</code></pre><p><strong> 特征值的大小代表特征向量的重要程度 </strong></p><p>下面的代码将其进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Make a list of (eigenvalue, eigenvector) tuples</span></span><br><span class="line">eig_pairs = [(np.<span class="built_in">abs</span>(eig_vals[i]), eig_vecs[:,i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_vals))]</span><br><span class="line"><span class="built_in">print</span> (eig_pairs)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;----------&#x27;</span>)</span><br><span class="line"><span class="comment"># Sort the (eigenvalue, eigenvector) tuples from high to low</span></span><br><span class="line">eig_pairs.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visually confirm that the list is correctly sorted by decreasing eigenvalues</span></span><br><span class="line">print(<span class="string">&#x27;Eigenvalues in descending order:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eig_pairs:</span><br><span class="line">    print(i[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>[(2.9244283691111144, array([ 0.52308496, -0.25956935,  0.58184289,  0.56609604])), (0.93215233025350641, array([-0.36956962, -0.92681168, -0.01912775, -0.06381646])), (0.14946373489813314, array([-0.72154279,  0.2411952 ,  0.13962963,  0.63380158])), (0.020982592764270606, array([ 0.26301409, -0.12437342, -0.80099722,  0.52321917]))]----------Eigenvalues in descending order:2.924428369110.9321523302540.1494637348980.0209825927643</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tot = <span class="built_in">sum</span>(eig_vals)</span><br><span class="line">var_exp = [(i / tot)*<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(eig_vals, reverse=<span class="literal">True</span>)]</span><br><span class="line"><span class="built_in">print</span> (var_exp)</span><br><span class="line">cum_var_exp = np.cumsum(var_exp)  <span class="comment"># 来验证最后的和是否为100% 以及维度的选择——cumsum()的解释在下面。</span></span><br><span class="line">cum_var_exp</span><br></pre></td></tr></table></figure><pre><code>[72.620033326920336, 23.147406858644135, 3.7115155645845164, 0.52104424985101538]array([  72.62003333,   95.76744019,   99.47895575,  100.        ])</code></pre><h3 id="cumsum-函数的解释："><a href="#cumsum-函数的解释：" class="headerlink" title="cumsum()函数的解释："></a>cumsum()函数的解释：</h3><ul><li>为什么要用它呢？<ul><li>可以判断到底降维到几维。（设置阈值。比如百分之95%，那么降到2维即可）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;-----------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (np.cumsum(a))</span><br></pre></td></tr></table></figure><pre><code>[1 2 3 4]-----------[ 1  3  6 10]</code></pre><p><strong> 作图展示特征值所占的百分比 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">plt.bar(<span class="built_in">range</span>(<span class="number">4</span>), var_exp, alpha=<span class="number">0.5</span>, align=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">            label=<span class="string">&#x27;individual explained variance&#x27;</span>)</span><br><span class="line">plt.step(<span class="built_in">range</span>(<span class="number">4</span>), cum_var_exp, where=<span class="string">&#x27;mid&#x27;</span>,                <span class="comment"># 阶梯图。where，表示在哪里开始跳跃。</span></span><br><span class="line">             label=<span class="string">&#x27;cumulative explained variance&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Explained variance ratio&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Principal components&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.tight_layout() <span class="comment"># 最自动调整图的大小。使其填满图像区域。</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143458.png" alt=""></p><p><strong> 确定w的维度 </strong></p><ul><li>拿前两个特征向量。——基变换:w.T * x0 = x1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix_w = np.hstack((eig_pairs[<span class="number">0</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">                      eig_pairs[<span class="number">1</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Matrix W:\n&#x27;</span>, matrix_w)</span><br></pre></td></tr></table></figure><pre><code>Matrix W: [[ 0.52308496 -0.36956962] [-0.25956935 -0.92681168] [ 0.58184289 -0.01912775] [ 0.56609604 -0.06381646]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y = X_std.dot(matrix_w)</span><br><span class="line">Y</span><br></pre></td></tr></table></figure><pre><code>array([[-2.10795032,  0.64427554],       [-2.38797131,  0.30583307],       [-2.32487909,  0.56292316],       [-2.40508635, -0.687591  ],       [-2.08320351, -1.53025171],       [-2.4636848 , -0.08795413],       [-2.25174963, -0.25964365],       [-2.3645813 ,  1.08255676],       [-2.20946338,  0.43707676],       [-2.17862017, -1.08221046],       [-2.34525657, -0.17122946],       ...       [ 2.00701161, -0.60663655],       [ 1.89319854, -0.68227708],       [ 1.13831104,  0.70171953],       [ 2.03519535, -0.86076914],       [ 1.99464025, -1.04517619],       [ 1.85977129, -0.37934387],       [ 1.54200377,  0.90808604],       [ 1.50925493, -0.26460621],       [ 1.3690965 , -1.01583909],       [ 0.94680339,  0.02182097]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> lab, col <span class="keyword">in</span> <span class="built_in">zip</span>((<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>),</span><br><span class="line">                        (<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line">     plt.scatter(X[y==lab, <span class="number">0</span>],</span><br><span class="line">                X[y==lab, <span class="number">1</span>],</span><br><span class="line">                label=lab,</span><br><span class="line">                c=col)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;sepal_len&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;sepal_wid&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143541.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> lab, col <span class="keyword">in</span> <span class="built_in">zip</span>((<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>),</span><br><span class="line">                        (<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line">     plt.scatter(Y[y==lab, <span class="number">0</span>],</span><br><span class="line">                Y[y==lab, <span class="number">1</span>],</span><br><span class="line">                label=lab,</span><br><span class="line">                c=col)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Principal Component 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Principal Component 2&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower center&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143554.png" alt=""></p><h2 id="PCA使得结果更容易分类"><a href="#PCA使得结果更容易分类" class="headerlink" title="PCA使得结果更容易分类"></a>PCA使得结果更容易分类</h2><p><strong> 降维后数据的意义不存在了 </strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;鸢尾花数据集的降维——PCA&quot;&gt;&lt;a href=&quot;#鸢尾花数据集的降维——PCA&quot; class=&quot;headerlink&quot; title=&quot;鸢尾花数据集的降维——PCA&quot;&gt;&lt;/a&gt;鸢尾花数据集的降维——PCA&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;PCA的降维是不依赖标签（分类的</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
