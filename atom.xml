<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-07-04T13:38:02.041Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>06-二叉树的最小深度</title>
    <link href="https://xxren8218.github.io/20210704/06-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html"/>
    <id>https://xxren8218.github.io/20210704/06-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html</id>
    <published>2021-07-04T13:36:56.000Z</published>
    <updated>2021-07-04T13:38:02.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><ul><li>111.二叉树的最小深度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704213732.PNG" alt=""></p><p>直觉上好像和求最大深度差不多，其实还是差不少的。</p><p>遍历顺序上依然是后序遍历（因为要比较递归返回之后的结果），但在处理中间节点的逻辑上，最大深度很容易理解，最小深度可有一个误区，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704213744.png" alt=""></p><p>这就重新审题了，题目中说的是：<strong>「最小深度是从根节点到最近叶子节点的最短路径上的节点数量。」</strong>，注意是<strong>「叶子节点」</strong>。</p><p>什么是叶子节点，左右孩子都为空的节点才是叶子节点！</p><h4 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1.递归法"></a>1.递归法</h4><p>来来来，一起递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li></ol><p>参数为要传入的二叉树根节点。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">node</span>):</span></span><br></pre></td></tr></table></figure><ol><li>确定终止条件</li></ol><p>终止条件也是遇到空节点返回0，表示当前节点的高度为0。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>这块和求最大深度可就不一样了，一些同学可能会写如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leftDepth = getDepth(node.left)</span><br><span class="line">rightDepth = getDepth(node.right)</span><br><span class="line">result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这个代码就犯了此图中的误区：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704213744.png" alt=""></p><p>如果这么求的话，没有左孩子的分支会算为最短深度。</p><p>所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。</p><p>反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">leftDepth = getDepth(node.left)    <span class="comment"># 左</span></span><br><span class="line">rightDepth = getDepth(node.right)  <span class="comment"># 右</span></span><br><span class="line">                                   <span class="comment"># 中</span></span><br><span class="line"><span class="comment"># 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> node.right: </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + rightDepth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line"><span class="keyword">if</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right: </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + leftDepth</span><br><span class="line">result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth)  </span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>遍历的顺序为后序（左右中），可以看出：<strong>「求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。」</strong></p><p>整体递归代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.getDepth(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftDpeth = self.getDepth(node.left)</span><br><span class="line">        rightDepth = self.getDepth(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDpeth</span><br><span class="line">        result = <span class="number">1</span> + <span class="built_in">min</span>(leftDpeth, rightDepth)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="2. 迭代法"></a>2. 迭代法</h4><p>按照层序遍历的方法很好解决：直接套模板。用res来记录结果，每进入一层res加1，当左右孩子都为空的时候，说明为最小深度，直接返回结果即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur_node.left <span class="keyword">and</span> <span class="keyword">not</span> cur_node.right:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></blockquote><p>最大深度与最小深度也不过如此嘛！可以用【递归法】和【迭代法分别实现】！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树的最小深度&quot;&gt;&lt;a href=&quot;#二叉树的最小深度&quot; class=&quot;headerlink&quot; title=&quot;二叉树的最小深度&quot;&gt;&lt;/a&gt;二叉树的最小深度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;111.二叉树的最小深度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>05-二（N）叉树的最大深度</title>
    <link href="https://xxren8218.github.io/20210704/05-%E4%BA%8C%EF%BC%88N%EF%BC%89%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html"/>
    <id>https://xxren8218.github.io/20210704/05-%E4%BA%8C%EF%BC%88N%EF%BC%89%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html</id>
    <published>2021-07-04T13:35:05.000Z</published>
    <updated>2021-07-04T13:36:26.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二（N）叉树的最大深度"><a href="#二（N）叉树的最大深度" class="headerlink" title="二（N）叉树的最大深度"></a>二（N）叉树的最大深度</h2><blockquote><h3 id="1-二叉树的最大深度"><a href="#1-二叉树的最大深度" class="headerlink" title="1. 二叉树的最大深度"></a>1. 二叉树的最大深度</h3></blockquote><ul><li>104.二叉树的最大深度</li><li>559.N叉树的最大深度</li></ul><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704213548.png" alt=""></p><p>返回它的最大深度 3 。</p><h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h4><h4 id="1-1-递归法"><a href="#1-1-递归法" class="headerlink" title="1.1 递归法"></a>1.1 递归法</h4><p>本题其实也要后序遍历（左右中），依然是因为要通过递归函数的返回值做计算树的高度。</p><p>按照递归三部曲，来看看如何来写。</p><ol><li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度。</li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">self, node</span>):</span></span><br></pre></td></tr></table></figure><ol><li>确定终止条件：如果为空节点的话，就返回0，表示高度为0。</li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> node == <span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ol><li>确定单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li></ol><p>代码如下：后序遍历，按照左右中的顺序）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leftDepth = getDepth(node.left);       <span class="comment"># 左</span></span><br><span class="line">rightDepth = getDepth(node.right);     <span class="comment"># 右</span></span><br><span class="line">depth = <span class="number">1</span> + <span class="built_in">max</span>(leftDepth, rightDepth); <span class="comment"># 中</span></span><br><span class="line"><span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><p>所以整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.getDepth(root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftDepth = self.getDepth(node.left)</span><br><span class="line">        rightDepth = self.getDepth(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(leftDepth, rightDepth) </span><br></pre></td></tr></table></figure><h4 id="1-2-迭代法"><a href="#1-2-迭代法" class="headerlink" title="1.2 迭代法"></a>1.2 迭代法</h4><p>使用迭代法的话，使用层序遍历是比较合适的，也是比较容易理解的。因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。</p><p>在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704213601.png" alt=""></p><p>所以这道题的迭代法就是一道【模板题】，可以使用二叉树层序遍历的模板来解决的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 框架上改一行</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><h3 id="2-N叉树的最大深度"><a href="#2-N叉树的最大深度" class="headerlink" title="2. N叉树的最大深度"></a>2. N叉树的最大深度</h3></blockquote><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>例如，给定一个 3叉树 :</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704213613.png" alt=""></p><p>我们应返回其最大深度，3。</p><h4 id="1-思路："><a href="#1-思路：" class="headerlink" title="1. 思路："></a>1. 思路：</h4><p>依然可以提供递归法和迭代法，来解决这个问题，思路是和二叉树思路一样的，直接给出代码如下：</p><h4 id="2-1-递归法"><a href="#2-1-递归法" class="headerlink" title="2.1 递归法"></a>2.1 递归法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.getDepth(root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="comment"># leftDepth = self.getDepth(node.left)</span></span><br><span class="line">        <span class="comment"># rightDepth = self.getDepth(node.right)</span></span><br><span class="line">        <span class="comment"># return 1 + max(leftDepth, rightDepth)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(node.children)):</span><br><span class="line">            depth = <span class="built_in">max</span>(depth, self.getDepth(node.children[i]))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + depth</span><br></pre></td></tr></table></figure><h4 id="2-2-迭代法"><a href="#2-2-迭代法" class="headerlink" title="2.2 迭代法"></a>2.2 迭代法</h4><p>同样的也是套用模板。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 只需要改变这里就可以了。</span></span><br><span class="line">                <span class="keyword">while</span> cur_node.children:</span><br><span class="line">                    queue.append(cur_node.children.pop(<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3></blockquote><p>至此，二（N）叉树的最大深度就完成了，分别采用了递归法和迭代法进行求解，递归法可以看到递归三部曲的身影，迭代法套用模板即可！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二（N）叉树的最大深度&quot;&gt;&lt;a href=&quot;#二（N）叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;二（N）叉树的最大深度&quot;&gt;&lt;/a&gt;二（N）叉树的最大深度&lt;/h2&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;1-二叉树的最大深度&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>04-对称二叉树</title>
    <link href="https://xxren8218.github.io/20210704/04-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://xxren8218.github.io/20210704/04-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html</id>
    <published>2021-07-04T13:32:41.000Z</published>
    <updated>2021-07-04T13:34:15.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><ul><li>101.对称二叉树</li></ul><p>给定一个二叉树，检查它是否是镜像对称的。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704213329.PNG" alt=""></p><h3 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h3><p><strong>「首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！」</strong></p><p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>「其实我们要比较的是两个树（这两个树是根节点的左右子树）」</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p><p>那么如果比较呢？</p><p>比较的是两个子树的里侧和外侧的元素是否相等。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704213343.jpg" alt=""></p><p>那么遍历的顺序应该是什么样的呢？</p><p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p><p><strong>「正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。」</strong></p><p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p><p>说到这大家可能感觉我有点啰嗦，哪有这么多道理，上来就干就完事了。别急，我说的这些在下面的代码讲解中都有身影。</p><p>那么我们先来看看递归法的代码应该怎么写。</p><h3 id="二、递归法"><a href="#二、递归法" class="headerlink" title="二、递归法"></a>二、递归法</h3><p><strong>递归三部曲</strong></p><ul><li><p>确定递归函数的参数和返回值</p><p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p><p>返回值自然是bool类型。</p></li></ul><p>代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def compare(left, right): -&gt; bool</span><br></pre></td></tr></table></figure><ul><li><p>确定终止条件</p><p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p><p>节点为空的情况有：（<strong>「注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点」</strong>）</p><ul><li><p>左节点为空，右节点不为空，不对称，return false</p></li><li><p>左不为空，右为空，不对称 return  false</p></li><li><p>左右都为空，对称，返回true</p></li></ul><p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p><ul><li>左右都不为空，比较节点数值，不相同就return false</li></ul><p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p></li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li><p>确定单层递归的逻辑</p><p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 右节点都不为空，且数值相同的情况。</p><ul><li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li><li>比较内测是否对称，传入左节点的右孩子，右节点的左孩子。</li><li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li></ul></li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outside = compare(left.left, right.right)</span><br><span class="line">inside = compare(left.right, right.left)</span><br><span class="line">isSame = outside <span class="keyword">and</span> inside</span><br></pre></td></tr></table></figure><p>如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）.</p><p>最后看一下完整的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.compare(root.left, root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        outside = self.compare(left.left, right.right)</span><br><span class="line">        inside = self.compare(left.right, right.left)</span><br><span class="line">        isSame = outside <span class="keyword">and</span> inside</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isSame</span><br></pre></td></tr></table></figure><p><strong>「建议大家做题的时候，一定要想清楚逻辑，每一步做什么。把道题目所有情况想到位，相应的代码写出来之后，再去追求简洁代码的效果。」</strong></p><h3 id="三、迭代法"><a href="#三、迭代法" class="headerlink" title="三、迭代法"></a>三、迭代法</h3><p>这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。</p><p>这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（<strong>「注意这不是层序遍历」</strong>）</p><h4 id="1-使用队列"><a href="#1-使用队列" class="headerlink" title="1.使用队列"></a>1.使用队列</h4><p>通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704213358.gif" alt=""></p><p>如下的条件判断和递归的逻辑是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root.left)</span><br><span class="line">        queue.append(root.right)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 将左右节点分别加入队列</span></span><br><span class="line">            left_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            right_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 两个都为空，则对称，继续。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left_node <span class="keyword">and</span> <span class="keyword">not</span> right_node: </span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 一个为空，另一个不为空，返回False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> left_node <span class="keyword">and</span> right_node) <span class="keyword">or</span> \</span><br><span class="line">               (left_node <span class="keyword">and</span> <span class="keyword">not</span> right_node):</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 两个都不为空，值不相等，返回False</span></span><br><span class="line">            <span class="keyword">if</span> left_node.val != right_node.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            queue.append(left_node.left)</span><br><span class="line">            queue.append(right_node.right)</span><br><span class="line">            queue.append(left_node.right)</span><br><span class="line">            queue.append(right_node.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="2-使用栈"><a href="#2-使用栈" class="headerlink" title="2.使用栈"></a>2.使用栈</h4><p>细心的话，其实可以发现，这个迭代法，其实是把左右两个子树要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较，那么其实使用栈也是可以的。——先判断里侧和先判断外侧的顺序不影响。</p><p>只要把队列原封不动的改成栈就可以了，我下面也给出了代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root.left)</span><br><span class="line">        stack.append(root.right)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="comment"># 将左右节点分别加入队列</span></span><br><span class="line">            left_node = stack.pop()</span><br><span class="line">            right_node = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 两个都为空，则对称，继续。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left_node <span class="keyword">and</span> <span class="keyword">not</span> right_node: </span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 一个为空，另一个不为空，返回False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> left_node <span class="keyword">and</span> right_node) <span class="keyword">or</span> \</span><br><span class="line">               (left_node <span class="keyword">and</span> <span class="keyword">not</span> right_node):</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 两个都不为空，值不相等，返回False</span></span><br><span class="line">            <span class="keyword">if</span> left_node.val != right_node.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            stack.append(left_node.left)</span><br><span class="line">            stack.append(right_node.right)</span><br><span class="line">            stack.append(left_node.right)</span><br><span class="line">            stack.append(right_node.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3></blockquote><p>这次我们又深度剖析了一道二叉树的“简单题”，大家会发现，真正的把题目搞清楚其实并不简单，leetcode上accept了和真正掌握了还是有距离的。</p><p>我们介绍了递归法和迭代法，递归依然通过递归三部曲来解决了这道题目。</p><p>在迭代法中我们使用了队列，需要注意的是这不是层序遍历，而且仅仅通过一个容器来成对的存放我们要比较的元素，知道这一本质之后就发现：用队列，用栈，甚至用数组，都是可以的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对称二叉树&quot;&gt;&lt;a href=&quot;#对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;对称二叉树&quot;&gt;&lt;/a&gt;对称二叉树&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;101.对称二叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>29-spark_core补充</title>
    <link href="https://xxren8218.github.io/20210704/29-spark-core%E8%A1%A5%E5%85%85.html"/>
    <id>https://xxren8218.github.io/20210704/29-spark-core%E8%A1%A5%E5%85%85.html</id>
    <published>2021-07-03T17:58:13.000Z</published>
    <updated>2021-07-03T18:01:52.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spark-相关概念补充"><a href="#spark-相关概念补充" class="headerlink" title="spark 相关概念补充"></a>spark 相关概念补充</h2><p>掌握目标</p><ul><li>了解spark的安装部署</li><li>知道spark作业提交集群的过程</li></ul><h3 id="1-spark的安装部署"><a href="#1-spark的安装部署" class="headerlink" title="1. spark的安装部署"></a>1. spark的安装部署</h3><ul><li><p>1、下载spark安装包</p><p><a href="http://spark.apache.org/downloads.html">http://spark.apache.org/downloads.html</a></p><p>高版本不存在cdh的编译版本，可以从官网下载源码版本，指定高版本hadoop进行编译</p><p>编译步骤：</p><ul><li><p>1，安装java(JDK 1.7及以上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;xxx</span><br><span class="line">export JRE_HOME&#x3D;&#x2F;xxx</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib:$CLASSPATH</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>2，安装Maven， 版本为3.3.9或者以上</p><p>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache//maven/maven-3/3.3.9/binaries">https://mirrors.tuna.tsinghua.edu.cn/apache//maven/maven-3/3.3.9/binaries</a></p><p>配置MAVEN_HOME</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MAVEN_HOME&#x3D;&#x2F;xxx</span><br><span class="line">export PATH&#x3D;$MAVEN_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>3，下载spark源码</p></li><li><p>4，增加cdh的repository</p><p>解压spark的源码包，编辑pom.xml文件， 在repositories节点 加入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;repository&gt;</span><br><span class="line">          &lt;id&gt;cloudera&lt;&#x2F;id&gt;</span><br><span class="line">          &lt;url&gt;https:&#x2F;&#x2F;repository.cloudera.com&#x2F;artifactory&#x2F;cloudera-repos&#x2F;&lt;&#x2F;url&gt;&lt;&#x2F;repository&gt;</span><br></pre></td></tr></table></figure></li><li><p>5，编译</p><p>设置内存：</p><p>export MAVEN_OPTS=”-Xmx2g -XX:ReservedCodeCacheSize=512m”</p><p>开始编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;dev&#x2F;make-distribution.sh --name 2.6.0-cdh5.7.0 --tgz  -Pyarn -Phadoop-2.6 -Phive -Phive-thriftserver -Dhadoop.version&#x3D;2.6.0-cdh5.7.0 -DskipTests clean package</span><br></pre></td></tr></table></figure><p>源码编译后，bin目录下的文件可能不存在可执行权限，需要通过chmod指令添加可执行权限</p><p>chmod +x xxx</p></li></ul></li><li><p>2、规划spark安装目录</p></li><li><p>3、解压安装包</p></li><li><p>4、重命名安装目录</p></li><li><p>5、修改配置文件</p><ul><li>spark-env.sh(需要将spark-env.sh.template重命名)<ul><li>配置java环境变量<ul><li>export JAVA_HOME=java_home_path</li></ul></li><li>配置PYTHON环境<ul><li>export PYSPARK_PYTHON=/xx/pythonx_home/bin/pythonx</li></ul></li><li>配置master的地址<ul><li>export SPARK_MASTER_HOST=node-teach</li></ul></li><li>配置master的端口<ul><li>export SPARK_MASTER_PORT=7077</li></ul></li></ul></li></ul></li><li><p>6、配置spark环境变量</p><ul><li>export SPARK_HOME=/xxx/spark2.x</li><li>export PATH=\$PATH:\$SPARK_HOME/bin</li></ul></li></ul><h3 id="2-启动Spark集群"><a href="#2-启动Spark集群" class="headerlink" title="2. 启动Spark集群"></a>2. 启动Spark集群</h3><ul><li>进入到$SPARK_HOME/sbin目录</li><li>启动Master    </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start-master.sh -h 192.168.19.137</span><br></pre></td></tr></table></figure><ul><li>启动Slave</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start-slave.sh spark://192.168.19.137:7077</span><br></pre></td></tr></table></figure><ul><li>jps查看进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">27073 Master</span><br><span class="line">27151 Worker</span><br></pre></td></tr></table></figure><ul><li>关闭防火墙</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><ul><li>通过SPARK WEB UI查看Spark集群及Spark<ul><li><a href="http://192.168.199.188:8080/">http://192.168.199.188:8080/</a>  监控Spark集群</li><li><a href="http://192.168.199.188:4040/">http://192.168.199.188:4040/</a>  监控Spark Job</li></ul></li></ul><h3 id="3-spark-集群相关概念"><a href="#3-spark-集群相关概念" class="headerlink" title="3. spark 集群相关概念"></a>3. spark 集群相关概念</h3><ul><li><p>spark集群架构(Standalone模式)</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704015921.png" alt=""></p><ul><li><p>Application</p><p>用户自己写的Spark应用程序，批处理作业的集合。Application的main方法为应用程序的入口，用户通过Spark的API，定义了RDD和对RDD的操作。</p></li><li><p>Master和Worker</p><p>整个集群分为 Master 节点和 Worker 节点，相当于 Hadoop 的 Master 和 Slave 节点。</p><ul><li>Master：Standalone模式中主控节点，负责接收Client提交的作业，管理Worker，并命令Worker启动Driver和Executor。</li><li>Worker：Standalone模式中slave节点上的守护进程，负责管理本节点的资源，定期向Master汇报心跳，接收Master的命令，启动Driver和Executor。</li></ul></li><li><p>Client：客户端进程，负责提交作业到Master。</p></li><li><p>Driver： 一个Spark作业运行时包括一个Driver进程，也是作业的主进程，负责作业的解析、生成Stage并调度Task到Executor上。包括DAGSchedule（负责作业的拆解），TaskScheduler（负责把对应的Task发到对应的Worker上，交给Executor求执行）。</p></li><li><p>Executor：即真正执行作业的地方，一个集群一般包含多个Executor，每个Executor接收Driver的命令Launch Task，一个Executor可以执行一到多个Task。</p></li></ul></li><li><p>Spark作业相关概念</p><ul><li><p>Stage：一个Spark作业一般包含一到多个Stage。</p></li><li><p>Task：一个Stage包含一到多个Task，通过多个Task实现并行运行的功能（可能算的结果不一样，前面有讲）。</p></li><li><p>DAGScheduler： 实现将Spark作业分解成一到多个Stage，每个Stage根据RDD的Partition个数决定Task的个数，然后生成相应的Task set放到TaskScheduler中。</p></li><li><p>TaskScheduler：实现Task分配到Executor上执行。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704015938.png" alt=""></p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210704020004.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;spark-相关概念补充&quot;&gt;&lt;a href=&quot;#spark-相关概念补充&quot; class=&quot;headerlink&quot; title=&quot;spark 相关概念补充&quot;&gt;&lt;/a&gt;spark 相关概念补充&lt;/h2&gt;&lt;p&gt;掌握目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解spark的安装部署</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>28-spark_core 实战案例</title>
    <link href="https://xxren8218.github.io/20210703/28-spark-core-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B.html"/>
    <id>https://xxren8218.github.io/20210703/28-spark-core-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B.html</id>
    <published>2021-07-02T17:03:57.000Z</published>
    <updated>2021-07-02T17:07:57.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spark-core-实战案例"><a href="#spark-core-实战案例" class="headerlink" title="spark-core 实战案例"></a>spark-core 实战案例</h2><p>掌握目标：</p><ul><li>独立实现Spark RDD的word count案例</li><li>独立实现spark RDD的PV UV统计案例</li><li>说出广播变量的概念</li></ul><p>对于数据在shell里面写，没有交互，对于数据分析而言不好，将其用PyCharm编写可进行交互，便于分析。</p><ul><li>即在PyCharm上编写，然后数据同步到Centos上面运行，运行结束后，还在PyCharm上面显示。</li></ul><h3 id="1-0-Pycharm编写spark代码环境配置"><a href="#1-0-Pycharm编写spark代码环境配置" class="headerlink" title="1.0 Pycharm编写spark代码环境配置"></a>1.0 Pycharm编写spark代码环境配置</h3><p>准备pycharm环境</p><ul><li><p>1.PyCharm的配置</p><ul><li>file-&gt;new-project-&gt;pure Python-&gt;exiting interpreter-&gt;add remote-&gt;SSH Crederitals-&gt;填写Host(192.168.19.137)-&gt;Username(root)-&gt;密码-&gt;选择python的解释器路径为(/miniconda2/envs/py365/bin/python)-&gt;Remote project location(/root/bigdata/code)</li></ul></li><li><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个是链接用的哪种环境，若几个集群的话，传递的应该是master节点的RL地址</span></span><br><span class="line">sc = SparkContext(<span class="string">&#x27;local[2]&#x27;</span>,<span class="string">&#x27;wordcount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdd1 = sc.textFile(<span class="string">&quot;file:///root/code/test.txt&quot;</span>).\</span><br><span class="line">    flatMap(<span class="keyword">lambda</span> x: x.split()).<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x, <span class="number">1</span>)).\</span><br><span class="line">    reduceByKey(<span class="keyword">lambda</span> a,b: a+b)</span><br><span class="line"></span><br><span class="line">print(rdd1.collect())</span><br></pre></td></tr></table></figure><p>运行出现了错误：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210703010459.PNG" alt=""></p></li></ul><p>解决方法：</p><ul><li>在centos上面查找JAVA_HOME所在位置(vi ~/.bash_profile)，添加到环境变量中：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####################################</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">JAVA_HOME = <span class="string">&#x27;/root/bigdata/jdk&#x27;</span></span><br><span class="line">os.environ[<span class="string">&#x27;JAVA_HOME&#x27;</span>] = JAVA_HOME</span><br><span class="line"><span class="comment">####################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个master的位置，第二个是spark作业的名字。</span></span><br><span class="line">sc = SparkContext(<span class="string">&#x27;local[2]&#x27;</span>,<span class="string">&#x27;wordcount&#x27;</span>) <span class="comment"># 第一个是链接用的哪种环境，若几个集群的话，传递的应该是master节点的RL地址</span></span><br><span class="line"></span><br><span class="line">rdd1 = sc.textFile(<span class="string">&quot;file:///root/code/test.txt&quot;</span>).\</span><br><span class="line">    flatMap(<span class="keyword">lambda</span> x: x.split()).<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x, <span class="number">1</span>)).\</span><br><span class="line">    reduceByKey(<span class="keyword">lambda</span> a,b: a+b)</span><br><span class="line"></span><br><span class="line">print(rdd1.collect())</span><br></pre></td></tr></table></figure><p>  还会出现python的版本不一致的问题，再添加python的环境。以及pyspark的版本问题。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####################################</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">JAVA_HOME = <span class="string">&#x27;/root/bigdata/jdk&#x27;</span></span><br><span class="line">PYSPARK_PYTHON = <span class="string">&quot;/miniconda2/envs/py365/bin/python&quot;</span></span><br><span class="line">os.environ[<span class="string">&#x27;JAVA_HOME&#x27;</span>] = JAVA_HOME</span><br><span class="line">os.environ[<span class="string">&#x27;PYSPARK_PYTHON&#x27;</span>] = PYSPARK_PYTHON</span><br><span class="line">os.environ[<span class="string">&#x27;PYSPARK_DRIVER_PYTHON&#x27;</span>] = PYSPARK_PYTHON</span><br><span class="line"><span class="comment">####################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"></span><br><span class="line">sc = SparkContext(<span class="string">&#x27;local[2]&#x27;</span>,<span class="string">&#x27;wordcount&#x27;</span>)</span><br><span class="line">rdd1 = sc.textFile(<span class="string">&quot;file:///root/code/test.txt&quot;</span>).\</span><br><span class="line">    flatMap(<span class="keyword">lambda</span> x: x.split()).<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x,<span class="number">1</span>)).\</span><br><span class="line">    reduceByKey(<span class="keyword">lambda</span> a,b: a+b)</span><br><span class="line"></span><br><span class="line">print(rdd1.collect())</span><br></pre></td></tr></table></figure><h3 id="1-1利用PyCharm编写spark-wordcount程序"><a href="#1-1利用PyCharm编写spark-wordcount程序" class="headerlink" title="1.1利用PyCharm编写spark wordcount程序"></a>1.1利用PyCharm编写spark wordcount程序</h3><ul><li>代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">JAVA_HOME = <span class="string">&#x27;/root/bigdata/jdk&#x27;</span></span><br><span class="line">PYSPARK_PYTHON = <span class="string">&quot;/miniconda2/envs/py365/bin/python&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;JAVA_HOME&quot;</span>] = JAVA_HOME</span><br><span class="line">os.environ[<span class="string">&quot;PYSPARK_PYTHON&quot;</span>] = PYSPARK_PYTHON</span><br><span class="line">os.environ[<span class="string">&quot;PYSPARK_DRIVER_PYTHON&quot;</span>] = PYSPARK_PYTHON</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建spark context</span></span><br><span class="line">    sc = SparkContext(<span class="string">&#x27;local[2]&#x27;</span>,<span class="string">&#x27;wordcount&#x27;</span>)</span><br><span class="line">    <span class="comment"># 通过spark context 获取rdd</span></span><br><span class="line">    rdd1 = sc.textFile(<span class="string">&#x27;file:///root/tmp/test.txt&#x27;</span>)</span><br><span class="line">    rdd2 = rdd1.flatMap(<span class="keyword">lambda</span> line:line.split())</span><br><span class="line">    rdd3 = rdd2.<span class="built_in">map</span>(<span class="keyword">lambda</span> x:(x,<span class="number">1</span>))</span><br><span class="line">    rdd4 = rdd3.reduceByKey(<span class="keyword">lambda</span> x,y:x+y)</span><br><span class="line">    print(rdd4.collect())</span><br></pre></td></tr></table></figure><h3 id="1-2-通过spark实现点击流日志分析"><a href="#1-2-通过spark实现点击流日志分析" class="headerlink" title="1.2 通过spark实现点击流日志分析"></a>1.2 通过spark实现点击流日志分析</h3><p>在新闻类网站中，经常要衡量一条网络新闻的页面访问量，最常见的就是uv和pv，如果在所有新闻中找到访问最多的前几条新闻，topN是最常见的指标。</p><ul><li>数据示例</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每条数据代表一次访问记录 包含了ip 访问时间 访问的请求方式 访问的地址...信息</span></span><br><span class="line">194.237.142.21 - - [18/Sep/2013:06:49:18 +0000] &quot;GET /wp-content/uploads/2013/07/rstudio-git3.png HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/4.0 (compatible;)&quot;</span><br><span class="line">183.49.46.228 - - [18/Sep/2013:06:49:23 +0000] &quot;-&quot; 400 0 &quot;-&quot; &quot;-&quot;</span><br><span class="line">163.177.71.12 - - [18/Sep/2013:06:49:33 +0000] &quot;HEAD / HTTP/1.1&quot; 200 20 &quot;-&quot; &quot;DNSPod-Monitor/1.0&quot;</span><br><span class="line">163.177.71.12 - - [18/Sep/2013:06:49:36 +0000] &quot;HEAD / HTTP/1.1&quot; 200 20 &quot;-&quot; &quot;DNSPod-Monitor/1.0&quot;</span><br><span class="line">101.226.68.137 - - [18/Sep/2013:06:49:42 +0000] &quot;HEAD / HTTP/1.1&quot; 200 20 &quot;-&quot; &quot;DNSPod-Monitor/1.0&quot;</span><br><span class="line">101.226.68.137 - - [18/Sep/2013:06:49:45 +0000] &quot;HEAD / HTTP/1.1&quot; 200 20 &quot;-&quot; &quot;DNSPod-Monitor/1.0&quot;</span><br><span class="line">60.208.6.156 - - [18/Sep/2013:06:49:48 +0000] &quot;GET /wp-content/uploads/2013/07/rcassandra.png HTTP/1.0&quot; 200 185524 &quot;http://cos.name/category/software/packages/&quot; &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36&quot;</span><br><span class="line">222.68.172.190 - - [18/Sep/2013:06:49:57 +0000] &quot;GET /images/my.jpg HTTP/1.1&quot; 200 19939 &quot;http://www.angularjs.cn/A00n&quot; &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36&quot;</span><br><span class="line">222.68.172.190 - - [18/Sep/2013:06:50:08 +0000] &quot;-&quot; 400 0 &quot;-&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><ul><li><p>访问的pv</p><p>pv：网站的总访问量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession.builder.appName(<span class="string">&quot;pv&quot;</span>).getOrCreate()</span><br><span class="line">sc = spark.sparkContext</span><br><span class="line">rdd1 = sc.textFile(<span class="string">&quot;file:///root/bigdata/data/access.log&quot;</span>)</span><br><span class="line"><span class="comment"># 把每一行数据记为(&quot;pv&quot;,1)</span></span><br><span class="line">rdd2 = rdd1.<span class="built_in">map</span>(<span class="keyword">lambda</span> x:(<span class="string">&quot;pv&quot;</span>,<span class="number">1</span>)).reduceByKey(<span class="keyword">lambda</span> a,b:a+b)</span><br><span class="line">rdd2.collect()</span><br><span class="line">sc.stop()</span><br></pre></td></tr></table></figure></li><li><p>访问的uv</p><p>uv：网站的独立用户访问量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession.builder.appName(<span class="string">&quot;pv&quot;</span>).getOrCreate()</span><br><span class="line">sc = spark.sparkContext</span><br><span class="line">rdd1 = sc.textFile(<span class="string">&quot;file:///root/bigdata/data/access.log&quot;</span>)</span><br><span class="line"><span class="comment"># 对每一行按照空格拆分，将ip地址取出</span></span><br><span class="line">rdd2 = rdd1.<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x.split(<span class="string">&quot; &quot;</span>)).<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 把每个ur记为1</span></span><br><span class="line">rdd3 = rdd2.distinct().<span class="built_in">map</span>(<span class="keyword">lambda</span> x:(<span class="string">&quot;uv&quot;</span>,<span class="number">1</span>))</span><br><span class="line">rdd4 = rdd3.reduceByKey(<span class="keyword">lambda</span> a,b:a+b)</span><br><span class="line">rdd4.saveAsTextFile(<span class="string">&quot;hdfs:///uv/result&quot;</span>)</span><br><span class="line">sc.stop()</span><br></pre></td></tr></table></figure></li><li><p>访问的topN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession.builder.appName(<span class="string">&quot;topN&quot;</span>).getOrCreate()</span><br><span class="line">sc = spark.sparkContext</span><br><span class="line">rdd1 = sc.textFile(<span class="string">&quot;file:///root/bigdata/data/access.log&quot;</span>)</span><br><span class="line"><span class="comment"># 对每一行按照空格拆分，将url数据取出，把每个url记为1</span></span><br><span class="line">rdd2 = rdd1.<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x.split(<span class="string">&quot; &quot;</span>)).<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:<span class="built_in">len</span>(x)&gt;<span class="number">10</span>).<span class="built_in">map</span>(<span class="keyword">lambda</span> x:(x[<span class="number">10</span>],<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 对数据进行累加，按照url出现次数的降序排列</span></span><br><span class="line">rdd3 = rdd2.reduceByKey(<span class="keyword">lambda</span> a,b:a+b).sortBy(<span class="keyword">lambda</span> x:x[<span class="number">1</span>],ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 取出序列数据中的前n个</span></span><br><span class="line">rdd4 = rdd3.take(<span class="number">5</span>)</span><br><span class="line">rdd4.collect()</span><br><span class="line">sc.stop()</span><br></pre></td></tr></table></figure></li></ul><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>这里不懂的可以去上篇看数据的具体格式！</p><h3 id="2-通过spark实现ip地址查询"><a href="#2-通过spark实现ip地址查询" class="headerlink" title="2. 通过spark实现ip地址查询"></a>2. 通过spark实现ip地址查询</h3><p><strong>需求</strong></p><p>在互联网中，我们经常会见到城市热点图这样的报表数据，例如在百度统计中，会统计今年的热门旅游城市、热门报考学校等，会将这样的信息显示在热点图中。</p><p>因此，我们需要通过日志信息（运行商或者网站自己生成）和城市ip段信息来判断用户的ip段，统计热点经纬度。</p><p><strong>ip日志信息</strong></p><p>在ip日志信息中，我们只需要关心ip这一个维度就可以了，其他的不做介绍</p><p><strong>思路</strong></p><p>1、 加载城市ip段信息，获取ip起始数字和结束数字，经度，纬度</p><p>2、 加载日志数据，获取ip信息，然后转换为数字，和ip段比较</p><p>3、 比较的时候采用二分法查找，找到对应的经度和纬度</p><p>4，对相同的经度和纬度做累计求和</p><p>5， 取出最终的topN的经纬度</p><p><strong>启动Spark集群</strong></p><ul><li><p>进入到$SPARK_HOME/sbin目录</p><ul><li>启动Master    </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start-master.sh -h 192.168.199.188</span><br></pre></td></tr></table></figure><ul><li>启动Slave</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start-slave.sh spark://192.168.199.188:7077</span><br></pre></td></tr></table></figure><ul><li>jps查看进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">27073 Master</span><br><span class="line">27151 Worker</span><br></pre></td></tr></table></figure><ul><li>关闭防火墙</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><ul><li>通过SPARK WEB UI查看Spark集群及Spark<ul><li><a href="http://192.168.199.188:8080/">http://192.168.199.188:8080/</a>  监控Spark集群</li><li><a href="http://192.168.199.188:4040/">http://192.168.199.188:4040/</a>  监控Spark Job</li></ul></li></ul></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="comment"># 255.255.255.255 0~255 256个数  2^8 是8位2进制数  ——&gt;转化成32位的二进制数</span></span><br><span class="line"><span class="comment">#将ip转换为特殊的数字形式  223.243.0.0|223.243.191.255|  255 2^8</span></span><br><span class="line"><span class="comment">#‭11011111‬</span></span><br><span class="line"><span class="comment">#00000000</span></span><br><span class="line"><span class="comment">#1101111100000000</span></span><br><span class="line"><span class="comment">#‭        11110011‬</span></span><br><span class="line"><span class="comment">#11011111111100110000000000000000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ip_transform</span>(<span class="params">ip</span>):</span>     </span><br><span class="line">    ips = ip.split(<span class="string">&quot;.&quot;</span>) <span class="comment"># [223,243,0,0] 32位二进制数</span></span><br><span class="line">    ip_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ips:</span><br><span class="line">        ip_num = <span class="built_in">int</span>(i) | ip_num &lt;&lt; <span class="number">8</span></span><br><span class="line">    <span class="keyword">return</span> ip_num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分法查找ip对应的行的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">ip_num, broadcast_value</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(broadcast_value) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end):</span><br><span class="line">        mid = <span class="built_in">int</span>((start + end) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> ip_num &gt;= <span class="built_in">int</span>(broadcast_value[mid][<span class="number">0</span>]) <span class="keyword">and</span> ip_num &lt;= <span class="built_in">int</span>(broadcast_value[mid][<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> ip_num &lt; <span class="built_in">int</span>(broadcast_value[mid][<span class="number">0</span>]):</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">if</span> ip_num &gt; <span class="built_in">int</span>(broadcast_value[mid][<span class="number">1</span>]):</span><br><span class="line">            start = mid</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    spark = SparkSession.builder.appName(<span class="string">&quot;test&quot;</span>).getOrCreate()</span><br><span class="line">    sc = spark.sparkContext</span><br><span class="line">    city_id_rdd = sc.textFile(<span class="string">&quot;file:///home/hadoop/app/tmp/data/ip.txt&quot;</span>).<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x.split(<span class="string">&quot;|&quot;</span>)).<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x[<span class="number">2</span>], x[<span class="number">3</span>], x[<span class="number">13</span>], x[<span class="number">14</span>]))</span><br><span class="line">    <span class="comment"># 创建一个广播变量</span></span><br><span class="line">    city_broadcast = sc.broadcast(city_id_rdd.collect())</span><br><span class="line">    dest_data = sc.textFile(<span class="string">&quot;file:///home/hadoop/app/tmp/data/20090121000132.394251.http.format&quot;</span>).<span class="built_in">map</span>(</span><br><span class="line">        <span class="keyword">lambda</span> x: x.split(<span class="string">&quot;|&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 根据取出对应的位置信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pos</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="comment"># 从广播变量中获取ip地址库</span></span><br><span class="line">        city_broadcast_value = city_broadcast.value</span><br><span class="line">        <span class="comment"># 根据单个ip获取对应经纬度信息</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_result</span>(<span class="params">ip</span>):</span></span><br><span class="line">            ip_num = ip_transform(ip)</span><br><span class="line">            index = binary_search(ip_num, city_broadcast_value)</span><br><span class="line">            <span class="comment"># ((纬度,精度),1)</span></span><br><span class="line">            <span class="keyword">return</span> ((city_broadcast_value[index][<span class="number">2</span>], city_broadcast_value[index][<span class="number">3</span>]), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        x = <span class="built_in">map</span>(<span class="built_in">tuple</span>,[get_result(ip) <span class="keyword">for</span> ip <span class="keyword">in</span> x])</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    dest_rdd = dest_data.mapPartitions(<span class="keyword">lambda</span> x: get_pos(x)) <span class="comment"># ((纬度,精度),1)</span></span><br><span class="line">    result_rdd = dest_rdd.reduceByKey(<span class="keyword">lambda</span> a, b: a + b).sortBy(<span class="keyword">lambda</span> x:x[<span class="number">1</span>],ascending=<span class="literal">False</span>)</span><br><span class="line">    print(result_rdd.collect())</span><br><span class="line">    sc.stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li><p><strong>广播变量的使用</strong></p><ul><li>要统计Ip所对应的经纬度, 每一条数据都会去查询ip表</li><li>每一个task 都需要这一个ip表, 默认情况下, 所有task都会去复制ip表</li><li>实际上 每一个Worker上会有多个task, 数据也是只需要进行查询操作的, 所以这份数据可以共享,没必要每个task复制一份</li><li>可以通过广播变量, 通知当前worker上所有的task, 来共享这个数据,避免数据的多次复制,可以大大降低内存的开销</li><li>sparkContext.broadcast(要共享的数据)</li></ul></li><li><p><strong>mapPartitions</strong> </p><ul><li>transformation操作 </li><li>类似map 但是map是一条一条传给里面函数的 mapPartitions 数据是一部分一部分传给函数的</li><li>应用场景 数据处理的时候 需要连接其它资源 如果一条一条处理 会处理一条连一次， 一份一份处理可以很多条数据连一次其它资源 可以提高效率</li></ul></li><li><p><strong>二分法查找</strong></p></li><li><p>ip_transform 把223.243.0.0 转换成10进制的数字——位运算。 </p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;spark-core-实战案例&quot;&gt;&lt;a href=&quot;#spark-core-实战案例&quot; class=&quot;headerlink&quot; title=&quot;spark-core 实战案例&quot;&gt;&lt;/a&gt;spark-core 实战案例&lt;/h2&gt;&lt;p&gt;掌握目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>03-翻转二叉树--递归和迭代的应用</title>
    <link href="https://xxren8218.github.io/20210702/03-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%BA%94%E7%94%A8.html"/>
    <id>https://xxren8218.github.io/20210702/03-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%BA%94%E7%94%A8.html</id>
    <published>2021-07-02T10:16:14.000Z</published>
    <updated>2021-07-04T13:29:55.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="03-翻转二叉树—递归和迭代的应用"><a href="#03-翻转二叉树—递归和迭代的应用" class="headerlink" title="03_翻转二叉树—递归和迭代的应用"></a>03_翻转二叉树—递归和迭代的应用</h2><ul><li>226.翻转二叉树</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702181715.PNG" alt=""></p><p>这道题目是非常经典的题目，也是比较简单的题目（至少一看就会）。</p><p>但正是因为这道题太简单，一看就会，一些同学都没有抓住其本质，稀里糊涂的就把这道题目过了。</p><p>如果做过这道题的同学也建议认真看完，相信一定有所收获！</p><h3 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h3><p>我们之前介绍的都是各种方式遍历二叉树，这次要翻转了，感觉还是有点懵逼。</p><p>这得怎么翻转呢？</p><p>如果要从整个树来看，翻转还真的挺复杂，整个树以中间线进行翻转，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702181727.png" alt=""></p><p>可以发现想要翻转它，其实就把每一个节点的左右孩子交换一下（注意孩子下面的节点是一起交换的）就可以了。</p><p>关键在于遍历顺序，前中后序应该选哪一种遍历顺序？（一些同学这道题都过了，但是不知道自己用的是什么顺序）</p><p>遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。</p><p><strong>「注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果」</strong></p><p><strong>「这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不行，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了」</strong></p><p>那么层序遍历可以不可以呢？<strong>「依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！」</strong></p><h3 id="二、递归法"><a href="#二、递归法" class="headerlink" title="二、递归法"></a>二、递归法</h3><p>我们下文以前序遍历为例，通过动画来看一下翻转的过程:</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702181742.gif" alt=""></p><p>我们来看一下递归三部曲：</p><p>1.确定递归函数的参数和返回值</p><p>参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。</p><p>返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为<code>TreeNode</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br></pre></td></tr></table></figure><p>2.确定终止条件:</p><p>当前节点为空的时候，就返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>3.确定单层递归的逻辑</p><p>因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root.left, root.right = root.right, root.left</span><br><span class="line"></span><br><span class="line"><span class="comment"># tmp = root.left</span></span><br><span class="line"><span class="comment"># root.left = root.right</span></span><br><span class="line"><span class="comment"># root.right = tmp</span></span><br><span class="line"></span><br><span class="line">invertTree(root.left)</span><br><span class="line">invertTree(root.right)</span><br></pre></td></tr></table></figure><p>基于这递归三步法，代码基本写完，代码如下（前序）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前序遍历</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line"></span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="三、迭代法"><a href="#三、迭代法" class="headerlink" title="三、迭代法"></a>三、迭代法</h3><h4 id="1-深度优先遍历"><a href="#1-深度优先遍历" class="headerlink" title="1.深度优先遍历"></a>1.深度优先遍历</h4><p>可以很轻松的切出如下迭代法（前序）的代码：只需稍作修改即可。将添加值的操作改为变化左右</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">            <span class="comment">### 若不为空，将node的左右孩子调换。</span></span><br><span class="line">                node.left, node.right = node.right, node.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 若为空，结束本次循环（他没有左右孩子）</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将右左孩子分别添加进stack中，因为是栈,所以先处理的是左</span></span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="2-广度优先遍历"><a href="#2-广度优先遍历" class="headerlink" title="2.广度优先遍历"></a>2.广度优先遍历</h4><p>广度优先遍历也是比较容易的：只需要添加一行——处理队列的节点的代码改变即可。直接上代码！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line"><span class="comment">## 只需要添加这一行就行了！</span></span><br><span class="line">            cur_node.left, cur_node.right = cur_node.right, cur_node.left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                queue.append(cur_node.left)</span><br><span class="line">            <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                queue.append(cur_node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3></blockquote><p>针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。</p><p><strong>「二叉树解题的大忌就是自己稀里糊涂的过了（因为这道题相对简单），但是也不知道自己是怎么遍历的。」</strong></p><p>这也是造成了二叉树的题目“一看就会，一写就废”的原因。</p><p><strong>针对翻转二叉树，我给出了一种递归，三种迭代（一种深度优先遍历，一种层序遍历）的写法，都是之前我们讲过的写法，融汇贯通一下而已。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;03-翻转二叉树—递归和迭代的应用&quot;&gt;&lt;a href=&quot;#03-翻转二叉树—递归和迭代的应用&quot; class=&quot;headerlink&quot; title=&quot;03_翻转二叉树—递归和迭代的应用&quot;&gt;&lt;/a&gt;03_翻转二叉树—递归和迭代的应用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;226.</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>00-二叉树的层序遍历2</title>
    <link href="https://xxren8218.github.io/20210702/00-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%862.html"/>
    <id>https://xxren8218.github.io/20210702/00-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%862.html</id>
    <published>2021-07-02T10:13:20.000Z</published>
    <updated>2021-07-04T13:30:05.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二-N-叉树的层序遍历2"><a href="#二-N-叉树的层序遍历2" class="headerlink" title="二(N)叉树的层序遍历2"></a>二(N)叉树的层序遍历2</h2><p>上文学习了二叉树的层序遍历，还有四道题没有做完，今天就给做了吧！</p><ul><li>637.⼆叉树的层平均值</li><li>515.在每个树行中找最⼤值</li><li>116.填充每个节点的下⼀个右侧节点指针</li><li>117.填充每个节点的下⼀个右侧节点指针II  </li></ul><blockquote><h3 id="一、二叉树的层平均值"><a href="#一、二叉树的层平均值" class="headerlink" title="一、二叉树的层平均值"></a>一、二叉树的层平均值</h3></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702181409.PNG" alt=""></p><p>思路也是比较简单的，只需要在原来的基础上修改一行即可。对tmp列表的元素求和，然后除以列表的长度。——<strong>注意</strong>，python的两个整数相除仍是整数，需要把一个转化为浮点型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[float]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                tmp.append(cur_node.val)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line">     <span class="comment"># 仅仅修改这一行即可。</span></span><br><span class="line">            res.append(<span class="built_in">sum</span>(tmp)/<span class="built_in">float</span>(<span class="built_in">len</span>(tmp)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><h3 id="二、在每个树行中找最⼤值"><a href="#二、在每个树行中找最⼤值" class="headerlink" title="二、在每个树行中找最⼤值"></a>二、在每个树行中找最⼤值</h3></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702181431.PNG" alt=""></p><p>这个思路不需多说吧，也是改变那一行的事情！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestValues</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                tmp.append(cur_node.val)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line"><span class="comment"># 仅需修改这一行</span></span><br><span class="line">            res.append(<span class="built_in">max</span>(tmp))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><h3 id="三、填充每个节点的下⼀个右侧节点指针"><a href="#三、填充每个节点的下⼀个右侧节点指针" class="headerlink" title="三、填充每个节点的下⼀个右侧节点指针"></a>三、填充每个节点的下⼀个右侧节点指针</h3></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702181443.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702181454.PNG" alt=""></p><p>看着这道题像层序遍历，那么我们就先写下我们的框架，然后看怎么处理！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val=0, left=None, right=None, next=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line"></span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>这道题目的关键是返回Node，并不是list，所以，我写了上面的框架。</p><p>在框架上每层处理节点之间的“<code>连线</code>”即可。题目的难点在于:</p><ul><li>如何知道下一个节点是啥？很容易那就是队列的第一个元素。</li><li>如何找到这层的最后一个节点。可以在进入for遍历之后取一下本层的长度n。这样“<code>连线</code>”时，n-1这个节点就是本层的最后了，不需要“连线”了。这样就解决了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val=0, left=None, right=None, next=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录本层的长度</span></span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):       </span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 判断是否是本层的最后一个节点</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; n - <span class="number">1</span>:</span><br><span class="line">                    cur_node.<span class="built_in">next</span> = queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><blockquote><h3 id="四、填充每个节点的下⼀个右侧节点指针II"><a href="#四、填充每个节点的下⼀个右侧节点指针II" class="headerlink" title="四、填充每个节点的下⼀个右侧节点指针II"></a>四、填充每个节点的下⼀个右侧节点指针II</h3></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702181512.PNG" alt=""></p><p>代码思路完全一样，不过一个是完全二叉树、一个不是而已。上题写的代码具有鲁棒性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val=0, left=None, right=None, next=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> i &lt; n - <span class="number">1</span>:</span><br><span class="line">                    cur_node.<span class="built_in">next</span> = queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><blockquote><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3></blockquote><p>至此层序遍历的题目做完了。归根结底就两个框架。</p><ul><li><p>返回Node</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line"></span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></li><li><p>返回列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        queue = [root]</span><br><span class="line">res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line"></span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">tmp.append(cur_node.val)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line">            </span><br><span class="line">            res.append(tmp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二-N-叉树的层序遍历2&quot;&gt;&lt;a href=&quot;#二-N-叉树的层序遍历2&quot; class=&quot;headerlink&quot; title=&quot;二(N)叉树的层序遍历2&quot;&gt;&lt;/a&gt;二(N)叉树的层序遍历2&lt;/h2&gt;&lt;p&gt;上文学习了二叉树的层序遍历，还有四道题没有做完，今天就给做了</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>27-Spark_core概述</title>
    <link href="https://xxren8218.github.io/20210702/27-Spark-core%E6%A6%82%E8%BF%B0.html"/>
    <id>https://xxren8218.github.io/20210702/27-Spark-core%E6%A6%82%E8%BF%B0.html</id>
    <published>2021-07-01T17:32:25.000Z</published>
    <updated>2021-07-01T17:36:09.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-spark-core概述"><a href="#1-spark-core概述" class="headerlink" title="1. spark-core概述"></a>1. spark-core概述</h2><p>掌握目标：</p><ul><li>知道RDD的概念</li><li>独立实现RDD的创建</li></ul><h3 id="1-1-什么是RDD"><a href="#1-1-什么是RDD" class="headerlink" title="1.1 什么是RDD"></a>1.1 什么是RDD</h3><ul><li>RDD（Resilient Distributed Dataset）叫做<strong>弹性分布式数据集</strong>，是Spark中最基本的数据抽象，它代表一个<strong>不可变、可分区</strong>、里面的元素<strong>可并行</strong>计算的集合.<ul><li>Dataset:一个数据集，简单的理解为集合，用于存放数据的</li><li>Distributed：它的数据是分布式存储，并且可以做分布式的计算</li><li>Resilient：弹性的<ul><li>它表示的是数据可以保存在磁盘，也可以保存在内存中——弹性的一种表现</li><li>数据分布式也是弹性的</li><li>弹性:并不是指他可以动态扩展，而是容错机制。<ul><li>RDD会在多个节点上存储，就和hdfs的分布式道理是一样的。<strong>hdfs</strong>文件被<strong>切分为多个block存储在各个节点上</strong>，而<strong>RDD</strong>是被切分为多个<strong>partition</strong>。<strong>不同的partition</strong>可能在<strong>不同的节点</strong>上</li><li>spark读取hdfs的场景下，spark把hdfs的block读到内存就会抽象为spark的partition。</li><li>spark计算结束，一般会把数据做持久化到hive，hbase，hdfs等等。我们就拿hdfs举例，将RDD持久化到hdfs上，RDD的每个partition就会存成一个文件，如果文件小于128M，就可以理解为一个partition对应hdfs的一个block。反之，如果大于128M，就会被且分为多个block，这样，一个partition就会对应多个block。</li></ul></li></ul></li><li>不可变</li><li>可分区</li><li>并行计算</li></ul></li></ul><h3 id="1-2-RDD的创建"><a href="#1-2-RDD的创建" class="headerlink" title="1.2 RDD的创建"></a>1.2 RDD的创建</h3><ul><li><p>第一步 创建sparkContext</p><ul><li>SparkContext, Spark程序的入口. SparkContext代表了和Spark集群的链接, 在Spark集群中通过SparkContext来创建RDD</li><li>SparkConf  创建SparkContext的时候需要一个SparkConf， 用来传递Spark应用的基本信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf = SparkConf().setAppName(appName).setMaster(master)</span><br><span class="line">sc = SparkContext(conf=conf)</span><br></pre></td></tr></table></figure></li><li><p>创建RDD</p><ul><li>进入pyspark环境</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop000 ~]$ pyspark</span><br><span class="line">Python 3.5.0 (default, Nov 13 2018, 15:43:53)</span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">19/03/08 12:19:55 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</span><br><span class="line">Welcome to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  &#x27;_/</span><br><span class="line">   /__ / .__/\_,_/_/ /_/\_\   version 2.3.0</span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line">Using Python version 3.5.0 (default, Nov 13 2018 15:43:53)</span><br><span class="line">SparkSession available as &#x27;spark&#x27;.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sc</span></span><br><span class="line">&lt;SparkContext master=local[*] appName=PySparkShell&gt;</span><br></pre></td></tr></table></figure><ul><li>在spark shell中 已经为我们创建好了 SparkContext 通过sc直接使用</li><li>可以在spark UI中看到当前的Spark作业 在浏览器访问当前centos的4040端口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702013325.png" alt=""></p><ul><li><p>Parallelized Collections方式创建RDD</p><ul><li>调用<code>SparkContext</code>的 <code>parallelize</code> 方法并且传入已有的可迭代对象或者集合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">distData = sc.parallelize(data)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; data = [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; distData = sc.parallelize(data)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; data</span></span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; distData</span></span><br><span class="line">ParallelCollectionRDD[0] at parallelize at PythonRDD.scala:175</span><br></pre></td></tr></table></figure><ul><li>在spark ui中观察执行情况</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702013346.png" alt=""></p><ul><li>在通过<code>parallelize</code>方法创建RDD 的时候可以指定分区数量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; distData = sc.parallelize(data,5) <span class="comment"># 5表示数据分区的数量，最终一个分区对应一个task</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; distData.reduce(lambda a, b: a + b)</span></span><br><span class="line">15</span><br></pre></td></tr></table></figure><ul><li>在spark ui中观察执行情况</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702013411.png" alt=""></p><ul><li>Spark将为群集的每个分区（partition）运行一个任务（task）。 通常，可以根据CPU核心数量指定分区数量（每个CPU有2-4个分区）如未指定分区数量，Spark会自动设置分区数。</li></ul></li><li><p>通过外部数据创建RDD</p><ul><li>PySpark可以<strong>从Hadoop支持的任何存储源创建RDD</strong>，包括本地文件系统，HDFS，Cassandra，HBase，Amazon S3等</li><li>支持整个目录、多文件、通配符</li><li>支持压缩文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd1 = sc.textFile(<span class="string">&#x27;file:///home/hadoop/tmp/word.txt&#x27;</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd1.collect()</span></span><br><span class="line">[&#x27;foo foo quux labs foo bar quux abc bar see you by test welcome test&#x27;, &#x27;abc labs foo me python hadoop ab ac bc bec python&#x27;]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>加载了数据以后接下来就是计算了。</p></li></ul><h2 id="2-spark-core-RDD常用算子练习"><a href="#2-spark-core-RDD常用算子练习" class="headerlink" title="2. spark-core RDD常用算子练习"></a>2. spark-core RDD常用算子练习</h2><p>掌握目标</p><ul><li>说出RDD的三类算子</li><li>掌握transformation和action算子的基本使用</li></ul><h3 id="2-1-RDD-常用操作"><a href="#2-1-RDD-常用操作" class="headerlink" title="2.1 RDD 常用操作"></a>2.1 RDD 常用操作</h3><ul><li><p>RDD 支持两种类型的操作：</p><ul><li>transformation<ul><li>从一个已经存在的数据集创建一个新的数据集<ul><li>rdd a ——-&gt;transformation ——&gt; rdd b</li></ul></li><li>比如， map就是一个transformation 操作，把数据集中的每一个元素传给一个函数并<strong>返回一个新的RDD</strong>，代表transformation操作的结果 </li></ul></li><li>action<ul><li>获取对数据进行运算操作之后的结果</li><li>比如， reduce 就是一个action操作，使用某个函数聚合RDD所有元素的操作，并<strong>返回最终计算结果</strong></li></ul></li></ul></li><li><p>所有的transformation操作都是惰性的（lazy）</p><ul><li>不会立即计算结果</li><li>只记下应用于数据集的transformation操作</li><li>只有调用action一类的操作之后才会计算所有transformation</li><li>这种设计使Spark运行效率更高</li><li>例如map reduce 操作，map创建的数据集将用于reduce，map阶段的结果不会返回，仅会返回reduce结果。</li></ul></li><li><em>persist</em> 操作<ul><li><em>persist</em>操作用于将数据缓存 可以缓存在内存中 也可以缓存到磁盘上， 也可以复制到磁盘的其它节点上</li></ul></li></ul><h3 id="2-2-RDD-Transformation算子"><a href="#2-2-RDD-Transformation算子" class="headerlink" title="2.2 RDD Transformation算子"></a>2.2 RDD Transformation算子</h3><ul><li><p>map: map(func)——<strong>进来几个元素，出去几个元素。</strong></p><ul><li>将func函数作用到数据集的每一个元素上，生成一个新的RDD返回</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd1 = sc.parallelize([1,2,3,4,5,6,7,8,9],3)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd2 = rdd1.map(lambda x: x+1)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd2.collect() <span class="comment"># collect就属于 action。若不调用拿不到结果。</span></span></span><br><span class="line">[2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd1 = sc.parallelize([1,2,3,4,5,6,7,8,9],3)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; def add(x):</span></span><br><span class="line">...     return x+1</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd2 = rdd1.map(add)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd2.collect()</span></span><br><span class="line">[2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure></li></ul><p>  <img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702013432.png" alt=""></p><ul><li><p>filter</p><ul><li>filter(func) 选出所有func返回值为true的元素，生成一个新的RDD返回</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd1 = sc.parallelize([1,2,3,4,5,6,7,8,9],3)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd2 = rdd1.map(lambda x:x*2)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd3 = rdd2.filter(lambda x:x&gt;4)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd3.collect()</span></span><br><span class="line">[6, 8, 10, 12, 14, 16, 18]</span><br></pre></td></tr></table></figure></li><li><p>flatmap</p><ul><li>flatMap会先执行map的操作，再将所有对象合并为一个对象</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd1 = sc.parallelize([<span class="string">&quot;a b c&quot;</span>,<span class="string">&quot;d e f&quot;</span>,<span class="string">&quot;h i j&quot;</span>])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd2 = rdd1.flatMap(lambda x:x.split(<span class="string">&quot; &quot;</span>))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd2.collect()</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;]</span><br></pre></td></tr></table></figure><ul><li>flatMap和map的区别：flatMap在map的基础上将结果合并到一个list中</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd1 = sc.parallelize([<span class="string">&quot;a b c&quot;</span>,<span class="string">&quot;d e f&quot;</span>,<span class="string">&quot;h i j&quot;</span>])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd2 = rdd1.map(lambda x:x.split(<span class="string">&quot; &quot;</span>))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd2.collect()</span></span><br><span class="line">[[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;], [&#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;]]</span><br></pre></td></tr></table></figure></li><li><p>union</p><ul><li>对两个RDD求并集</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd1 = sc.parallelize([(<span class="string">&quot;a&quot;</span>,1),(<span class="string">&quot;b&quot;</span>,2)])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd2 = sc.parallelize([(<span class="string">&quot;c&quot;</span>,1),(<span class="string">&quot;b&quot;</span>,3)])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd3 = rdd1.union(rdd2)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd3.collect()</span></span><br><span class="line">[(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 1), (&#x27;b&#x27;, 3)]</span><br></pre></td></tr></table></figure></li><li><p>intersection</p><ul><li>对两个RDD求交集</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd1 = sc.parallelize([(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd2 = sc.parallelize([(<span class="string">&quot;c&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd3 = rdd1.union(rdd2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd4 = rdd3.intersection(rdd2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd4.collect()</span><br><span class="line">[(<span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure></li><li><p>groupByKey</p><ul><li>以元组中的第0个元素作为key，进行分组，返回一个新的RDD</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd1 = sc.parallelize([(<span class="string">&quot;a&quot;</span>,1),(<span class="string">&quot;b&quot;</span>,2)])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd2 = sc.parallelize([(<span class="string">&quot;c&quot;</span>,1),(<span class="string">&quot;b&quot;</span>,3)])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd3 = rdd1.union(rdd2)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd4 = rdd3.groupByKey()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd4.collect()</span></span><br><span class="line">[(&#x27;a&#x27;, &lt;pyspark.resultiterable.ResultIterable object at 0x7fba6a5e5898&gt;), (&#x27;c&#x27;, &lt;pyspark.resultiterable.ResultIterable object at 0x7fba6a5e5518&gt;), (&#x27;b&#x27;, &lt;pyspark.resultiterable.ResultIterable object at 0x7fba6a5e5f28&gt;)]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>groupByKey之后的结果中 value是一个Iterable</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result[<span class="number">2</span>]</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, &lt;pyspark.resultiterable.ResultIterable <span class="built_in">object</span> at <span class="number">0x7fba6c18e518</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">&lt;pyspark.resultiterable.ResultIterable <span class="built_in">object</span> at <span class="number">0x7fba6c18e518</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(result[<span class="number">2</span>][<span class="number">1</span>])</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><ul><li><p>reduceByKey</p><ul><li>将key相同的键值对，按照Function进行计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd = sc.parallelize([(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">1</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd.reduceByKey(<span class="keyword">lambda</span> x,y:x+y).collect()</span><br><span class="line">[(<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure></li><li><p>sortByKey</p><ul><li><p><code>sortByKey</code>(<em>ascending=True</em>, <em>numPartitions=None</em>, <em>keyfunc=<function RDD.<lambda>&gt;</em>)</p><p>Sorts this RDD, which is assumed to consist of (key, value) pairs.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmp = [(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;1&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;2&#x27;</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc.parallelize(tmp).sortByKey().first()</span><br><span class="line">(<span class="string">&#x27;1&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc.parallelize(tmp).sortByKey(<span class="literal">True</span>, <span class="number">1</span>).collect()</span><br><span class="line">[(<span class="string">&#x27;1&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;2&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc.parallelize(tmp).sortByKey(<span class="literal">True</span>, <span class="number">2</span>).collect()</span><br><span class="line">[(<span class="string">&#x27;1&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;2&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmp2 = [(<span class="string">&#x27;Mary&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;had&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;little&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;lamb&#x27;</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmp2.extend([(<span class="string">&#x27;whose&#x27;</span>, <span class="number">6</span>), (<span class="string">&#x27;fleece&#x27;</span>, <span class="number">7</span>), (<span class="string">&#x27;was&#x27;</span>, <span class="number">8</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="number">9</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc.parallelize(tmp2).sortByKey(<span class="literal">True</span>, <span class="number">3</span>, keyfunc=<span class="keyword">lambda</span> k: k.lower()).collect()</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;fleece&#x27;</span>, <span class="number">7</span>), (<span class="string">&#x27;had&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;lamb&#x27;</span>, <span class="number">5</span>),...(<span class="string">&#x27;white&#x27;</span>, <span class="number">9</span>), (<span class="string">&#x27;whose&#x27;</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-3-RDD-Action算子"><a href="#2-3-RDD-Action算子" class="headerlink" title="2.3 RDD Action算子"></a>2.3 RDD Action算子</h3><ul><li><p>collect——大数据慎用！</p><ul><li>返回一个list，list中包含 RDD中的所有元素</li><li>只有当数据量较小的时候使用Collect 因为所有的结果都会加载到内存中</li></ul></li><li><p>reduce</p><ul><li><strong>reduce</strong>将<strong>RDD</strong>中元素两两传递给输入函数，同时产生一个新的值，新产生的值与RDD中下一个元素再被传递给输入函数直到最后只有一个值为止。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd1 = sc.parallelize([1,2,3,4,5])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rdd1.reduce(lambda x,y : x+y)</span></span><br><span class="line">15</span><br></pre></td></tr></table></figure></li><li><p>first</p><ul><li>返回RDD的第一个元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc.parallelize([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).first()</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>take</p><ul><li>返回RDD的前N个元素</li><li><code>take</code>(<em>num</em>)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sc.parallelize([2, 3, 4, 5, 6]).take(2)</span></span><br><span class="line">[2, 3]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sc.parallelize([2, 3, 4, 5, 6]).take(10)</span></span><br><span class="line">[2, 3, 4, 5, 6]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sc.parallelize(range(100), 100).filter(lambda x: x &gt; 90).take(3)</span></span><br><span class="line">[91, 92, 93]</span><br></pre></td></tr></table></figure></li><li><p>count</p><p>返回RDD中元素的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sc.parallelize([2, 3, 4]).count()</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-Spark-RDD两类算子执行示意"><a href="#2-4-Spark-RDD两类算子执行示意" class="headerlink" title="2.4 Spark RDD两类算子执行示意"></a>2.4 Spark RDD两类算子执行示意</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702013508.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210702013522.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-spark-core概述&quot;&gt;&lt;a href=&quot;#1-spark-core概述&quot; class=&quot;headerlink&quot; title=&quot;1. spark-core概述&quot;&gt;&lt;/a&gt;1. spark-core概述&lt;/h2&gt;&lt;p&gt;掌握目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;知</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>00-二(N)叉树的层序遍历——训练</title>
    <link href="https://xxren8218.github.io/20210701/00-%E4%BA%8C-N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83.html"/>
    <id>https://xxren8218.github.io/20210701/00-%E4%BA%8C-N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83.html</id>
    <published>2021-07-01T11:02:04.000Z</published>
    <updated>2021-07-01T11:04:38.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二-N-叉树的层序遍历——训练"><a href="#二-N-叉树的层序遍历——训练" class="headerlink" title="二(N)叉树的层序遍历——训练"></a>二(N)叉树的层序遍历——训练</h2><p>学会⼆叉树的层序遍历，可以⼀⼝⽓撸完leetcode上⼋道题⽬：</p><ul><li>102.⼆叉树的层序遍历</li><li>429.N叉树的前序遍历</li><li>107.⼆叉树的层次遍历II</li><li>199.⼆叉树的右视图</li><li>637.⼆叉树的层平均值</li><li>515.在每个树⾏中找最⼤值</li><li>116.填充每个节点的下⼀个右侧节点指针</li><li>117.填充每个节点的下⼀个右侧节点指针II  </li></ul><p><code>这次先做四道题吧！，找找感觉！</code></p><p>给你⼀个⼆叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。  </p><p><code>层序遍历</code>是利用<code>队列</code>实现的：</p><p>如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701190308.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701190321.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701190334.png" alt=""></p><p>可以看出来，队列实现层序遍历是这样的顺序，现将节点出队-&gt;然后取值-&gt;将其左右孩子分别入队-&gt;出队-&gt;取值-&gt;将其左右孩子入队。。。一直到队列为空，此时输出结果。符合这样的逻辑，可以写出这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadth_travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;广度遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># print(cur_node.elem, end=&quot; &quot;)</span></span><br><span class="line">            res.append(cur_node.val)</span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild:</span><br><span class="line">                queue.append(cur_node.rchild)</span><br></pre></td></tr></table></figure><p>有了这样的框架我们就可以做题了。</p><blockquote><h3 id="一、二叉树的层序遍历"><a href="#一、二叉树的层序遍历" class="headerlink" title="一、二叉树的层序遍历"></a>一、二叉树的层序遍历</h3></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701190241.PNG" alt=""></p><p>可以看出这个与我们框架不同的地方是，每一层都用一个列表包裹，那么我们可以使用一个循环来遍历当前层的节点，并在每层使用一个临时列表存储值不就解决了吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="comment"># 用其来处理每一层的节点</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                tmp.append(cur_node.val)</span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><h3 id="二、N叉树的层序遍历"><a href="#二、N叉树的层序遍历" class="headerlink" title="二、N叉树的层序遍历"></a>二、N叉树的层序遍历</h3></blockquote><p>会了二叉树相信你N叉树的层序遍历也一定会了。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701190351.PNG" alt=""></p><p>分析一下，我们把之前的框架稍作修改，之前不是只有左右孩子嘛！现在有多个孩子，其实比较简单了，当前出队的节点添加孩子时，将所有的孩子都入队即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                </span><br><span class="line">                tmp.append(cur_node.val)        </span><br><span class="line">                <span class="comment"># 如果当前弹出的节点有孩子，将所有的孩子入队。</span></span><br><span class="line">                <span class="keyword">if</span> cur_node.children:</span><br><span class="line">                    queue.extend(cur_node.children[::<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">            res.append(tmp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><h3 id="三、⼆叉树的层次遍历II"><a href="#三、⼆叉树的层次遍历II" class="headerlink" title="三、⼆叉树的层次遍历II"></a>三、⼆叉树的层次遍历II</h3></blockquote><p>题目如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701190408.PNG" alt=""></p><p>这道题很简单，看输出结果不就是之前层序结果的反转嘛！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="comment"># 用其来处理每一层的节点</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                tmp.append(cur_node.val)</span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><h3 id="四、二叉树的右视图"><a href="#四、二叉树的右视图" class="headerlink" title="四、二叉树的右视图"></a>四、二叉树的右视图</h3></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701190422.PNG" alt=""></p><p>这道题也是比较简单的：上面不是有了包裹式的层序遍历嘛，里面有个临时列表不知道还记得不？添加时将临时列表的最后一个加入结果列表即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                tmp.append(cur_node.val)</span><br><span class="line">                <span class="keyword">if</span> cur_node.left:</span><br><span class="line">                    queue.append(cur_node.left)</span><br><span class="line">                <span class="keyword">if</span> cur_node.right:</span><br><span class="line">                    queue.append(cur_node.right)</span><br><span class="line"></span><br><span class="line">            res.append(tmp[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3></blockquote><p>对于层序遍历、理解其队列的执行过程很重要！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二-N-叉树的层序遍历——训练&quot;&gt;&lt;a href=&quot;#二-N-叉树的层序遍历——训练&quot; class=&quot;headerlink&quot; title=&quot;二(N)叉树的层序遍历——训练&quot;&gt;&lt;/a&gt;二(N)叉树的层序遍历——训练&lt;/h2&gt;&lt;p&gt;学会⼆叉树的层序遍历，可以⼀⼝⽓撸完</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>26-HBase概述</title>
    <link href="https://xxren8218.github.io/20210701/26-HBase%E6%A6%82%E8%BF%B0.html"/>
    <id>https://xxren8218.github.io/20210701/26-HBase%E6%A6%82%E8%BF%B0.html</id>
    <published>2021-06-30T16:54:44.000Z</published>
    <updated>2021-06-30T17:01:15.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HBase简介与环境部署"><a href="#HBase简介与环境部署" class="headerlink" title="HBase简介与环境部署"></a>HBase简介与环境部署</h2><h3 id="1-HBase简介-amp-在Hadoop生态中的地位"><a href="#1-HBase简介-amp-在Hadoop生态中的地位" class="headerlink" title="1. HBase简介&amp;在Hadoop生态中的地位"></a>1. HBase简介&amp;在Hadoop生态中的地位</h3><h4 id="1-1-什么是HBase"><a href="#1-1-什么是HBase" class="headerlink" title="1.1. 什么是HBase"></a>1.1. 什么是HBase</h4><ul><li>HBase是一个<strong>分布式</strong>的、<strong>面向列</strong>的<strong>开源数据库</strong></li><li>HBase是Google BigTable的开源实现</li><li>HBase不同于一般的关系数据库, 适合<strong>非结构化数据存储</strong></li></ul><h4 id="1-2-BigTable"><a href="#1-2-BigTable" class="headerlink" title="1.2 BigTable"></a>1.2 BigTable</h4><ul><li>BigTable是Google设计的分布式数据存储系统，用来处理海量的数据的一种非关系型的数据库。<ul><li>适合大规模海量数据，PB级数据；</li><li>分布式、并发数据处理，效率极高；</li><li>易于扩展，支持动态伸缩</li><li>适用于廉价设备；</li><li>不适用于传统关系型数据的存储；</li></ul></li></ul><h4 id="1-3-什么是非结构化数据存储"><a href="#1-3-什么是非结构化数据存储" class="headerlink" title="1.3 什么是非结构化数据存储"></a>1.3 什么是非结构化数据存储</h4><ul><li>结构化数据<ul><li>适合用二维表来展示的数据</li></ul></li><li>非结构化数据<ul><li>非结构化数据是数据结构不规则或不完整<ul><li>如名人词条：科学家：成果；演员：电影；其中如演员有50个字段，但是只有5个与科学家是公用的。如年龄、性别等。导致二维表出现很多数据稀疏。</li><li>或者处理业务时数据一直变，删一行，当达到100000行时，此时处理时间很长，需要把数据库锁起来，这样对线上的业务就有影响了。</li></ul></li><li>没有预定义的数据模型<ul><li>开始没想好字段是什么，随着业务逻辑增加。</li></ul></li><li>不方便用数据库二维逻辑表来表现<ul><li>办公文档、文本、图片、XML, HTML、各类报表、图像和音频/视频信息等</li></ul></li></ul></li></ul><h4 id="1-4-HBase在Hadoop生态中的地位"><a href="#1-4-HBase在Hadoop生态中的地位" class="headerlink" title="1.4 HBase在Hadoop生态中的地位"></a>1.4 HBase在Hadoop生态中的地位</h4><ul><li><p>HBase是Apache基金会顶级项目</p></li><li><p>HBase基于HDFS进行数据存储</p></li><li><p>HBase可以存储超大数据并适合用来进行大数据的实时查询</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005654.png" alt=""></p></li></ul><h4 id="1-5-HBase与HDFS"><a href="#1-5-HBase与HDFS" class="headerlink" title="1.5 HBase与HDFS"></a>1.5 HBase与HDFS</h4><ul><li>HBase建立在Hadoop文件系统上, 利用了HDFS的容错能力</li><li>HBase提供对数据的<strong>随机实时读/写访问功能</strong></li><li>HBase<strong>内部使用哈希表, 并存储索引</strong>, 可以<strong>快速查找HDFS中数据</strong></li></ul><h4 id="1-6-HBase使用场景"><a href="#1-6-HBase使用场景" class="headerlink" title="1.6 HBase使用场景"></a>1.6 HBase使用场景</h4><ul><li>瞬间写入量很大</li><li>大量数据需要长期保存, 且数量会持续增长</li><li>HBase不适合有join, 多级索引, 表关系复杂的数据模型</li></ul><h3 id="2-HBase的数据模型"><a href="#2-HBase的数据模型" class="headerlink" title="2 HBase的数据模型"></a>2 HBase的数据模型</h3><h4 id="2-1-ACID定义"><a href="#2-1-ACID定义" class="headerlink" title="2.1 ACID定义"></a>2.1 ACID定义</h4><ul><li>指数据库事务正确执行的四个基本要素的缩写<ul><li>原子性 A <ul><li><strong>要么都完成，要么都失败，事务过程不能分割。</strong></li><li>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li></ul></li><li>一致性 C<ul><li><strong>状态改变，无论并发的事务有多少，必须保持同一个状态。</strong></li><li>一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91"><strong>并发</strong></a>事务有多少。</li></ul></li><li>隔离性 I<ul><li><strong>两个事务同时运行必须是一个事务运行完了，再运行另一个事务。不能同时执行</strong>。</li><li>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</li></ul></li><li>持久性 D<ul><li><strong>事务一旦完成不会回滚</strong></li><li>在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li></ul></li><li>HBase<ul><li>不同于Hive，Hive只是涉及到查询操作，并不涉及事务的概念。但是HBase就不是了。</li><li>HBase 支持特定场景下的 ACID，即对<strong>行级别的事务</strong> 操作保证完全的 ACID</li></ul></li></ul></li></ul><h4 id="2-2-cap定理"><a href="#2-2-cap定理" class="headerlink" title="2.2 cap定理"></a>2.2 cap定理</h4><ul><li><p>分布式系统的最大难点，就是<strong>各个节点的状态如何同步</strong>。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。</p><ul><li><p><strong>一致性</strong>(所有节点在同一时间具有相同的数据)</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005726.png" alt=""></p></li><li><p><strong>可用性</strong>(保证每个请求不管成功或失败都有响应,但不保证获取的数据的正确性)</p></li><li><p><strong>分区容错性</strong>(系统中任意信息的丢失或失败不会影响系统的运行,系统如果不能在某个时限内达成数据一致性,就必须在上面两个操作之间做出选择)——<strong>任何时候都要保证的！</strong>其余两个就要做取舍了。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005748.jpg" alt=""></p><p><strong>hbase是CAP中的CP系统,即hbase是强一致性的</strong>——用牺牲可用性的代价。</p></li></ul><h4 id="2-3-HBase表结构"><a href="#2-3-HBase表结构" class="headerlink" title="2.3 HBase表结构"></a>2.3 HBase表结构</h4><ul><li><code>NameSpace</code>: 关系型数据库的”数据库”(database)</li><li>表(table)：用于存储管理数据，具有稀疏的、面向列的特点。HBase中的每一张表，就是所谓的大表(Bigtable)，可以有上亿行，上百万列。对于为值为空的列，并不占用存储空间，因此表可以设计的非常稀疏。</li><li>行(Row)：在表里面,每一行代表着一个数据对象,每一行都是以一个行键(Row Key)来进行唯一标识的, 行键并没有什么特定的数据类型, 以二进制的字节来存储</li><li>列(Column): HBase的列由 Column family 和 Column qualifier 组成, 由冒号: 进行行间隔, 如 family: qualifier</li><li>行键(RowKey)：类似于MySQL中的主键，HBase根据行键来快速检索数据，一个行键对应一条记录。与MySQL主键不同的是，HBase的行键是天然固有的，每一行数据都存在行键。</li><li>列族(ColumnFamily)：是列的集合。列族在表定义时需要指定，而列在插入数据时动态指定。列中的数据都是以二进制形式存在，没有数据类型。在物理存储结构上，<strong>每个表中的每个列族单独以一个文件存储</strong>。一个表可以有多个列簇。</li><li>列修饰符(<em>Column</em> <em>Qualifier</em>) : 列族中的数据通过列标识来进行映射, 可以理解为一个键值对(key-value), 列修饰符(<em>Column</em> <em>Qualifier</em>) 就是key 对应关系型数据库的列</li><li>时间戳(TimeStamp)：是列的一个属性，是一个64位整数。由行键和列确定的单元格，可以存储多个数据，每个数据含有时间戳属性，数据具有版本特性。可根据版本(VERSIONS)或时间戳来指定查询历史版本数据，如果都不指定，则默认返回最新版本的数据。</li><li>区域(Region)：HBase自动把表水平划分成的多个区域，划分的区域随着数据的增大而增多。</li><li>HBase 支持特定场景下的 ACID，即对行级别的 操作保证完全的 ACID</li></ul><h4 id="2-4-面向列的数据库"><a href="#2-4-面向列的数据库" class="headerlink" title="2.4 面向列的数据库"></a>2.4 面向列的数据库</h4><p><strong>HBase 与 传统关系数据库的区别</strong></p><table style="overflow: scroll;">  <tr>    <th></th>    <th>HBase</th>    <th>关系型数据库</th>  </tr>  <tr>    <td> 数据库大小 </td>    <td> PB级别  </td>    <td>GB TB</td>  </tr>  <tr>    <td> 数据类型 </td>    <td> Bytes </td>    <td> 丰富的数据类型 </td>  </tr>    <tr>    <td> 事务支持 </td>    <td> ACID只支持单个Row级别 </td>    <td> 全面的ACID支持, 对Row和表</td>  </tr>  <tr>    <td> 索引 </td>    <td> 只支持Row-key </td>    <td> 支持 </td>  </tr>    <tr>    <td> 吞吐量 </td>    <td> 百万写入/秒 </td>    <td> 数千写入/秒</td>  </tr></table><ul><li>关系型数据库中数据示例</li></ul><table style="overflow: scroll;">  <tr>    <th>ID</th>    <th>FILE NAME</th>    <th>FILE PATH</th>    <th>FILE TYPE</th>    <th>FILE SIZE</th>    <th>CREATOR</th>  </tr>  <tr>    <td> 1 </td>    <td> file1.txt  </td>    <td>/home</td>    <td> txt </td>    <td> 1024 </td>    <td> tom </td>  </tr>  <tr>    <td> 2 </td>    <td> file2.txt  </td>    <td>/home/pics</td>    <td> jpg </td>    <td> 5032 </td>    <td> jerry </td>  </tr></table><ul><li>同样数据保存到列式数据库中</li></ul><table style="overflow: scroll;"><tr><th>RowKey</th><th>FILE INFO（列族：列标识符[列名]：值）</th><th>SAVE INFO</th></tr><tr><td> 1 </td><td> file_info:name:file1.txt<br>file_info:type:txt<br>file_info:size:1024</td><td>path:/home/picscreator:Jerry</td></tr><tr><td> 2 </td><td>file_info:name:file2.jpg<br>file_info:type:jpg<br>file_info:size:5032</td><td> path:/homecreator:Tom</td></tr></table><ul><li>行数据库&amp;列数据库存储方式比较</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005813.png" alt=""></p><h3 id="3-HBase组件"><a href="#3-HBase组件" class="headerlink" title="3 HBase组件"></a>3 HBase组件</h3><h4 id="3-1-HBase-基础架构"><a href="#3-1-HBase-基础架构" class="headerlink" title="3.1 HBase 基础架构"></a>3.1 HBase 基础架构</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005839.jpg" alt=""></p><h5 id="3-1-1-Client"><a href="#3-1-1-Client" class="headerlink" title="3.1.1 Client"></a><strong>3.1.1 Client</strong></h5><ul><li>①与zookeeper通信, 找到数据入口地址</li><li>②使用HBase RPC机制与HMaster和HRegionServer进行通信；</li><li>③Client与HMaster进行通信进行管理类操作；</li><li>④Client与HRegionServer进行数据读写类操作。</li></ul><h5 id="3-1-2-Zookeeper"><a href="#3-1-2-Zookeeper" class="headerlink" title="3.1.2 Zookeeper"></a>3.1.2 <strong>Zookeeper</strong></h5><ul><li>①保证任何时候，集群中只有一个running master，避免单点问题；</li><li>②存贮所有Region的寻址入口，包括-ROOT-表地址、HMaster地址；</li><li>③实时监控Region Server的状态，将Region server的上线和下线信息，实时通知给Master；</li><li>④存储Hbase的schema，包括有哪些table，每个table有哪些column family。</li></ul><h5 id="3-1-3-HMaster（主）"><a href="#3-1-3-HMaster（主）" class="headerlink" title="3.1.3 HMaster（主）"></a>3.1.3 <strong>HMaster（主）</strong></h5><p>可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master运行。</p><p>角色功能：</p><ul><li>①为Region server分配region；</li><li>②负责region server的负载均衡；</li><li>③发现失效的region serve并重新分配其上的region；</li><li>④HDFS上的垃圾文件回收；</li><li>⑤处理用户对表的增删改查操作。</li></ul><h5 id="3-1-4-HRegionServer（从）"><a href="#3-1-4-HRegionServer（从）" class="headerlink" title="3.1.4 HRegionServer（从）"></a>3.1.4 <strong>HRegionServer（从）</strong></h5><p>HBase中最核心的模块，主要负责响应用户I/O请求，向HDFS文件系统中读写数据。</p><p>作用：</p><ul><li>①维护Master分配给它的region，处理对这些region的IO请求；</li><li>②负责切分在运行过程中变得过大的region。</li><li>此外，HRegionServer管理一系列HRegion对象，每个HRegion对应Table中一个Region，HRegion由多个HStore组成，每个HStore对应Table中一个Column Family的存储，Column Family就是一个集中的存储单元，故将具有相同IO特性的Column放在一个Column Family会更高效。</li></ul><h5 id="3-1-5-HStore"><a href="#3-1-5-HStore" class="headerlink" title="3.1.5 HStore"></a>3.1.5 <strong>HStore</strong></h5><ul><li>HBase存储的核心，由MemStore和StoreFile组成。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005904.png" alt=""></p><ul><li>用户写入数据的流程为：client访问ZK, ZK返回RegionServer地址-&gt; client访问RegionServer写入数据 -&gt; 数据存入MemStore，一直到MemStore满 -&gt; Flush成StoreFile</li><li>写也是一样的操作，先看内存有没，没有才去Storefile中读取。</li></ul><h5 id="3-1-6-HRegion"><a href="#3-1-6-HRegion" class="headerlink" title="3.1.6 HRegion"></a>3.1.6 <strong>HRegion</strong></h5><ul><li>一个表最开始存储的时候，是一个region。</li><li>一个Region中会有个多个store，<strong>每个store用来存储一个列簇</strong>。如果只有一个column family，就只有一个store。</li><li>region会随着插入的数据越来越多，会进行拆分。默认大小是<strong>10G</strong>一个。</li></ul><h5 id="3-1-7-HLog"><a href="#3-1-7-HLog" class="headerlink" title="3.1.7 HLog"></a>3.1.7 <strong>HLog</strong></h5><ul><li>在分布式系统环境中，无法避免系统出错或者宕机，一旦HRegionServer意外退出，MemStore中的内存数据就会丢失，引入HLog就是防止这种情况，其在磁盘上不会像内存那样出大问题，内存出问题，将其写进内存即可。</li><li>而且一旦MemStore的数据flush到Hstore中，HLog中的数据就会抹掉。——持久化后抹除。避免其过大</li></ul><h4 id="3-2-HBase模块协作"><a href="#3-2-HBase模块协作" class="headerlink" title="3.2 HBase模块协作"></a>3.2 HBase模块协作</h4><ul><li>HBase启动<ul><li>HMaster启动, 注册到Zookeeper, 等待RegionServer汇报</li><li>RegionServer注册到Zookeeper, 并向HMaster汇报</li><li>对各个RegionServer(包括失效的)的数据进行整理, 分配Region和meta信息</li></ul></li><li>RegionServer失效<ul><li>HMaster将失效RegionServer上的Region分配到其他节点</li><li>HMaster更新hbase: meta 表以保证数据正常访问</li></ul></li><li>HMaster失效<ul><li>处于Backup状态的其他HMaster节点推选出一个转为Active状态</li><li>数据能正常读写, 但是不能创建删除表, 也不能更改表结构</li></ul></li></ul><h3 id="4-HBase-的安装与实战"><a href="#4-HBase-的安装与实战" class="headerlink" title="4 HBase 的安装与实战"></a>4 HBase 的安装与实战</h3><h4 id="4-1-HBase的安装"><a href="#4-1-HBase的安装" class="headerlink" title="4.1 HBase的安装"></a>4.1 HBase的安装</h4><ul><li><p>下载安装包 <a href="http://archive.cloudera.com/cdh5/cdh/5/hbase-1.2.0-cdh5.7.0.tar.gz">http://archive.cloudera.com/cdh5/cdh/5/hbase-1.2.0-cdh5.7.0.tar.gz</a></p></li><li><p>配置伪分布式环境</p><ul><li><p>环境变量配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HBASE_HOME=/usr/local/development/hbase-1.2.4</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>配置hbase-env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/development/jdk1.7.0_15</span><br><span class="line">export HBASE_MANAGES_ZK=false  --如果你是使用hbase自带的zk就是true，如果使用自己的zk就是false</span><br></pre></td></tr></table></figure></li><li><p>配置hbase-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>　　--hbase持久保存的目录</span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020/opt/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  --是否是分布式</span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>     </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    --指定要连接zk的端口</span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>        </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/app/hbase/zkData<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>          </span><br></pre></td></tr></table></figure></li><li><p>启动hbase（启动的hbase的时候要保证hadoop集群已经启动）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hbase/bin/start-hbase.sh</span><br></pre></td></tr></table></figure></li><li><p>输入hbase shell（进入shell命令行）</p></li></ul></li></ul><h4 id="4-2-HBase-shell"><a href="#4-2-HBase-shell" class="headerlink" title="4.2 HBase shell"></a>4.2 HBase shell</h4><ul><li>HBase DDL 和 DML 命令</li></ul><table style="overflow: scroll;">  <tr>    <th>名称</th>    <th>命令表达式</th>  </tr>  <tr>    <td> 创建表 </td>   <td> create '表名', '列族名1','列族名2','列族名n' </td>  </tr>  <tr>    <td> 添加记录 </td>    <td> put '表名','行名','列名:','值 </td>  </tr>    <tr>    <td> 查看记录 </td>    <td> get '表名','行名' </td>  </tr>  <tr>    <td> 查看表中的记录总数 </td>    <td> count '表名' </td>  </tr>    <tr>    <td> 删除记录 </td>    <td> delete '表名', '行名','列名' </td>  </tr>  <tr>    <td> 删除一张表 </td>    <td> 第一步 disable '表名' 第二步 drop '表名' </td>  </tr>  <tr>    <td> 查看所有记录 </td>    <td> scan "表名称" </td>  </tr>  <tr>    <td> 查看指定表指定列所有数据 </td>    <td> scan '表名' ,{COLUMNS=>'列族名:列名'} </td>  </tr>   <tr>    <td> 更新记录 </td>    <td> 重写覆盖 </td>  </tr></table><ul><li>连接集群</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase shell</span><br></pre></td></tr></table></figure><ul><li>创建表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;base_info&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>删除表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable <span class="string">&#x27;user&#x27;</span></span><br><span class="line"><span class="keyword">drop</span> <span class="string">&#x27;user&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>创建名称空间</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_namespace <span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>展示现有名称空间</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_namespace</span><br></pre></td></tr></table></figure><ul><li>创建表的时候添加namespace</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="string">&#x27;test:user&#x27;</span>,<span class="string">&#x27;base_info&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>显示某个名称空间下有哪些表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_namespace_tables &#39;test&#39;</span><br></pre></td></tr></table></figure><ul><li><p>插入数据</p><p>put  ‘表名’，‘rowkey的值’，’列族：列标识符‘，’值‘</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">put &#39;user&#39;,&#39;rowkey_10&#39;,&#39;base_info:username&#39;,&#39;Tom&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_10&#39;,&#39;base_info:birthday&#39;,&#39;2014-07-10&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_10&#39;,&#39;base_info:sex&#39;,&#39;1&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_10&#39;,&#39;base_info:address&#39;,&#39;Tokyo&#39;</span><br><span class="line"></span><br><span class="line">put &#39;user&#39;,&#39;rowkey_16&#39;,&#39;base_info:username&#39;,&#39;Mike&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_16&#39;,&#39;base_info:birthday&#39;,&#39;2014-07-10&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_16&#39;,&#39;base_info:sex&#39;,&#39;1&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_16&#39;,&#39;base_info:address&#39;,&#39;beijing&#39;</span><br><span class="line"></span><br><span class="line">put &#39;user&#39;,&#39;rowkey_22&#39;,&#39;base_info:username&#39;,&#39;Jerry&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_22&#39;,&#39;base_info:birthday&#39;,&#39;2014-07-10&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_22&#39;,&#39;base_info:sex&#39;,&#39;1&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_22&#39;,&#39;base_info:address&#39;,&#39;Newyork&#39;</span><br><span class="line"></span><br><span class="line">put &#39;user&#39;,&#39;rowkey_24&#39;,&#39;base_info:username&#39;,&#39;Nico&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_24&#39;,&#39;base_info:birthday&#39;,&#39;2014-07-10&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_24&#39;,&#39;base_info:sex&#39;,&#39;1&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_24&#39;,&#39;base_info:address&#39;,&#39;shanghai&#39;</span><br><span class="line"></span><br><span class="line">put &#39;user&#39;,&#39;rowkey_25&#39;,&#39;base_info:username&#39;,&#39;Rose&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_25&#39;,&#39;base_info:birthday&#39;,&#39;2014-07-10&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_25&#39;,&#39;base_info:sex&#39;,&#39;1&#39;</span><br><span class="line">put &#39;user&#39;,&#39;rowkey_25&#39;,&#39;base_info:address&#39;,&#39;Soul&#39;</span><br></pre></td></tr></table></figure><ul><li>查询表中的所有数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#39;user&#39;</span><br></pre></td></tr></table></figure><ul><li>查询某个rowkey的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get &#39;user&#39;,&#39;rowkey_16&#39;</span><br></pre></td></tr></table></figure><ul><li>查询某个列簇的数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get &#x27;user&#x27;,&#x27;rowkey_16&#x27;,&#x27;base_info&#x27;</span><br><span class="line">get &#x27;user&#x27;,&#x27;rowkey_16&#x27;,&#x27;base_info:username&#x27;</span><br><span class="line">get &#x27;user&#x27;, &#x27;rowkey_16&#x27;, &#123;COLUMN =&gt; [&#x27;base_info:username&#x27;,&#x27;base_info:sex&#x27;]&#125;</span><br></pre></td></tr></table></figure><ul><li>删除表中的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete &#39;user&#39;, &#39;rowkey_16&#39;, &#39;base_info:username&#39;</span><br></pre></td></tr></table></figure><ul><li>清空数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate &#39;user&#39;</span><br></pre></td></tr></table></figure><ul><li>操作列簇</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter &#39;user&#39;, NAME &#x3D;&gt; &#39;f2&#39;</span><br><span class="line">alter &#39;user&#39;, &#39;delete&#39; &#x3D;&gt; &#39;f2&#39;</span><br></pre></td></tr></table></figure><ul><li><p>HBase 追加型数据库 会保留多个版本数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> <span class="string">&#x27;user&#x27;</span></span><br><span class="line"><span class="keyword">Table</span> <span class="keyword">user</span> <span class="keyword">is</span> ENABLED</span><br><span class="line"><span class="keyword">user</span></span><br><span class="line"><span class="keyword">COLUMN</span> FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;base_info&#x27;, VERSIONS =&gt; &#x27;1&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_B</span><br><span class="line">HE_DATA_ON_WRITE <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;false&#x27;</span>, DATA_BLOCK_ENCODING <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;NONE&#x27;</span>, TTL <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;FOREVER&#x27;</span>, MI</span><br><span class="line">ER <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;NONE&#x27;</span>, CACHE_INDEX_ON_WRITE <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;false&#x27;</span>, IN_MEMORY <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;false&#x27;</span>, CACHE_BLOOM</span><br><span class="line">se<span class="string">&#x27;, COMPRESSION =&gt; &#x27;</span><span class="keyword">NONE</span><span class="string">&#x27;, BLOCKCACHE =&gt; &#x27;</span><span class="literal">false</span><span class="string">&#x27;, BLOCKSIZE =&gt; &#x27;</span><span class="number">65536</span><span class="string">&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>VERSIONS=&gt;’1’说明最多可以显示一个版本 修改数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put <span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;rowkey_10&#x27;</span>,<span class="string">&#x27;base_info:username&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>指定显示多个版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get &#x27;user&#x27;,&#x27;rowkey_10&#x27;,&#123;COLUMN=&gt;&#x27;base_info:username&#x27;,VERSIONS=&gt;2&#125;</span><br></pre></td></tr></table></figure><ul><li>修改可以显示的版本数量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &#x27;user&#x27;,NAME=&gt;&#x27;base_info&#x27;,VERSIONS=&gt;10</span><br></pre></td></tr></table></figure></li></ul><ul><li>命令表</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701005940.jpg" alt=""></p><p>可以通过HbaseUi界面查看表的信息</p><p>端口60010打不开的情况，是因为hbase 1.0 以后的版本，需要自己手动配置，在文件 hbase-site</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;  </span><br><span class="line">&lt;name&gt;hbase.master.info.port&lt;&#x2F;name&gt;  </span><br><span class="line">&lt;value&gt;60010&lt;&#x2F;value&gt;  </span><br><span class="line">&lt;&#x2F;property&gt; </span><br></pre></td></tr></table></figure><h4 id="4-3-HappyBase操作Hbase"><a href="#4-3-HappyBase操作Hbase" class="headerlink" title="4.3 HappyBase操作Hbase"></a>4.3 HappyBase操作Hbase</h4><ul><li><p>什么是HappyBase</p><ul><li><strong>HappyBase</strong> is a developer-friendly <a href="http://python.org/">Python</a> library to interact with <a href="http://hbase.apache.org/">Apache HBase</a>. HappyBase is designed for use in standard HBase setups, and offers application developers a Pythonic API to interact with HBase. Below the surface, HappyBase uses the <a href="http://pypi.python.org/pypi/thrift">Python Thrift library</a> to connect to HBase using its <a href="http://thrift.apache.org/">Thrift</a> gateway, which is included in the standard HBase 0.9x releases.</li></ul></li><li><p>HappyBase 是FaceBook员工开发的操作HBase的python库, 其基于Python Thrift, 但使用方式比Thrift简单, 已被广泛应用</p></li><li><p>启动hbase thrift server : hbase-daemon.sh start thrift</p></li><li><p>安装happy base</p><ul><li>pip install happybase</li></ul></li><li><p>使用happy base时可能出现的问题(windows系统)</p><ul><li>happybase1.0在win下不支持绝对路径</li><li>解决方案：将488行的url_scheme == ”改为url_scheme in (‘代码盘符’, ”)</li></ul></li><li><p>如何使用HappyBase</p><ul><li>建立连接</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> happybase</span><br><span class="line">connection = happybase.Connection(<span class="string">&#x27;somehost&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>当连接建立时, 会自动创建一个与 HBase Thrift server的socket链接. 可以通过参数禁止自动链接, 然后再需要连接是调用 <a href="https://happybase.readthedocs.io/en/latest/api.html#happybase.Connection.open"><code>Connection.open()</code></a>:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection = happybase.Connection(<span class="string">&#x27;somehost&#x27;</span>, autoconnect=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># before first use:</span></span><br><span class="line">connection.<span class="built_in">open</span>()</span><br></pre></td></tr></table></figure><ul><li><a href="https://happybase.readthedocs.io/en/latest/api.html#happybase.Connection"><code>Connection</code></a>  这个类提供了一个与HBase交互的入口, 比如获取HBase中所有的表:  <a href="https://happybase.readthedocs.io/en/latest/api.html#happybase.Connection.tables"><code>Connection.tables()</code></a>:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(connection.tables())</span><br></pre></td></tr></table></figure><ul><li>操作表<ul><li>Table类提供了大量API, 这些API用于检索和操作HBase中的数据。 在上面的示例中，我们已经使用Connection.tables（）方法查询HBase中的表。 如果还没有任何表，可使用Connection.create_table（）创建一个新表：</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.create_table(<span class="string">&#x27;users&#x27;</span>,&#123;<span class="string">&#x27;cf1&#x27;</span>: <span class="built_in">dict</span>()&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>创建表之后可以传入表名获取到Table类的实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#x3D; connection.table(&#39;mytable&#39;)</span><br></pre></td></tr></table></figure></li><li><p>查询操作</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># api</span></span><br><span class="line">table.scan() <span class="comment">#全表查询</span></span><br><span class="line">table.row(row_keys[<span class="number">0</span>]) <span class="comment"># 查询一行</span></span><br><span class="line">table.rows(row_keys) <span class="comment"># 查询多行</span></span><br><span class="line"><span class="comment">#封装函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_rows</span>(<span class="params">table, row_keys=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> row_keys:</span><br><span class="line">        print(<span class="string">&#x27;show value of row named %s&#x27;</span> % row_keys)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(row_keys) == <span class="number">1</span>:</span><br><span class="line">            print(table.row(row_keys[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(table.rows(row_keys))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;show all row values of table named %s&#x27;</span> % table.name)</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> table.scan():</span><br><span class="line">            print(key, value)</span><br></pre></td></tr></table></figure><ul><li>插入数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#api</span></span><br><span class="line">table.put(row_key, &#123;cf:cq:value&#125;)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_row</span>(<span class="params">table, column_family, row_key, value</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;insert one row to hbase&#x27;</span>)</span><br><span class="line">    <span class="comment">#put &#x27;user&#x27;,&#x27;rowkey_10&#x27;,&#x27;base_info:username&#x27;,&#x27;Tom&#x27;</span></span><br><span class="line">    <span class="comment">#&#123;&#x27;cf:cq&#x27;:’数据‘&#125;</span></span><br><span class="line">    table.put(row_key, &#123;<span class="string">&#x27;%s:name&#x27;</span> % column_family:<span class="string">&#x27;name_%s&#x27;</span> % value&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_rows</span>(<span class="params">table, column_family, row_lines=<span class="number">30</span></span>):</span></span><br><span class="line">    print(<span class="string">&#x27;insert rows to hbase now&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row_lines):</span><br><span class="line">        put_row(table, column_family, <span class="string">&#x27;row_%s&#x27;</span> % i, i)</span><br></pre></td></tr></table></figure><ul><li>删除数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#api</span></span><br><span class="line">table.delete(row_key, cf_list)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#函数封装    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_row</span>(<span class="params">table, row_key, column_family=<span class="literal">None</span>, keys=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> keys:</span><br><span class="line">        print(<span class="string">&#x27;delete keys:%s from row_key:%s&#x27;</span> % (keys, row_key))</span><br><span class="line">        key_list = [<span class="string">&#x27;%s:%s&#x27;</span> % (column_family, key) <span class="keyword">for</span> key <span class="keyword">in</span> keys]</span><br><span class="line">        table.delete(row_key, key_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;delete row(column_family:) from hbase&#x27;</span>)</span><br><span class="line">        table.delete(row_key)</span><br></pre></td></tr></table></figure><ul><li>删除表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#api</span></span><br><span class="line">conn.delete_table(table_name, <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#函数封装</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_table</span>(<span class="params">table_name</span>):</span></span><br><span class="line">    pretty_print(<span class="string">&#x27;delete table %s now.&#x27;</span> % table_name)</span><br><span class="line">    conn.delete_table(table_name, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li>完整代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> happybase</span><br><span class="line"></span><br><span class="line">hostname = <span class="string">&#x27;192.168.199.188&#x27;</span></span><br><span class="line">table_name = <span class="string">&#x27;users&#x27;</span></span><br><span class="line">column_family = <span class="string">&#x27;cf&#x27;</span></span><br><span class="line">row_key = <span class="string">&#x27;row_1&#x27;</span></span><br><span class="line"></span><br><span class="line">conn = happybase.Connection(hostname)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_tables</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;show all tables now&#x27;</span>)</span><br><span class="line">    tables =  conn.tables()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> tables:</span><br><span class="line">        <span class="built_in">print</span> t</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_table</span>(<span class="params">table_name, column_family</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;create table %s&#x27;</span> % table_name)</span><br><span class="line">    conn.create_table(table_name, &#123;column_family:<span class="built_in">dict</span>()&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_rows</span>(<span class="params">table, row_keys=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> row_keys:</span><br><span class="line">        print(<span class="string">&#x27;show value of row named %s&#x27;</span> % row_keys)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(row_keys) == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span> table.row(row_keys[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span> table.rows(row_keys)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;show all row values of table named %s&#x27;</span> % table.name)</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> table.scan():</span><br><span class="line">            <span class="built_in">print</span> key, value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_row</span>(<span class="params">table, column_family, row_key, value</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;insert one row to hbase&#x27;</span>)</span><br><span class="line">    table.put(row_key, &#123;<span class="string">&#x27;%s:name&#x27;</span> % column_family:<span class="string">&#x27;name_%s&#x27;</span> % value&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_rows</span>(<span class="params">table, column_family, row_lines=<span class="number">30</span></span>):</span></span><br><span class="line">    print(<span class="string">&#x27;insert rows to hbase now&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row_lines):</span><br><span class="line">        put_row(table, column_family, <span class="string">&#x27;row_%s&#x27;</span> % i, i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_row</span>(<span class="params">table, row_key, column_family=<span class="literal">None</span>, keys=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> keys:</span><br><span class="line">        print(<span class="string">&#x27;delete keys:%s from row_key:%s&#x27;</span> % (keys, row_key))</span><br><span class="line">        key_list = [<span class="string">&#x27;%s:%s&#x27;</span> % (column_family, key) <span class="keyword">for</span> key <span class="keyword">in</span> keys]</span><br><span class="line">        table.delete(row_key, key_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;delete row(column_family:) from hbase&#x27;</span>)</span><br><span class="line">        table.delete(row_key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_table</span>(<span class="params">table_name</span>):</span></span><br><span class="line">    pretty_print(<span class="string">&#x27;delete table %s now.&#x27;</span> % table_name)</span><br><span class="line">    conn.delete_table(table_name, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool</span>():</span></span><br><span class="line">    pretty_print(<span class="string">&#x27;test pool connection now.&#x27;</span>)</span><br><span class="line">    pool = happybase.ConnectionPool(size=<span class="number">3</span>, host=hostname)</span><br><span class="line">    <span class="keyword">with</span> pool.connection() <span class="keyword">as</span> connection:</span><br><span class="line">        <span class="built_in">print</span> connection.tables()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># show_tables()</span></span><br><span class="line">    <span class="comment"># create_table(table_name, column_family)</span></span><br><span class="line">    <span class="comment"># show_tables()</span></span><br><span class="line"></span><br><span class="line">    table = conn.table(table_name)</span><br><span class="line">    show_rows(table)</span><br><span class="line">    put_rows(table, column_family)</span><br><span class="line">    show_rows(table)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 更新操作</span></span><br><span class="line">    <span class="comment"># put_row(table, column_family, row_key, &#x27;xiaoh.me&#x27;)</span></span><br><span class="line">    <span class="comment"># show_rows(table, [row_key])</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 删除数据</span></span><br><span class="line">    <span class="comment"># delete_row(table, row_key)</span></span><br><span class="line">    <span class="comment"># show_rows(table, [row_key])</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># delete_row(table, row_key, column_family, [&#x27;name&#x27;])</span></span><br><span class="line">    <span class="comment"># show_rows(table, [row_key])</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># counter(table, row_key, column_family)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># delete_table(table_name)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="5-HBase表设计"><a href="#5-HBase表设计" class="headerlink" title="5  HBase表设计"></a>5  HBase表设计</h3><ul><li>设计HBase表时需要注意的特点<ul><li>HBase中表的索引是通过rowkey实现的</li><li>在表中是通过Row key的字典顺序来对数据进行排序的, 表中Region的划分通过起始Rowkey和结束Rowkey来决定的</li><li>所有存储在HBase中的数据都是二进制字节, 没有数据类型</li><li>原子性只在行内保证, HBase表中没有多行事务</li><li>列族(Column Family)在表创建之前就要定义好</li><li>列族中的列标识(Column Qualifier)可以在表创建后动态插入数据的时候添加</li><li>不同的column family保存在不同的文件中。</li></ul></li><li>如何设计HBase表<ul><li>Row key的结构该如何设置, Row key中又该包含什么样的信息</li><li>表中应该有多少的列族</li><li>列族中应该存储什么样的数据</li><li>每个列族中存储多少列数据</li><li>列的名字分别是什么</li><li>cell中应该存储什么样的信息</li><li>每个cell中存储多少个版本信息</li></ul></li><li>DDI  目的是为了克服HBase架构上的缺陷(join繁琐 只有row key索引等)<ul><li>Denormalization (反规范化, 解决join麻烦的问题)</li><li>Duplication (数据冗余)</li><li>Intelligent keys(通过row key设计实现 索引 排序对读写优化) </li></ul></li></ul><h4 id="5-1-HBase表设计案例-社交应用互粉信息表"><a href="#5-1-HBase表设计案例-社交应用互粉信息表" class="headerlink" title="5.1 HBase表设计案例: 社交应用互粉信息表"></a>5.1 HBase表设计案例: 社交应用互粉信息表</h4><ul><li><p>设计表保存应用中用户互粉的信息</p><ul><li>读场景:<ul><li>某用户都关注了哪些用户</li><li>用户A有没有关注用户B</li><li>谁关注了用户A</li></ul></li><li>写场景<ul><li>用户关注了某个用户</li><li>用户取消关注了某个用户</li></ul></li></ul></li><li><p>设计1:</p><ul><li>colunm qulifier(列名)  1:  2:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701010027.png" alt=""></p></li><li><p>设计2</p><ul><li>添加了一个 count 记录当前的最后一个记录的列名</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701010042.png" alt=""></p></li><li><p>设计3</p><ul><li>列名 user_id</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701010057.png" alt=""></p></li><li><p>最终设计(DDI)</p><ul><li>解决谁关注了用户A问题<ul><li>① 设计一张新表, 里面保存某个用户和他的粉丝</li><li>② 在同一张表中同时记录粉丝列表的和用户关注的列表, 并通过Rowkey来区分<ul><li>01_userid: 用户关注列表</li><li>02_userid: 粉丝列表</li></ul></li><li>上两种设计方案的问题(事务)</li></ul></li></ul></li><li><p>案例总结</p><ul><li>Rowkey是HBase表结构设计中很重要的环节, 直接影响到HBase的效率和性能</li><li>HBase的表结构比传统关系型数据库更灵活, 能存储任何二进制数据,无需考虑数据类型</li><li>利用列标识(Column Qualifier)来存储数据</li><li>衡量设计好坏的简单标准 是否会全表查询 </li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HBase简介与环境部署&quot;&gt;&lt;a href=&quot;#HBase简介与环境部署&quot; class=&quot;headerlink&quot; title=&quot;HBase简介与环境部署&quot;&gt;&lt;/a&gt;HBase简介与环境部署&lt;/h2&gt;&lt;h3 id=&quot;1-HBase简介-amp-在Hadoop生态中的</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>25-Sqoop概述</title>
    <link href="https://xxren8218.github.io/20210630/25-Sqoop%E6%A6%82%E8%BF%B0.html"/>
    <id>https://xxren8218.github.io/20210630/25-Sqoop%E6%A6%82%E8%BF%B0.html</id>
    <published>2021-06-29T16:51:29.000Z</published>
    <updated>2021-06-29T16:53:26.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h2><h3 id="1-Sqoop概述"><a href="#1-Sqoop概述" class="headerlink" title="1 Sqoop概述"></a>1 Sqoop概述</h3><ul><li><p>什么是Sqoop</p><ul><li>Sqoop 是一款进行数据传输的工具, 可在hadoop 的 hdfs 和关系型数据库之间传输数据</li><li>可以使用Sqoop把数据从MySQL 或 Oracle导入到hdfs中, 也可以把数据从hdfs导入到MySQL或Oracle中</li><li>Sqoop可自动执行数据传输的大部分过程, 使用MapReduce导入和导出数据，提供并行操作和容错</li></ul></li><li><p>为什么要使用sqoop?</p><ul><li>快速实现Hadoop(HDFS/hive/hbase)与mysql/Oracle等关系型数据库之间的数据传递</li><li>Sqoop提供多种数据传输方式</li></ul></li><li><p>Sqoop原理</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630005225.png" alt=""></p></li></ul><h3 id="2-Sqoop安装"><a href="#2-Sqoop安装" class="headerlink" title="2 Sqoop安装"></a>2 Sqoop安装</h3><ul><li><p>下载安装包<a href="http://archive.cloudera.com/cdh5/cdh/5/sqoop-1.4.6-cdh5.7.0.tar.gz">url</a> </p></li><li><p>解压到centos中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf &#x2F;home&#x2F;hadoop&#x2F;software&#x2F;sqoop-1.4.6-cdh5.7.0.tar.gz  -C ~&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line">export SQOOP_HOME=/home/hadoop/app/sqoop-1.4.6-cdh5.7.0</span><br><span class="line">export PATH=$SQOOP_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>激活环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>到 $SQOOP_HOME/conf 目录下 配置sqoop_env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp sqoop-env-template.sh sqoop-env.sh</span><br><span class="line">vi sqoop-env.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">在sqoop_env.sh中</span></span><br><span class="line">export HADOOP_COMMON_HOME=/home/hadoop/app/hadoop-2.6.0-cdh5.7.0/</span><br><span class="line">export HADOOP_MAPRED_HOME=/home/hadoop/app/hadoop-2.6.0-cdh5.7.0/</span><br><span class="line">export HIVE_HOME=/home/hadoop/app/hive-1.1.0-cdh5.7.0/</span><br></pre></td></tr></table></figure></li><li><p>拷贝 mysql驱动到$SQOOP_HOME/lib目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /home/hadoop/app/hive-1.1.0-cdh5.7.0/lib/mysql-connector-java-5.1.47.jar /home/hadoop/app/sqoop-1.4.6-cdh5.7.0/lib/</span><br></pre></td></tr></table></figure></li><li><p>测试sqoop环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop-version</span><br></pre></td></tr></table></figure><p>看到如下输出 说明sqoop安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sqoop 1.4.6-cdh5.7.0</span><br><span class="line">git commit id</span><br><span class="line">Compiled by jenkins on ******</span><br></pre></td></tr></table></figure></li><li><p>然后进入到MySQL的Docker环境中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -ti mysql bash</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-使用Sqoop导入数据到hdfs中"><a href="#3-使用Sqoop导入数据到hdfs中" class="headerlink" title="3 使用Sqoop导入数据到hdfs中"></a>3 使用Sqoop导入数据到hdfs中</h3><ul><li><p>准备mysql数据</p><p>建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> u(id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,fname <span class="type">varchar</span>(<span class="number">20</span>),lname <span class="type">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> u3 (fname, lname) <span class="keyword">values</span>(<span class="string">&#x27;George&#x27;</span>,<span class="string">&#x27;washington&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> u3 (fname, lname) <span class="keyword">values</span>(<span class="string">&#x27;George&#x27;</span>,<span class="string">&#x27;bush&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> u3 (fname, lname) <span class="keyword">values</span>(<span class="string">&#x27;Bill&#x27;</span>,<span class="string">&#x27;clinton&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> u3 (fname, lname) <span class="keyword">values</span>(<span class="string">&#x27;Bill&#x27;</span>,<span class="string">&#x27;gates&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>Sqoop导入命令介绍</p><ul><li>命令语法: sqoop import (控制参数) (导入参数)</li><li>命令元素: 导入操作, 数据源, 访问方式, 导入控制, 目标地址 </li><li>命令理解: 数据从哪里来, 有什么控制, 到哪里去</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqoop import --connect jdbc:mysql://127.0.0.1:3306/test --username root --password root\!123A --table u -m 1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> -m 表示用几个MR任务执行，前提是文件小于128M，否则拆成多个block</span></span><br></pre></td></tr></table></figure><ul><li>添加—target-dir 指定hdfs上数据存放的目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqoop import --connect jdbc:mysql://localhost:3306/test --username root --password root!123A --table u --target-dir /tmp/u1 -m 1</span><br></pre></td></tr></table></figure></li><li><p>导入可能出现的问题 </p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630005303.png" alt=""></p><p>​    解决 上传java-json.jar到$SQOOP_HOME/lib目录下</p><ul><li><p>默认数据上传到hdfs中如下路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;user&#x2F;当前linux用户名&#x2F;mysql表名&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>通过hive 建立外表导入数据到hive</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> u4(</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    fname STRING,</span><br><span class="line">    lname STRING</span><br><span class="line">)</span><br><span class="line"><span class="type">ROW</span> FORMAT delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">LOCATION <span class="string">&#x27;/user/hadoop/u/&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>也可能出现断开连接的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive --service metastore&amp;  # 加上&amp;表示在后台跑。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Sqoop&quot;&gt;&lt;a href=&quot;#Sqoop&quot; class=&quot;headerlink&quot; title=&quot;Sqoop&quot;&gt;&lt;/a&gt;Sqoop&lt;/h2&gt;&lt;h3 id=&quot;1-Sqoop概述&quot;&gt;&lt;a href=&quot;#1-Sqoop概述&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>02-二叉树之深度遍历思想训练</title>
    <link href="https://xxren8218.github.io/20210629/02-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%80%9D%E6%83%B3%E8%AE%AD%E7%BB%83.html"/>
    <id>https://xxren8218.github.io/20210629/02-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E6%80%9D%E6%83%B3%E8%AE%AD%E7%BB%83.html</id>
    <published>2021-06-29T10:19:29.000Z</published>
    <updated>2021-07-04T13:30:25.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树之深度遍历思想训练"><a href="#二叉树之深度遍历思想训练" class="headerlink" title="二叉树之深度遍历思想训练"></a>二叉树之深度遍历思想训练</h2><p>读完本文，你能去力扣解决如下题目：</p><p>654.最大二叉树（难度 <strong>Medium</strong>）</p><p>105.从前序与中序遍历序列构造二叉树（难度 <strong>Medium</strong>）</p><p>106.从中序与后序遍历序列构造二叉树（难度 <strong>Medium</strong>）</p><p>先来复习一下，我们说过写树的算法，关键思路如下：</p><p><strong>把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了</strong>，我们千万不要跳进递归的细节里，你的脑袋才能压几个栈呀。</p><p>也许你还不太理解这句话，我们下面来看例子。</p><blockquote><h3 id="一、构造最大二叉树"><a href="#一、构造最大二叉树" class="headerlink" title="一、构造最大二叉树"></a>一、构造最大二叉树</h3></blockquote><p>先来道简单的，这是力扣第 654 题，题目如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182049.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：[<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,null,<span class="number">2</span>,<span class="number">0</span>,null,null,<span class="number">1</span>]</span><br><span class="line">返回: TreeNode</span><br></pre></td></tr></table></figure><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br></pre></td></tr></table></figure><p>按照我们刚才说的，先明确根节点做什么？<strong>对于构造二叉树的问题，根节点要做的就是把想办法把自己构造出来</strong>。</p><p>我们肯定要遍历数组把找到最大值<code>maxVal</code>，把根节点<code>root</code>做出来，然后对<code>maxVal</code>左边的数组和右边的数组进行递归调用，作为<code>root</code>的左右子树。</p><p>按照题目给出的例子，输入的数组为<code>[3,2,1,6,0,5]</code>，对于整棵树的根节点来说，其实在做这件事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>]</span>):</span></span><br><span class="line">    <span class="comment"># 找到数组中的最大值</span></span><br><span class="line">    root = TreeNode(<span class="number">6</span>)</span><br><span class="line">    <span class="comment"># 递归调用构造左右子树</span></span><br><span class="line">    root.left = constructMaximumBinaryTree([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">    root.right = constructMaximumBinaryTree([<span class="number">0</span>,<span class="number">5</span>])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>再详细一点，就是如下伪码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 找到数组中的最大值</span></span><br><span class="line">    maxVal = <span class="built_in">max</span>(nums)</span><br><span class="line">    index = nums.index(maxVal)</span><br><span class="line"></span><br><span class="line">root = TreeNode(maxVal)</span><br><span class="line">    <span class="comment"># 递归调用构造左右子树</span></span><br><span class="line">    root.left = constructMaximumBinaryTree(nums[:index])</span><br><span class="line">    root.right = constructMaximumBinaryTree(nums[index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>看懂了吗？<strong>对于每个根节点，只需要找到当前<code>nums</code>中的最大值和对应的索引，然后递归调用左右数组构造左右子树即可。</strong></p><p><strong>将其拆分成两个函数如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> build(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">nums. lo, hi</span>):</span></span><br><span class="line">    <span class="keyword">if</span> lo &gt; hi:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 找到数组中的最大值</span></span><br><span class="line">    maxVal = <span class="built_in">max</span>(nums[lo:hi + <span class="number">1</span>])</span><br><span class="line">    index = nums.index(maxVal)</span><br><span class="line"></span><br><span class="line">root = TreeNode(maxVal)</span><br><span class="line">    <span class="comment"># 递归调用构造左右子树</span></span><br><span class="line">    root.left = build(nums,lo, index - <span class="number">1</span>)</span><br><span class="line">    root.right = build(nums, index, hi)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>至此，这道题就做完了，还是挺简单的对吧，下面看两道更困难一些的。</p><blockquote><h3 id="二、通过前序和中序遍历结果构造二叉树"><a href="#二、通过前序和中序遍历结果构造二叉树" class="headerlink" title="二、通过前序和中序遍历结果构造二叉树"></a>二、通过前序和中序遍历结果构造二叉树</h3></blockquote><p>经典问题了，面试/笔试中常考，力扣第 105 题就是这个问题：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182105.jpg" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br></pre></td></tr></table></figure><p>废话不多说，直接来想思路，首先思考，根节点应该做什么。</p><p><strong>类似上一题，我们肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右子树即可</strong>。</p><p>我们先来回顾一下，前序遍历和中序遍历的结果有什么特点？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># 前序遍历</span></span><br><span class="line">    preorder.append(root.val)</span><br><span class="line">    traverse(root.left)</span><br><span class="line">    traverse(root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment"># 中序遍历</span></span><br><span class="line">    inorder.append(root.val)</span><br><span class="line">    traverse(root.right)</span><br></pre></td></tr></table></figure><p>这样的遍历顺序差异，导致了<code>preorder</code>和<code>inorder</code>数组中的元素分布有如下特点：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182119.jpg" alt=""></p><p>找到根节点是很简单的，前序遍历的第一个值<code>preorder[0]</code>就是根节点的值，关键在于如何通过根节点的值，将<code>preorder</code>和<code>postorder</code>数组划分成两半，构造根节点的左右子树？</p><p>换句话说，对于以下代码中的<code>?</code>部分应该填入什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">preorder, inorder</span>):</span></span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>,</span><br><span class="line">                 inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   若前序遍历数组为 preorder[preStart..preEnd]，</span></span><br><span class="line"><span class="string">   后续遍历数组为 postorder[postStart..postEnd]，</span></span><br><span class="line"><span class="string">   构造二叉树，返回该二叉树的根节点 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">preorder, preStart, preEnd, </span></span></span><br><span class="line"><span class="function"><span class="params">          inorder, inStart, inEnd</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">    rootVal = preorder[preStart]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># rootVal 在中序遍历数组中的索引</span></span><br><span class="line">    index = inorder.index(rootVal)</span><br><span class="line"></span><br><span class="line">    root = TreeNode(rootVal)</span><br><span class="line">    <span class="comment"># 递归构造左右子树</span></span><br><span class="line">    root.left = build(preorder, ?, ?,</span><br><span class="line">                      inorder, ?, ?)</span><br><span class="line"></span><br><span class="line">    root.right = build(preorder, ?, ?,</span><br><span class="line">                       inorder, ?, ?)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>对于代码中的<code>rootVal</code>和<code>index</code>变量，就是下图这种情况：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182133.jpg" alt=""></p><p>现在我们来看图做填空题，下面这几个问号处应该填什么：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root.left = build(preorder, ?, ?,</span><br><span class="line">                  inorder, ?, ?)</span><br><span class="line"></span><br><span class="line">root.right = build(preorder, ?, ?,</span><br><span class="line">                   inorder, ?, ?)</span><br></pre></td></tr></table></figure><p>对于左右子树对应的<code>inorder</code>数组的起始索引和终止索引比较容易确定：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182146.jpg" alt=""></p><p>对于<code>preorder</code>数组呢？如何确定左右数组对应的起始索引和终止索引？</p><p>这个可以通过左子树的节点数推导出来，假设左子树的节点数为<code>leftSize</code>，那么<code>preorder</code>数组上的索引情况是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182201.jpg" alt=""></p><p>看着这个图就可以把<code>preorder</code>对应的索引写进去了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leftSize = index - inStart</span><br><span class="line"></span><br><span class="line">root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize,</span><br><span class="line">                  inorder, inStart, index - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd,</span><br><span class="line">                   inorder, index + <span class="number">1</span>, inEnd)</span><br></pre></td></tr></table></figure><p>至此，整个算法思路就完成了，我们再补一补 base case 即可写出解法代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">preorder, inorder</span>):</span></span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>,</span><br><span class="line">                 inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   若前序遍历数组为 preorder[preStart..preEnd]，</span></span><br><span class="line"><span class="string">   后续遍历数组为 postorder[postStart..postEnd]，</span></span><br><span class="line"><span class="string">   构造二叉树，返回该二叉树的根节点 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">preorder, preStart, preEnd, </span></span></span><br><span class="line"><span class="function"><span class="params">          inorder, inStart, inEnd</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> preStart &gt; preEnd: <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">    rootVal = preorder[preStart]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># rootVal 在中序遍历数组中的索引</span></span><br><span class="line">    index = inorder.index(rootVal)</span><br><span class="line">    leftSize = index - inStart</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先构造出当前根节点</span></span><br><span class="line">    root = TreeNode(rootVal)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归构造左右子树</span></span><br><span class="line">    root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize,</span><br><span class="line">                      inorder, inStart, index - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd,</span><br><span class="line">                       inorder, index + <span class="number">1</span>, inEnd)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>我们的主函数只要调用<code>build</code>函数即可，你看着函数这么多参数，解法这么多代码，似乎比我们上面讲的那道题难很多，让人望而生畏，实际上呢，这些参数无非就是控制数组起止位置的，画个图就能解决了。</p><blockquote><h3 id="三、通过后序和中序遍历结果构造二叉树"><a href="#三、通过后序和中序遍历结果构造二叉树" class="headerlink" title="三、通过后序和中序遍历结果构造二叉树"></a>三、通过后序和中序遍历结果构造二叉树</h3></blockquote><p>类似上一题，这次我们利用<strong>后序</strong>和<strong>中序</strong>遍历的结果数组来还原二叉树，这是力扣第 106 题：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182214.png" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[<span class="built_in">int</span>], postorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br></pre></td></tr></table></figure><p>类似的，看下后序和中序遍历的特点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">TreeNode root</span>):</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment"># 前序遍历</span></span><br><span class="line">    postorder.append(root.val)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">TreeNode root</span>):</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment"># 中序遍历</span></span><br><span class="line">    inorder.append(root.val)</span><br><span class="line">    traverse(root.right)</span><br></pre></td></tr></table></figure><p>这样的遍历顺序差异，导致了<code>preorder</code>和<code>inorder</code>数组中的元素分布有如下特点：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182229.jpg" alt=""></p><p>这道题和上一题的关键区别是，后序遍历和前序遍历相反，根节点对应的值为<code>postorder</code>的最后一个元素。</p><p>整体的算法框架和上一题非常类似，我们依然写一个辅助函数<code>build</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">inorder, postorder</span>):</span></span><br><span class="line">    <span class="keyword">return</span> build(inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>,</span><br><span class="line">                 postorder, <span class="number">0</span>, <span class="built_in">len</span>(postorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">inorder, inStart, inEnd, </span></span></span><br><span class="line"><span class="function"><span class="params">          postorder, postStart, postEnd</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">    rootVal = postorder[preEnd]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># rootVal 在中序遍历数组中的索引</span></span><br><span class="line">    index = inorder.index(rootVal)</span><br><span class="line"></span><br><span class="line">    root = TreeNode(rootVal)</span><br><span class="line">    <span class="comment"># 递归构造左右子树</span></span><br><span class="line">    root.left = build(inorder, ?, ?,</span><br><span class="line">                      postorder, ?, ?)</span><br><span class="line"></span><br><span class="line">    root.right = build(inorder, ?, ?,</span><br><span class="line">                       postorder, ?, ?)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>现在<code>postoder</code>和<code>inorder</code>对应的状态如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629182242.jpg" alt=""></p><p>我们可以按照上图将问号处的索引正确填入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leftSize = index - inStart</span><br><span class="line"></span><br><span class="line">root.left = build(inorder, inStart, index - <span class="number">1</span>,</span><br><span class="line">                  postorder, postStart, postStart + leftSize - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">root.right = build(inorder, index + <span class="number">1</span>, inEnd,</span><br><span class="line">                   postorder, postStart + leftSize, postEnd - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>综上，可以写出完整的解法代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">inorder, postorder</span>):</span></span><br><span class="line">    <span class="keyword">return</span> build(inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>,</span><br><span class="line">                 postorder, <span class="number">0</span>, <span class="built_in">len</span>(postorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">inorder, inStart, inEnd, </span></span></span><br><span class="line"><span class="function"><span class="params">          postorder, postStart, postEnd</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> inStart &gt; inEnd: <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">    rootVal = postorder[postEnd]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># rootVal 在中序遍历数组中的索引</span></span><br><span class="line">    index = inorder.index(rootVal)</span><br><span class="line"></span><br><span class="line">    leftSize = index - inStart</span><br><span class="line">    </span><br><span class="line">    root = TreeNode(rootVal)</span><br><span class="line">    <span class="comment"># 递归构造左右子树</span></span><br><span class="line">root.left = build(inorder, inStart, index - <span class="number">1</span>,</span><br><span class="line">                  postorder, postStart, postStart + leftSize - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">root.right = build(inorder, index + <span class="number">1</span>, inEnd,</span><br><span class="line">                   postorder, postStart + leftSize, postEnd - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>有了前一题的铺垫，这道题很快就解决了，无非就是<code>rootVal</code>变成了最后一个元素，再改改递归函数的参数而已，只要明白二叉树的特性，也不难写出来。</p><p>最后呼应下前文，<strong>做二叉树的问题，关键是把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树之深度遍历思想训练&quot;&gt;&lt;a href=&quot;#二叉树之深度遍历思想训练&quot; class=&quot;headerlink&quot; title=&quot;二叉树之深度遍历思想训练&quot;&gt;&lt;/a&gt;二叉树之深度遍历思想训练&lt;/h2&gt;&lt;p&gt;读完本文，你能去力扣解决如下题目：&lt;/p&gt;
&lt;p&gt;654.最</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>24-Hive概述</title>
    <link href="https://xxren8218.github.io/20210629/24-Hive%E6%A6%82%E8%BF%B0.html"/>
    <id>https://xxren8218.github.io/20210629/24-Hive%E6%A6%82%E8%BF%B0.html</id>
    <published>2021-06-28T16:47:32.000Z</published>
    <updated>2021-06-28T16:52:13.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><h2 id="一-Hive基本概念"><a href="#一-Hive基本概念" class="headerlink" title="一 Hive基本概念"></a>一 Hive基本概念</h2><h3 id="1-Hive简介"><a href="#1-Hive简介" class="headerlink" title="1 Hive简介 "></a>1 Hive简介 <img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629004922.jpg" alt=""></h3><p>学习目标</p><ul><li>了解什么是Hive</li><li>了解为什么使用Hive</li></ul><h4 id="1-1-什么是-Hive"><a href="#1-1-什么是-Hive" class="headerlink" title="1.1 什么是 Hive"></a>1.1 什么是 Hive</h4><ul><li>Hive 由 Facebook 实现并开源，是基于 Hadoop 的一个数据仓库工具，可以将结构化的数据映射为一张数据库表，并提供 HQL(Hive SQL)查询功能，底层数据是存储在 HDFS 上。</li><li>Hive 本质: 将 SQL 语句转换为 MapReduce 任务运行，使不熟悉 MapReduce 的用户很方便地利用 HQL 处理和计算 HDFS 上的结构化的数据,是一款基于 HDFS 的 MapReduce <strong>计算框架</strong>——相当于给MR套了壳子。</li><li>主要用途：用来做离线数据分析，比直接用 MapReduce 开发效率更高。</li></ul><h4 id="1-2-为什么使用-Hive"><a href="#1-2-为什么使用-Hive" class="headerlink" title="1.2 为什么使用 Hive"></a>1.2 为什么使用 Hive</h4><ul><li><p>直接使用 Hadoop MapReduce 处理数据所面临的问题：</p><ul><li>人员学习成本太高</li><li>MapReduce 实现复杂查询逻辑开发难度太大——得适应Map和Reduce的思维。</li></ul></li><li><p>使用 Hive</p><ul><li>操作接口采用类 SQL 语法，提供快速开发的能力</li></ul></li><li>避免了去写 MapReduce，减少开发人员的学习成本<ul><li>功能扩展很方便</li><li>缺点：非结构化数据不能用Hive，还是用MR来算。</li></ul></li></ul><h3 id="2-Hive-架构"><a href="#2-Hive-架构" class="headerlink" title="2 Hive 架构"></a>2 Hive 架构</h3><h4 id="2-1-Hive-架构图"><a href="#2-1-Hive-架构图" class="headerlink" title="2.1 Hive 架构图"></a>2.1 Hive 架构图</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629004940.jpg" alt=""></p><h4 id="2-2-Hive-组件"><a href="#2-2-Hive-组件" class="headerlink" title="2.2 Hive 组件"></a>2.2 Hive 组件</h4><ul><li>用户接口：包括 CLI、JDBC/ODBC、WebGUI。<ul><li>CLI(command line interface)为 shell 命令行</li><li>JDBC/ODBC 是 Hive 的 JAVA 实现，与传统数据库JDBC 类似</li><li>WebGUI 是通过浏览器访问 Hive。</li><li>HiveServer2基于Thrift, 允许远程客户端使用多种编程语言如Java、Python向Hive提交请求</li></ul></li><li>元数据存储：通常是存储在关系数据库如 mysql/derby 中。<ul><li>Hive 将元数据存储在数据库中。</li><li>Hive 中的元数据包括<ul><li>表的名字</li><li>表的列</li><li>分区及其属性</li><li>表的属性（是否为外部表等）</li><li>表的数据所在目录等。</li></ul></li></ul></li><li>解释器、编译器、优化器、执行器:完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在 HDFS 中，并在随后由 MapReduce 调用执行</li></ul><h4 id="2-3-Hive-与-Hadoop-的关系"><a href="#2-3-Hive-与-Hadoop-的关系" class="headerlink" title="2.3 Hive 与 Hadoop 的关系"></a>2.3 Hive 与 Hadoop 的关系</h4><p>Hive 利用 HDFS 存储数据，利用 MapReduce 查询分析数据。</p><p>Hive是数据仓库工具，没有集群的概念，如果想提交Hive作业只需要在hadoop集群 Master节点上装Hive就可以了</p><h3 id="3-Hive-与传统数据库对比"><a href="#3-Hive-与传统数据库对比" class="headerlink" title="3 Hive 与传统数据库对比"></a>3 Hive 与传统数据库对比</h3><ul><li>hive 用于海量数据的离线数据分析。</li></ul><table style="overflow: scroll;">  <tr>    <th></th>    <th>Hive</th>    <th>关系型数据库</th>  </tr>  <tr>    <td> ANSI SQL </td>    <td> 不完全支持 </td>    <td> 支持 </td>  </tr>  <tr>    <td> 更新 </td>    <td> INSERT OVERWRITE\INTO TABLE(默认) </td>    <td> UPDATE\INSERT\DELETE </td>  </tr>  <tr>    <td> 事务 </td>    <td> 不支持(默认) </td>    <td> 支持 </td>  </tr>  <tr>    <td> 模式 </td>    <td> 读模式 </td>    <td> 写模式 </td>  </tr>  <tr>    <td> 查询语言 </td>    <td> HQL  </td>    <td> SQL</td>  </tr>  <tr>    <td> 数据存储 </td>    <td> HDFS </td>    <td> Raw Device or Local FS </td>  </tr>  <tr>    <td> 执行 </td>    <td> MapReduce </td>    <td> Executor</td>  </tr>  <tr>    <td> 执行延迟 </td>    <td> 高 </td>    <td> 低 </td>  </tr>  <tr>    <td> 子查询 </td>    <td> 只能用在From子句中 </td>    <td> 完全支持 </td>  </tr>  <tr>    <td> 处理数据规模 </td>    <td> 大 </td>    <td> 小 </td>  </tr>  <tr>    <td> 可扩展性 </td>    <td> 高 </td>    <td> 低 </td>  </tr>  <tr>    <td> 索引 </td>    <td> 0.8版本后加入位图索引 </td>    <td> 有复杂的索引 </td>  </tr></table><ul><li>hive支持的数据类型<ul><li>原子数据类型  <ul><li>TINYINT SMALLINT INT BIGINT BOOLEAN FLOAT DOUBLE STRING BINARY TIMESTAMP DECIMAL CHAR VARCHAR DATE</li></ul></li><li>复杂数据类型<ul><li>ARRAY</li><li>MAP</li><li>STRUCT</li></ul></li></ul></li><li>hive中表的类型<ul><li>托管表 (managed table) (内部表)</li><li>外部表</li></ul></li></ul><h3 id="4-Hive-数据模型"><a href="#4-Hive-数据模型" class="headerlink" title="4 Hive 数据模型"></a>4 Hive 数据模型</h3><ul><li>Hive 中所有的数据都存储在 HDFS 中，没有专门的数据存储格式</li><li>在创建表时指定数据中的分隔符，Hive 就可以映射成功，解析数据。</li><li>Hive 中包含以下数据模型：<ul><li>db：在 hdfs 中表现为 hive.metastore.warehouse.dir 目录下一个文件夹</li><li>table：在 hdfs 中表现所属 db 目录下一个文件夹</li><li>external table：数据存放位置可以在 HDFS 任意指定路径</li><li>partition：在 hdfs 中表现为 table 目录下的子目录</li><li>bucket：在 hdfs 中表现为同一个表目录下根据 hash 散列之后的多个文件</li></ul></li></ul><h3 id="5-Hive-安装部署"><a href="#5-Hive-安装部署" class="headerlink" title="5 Hive 安装部署"></a>5 Hive 安装部署</h3><ul><li><p>Hive 安装前需要安装好 JDK 和 Hadoop。配置好环境变量。</p></li><li><p>下载Hive的安装包 <a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a> 并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hive-1.1.0-cdh5.7.0.tar.gz  -C ~/app/</span><br></pre></td></tr></table></figure></li><li><p>进入到 解压后的hive目录 找到 conf目录, 修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp hive-env.sh.template hive-env.sh</span><br><span class="line">vi hive-env.sh</span><br></pre></td></tr></table></figure><p>在hive-env.sh中指定hadoop的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HADOOP_HOME=/home/hadoop/app/hadoop-2.6.0-cdh5.7.0</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><ul><li><p>```shell<br>vi ~/.bash_profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;shell</span><br><span class="line">  export HIVE_HOME&#x3D;&#x2F;home&#x2F;hadoop&#x2F;app&#x2F;hive-1.1.0-cdh5.7.0</span><br><span class="line">  export PATH&#x3D;$HIVE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>```shell<br>source ~/.bash_profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 根据元数据存储的介质不同，分为下面两个版本，其中 derby 属于内嵌模式。实际生产环境中则使用 mysql 来进行元数据的存储。</span><br><span class="line"></span><br><span class="line">  - 内置 derby 版： </span><br><span class="line">    bin&#x2F;hive 启动即可使用</span><br><span class="line">    缺点：不同路径启动 hive，每一个 hive 拥有一套自己的元数据，无法共享</span><br><span class="line"></span><br><span class="line">  - mysql 版： </span><br><span class="line"></span><br><span class="line">    - 上传 mysql驱动到 hive安装目录的lib目录下</span><br><span class="line"></span><br><span class="line">      mysql-connector-java-5.*.jar</span><br><span class="line"></span><br><span class="line">    - vi conf&#x2F;hive-site.xml 配置 Mysql 元数据库信息(MySql安装见文档)</span><br><span class="line"></span><br><span class="line">      &#96;&#96;&#96;xml-dtd</span><br><span class="line">      &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; standalone&#x3D;&quot;no&quot;?&gt;</span><br><span class="line">      &lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;xsl&quot; href&#x3D;&quot;configuration.xsl&quot;?&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">      &lt;!-- 插入以下代码 --&gt;</span><br><span class="line">          &lt;property&gt;</span><br><span class="line">              &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;&#x2F;name&gt;</span><br><span class="line">              &lt;value&gt;hive&lt;&#x2F;value&gt;&lt;!-- 指定mysql用户名 --&gt;</span><br><span class="line">          &lt;&#x2F;property&gt;</span><br><span class="line">          &lt;property&gt;</span><br><span class="line">              &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;&#x2F;name&gt;</span><br><span class="line">              &lt;value&gt;hive&lt;&#x2F;value&gt;&lt;!-- 指定mysql密码 --&gt;</span><br><span class="line">          &lt;&#x2F;property&gt;</span><br><span class="line">         &lt;property&gt;</span><br><span class="line">              &lt;name&gt;javax.jdo.option.ConnectionURL&lt;&#x2F;name&gt;mysql</span><br><span class="line">              &lt;value&gt;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;hive&lt;&#x2F;value&gt;</span><br><span class="line">          &lt;&#x2F;property&gt;&lt;!-- 指定mysql数据库地址 --&gt;</span><br><span class="line">          &lt;property&gt;</span><br><span class="line">              &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;&#x2F;name&gt;</span><br><span class="line">              &lt;value&gt;com.mysql.jdbc.Driver&lt;&#x2F;value&gt;&lt;!-- 指定mysql驱动 --&gt;</span><br><span class="line">          &lt;&#x2F;property&gt;</span><br><span class="line">              &lt;!-- 到此结束代码 --&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">          &lt;name&gt;hive.exec.script.wrapper&lt;&#x2F;name&gt;</span><br><span class="line">          &lt;value&#x2F;&gt;</span><br><span class="line">          &lt;description&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">      &lt;&#x2F;configuration&gt;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li></ul></li><li><p>hive启动</p><ul><li><p>启动docker </p><p><code>service docker start</code></p></li><li><p>通过docker 启动mysql</p><p><code>docker start mysql</code></p></li><li><p>启动 hive的metastore元数据服务</p><p><code>hive --service metastore</code></p></li><li><p>启动hive</p><p><code>hive</code></p></li><li><p>MySQL root 密码 password         hive用户 密码 hive</p></li></ul></li></ul><h2 id="二-Hive-基本操作"><a href="#二-Hive-基本操作" class="headerlink" title="二 Hive 基本操作"></a>二 Hive 基本操作</h2><h3 id="2-1-Hive-HQL操作初体验"><a href="#2-1-Hive-HQL操作初体验" class="headerlink" title="2.1 Hive HQL操作初体验"></a>2.1 Hive HQL操作初体验</h3><ul><li><p>创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br></pre></td></tr></table></figure></li><li><p>显示所有数据库</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure></li><li><p>创建表</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(classNo string, stuNo string, score <span class="type">int</span>) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在text数据库下面创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> text.student(classNo string, stuNo string, score <span class="type">int</span>) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>row format delimited fields terminated by ‘,’  指定了字段的分隔符为逗号，所以load数据的时候，load的文本也要为逗号，否则加载后为NULL。hive只支持单个字符的分隔符，hive默认的分隔符是\001</li></ul></li><li><p>将数据load到表中</p><ul><li><p>在本地文件系统创建一个如下的文本文件：/home/hadoop/tmp/student.txt</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C01,N0101,82</span><br><span class="line">C01,N0102,59</span><br><span class="line">C01,N0103,65</span><br><span class="line">C02,N0201,81</span><br><span class="line">C02,N0202,82</span><br><span class="line">C02,N0203,79</span><br><span class="line">C03,N0301,56</span><br><span class="line">C03,N0302,92</span><br><span class="line">C03,N0306,72</span><br></pre></td></tr></table></figure></li><li><p>``` sql<br> load data local inpath ‘/home/hadoop/tmp/student.txt’overwrite into table student;<br> — 导入default.student</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">load data local inpath &#39;&#x2F;home&#x2F;hadoop&#x2F;tmp&#x2F;student.txt&#39;overwrite into table text.student; &#x2F;&#x2F;导入text下的studen</span><br></pre></td></tr></table></figure></li><li><p>这个命令将student.txt文件复制到hive的warehouse目录中，这个目录由hive.metastore.warehouse.dir配置项设置，默认值为/user/hive/warehouse。Overwrite选项将导致Hive事先删除student目录下所有的文件, 并将文件内容映射到表中。<br> Hive不会对student.txt做任何格式处理，因为Hive本身并不强调数据的存储格式。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 查询表中的数据 跟SQL类似——响应快（不涉及MR）</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96; sql</span><br><span class="line">   hive&gt;select * from student;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>分组查询group by和统计 count——响应慢（会启动一个MR作业，涉及MR）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span><span class="keyword">select</span> classNo,<span class="built_in">count</span>(score) <span class="keyword">from</span> student <span class="keyword">where</span> score<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">group</span> <span class="keyword">by</span> classNo;</span><br></pre></td></tr></table></figure><p>从执行结果可以看出 hive把查询的结果变成了MapReduce作业通过hadoop执行</p></li></ul><h3 id="2-2-Hive的内部表和外部表"><a href="#2-2-Hive的内部表和外部表" class="headerlink" title="2.2 Hive的内部表和外部表"></a>2.2 Hive的内部表和外部表</h3><table style="overflow: scroll;">  <tr>    <th></th>    <th>内部表(managed table)</th>    <th>外部表(external table)</th>  </tr>  <tr>    <td> 概念 </td>    <td> 创建表时无external修饰 </td>    <td> 创建表时被external修饰 </td>  </tr>  <tr>    <td> 数据管理 </td>    <td> 由Hive自身管理 </td>    <td> 由HDFS管理 </td>  </tr>  <tr>    <td> 数据保存位置 </td>    <td> hive.metastore.warehouse.dir  （默认：/user/hive/warehouse） </td>    <td> hdfs中任意位置 </td>  </tr>  <tr>    <td> 删除时影响 </td>    <td> 直接删除元数据（metadata）及存储数据 </td>    <td> 仅会删除元数据，HDFS上的文件并不会被删除 </td>  </tr>  <tr>    <td> 表结构修改时影响 </td>    <td> 修改会将修改直接同步给元数据  </td>    <td> 表结构和分区进行修改，则需要修复（MSCK REPAIR TABLE table_name;）</td>  </tr></table><ul><li><p>案例</p><ul><li>创建一个外部表student2</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> student2 (classNo string, stuNo string, score <span class="type">int</span>) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> location <span class="string">&#x27;/tmp/student&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>装载数据</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hadoop/tmp/student.txt&#x27;</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> student2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用...put 也可以放到/user/hive/warehouse中,不过上面的load是加载到了默认的路径/user/hive/warehouse中</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>显示表信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> formatted table_name;</span><br></pre></td></tr></table></figure></li><li><p>删除表查看结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure></li><li><p>再次创建外部表 student2</p></li><li><p>不插入数据直接查询查看结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student2;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-分区表——实际上是表目录下的子目录"><a href="#2-3-分区表——实际上是表目录下的子目录" class="headerlink" title="2.3 分区表——实际上是表目录下的子目录"></a>2.3 分区表——实际上是表目录下的子目录</h3><ul><li><p>什么是分区表</p><ul><li>随着表的不断增大，对于新纪录的增加，查找，删除等(DML)的维护也更加困难。对于数据库中的超大型表，可以通过把它的数据分成若干个小表，从而简化数据库的管理活动，对于每一个简化后的小表，我们称为一个单个的分区。</li><li>hive中分区表实际就是对应hdfs文件系统上独立的文件夹，该文件夹内的文件是该分区所有数据文件。</li><li>分区可以理解为分类，通过分类把不同类型的数据放到不同的目录下。</li><li>分类的标准就是分区字段，可以一个，也可以多个。</li><li>分区表的意义在于优化查询。查询时尽量利用分区字段。如果不使用分区字段，就会全部扫描。</li></ul></li><li><p>创建分区表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tom,4300</span><br><span class="line">jerry,12000</span><br><span class="line">mike,13000</span><br><span class="line">jake,11000</span><br><span class="line">rob,10000</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee (name string,salary <span class="type">bigint</span>) partitioned <span class="keyword">by</span> (date1 string) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> stored <span class="keyword">as</span> textfile;</span><br></pre></td></tr></table></figure><ul><li><p>查看表的分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> partitions employee;</span><br></pre></td></tr></table></figure></li><li><p>添加分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table employee add if not exists partition(date1&#x3D;&#39;2018-12-01&#39;);</span><br></pre></td></tr></table></figure></li><li><p>加载数据到分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hadoop/tmp/employee.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> employee <span class="keyword">partition</span>(date1<span class="operator">=</span><span class="string">&#x27;2018-12-01&#x27;</span>);</span><br><span class="line"><span class="comment">-- 也可以用put</span></span><br></pre></td></tr></table></figure></li><li><p>如果重复加载同名文件，不会报错，会自动创建一个*_copy_1.txt</p></li><li><p>外部分区表即使有分区的目录结构, 也必须要通过HQL添加分区, 才能看到相应的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /user/hive/warehouse/emp/dt=2018-12-04</span><br><span class="line">hadoop fs -copyFromLocal /tmp/employee.txt /user/hive/warehouse/test.db/emp/dt=2018-12-04/employee.txt</span><br></pre></td></tr></table></figure><ul><li><p>此时查看表中数据发现数据并没有变化, 需要通过hql添加分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp add if not exists partition(dt&#x3D;&#39;2018-12-04&#39;);</span><br></pre></td></tr></table></figure></li><li><p>此时再次查看才能看到新加入的数据</p></li></ul></li><li><p>总结</p><ul><li>利用分区表方式减少查询时需要扫描的数据量<ul><li>分区字段不是表中的列, 数据文件中没有对应的列</li><li>分区仅仅是一个目录名</li><li>查看数据时, hive会自动添加分区列</li><li>支持多级分区, 多级子目录</li></ul></li></ul></li></ul><h3 id="2-4-动态分区"><a href="#2-4-动态分区" class="headerlink" title="2.4 动态分区"></a>2.4 动态分区</h3><ul><li><p>在写入数据时自动创建分区(包括目录结构)</p></li><li><p>创建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table employee2 (name string,salary bigint) partitioned by (date1 string) row format delimited fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39; stored as textfile;</span><br></pre></td></tr></table></figure></li><li><p>导入数据——没有reduce,只有map。每条数据都丢过去。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> employee2 <span class="keyword">partition</span>(date1) <span class="keyword">select</span> name,salary,date1 <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure></li><li><p>使用动态分区需要设置参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set hive.exec.dynamic.partition.mode=nonstrict;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三-Hive-函数"><a href="#三-Hive-函数" class="headerlink" title="三 Hive 函数"></a>三 Hive 函数</h2><h3 id="3-1-内置运算符"><a href="#3-1-内置运算符" class="headerlink" title="3.1 内置运算符"></a>3.1 内置运算符</h3><p>在 Hive 有四种类型的运算符：</p><ul><li><p>关系运算符</p></li><li><p>算术运算符</p></li><li><p>逻辑运算符</p></li><li><p>复杂运算</p><p>(内容较多，见《Hive 官方文档》》)</p></li></ul><h3 id="3-2-内置函数"><a href="#3-2-内置函数" class="headerlink" title="3.2 内置函数"></a>3.2 内置函数</h3><p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF</a></p><ul><li>简单函数: 日期函数 字符串函数 类型转换 </li><li>统计函数: sum avg distinct</li><li>集合函数</li><li>分析函数</li><li>show functions;  显示所有函数</li><li>desc function 函数名;</li><li>desc function extended 函数名;</li></ul><h3 id="3-3-Hive-自定义函数和-Transform"><a href="#3-3-Hive-自定义函数和-Transform" class="headerlink" title="3.3 Hive 自定义函数和 Transform"></a>3.3 Hive 自定义函数和 Transform</h3><ul><li><p>UDF</p><ul><li><p>当 Hive 提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-defined function）。</p></li><li><p><strong>TRANSFORM</strong>,and <strong>UDF</strong> and <strong>UDAF</strong></p><p>it is possible to plug in your own custom mappers and reducers</p><p> A UDF is basically only a transformation done by a mapper meaning that each row should be mapped to exactly one row. A UDAF on the other hand allows us to transform a group of rows into one or more rows, meaning that we can reduce the number of input rows to a single output row by some custom aggregation.</p><p><strong>UDF</strong>：就是做一个mapper，对每一条输入数据，映射为一条输出数据。（输入一个，输出一个）</p><p><strong>UDAF</strong>:就是一个reducer，把一组输入数据映射为一条(或多条)输出数据。（输入100个，输出10个）</p><p>一个脚本至于是做mapper还是做reducer，又或者是做udf还是做udaf，取决于我们把它放在什么样的hive操作符中。放在select中的基本就是udf，放在distribute by和cluster by中的就是reducer。</p><p>We can control if the script is run in a mapper or reducer step by the way we formulate our HiveQL query.</p><p>The statements DISTRIBUTE BY and CLUSTER BY allow us to indicate that we want to actually perform an aggregation.</p><p>User-Defined Functions (UDFs) for transformations and even aggregations which are therefore called User-Defined Aggregation Functions (UDAFs)</p></li></ul></li><li><p>UDF示例(运行java已经编写好的UDF)</p><ul><li><p>在hdfs中创建 /user/hive/lib目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /user/hive/lib</span><br></pre></td></tr></table></figure></li><li><p>把 hive目录下 lib/hive-contrib-hive-contrib-1.1.0-cdh5.7.0.jar 放到hdfs中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put hive-contrib-1.1.0-cdh5.7.0.jar /user/hive/lib/</span><br></pre></td></tr></table></figure></li><li><p>把集群中jar包的位置添加到hive中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> add jar hdfs:///user/hive/lib/hive-contrib-1.1.0-cdh2.3.4.jar;</span></span><br></pre></td></tr></table></figure></li><li><p>在hive中创建<strong>临时</strong>UDF</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">CREATE</span> TEMPORARY <span class="keyword">FUNCTION</span> row_sequence <span class="keyword">as</span> <span class="string">&#x27;org.apache.hadoop.hive.contrib.udf.UDFRowSequence&#x27;</span> <span class="comment">-- 相当于给这个jar包重起名字叫row_FUNCTION了。</span></span><br></pre></td></tr></table></figure></li><li><p>在之前的案例中使用<strong>临时</strong>自定义函数(函数功能: 添加自增长的行号)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> row_sequence(),<span class="operator">*</span> <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure></li><li><p>创建<strong>非临时</strong>自定义函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> row_sequence <span class="keyword">as</span> <span class="string">&#x27;org.apache.hadoop.hive.contrib.udf.UDFRowSequence&#x27;</span> <span class="keyword">using</span> jar <span class="string">&#x27;hdfs:///user/hive/lib/hive-contrib-1.1.0-cdh2.3.4.jar&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Python UDF</p><ul><li><p>准备案例环境</p><ul><li><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> u(fname STRING,lname STRING);</span><br></pre></td></tr></table></figure></li><li><p>向表中插入数据(不要一条一条放，应该load或put)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> u2 <span class="keyword">values</span>(<span class="string">&#x27;George&#x27;</span>,<span class="string">&#x27;washington&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> u2 <span class="keyword">values</span>(<span class="string">&#x27;George&#x27;</span>,<span class="string">&#x27;bush&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> u2 <span class="keyword">values</span>(<span class="string">&#x27;Bill&#x27;</span>,<span class="string">&#x27;clinton&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> u2 <span class="keyword">values</span>(<span class="string">&#x27;Bill&#x27;</span>,<span class="string">&#x27;gates&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写map风格脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    line = line.strip()</span><br><span class="line">    fname , lname = line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    l_name = lname.upper()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;\t&#x27;</span>.join([fname, <span class="built_in">str</span>(l_name)])</span><br></pre></td></tr></table></figure></li><li><p>通过hdfs向hive中ADD file</p><ul><li><p>加载文件到hdfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put udf.py /user/hive/lib/</span><br></pre></td></tr></table></figure></li><li><p>hive从hdfs中加载python脚本——自己写的必须有这一步。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD FILE hdfs:///user/hive/lib/udf.py;</span><br><span class="line">ADD FILE /root/tmp/udf1.py;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Transform</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TRANSFORM(fname, lname) <span class="keyword">USING</span> <span class="string">&#x27;python udf1.py&#x27;</span> <span class="keyword">AS</span> (fname, l_name) <span class="keyword">FROM</span> u;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>Python UDAF</li></ul><h2 id="四-hive综合案例"><a href="#四-hive综合案例" class="headerlink" title="四 hive综合案例"></a>四 hive综合案例</h2><ul><li><p>内容推荐数据处理</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629005037.png" alt=""></p><ul><li>需求<ul><li>根据用户行为以及文章标签筛选出用户最感兴趣(阅读最多)的标签</li></ul></li></ul></li><li><p>相关数据</p><p>​    user_id article_id event_time</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">11,101,2018-12-01 06:01:10</span><br><span class="line">22,102,2018-12-01 07:28:12</span><br><span class="line">33,103,2018-12-01 07:50:14</span><br><span class="line">11,104,2018-12-01 09:08:12</span><br><span class="line">22,103,2018-12-01 13:37:12</span><br><span class="line">33,102,2018-12-02 07:09:12</span><br><span class="line">11,101,2018-12-02 18:42:12</span><br><span class="line">35,105,2018-12-03 09:21:12</span><br><span class="line">22,104,2018-12-03 16:42:12</span><br><span class="line">77,103,2018-12-03 18:31:12</span><br><span class="line">99,102,2018-12-04 00:04:12</span><br><span class="line">33,101,2018-12-04 19:10:12</span><br><span class="line">11,101,2018-12-05 09:07:12</span><br><span class="line">35,102,2018-12-05 11:00:12</span><br><span class="line">22,103,2018-12-05 12:11:12</span><br><span class="line">77,104,2018-12-05 18:02:02</span><br><span class="line">99,105,2018-12-05 20:09:11</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>文章数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">artical_id,artical_url,artical_keywords</span><br><span class="line">101,http:&#x2F;&#x2F;www.itcast.cn&#x2F;1.html,kw8|kw1</span><br><span class="line">102,http:&#x2F;&#x2F;www.itcast.cn&#x2F;2.html,kw6|kw3</span><br><span class="line">103,http:&#x2F;&#x2F;www.itcast.cn&#x2F;3.html,kw7</span><br><span class="line">104,http:&#x2F;&#x2F;www.itcast.cn&#x2F;4.html,kw5|kw1|kw4|kw9</span><br><span class="line">105,http:&#x2F;&#x2F;www.itcast.cn&#x2F;5.html,</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>要做的事情</strong>：将文章的关键词和用户联系起来。拿到任何一个用户可以知道他看这个标签文章的频率。</li></ul><ul><li><p>数据上传hdfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /tmp/demo</span><br><span class="line">hadoop fs -mkdir /tmp/demo/user_action</span><br></pre></td></tr></table></figure></li><li><p>创建外部表</p><ul><li>用户行为表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> user_actions;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> user_actions(</span><br><span class="line">    user_id STRING,</span><br><span class="line">    article_id STRING,</span><br><span class="line">    time_stamp STRING</span><br><span class="line">)</span><br><span class="line"><span class="type">ROW</span> FORMAT delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">LOCATION <span class="string">&#x27;/tmp/demo/user_action&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>文章表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> articles;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> articles(</span><br><span class="line">    article_id STRING,</span><br><span class="line">    url STRING,</span><br><span class="line">    key_words <span class="keyword">array</span><span class="operator">&lt;</span>STRING<span class="operator">&gt;</span></span><br><span class="line">)</span><br><span class="line"><span class="type">ROW</span> FORMAT delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> </span><br><span class="line">COLLECTION ITEMS terminated <span class="keyword">BY</span> <span class="string">&#x27;|&#x27;</span>   <span class="comment">-- key1|key2</span></span><br><span class="line">LOCATION <span class="string">&#x27;/tmp/demo/article_keywords&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">key_words array&lt;STRING&gt;  数组的数据类型</span></span><br><span class="line"><span class="comment">COLLECTION ITEMS terminated BY &#x27;|&#x27;  数组的元素之间用&#x27;|&#x27;分割</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>查看数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_actions;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> articles;</span><br></pre></td></tr></table></figure><ul><li><p>分组查询每个用户的浏览记录</p><ul><li>collect_set/collect_list作用:<ul><li>将group by中的某列转为一个数组返回</li><li>collect_list<strong>不去重</strong>而collect_set<strong>去重</strong></li></ul></li><li>collect_set</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,collect_set(article_id) </span><br><span class="line"><span class="keyword">from</span> user_actions <span class="keyword">group</span> <span class="keyword">by</span> user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11      [&quot;101&quot;,&quot;104&quot;]</span><br><span class="line">22      [&quot;102&quot;,&quot;103&quot;,&quot;104&quot;]</span><br><span class="line">33      [&quot;103&quot;,&quot;102&quot;,&quot;101&quot;]</span><br><span class="line">35      [&quot;105&quot;,&quot;102&quot;]</span><br><span class="line">77      [&quot;103&quot;,&quot;104&quot;]</span><br><span class="line">99      [&quot;102&quot;,&quot;105&quot;]</span><br></pre></td></tr></table></figure><ul><li>collect_list</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,collect_list(article_id) </span><br><span class="line"><span class="keyword">from</span> user_actions <span class="keyword">group</span> <span class="keyword">by</span> user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">11      [&quot;101&quot;,&quot;104&quot;,&quot;101&quot;,&quot;101&quot;]</span><br><span class="line">22      [&quot;102&quot;,&quot;103&quot;,&quot;104&quot;,&quot;103&quot;]</span><br><span class="line">33      [&quot;103&quot;,&quot;102&quot;,&quot;101&quot;]</span><br><span class="line">35      [&quot;105&quot;,&quot;102&quot;]</span><br><span class="line">77      [&quot;103&quot;,&quot;104&quot;]</span><br><span class="line">99      [&quot;102&quot;,&quot;105&quot;]</span><br></pre></td></tr></table></figure></li><li><p>sort_array: 对数组排序</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,sort_array(collect_list(article_id)) <span class="keyword">as</span> contents </span><br><span class="line"><span class="keyword">from</span> user_actions <span class="keyword">group</span> <span class="keyword">by</span> user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11      [&quot;101&quot;,&quot;101&quot;,&quot;101&quot;,&quot;104&quot;]</span><br><span class="line">22      [&quot;102&quot;,&quot;103&quot;,&quot;103&quot;,&quot;104&quot;]</span><br><span class="line">33      [&quot;101&quot;,&quot;102&quot;,&quot;103&quot;]</span><br><span class="line">35      [&quot;102&quot;,&quot;105&quot;]</span><br><span class="line">77      [&quot;103&quot;,&quot;104&quot;]</span><br><span class="line">99      [&quot;102&quot;,&quot;105&quot;]</span><br></pre></td></tr></table></figure><ul><li><p>如上所示：11与77都含有”104”,在Array里面不好统计次数。所以将其展开——拆分。</p></li><li><p>查看每一篇文章的关键字 lateral view explode</p><ul><li>explode函数 将array 拆分</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> explode(key_words) <span class="keyword">from</span> articles;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kw8</span><br><span class="line">kw1</span><br><span class="line">kw6</span><br><span class="line">kw3</span><br><span class="line">kw7</span><br><span class="line">kw5</span><br><span class="line">kw1</span><br><span class="line">kw4</span><br><span class="line">kw9</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- lateral view 和 explode 配合使用,将一行数据拆分成多行数据，在此基础上可以对拆分的数据进行聚合。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles <span class="keyword">lateral</span> <span class="keyword">view</span> explode(key_words) t <span class="keyword">as</span> kw;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">101     kw8</span><br><span class="line">101     kw1</span><br><span class="line">102     kw6</span><br><span class="line">102     kw3</span><br><span class="line">103     kw7</span><br><span class="line">104     kw5</span><br><span class="line">104     kw1</span><br><span class="line">104     kw4</span><br><span class="line">104     kw9</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">101     kw8</span><br><span class="line">101     kw1</span><br><span class="line">102     kw6</span><br><span class="line">102     kw3</span><br><span class="line">103     kw7</span><br><span class="line">104     kw5</span><br><span class="line">104     kw1</span><br><span class="line">104     kw4</span><br><span class="line">104     kw9</span><br><span class="line">105     NULL</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>含有outer——将105留下</p></li><li><p>根据文章id找到用户查看文章的关键字</p><ul><li>原始数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">101     http://www.itcast.cn/1.html     [&quot;kw8&quot;,&quot;kw1&quot;]</span><br><span class="line">102     http://www.itcast.cn/2.html     [&quot;kw6&quot;,&quot;kw3&quot;]</span><br><span class="line">103     http://www.itcast.cn/3.html     [&quot;kw7&quot;]</span><br><span class="line">104     http://www.itcast.cn/4.html     [&quot;kw5&quot;,&quot;kw1&quot;,&quot;kw4&quot;,&quot;kw9&quot;]</span><br><span class="line">105     http://www.itcast.cn/5.html     []</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_id, b.kw <span class="keyword">from</span> user_actions </span><br><span class="line"><span class="keyword">as</span> a <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line"><span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a.user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">11      kw1</span><br><span class="line">11      kw8</span><br><span class="line">11      kw5</span><br><span class="line">11      kw1</span><br><span class="line">11      kw4</span><br><span class="line">11      kw1</span><br><span class="line">11      kw9</span><br><span class="line">11      kw8</span><br><span class="line">11      kw1</span><br><span class="line">11      kw8</span><br><span class="line">22      kw1</span><br><span class="line">22      kw7</span><br><span class="line">22      kw9</span><br><span class="line">22      kw4</span><br><span class="line">22      kw5</span><br><span class="line">22      kw7</span><br><span class="line">22      kw3</span><br><span class="line">22      kw6</span><br><span class="line">33      kw8</span><br><span class="line">33      kw1</span><br><span class="line">33      kw3</span><br><span class="line">33      kw6</span><br><span class="line">33      kw7</span><br><span class="line">35      NULL</span><br><span class="line">35      kw6</span><br><span class="line">35      kw3</span><br><span class="line">77      kw9</span><br><span class="line">77      kw1</span><br><span class="line">77      kw7</span><br><span class="line">77      kw4</span><br><span class="line">77      kw5</span><br><span class="line">99      kw3</span><br><span class="line">99      kw6</span><br><span class="line">99      NULL</span><br></pre></td></tr></table></figure></li><li><p>根据文章id找到用户查看文章的关键字并统计频率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">select</span> a.user_id, b.kw,<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> weight </span><br><span class="line">  <span class="keyword">from</span> user_actions <span class="keyword">as</span> a </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line">  <span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> a.user_id,b.kw </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a.user_id,weight <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">11      kw1     4</span><br><span class="line">11      kw8     3</span><br><span class="line">11      kw5     1</span><br><span class="line">11      kw9     1</span><br><span class="line">11      kw4     1</span><br><span class="line">22      kw7     2</span><br><span class="line">22      kw9     1</span><br><span class="line">22      kw1     1</span><br><span class="line">22      kw3     1</span><br><span class="line">22      kw4     1</span><br><span class="line">22      kw5     1</span><br><span class="line">22      kw6     1</span><br><span class="line">33      kw3     1</span><br><span class="line">33      kw8     1</span><br><span class="line">33      kw7     1</span><br><span class="line">33      kw6     1</span><br><span class="line">33      kw1     1</span><br><span class="line">35      NULL    1</span><br><span class="line">35      kw3     1</span><br><span class="line">35      kw6     1</span><br><span class="line">77      kw1     1</span><br><span class="line">77      kw4     1</span><br><span class="line">77      kw5     1</span><br><span class="line">77      kw7     1</span><br><span class="line">77      kw9     1</span><br><span class="line">99      NULL    1</span><br><span class="line">99      kw3     1</span><br><span class="line">99      kw6     1</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>CONCAT：——将其链接在一起。<br>  CONCAT(str1,str2,…)  </p><p>  返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(user_id,article_id) <span class="keyword">from</span> user_actions;</span><br></pre></td></tr></table></figure><p>  CONCAT_WS:</p><p>  使用语法为：CONCAT_WS(separator,str1,str2,…)</p><p>  CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL，则结果为 NULL。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat_ws(<span class="string">&#x27;:&#x27;</span>,user_id,article_id) <span class="keyword">from</span> user_actions;</span><br></pre></td></tr></table></figure><ul><li><p>将用户查看的关键字和频率合并成 key:value形式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">select</span> a.user_id, concat_ws(<span class="string">&#x27;:&#x27;</span>,b.kw,<span class="built_in">cast</span> (<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> string)) <span class="keyword">as</span> kw_w  <span class="comment">--cast类型转化。</span></span><br><span class="line">  <span class="keyword">from</span> user_actions <span class="keyword">as</span> a </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line">  <span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.user_id,b.kw;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">11      kw1:4</span><br><span class="line">11      kw4:1</span><br><span class="line">11      kw5:1</span><br><span class="line">11      kw8:3</span><br><span class="line">11      kw9:1</span><br><span class="line">22      kw1:1</span><br><span class="line">22      kw3:1</span><br><span class="line">22      kw4:1</span><br><span class="line">22      kw5:1</span><br><span class="line">22      kw6:1</span><br><span class="line">22      kw7:2</span><br><span class="line">22      kw9:1</span><br><span class="line">33      kw1:1</span><br><span class="line">33      kw3:1</span><br><span class="line">33      kw6:1</span><br><span class="line">33      kw7:1</span><br><span class="line">33      kw8:1</span><br><span class="line">35      1</span><br><span class="line">35      kw3:1</span><br><span class="line">35      kw6:1</span><br><span class="line">77      kw1:1</span><br><span class="line">77      kw4:1</span><br><span class="line">77      kw5:1</span><br><span class="line">77      kw7:1</span><br><span class="line">77      kw9:1</span><br><span class="line">99      1</span><br><span class="line">99      kw3:1</span><br><span class="line">99      kw6:1</span><br></pre></td></tr></table></figure></li><li><p>将用户查看的关键字和频率合并成 key:value形式并按用户聚合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">select</span> cc.user_id,concat_ws(<span class="string">&#x27;,&#x27;</span>,collect_set(cc.kw_w))</span><br><span class="line">  <span class="keyword">from</span>(</span><br><span class="line">  <span class="keyword">select</span> a.user_id, concat_ws(<span class="string">&#x27;:&#x27;</span>,b.kw,<span class="built_in">cast</span> (<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> string)) <span class="keyword">as</span> kw_w </span><br><span class="line">  <span class="keyword">from</span> user_actions <span class="keyword">as</span> a </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line">  <span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> a.user_id,b.kw</span><br><span class="line">  ) <span class="keyword">as</span> cc </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cc.user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11      kw1:4,kw4:1,kw5:1,kw8:3,kw9:1</span><br><span class="line">22      kw1:1,kw3:1,kw4:1,kw5:1,kw6:1,kw7:2,kw9:1</span><br><span class="line">33      kw1:1,kw3:1,kw6:1,kw7:1,kw8:1</span><br><span class="line">35      1,kw3:1,kw6:1</span><br><span class="line">77      kw1:1,kw4:1,kw5:1,kw7:1,kw9:1</span><br><span class="line">99      1,kw3:1,kw6:1</span><br></pre></td></tr></table></figure></li><li><p>将上面聚合结果转换成map</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cc.user_id,str_to_map(concat_ws(<span class="string">&#x27;,&#x27;</span>,collect_set(cc.kw_w))) <span class="keyword">as</span> wm</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line"><span class="keyword">select</span> a.user_id, concat_ws(<span class="string">&#x27;:&#x27;</span>,b.kw,<span class="built_in">cast</span> (<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> string)) <span class="keyword">as</span> kw_w </span><br><span class="line"><span class="keyword">from</span> user_actions <span class="keyword">as</span> a </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line"><span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.user_id,b.kw</span><br><span class="line">) <span class="keyword">as</span> cc </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cc.user_id;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  11      &#123;&quot;kw1&quot;:&quot;4&quot;,&quot;kw4&quot;:&quot;1&quot;,&quot;kw5&quot;:&quot;1&quot;,&quot;kw8&quot;:&quot;3&quot;,&quot;kw9&quot;:&quot;1&quot;&#125;</span><br><span class="line">  22      &#123;&quot;kw1&quot;:&quot;1&quot;,&quot;kw3&quot;:&quot;1&quot;,&quot;kw4&quot;:&quot;1&quot;,&quot;kw5&quot;:&quot;1&quot;,&quot;kw6&quot;:&quot;1&quot;,&quot;kw7&quot;:&quot;2&quot;,&quot;kw9&quot;:&quot;1&quot;&#125;</span><br><span class="line">  33      &#123;&quot;kw1&quot;:&quot;1&quot;,&quot;kw3&quot;:&quot;1&quot;,&quot;kw6&quot;:&quot;1&quot;,&quot;kw7&quot;:&quot;1&quot;,&quot;kw8&quot;:&quot;1&quot;&#125;</span><br><span class="line">  35      &#123;&quot;1&quot;:null,&quot;kw3&quot;:&quot;1&quot;,&quot;kw6&quot;:&quot;1&quot;&#125;</span><br><span class="line">  77      &#123;&quot;kw1&quot;:&quot;1&quot;,&quot;kw4&quot;:&quot;1&quot;,&quot;kw5&quot;:&quot;1&quot;,&quot;kw7&quot;:&quot;1&quot;,&quot;kw9&quot;:&quot;1&quot;&#125;</span><br><span class="line">99      &#123;&quot;1&quot;:null,&quot;kw3&quot;:&quot;1&quot;,&quot;kw6&quot;:&quot;1&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>将用户的阅读偏好结果保存到表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">create</span> <span class="keyword">table</span> user_kws <span class="keyword">as</span> </span><br><span class="line">  <span class="keyword">select</span> cc.user_id,str_to_map(concat_ws(<span class="string">&#x27;,&#x27;</span>,collect_set(cc.kw_w))) <span class="keyword">as</span> wm</span><br><span class="line">  <span class="keyword">from</span>(</span><br><span class="line">  <span class="keyword">select</span> a.user_id, concat_ws(<span class="string">&#x27;:&#x27;</span>,b.kw,<span class="built_in">cast</span> (<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> string)) <span class="keyword">as</span> kw_w </span><br><span class="line">  <span class="keyword">from</span> user_actions <span class="keyword">as</span> a </span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line">  <span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> explode(key_words) t <span class="keyword">as</span> kw) b</span><br><span class="line">  <span class="keyword">on</span> (a.article_id <span class="operator">=</span> b.article_id)</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> a.user_id,b.kw</span><br><span class="line">  ) <span class="keyword">as</span> cc </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cc.user_id;</span><br></pre></td></tr></table></figure></li><li><p>从表中通过key查询map中的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id, wm[<span class="string">&#x27;kw1&#x27;</span>] <span class="keyword">from</span> user_kws;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11      4</span><br><span class="line">22      1</span><br><span class="line">33      1</span><br><span class="line">35      NULL</span><br><span class="line">77      1</span><br><span class="line">99      NULL</span><br></pre></td></tr></table></figure></li><li><p>从表中获取map中所有的key 和 所有的value</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,map_keys(wm),map_values(wm) <span class="keyword">from</span> user_kws;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11      [&quot;kw1&quot;,&quot;kw4&quot;,&quot;kw5&quot;,&quot;kw8&quot;,&quot;kw9&quot;] [&quot;4&quot;,&quot;1&quot;,&quot;1&quot;,&quot;3&quot;,&quot;1&quot;]</span><br><span class="line">22      [&quot;kw1&quot;,&quot;kw3&quot;,&quot;kw4&quot;,&quot;kw5&quot;,&quot;kw6&quot;,&quot;kw7&quot;,&quot;kw9&quot;]     [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;2&quot;,&quot;1&quot;]</span><br><span class="line">33      [&quot;kw1&quot;,&quot;kw3&quot;,&quot;kw6&quot;,&quot;kw7&quot;,&quot;kw8&quot;] [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">35      [&quot;1&quot;,&quot;kw3&quot;,&quot;kw6&quot;]       [null,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">77      [&quot;kw1&quot;,&quot;kw4&quot;,&quot;kw5&quot;,&quot;kw7&quot;,&quot;kw9&quot;] [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">99      [&quot;1&quot;,&quot;kw3&quot;,&quot;kw6&quot;]       [null,&quot;1&quot;,&quot;1&quot;]</span><br></pre></td></tr></table></figure></li><li><p>用lateral view explode把map中的数据转换成多列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,keyword,weight <span class="keyword">from</span> user_kws <span class="keyword">lateral</span> <span class="keyword">view</span> explode(wm) t <span class="keyword">as</span> keyword,weight;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">11      kw1     4</span><br><span class="line">11      kw4     1</span><br><span class="line">11      kw5     1</span><br><span class="line">11      kw8     3</span><br><span class="line">11      kw9     1</span><br><span class="line">22      kw1     1</span><br><span class="line">22      kw3     1</span><br><span class="line">22      kw4     1</span><br><span class="line">22      kw5     1</span><br><span class="line">22      kw6     1</span><br><span class="line">22      kw7     2</span><br><span class="line">22      kw9     1</span><br><span class="line">33      kw1     1</span><br><span class="line">33      kw3     1</span><br><span class="line">33      kw6     1</span><br><span class="line">33      kw7     1</span><br><span class="line">33      kw8     1</span><br><span class="line">35      1       NULL</span><br><span class="line">35      kw3     1</span><br><span class="line">35      kw6     1</span><br><span class="line">77      kw1     1</span><br><span class="line">77      kw4     1</span><br><span class="line">77      kw5     1</span><br><span class="line">77      kw7     1</span><br><span class="line">77      kw9     1</span><br><span class="line">99      1       NULL</span><br><span class="line">99      kw3     1</span><br><span class="line">99      kw6     1</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hive&quot;&gt;&lt;a href=&quot;#Hive&quot; class=&quot;headerlink&quot; title=&quot;Hive&quot;&gt;&lt;/a&gt;Hive&lt;/h1&gt;&lt;h2 id=&quot;一-Hive基本概念&quot;&gt;&lt;a href=&quot;#一-Hive基本概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>01-二叉树之常用框架</title>
    <link href="https://xxren8218.github.io/20210628/01-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6.html"/>
    <id>https://xxren8218.github.io/20210628/01-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6.html</id>
    <published>2021-06-28T14:07:14.000Z</published>
    <updated>2021-06-28T14:13:54.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树之常用框架"><a href="#二叉树之常用框架" class="headerlink" title="二叉树之常用框架"></a>二叉树之常用框架</h2><p>读完本文，你可以去力扣拿下：</p><p>226.翻转二叉树，难度 <strong>Easy</strong></p><p>116.将二叉树展开为链表，难度 <strong>Medium</strong></p><p>114.填充二叉树节点的右侧指针，难度 <strong>Medium</strong></p><p>先刷二叉树的题目，先刷二叉树的题目，先刷二叉树的题目，因为很多经典算法，回溯、动归、分治算法，其实都是树的问题，而树的问题就永远逃不开树的递归遍历框架这几行破代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># 前序遍历</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment"># 中序遍历</span></span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment"># 后序遍历</span></span><br></pre></td></tr></table></figure><p>递归解法应该是最简单，最容易理解的才对，行云流水地写递归代码是学好算法的基本功，而二叉树相关的题目就是最练习递归基本功，最练习框架思维的。</p><blockquote><h3 id="一、二叉树的重要性"><a href="#一、二叉树的重要性" class="headerlink" title="一、二叉树的重要性"></a>一、二叉树的重要性</h3></blockquote><p>举个例子，比如说我们的经典算法<code>「快速排序」</code>和<code>「归并排序」</code>，对于这两个算法，你有什么理解？<strong>如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后续遍历，那么我就知道你是个算法高手了</strong>。</p><p>为什么快速排序和归并排序能和二叉树扯上关系？我们来简单分析一下他们的算法思想和代码框架：</p><p>快速排序的逻辑是，若要对<code>nums[lo..hi]</code>进行排序，我们先找一个分界点<code>p</code>，通过交换元素使得<code>nums[lo..p-1]</code>都小于等于<code>nums[p]</code>，且<code>nums[p+1..hi]</code>都大于<code>nums[p]</code>，然后递归地去<code>nums[lo..p-1]</code>和<code>nums[p+1..hi]</code>中寻找新的分界点，最后整个数组就被排序了。</p><p>快速排序的代码框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">nums, lo, hi</span>):</span></span><br><span class="line">    <span class="comment">##### 前序遍历位置 ##### </span></span><br><span class="line">    <span class="comment"># 通过交换元素构建分界点 p</span></span><br><span class="line">    p = partition(nums, lo, hi)</span><br><span class="line"></span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>)</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi)</span><br></pre></td></tr></table></figure><p>先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？</p><p>再说说归并排序的逻辑，若要对<code>nums[lo..hi]</code>进行排序，我们先对<code>nums[lo..mid]</code>排序，再对<code>nums[mid+1..hi]</code>排序，最后把这两个有序的子数组合并，整个数组就排好序了。</p><p>归并排序的代码框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">nums, lo, hi</span>):</span></span><br><span class="line">    mid = (lo + hi) / <span class="number">2</span></span><br><span class="line">    sort(nums, lo, mid)</span><br><span class="line">    sort(nums, mid + <span class="number">1</span>, hi)</span><br><span class="line"></span><br><span class="line">    <span class="comment">###### 后序遍历位置 #####</span></span><br><span class="line">    <span class="comment"># 合并两个排好序的子数组</span></span><br><span class="line">    merge(nums, lo, mid, hi)</span><br><span class="line">    <span class="comment">########################</span></span><br></pre></td></tr></table></figure><p>先对左右子数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是二叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀。</p><p>如果你一眼就识破这些排序算法的底细，还需要背这些算法代码吗？这不是手到擒来，从框架慢慢扩展就能写出算法了。</p><p>说了这么多，旨在说明，二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树的问题。</p><p><strong>所以接下来，我们直接上几道比较有意思，且能体现出递归算法精妙的二叉树题目</strong>。</p><blockquote><h3 id="二、写递归算法的秘诀"><a href="#二、写递归算法的秘诀" class="headerlink" title="二、写递归算法的秘诀"></a>二、写递归算法的秘诀</h3></blockquote><p><strong>写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要试图跳入递归</strong>。</p><p>怎么理解呢，我们用一个具体的例子来说，比如说让你计算一棵二叉树共有几个节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义：count(root) 返回以 root 为根的树有多少节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 自己加上子树的节点数就是整棵树的节点数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + count(root.left) + count(root.right)</span><br></pre></td></tr></table></figure><p>这个问题非常简单，大家应该都会写这段代码，<code>root</code>本身就是一个节点，加上左右子树的节点数就是以<code>root</code>为根的树的节点总数。</p><p>左右子树的节点数怎么算？其实就是计算根为<code>root.left</code>和<code>root.right</code>两棵树的节点数呗，按照定义，递归调用<code>count</code>函数即可算出来。</p><p><strong>写树相关的算法，简单说就是，先搞清楚当前<code>root</code>节点该做什么，然后根据函数定义递归调用子节点</strong>，递归调用会让孩子节点做相同的事情。</p><p>我们接下来看几道算法题目实操一下。</p><blockquote><h3 id="三、算法实践"><a href="#三、算法实践" class="headerlink" title="三、算法实践"></a>三、算法实践</h3></blockquote><h4 id="第一题、翻转二叉树"><a href="#第一题、翻转二叉树" class="headerlink" title="第一题、翻转二叉树"></a>第一题、翻转二叉树</h4><p>我们先从简单的题开始，看看力扣第 226 题「翻转二叉树」，输入一个二叉树根节点<code>root</code>，让你把整棵树镜像翻转，比如输入的二叉树如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>算法原地翻转二叉树，使得以<code>root</code>为根的树变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><p>通过观察，<strong>我们发现只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树</strong>。</p><p>可以直接写出解法代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将整棵树的节点翻转</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前序遍历位置</span></span><br><span class="line">    <span class="comment"># root 节点需要交换它的左右子节点</span></span><br><span class="line">    tmp = root.left</span><br><span class="line">    root.left = root.right</span><br><span class="line">    root.right = tmp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 让左右子节点继续翻转它们的子节点</span></span><br><span class="line">    invertTree(root.left)</span><br><span class="line">    invertTree(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>这道题目比较简单，关键思路在于我们发现翻转整棵树就是交换每个节点的左右子节点，于是我们把交换左右子节点的代码放在了前序遍历的位置。</p><p>值得一提的是，如果把交换左右子节点的代码放在后序遍历的位置也是可以的，但是放在中序遍历的位置是不行的，请你想一想为什么？这个应该不难想到。</p><p><code>中序遍历换节点 根据左根右的遍历顺序 相当于左侧节点交换了两次 右侧节点没换  因为遍历根的时候交换了左右节点 遍历右侧的时候还是之前那个左节点</code></p><p>首先讲这道题目是想告诉你，<strong>二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情</strong>。</p><p>这种洞察力需要多刷题训练，我们看下一道题</p><h4 id="第二题、填充二叉树节点的右侧指针"><a href="#第二题、填充二叉树节点的右侧指针" class="headerlink" title="第二题、填充二叉树节点的右侧指针"></a>第二题、填充二叉树节点的右侧指针</h4><p>这是力扣第 116 题，看下题目：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220806.jpg" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">root</span>):</span></span><br></pre></td></tr></table></figure><p>题目的意思就是把二叉树的每一层节点都用<code>next</code>指针连接起来：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220820.jpg" alt=""></p><p>而且题目说了，输入是一棵「完美二叉树」，形象地说整棵二叉树是一个正三角形，除了最右侧的节点<code>next</code>指针会指向<code>null</code>，其他节点的右侧一定有相邻的节点。</p><p>这道题怎么做呢？把每一层的节点穿起来，是不是只要把每个节点的左右子节点都穿起来就行了？</p><p>我们可以模仿上一道题，写出如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">and</span> root.left == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    root.left.<span class="built_in">next</span> = root.right</span><br><span class="line"></span><br><span class="line">    connect(root.left)</span><br><span class="line">    connect(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>这样其实有很大问题，再看看这张图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220834.jpg" alt=""></p><p>节点 5 和节点 6 不属于同一个父节点，那么按照这段代码的逻辑，它俩就没办法被穿起来，这是不符合题意的。</p><p>回想刚才说的，<strong>二叉树的问题难点在于，如何把题目的要求细化成每个节点需要做的事情</strong>，但是如果只依赖一个节点的话，肯定是没办法连接<code>「跨父节点」</code>的两个相邻节点的。</p><p>那么，我们的做法就是增加函数参数，一个节点做不到，我们就给他安排两个节点，<code>「将每一层二叉树节点连接起来」</code>可以细化成<code>「将每两个相邻节点都连接起来」</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    connectTwoNode(root.left, root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义：输入两个节点，将它俩连接起来</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectTwoNode</span>(<span class="params">Node node1, Node node2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node1 == <span class="literal">None</span> <span class="keyword">and</span> node2 == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">#### 前序遍历位置 ####</span></span><br><span class="line">    <span class="comment"># 将传入的两个节点连接</span></span><br><span class="line">    node1.<span class="built_in">next</span> = node2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接相同父节点的两个子节点</span></span><br><span class="line">    connectTwoNode(node1.left, node1.right)</span><br><span class="line">    connectTwoNode(node2.left, node2.right)</span><br><span class="line">    <span class="comment"># 连接跨越父节点的两个子节点</span></span><br><span class="line">    connectTwoNode(node1.right, node2.left)</span><br></pre></td></tr></table></figure><p>这样，<code>connectTwoNode</code>函数不断递归，可以无死角覆盖整棵二叉树，将所有相邻节点都连接起来，也就避免了我们之前出现的问题，这道题就解决了。</p><h4 id="第三题、将二叉树展开为链表"><a href="#第三题、将二叉树展开为链表" class="headerlink" title="第三题、将二叉树展开为链表"></a>第三题、将二叉树展开为链表</h4><p>这是力扣第 114 题，看下题目：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220851.jpg" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">root</span>):</span></span><br></pre></td></tr></table></figure><p>我们尝试给出这个函数的定义：</p><p><strong>给<code>flatten</code>函数输入一个节点<code>root</code>，那么以<code>root</code>为根的二叉树就会被拉平为一条链表</strong>。</p><p>我们再梳理一下，如何按题目要求把一棵树拉平成一条链表？很简单，以下流程：</p><p>1、将<code>root</code>的左子树和右子树拉平。</p><p>2、将<code>root</code>的右子树接到左子树下方，然后将整个左子树作为右子树。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220915.jpg" alt=""></p><p>上面三步看起来最难的应该是第一步对吧，如何把<code>root</code>的左右子树拉平？其实很简单，按照<code>flatten</code>函数的定义，对<code>root</code>的左右子树递归调用<code>flatten</code>函数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义：将以 root 为根的树拉平为链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    flatten(root.left)</span><br><span class="line">    flatten(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment">##### 后序遍历位置 #####</span></span><br><span class="line">    <span class="comment"># 1、左右子树已经被拉平成一条链表</span></span><br><span class="line">    left = root.left</span><br><span class="line">    right = root.right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、将左子树作为右子树</span></span><br><span class="line">    root.left = <span class="literal">None</span></span><br><span class="line">    root.right = left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3、将原先的右子树接到当前右子树的末端</span></span><br><span class="line">    p = root</span><br><span class="line">    <span class="keyword">while</span> p.right != <span class="literal">None</span>:</span><br><span class="line">        p = p.right</span><br><span class="line">        </span><br><span class="line">    p.right = right</span><br></pre></td></tr></table></figure><p>你看，这就是递归的魅力，你说<code>flatten</code>函数是怎么把左右子树拉平的？不容易说清楚，<strong>但是只要知道<code>flatten</code>的定义如此，相信这个定义，让<code>root</code>做它该做的事情，然后<code>flatten</code>函数就会按照定义工作。</strong></p><p>另外注意递归框架是后序遍历，因为我们要先拉平左右子树才能进行后续操作。</p><p>至此，这道题也解决了，与 <code>[k 个一组反转链表]</code> 的递归思路和本题也有一些类似。</p><blockquote><h3 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h3></blockquote><p>递归算法的关键要明确函数的定义，相信这个定义，而不要跳进递归细节。</p><p>写二叉树的算法题，都是基于递归框架的，我们先要搞清楚<code>root</code>节点它自己要做什么，然后根据题目要求选择使用前序，中序，后续的递归框架。</p><p>二叉树题目的难点在于如何通过题目的要求思考出每一个节点需要做什么，这个只能通过多刷题进行练习了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树之常用框架&quot;&gt;&lt;a href=&quot;#二叉树之常用框架&quot; class=&quot;headerlink&quot; title=&quot;二叉树之常用框架&quot;&gt;&lt;/a&gt;二叉树之常用框架&lt;/h2&gt;&lt;p&gt;读完本文，你可以去力扣拿下：&lt;/p&gt;
&lt;p&gt;226.翻转二叉树，难度 &lt;strong&gt;Eas</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>08-动态规划之详解最长公共子序列系列问题</title>
    <link href="https://xxren8218.github.io/20210628/08-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%AF%A6%E8%A7%A3%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210628/08-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%AF%A6%E8%A7%A3%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98.html</id>
    <published>2021-06-28T14:02:58.000Z</published>
    <updated>2021-06-28T16:46:17.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划之详解最长公共子序列"><a href="#动态规划之详解最长公共子序列" class="headerlink" title="动态规划之详解最长公共子序列"></a>动态规划之详解最长公共子序列</h2><p><strong>本文从「最长公共子序列问题」展开，总结三道子序列问题</strong>，解这道题仔细讲讲这种子序列问题的套路，你就能感受到这种思维方式了。</p><blockquote><h3 id="一、最长公共子序列"><a href="#一、最长公共子序列" class="headerlink" title="一、最长公共子序列"></a>一、最长公共子序列</h3></blockquote><p>计算最长公共子序列（Longest Common Subsequence，简称 LCS）是一道经典的动态规划题目，大家应该都见过：</p><p>给你输入两个字符串<code>s1</code>和<code>s2</code>，请你找出他们俩的最长公共子序列，返回这个子序列的长度。</p><p>力扣第 1143 题就是这道题，函数签名如下：</p><p>计算最长公共子序列（Longest Common Subsequence，简称 LCS）是一道经典的动态规划题目，大家应该都见过：</p><p>给你输入两个字符串<code>s1</code>和<code>s2</code>，请你找出他们俩的最长公共子序列，返回这个子序列的长度。</p><p>力扣第 1143 题就是这道题，函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">s1, s2</span>):</span></span><br></pre></td></tr></table></figure><p>比如说输入<code>s1 = &quot;zabcde&quot;, s2 = &quot;acez&quot;</code>，它俩的最长公共子序列是<code>lcs = &quot;ace&quot;</code>，长度为 3，所以算法返回 3。</p><p>如果没有做过这道题，一个最简单的暴力算法就是，把<code>s1</code>和<code>s2</code>的所有子序列都穷举出来，然后看看有没有公共的，然后在所有公共子序列里面再寻找一个长度最大的。</p><p>显然，这种思路的复杂度非常高，你要穷举出所有子序列，这个复杂度就是指数级的，肯定不实际。</p><p>正确的思路是不要考虑整个字符串，而是细化到<code>s1</code>和<code>s2</code>的每个字符。前文 子序列解题模板 中总结的一个规律：</p><p><strong>对于两个字符串求子序列的问题，都是用两个指针<code>i</code>和<code>j</code>分别在两个字符串上移动，大概率是动态规划思路</strong>。</p><p>最长公共子序列的问题也可以遵循这个规律，我们可以先写一个<code>dp</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line">dp(s1, i, s2, j)</span><br></pre></td></tr></table></figure><p>这个<code>dp</code>函数的定义是：<strong><code>dp(s1, i, s2, j)</code>计算<code>s1[i..]</code>和<code>s2[j..]</code>的最长公共子序列长度</strong>。</p><p>根据这个定义，那么我们想要的答案就是<code>dp(s1, 0, s2, 0)</code>，且 base case 就是<code>i == len(s1)</code>或<code>j == len(s2)</code>时，因为这时候<code>s1[i..]</code>或<code>s2[j..]</code>就相当于空串了，最长公共子序列的长度显然是 0：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">s1, s2</span>):</span> </span><br><span class="line">    <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">s1, i, s2, j</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="built_in">len</span>(s1) <span class="keyword">or</span> j == <span class="built_in">len</span>(s2):</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p><strong>接下来，咱不要看<code>s1</code>和<code>s2</code>两个字符串，而是要具体到每一个字符，思考每个字符该做什么</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220432.jpg" alt=""></p><p>我们只看<code>s1[i]</code>和<code>s2[j]</code>，<strong>如果<code>s1[i] == s2[j]</code>，说明这个字符一定在<code>lcs</code>中</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220447.jpg" alt=""></p><p>这样，就找到了一个<code>lcs</code>中的字符，根据<code>dp</code>函数的定义，我们可以完善一下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">s1, i, s2, j</span>):</span></span><br><span class="line">    <span class="keyword">if</span> si[i] == s2[j]:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 必然在 lcs 中，</span></span><br><span class="line">        <span class="comment"># 加上 s1[i+1..] 和 s2[j+1..] 中的 lcs 长度，就是答案</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>刚才说的<code>s1[i] == s2[j]</code>的情况，但如果<code>s1[i] != s2[j]</code>，应该怎么办呢？</p><p><strong><code>s1[i] != s2[j]</code>意味着，<code>s1[i]</code>和<code>s2[j]</code>中至少有一个字符不在<code>lcs</code>中</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220502.jpg" alt=""></p><p>如上图，总共可能有三种情况，我怎么知道具体是那种情况呢？</p><p>其实我们也不知道，那就把这三种情况的答案都算出来，取其中结果最大的那个呗，因为题目让我们算「最长」公共子序列的长度嘛。</p><p>这三种情况的答案怎么算？回想一下我们的<code>dp</code>函数定义，不就是专门为了计算它们而设计的嘛！</p><p>代码可以再进一步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">s1, i, s2, j</span>):</span></span><br><span class="line">    <span class="keyword">if</span> si[i] == s2[j]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 中至少有一个字符不在 lcs 中，</span></span><br><span class="line">        <span class="comment"># 穷举三种情况的结果，取其中的最大结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(</span><br><span class="line">                    <span class="comment"># 情况一、s1[i] 不在 lcs 中</span></span><br><span class="line">                    dp(s1, i + <span class="number">1</span>, s2, j),</span><br><span class="line">                    <span class="comment"># 情况二、s2[j] 不在 lcs 中</span></span><br><span class="line">                    dp(s1, i, s2, j + <span class="number">1</span>),</span><br><span class="line">                    <span class="comment"># 情况三、都不在 lcs 中</span></span><br><span class="line">                    dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">          )</span><br></pre></td></tr></table></figure><p>这里就已经非常接近我们的最终答案了，<strong>还有一个小的优化，情况三「<code>s1[i]</code>和<code>s2[j]</code>都不在 lcs 中」其实可以直接忽略</strong>。</p><p>因为我们在求最大值嘛，情况三在计算<code>s1[i+1..]</code>和<code>s2[j+1..]</code>的<code>lcs</code>长度，这个长度肯定是小于等于情况二<code>s1[i..]</code>和<code>s2[j+1..]</code>中的<code>lcs</code>长度的，因为<code>s1[i+1..]</code>比<code>s1[i..]</code>短嘛，那从这里面算出的<code>lcs</code>当然也不可能更长嘛。</p><p>同理，情况三的结果肯定也小于等于情况一。<strong>说白了，情况三被情况一和情况二包含了</strong>，所以我们可以直接忽略掉情况三，完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">s1, s2</span>):</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">    <span class="comment"># 备忘录值为 -1 代表未曾计算</span></span><br><span class="line">    memo = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]  </span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 计算 s1[0..] 和 s2[0..] 的 lcs 长度</span></span><br><span class="line">    <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">s1, i, s2, j</span>):</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(s1) <span class="keyword">or</span> j == <span class="built_in">len</span>(s2):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 如果之前计算过，则直接返回备忘录中的答案</span></span><br><span class="line">    <span class="keyword">if</span> memo[i][j] != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> memo[i][j]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据 s1[i] 和 s2[j] 的情况做选择</span></span><br><span class="line">    <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 必然在 lcs 中</span></span><br><span class="line">        memo[i][j] = <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 至少有一个不在 lcs 中</span></span><br><span class="line">        memo[i][j] = <span class="built_in">max</span>(</span><br><span class="line">            dp(s1, i + <span class="number">1</span>, s2, j),</span><br><span class="line">            dp(s1, i, s2, j + <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> memo[i][j]</span><br></pre></td></tr></table></figure><p>以上思路完全就是按照我们之前的 <code>动态规划详解</code> 的框架来的，应该是很容易理解的。至于为什么要加<code>memo</code>备忘录，，这里再简单重复一下，首先抽象出我们核心<code>dp</code>函数的递归框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> j</span>):</span></span><br><span class="line">    dp(i + <span class="number">1</span>, j + <span class="number">1</span>)   <span class="comment">#1</span></span><br><span class="line">    dp(i, j + <span class="number">1</span>)       <span class="comment">#2</span></span><br><span class="line">    dp(i + <span class="number">1</span>, j)       <span class="comment">#3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你看，假设我想从<code>dp(i, j)</code>转移到<code>dp(i+1, j+1)</code>，有不止一种方式，可以直接走<code>#1</code>，也可以走<code>#2 -&gt; #3</code>，也可以走<code>#3 -&gt; #2</code>。</p><p>这就是重叠子问题，如果我们不用<code>memo</code>备忘录消除子问题，那么<code>dp(i+1, j+1)</code>就会被多次计算，这是没有必要的。</p><p>至此，最长公共子序列问题就完全解决了，用的是自顶向下带备忘录的动态规划思路。</p><p>下面，来看两道和最长公共子序列相似的两道题目。</p><blockquote><h3 id="二、字符串的删除操作"><a href="#二、字符串的删除操作" class="headerlink" title="二、字符串的删除操作"></a>二、字符串的删除操作</h3></blockquote><p>这是力扣第 583 题「两个字符串的删除操作」，看下题目：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629004432.jpg" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">s1, s2</span>):</span></span><br></pre></td></tr></table></figure><p>题目让我们计算将两个字符串变得相同的最少删除次数，那我们可以思考一下，最后这两个字符串会被删成什么样子？</p><p>删除的结果不就是它俩的最长公共子序列嘛！</p><p>那么，要计算删除的次数，就可以通过最长公共子序列的长度推导出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">s1, s2</span>):</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">    <span class="comment"># 复用前文计算 lcs 长度的函数</span></span><br><span class="line">    lcs = longestCommonSubsequence(s1, s2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> m - lcs + n - lcs;</span><br></pre></td></tr></table></figure><p><strong>完整代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.memo = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, s1, s2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">        <span class="comment"># 备忘录值为 -1 代表未曾计算</span></span><br><span class="line">        self.memo = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]  </span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 计算 s1[0..] 和 s2[0..] 的 lcs 长度</span></span><br><span class="line">        lcs = self.dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> m - lcs + n - lcs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">self, s1, i, s2, j</span>):</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(s1) <span class="keyword">or</span> j == <span class="built_in">len</span>(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 如果之前计算过，则直接返回备忘录中的答案</span></span><br><span class="line">        <span class="keyword">if</span> self.memo[i][j] != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.memo[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据 s1[i] 和 s2[j] 的情况做选择</span></span><br><span class="line">        <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">            <span class="comment"># s1[i] 和 s2[j] 必然在 lcs 中</span></span><br><span class="line">            self.memo[i][j] = <span class="number">1</span> + self.dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># s1[i] 和 s2[j] 至少有一个不在 lcs 中</span></span><br><span class="line">            self.memo[i][j] = <span class="built_in">max</span>(</span><br><span class="line">                            self.dp(s1, i + <span class="number">1</span>, s2, j),</span><br><span class="line">                            self.dp(s1, i, s2, j + <span class="number">1</span>)</span><br><span class="line">                            )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.memo[i][j]</span><br></pre></td></tr></table></figure><p>这道题就解决了！</p><blockquote><h3 id="三、最小-ASCII-删除和"><a href="#三、最小-ASCII-删除和" class="headerlink" title="三、最小 ASCII 删除和"></a>三、最小 ASCII 删除和</h3></blockquote><p>这是力扣第 712 题，看下题目：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210629004602.jpg" alt=""></p><p>这道题，和上一道题非常类似，这回不问我们删除的字符个数了，问我们删除的字符的 ASCII 码加起来是多少。</p><p>那就不能直接复用计算最长公共子序列的函数了，但是可以依照之前的思路，<strong>稍微修改 base case 和状态转移部分即可直接写出解法代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumDeleteSum</span>(<span class="params">s1, s2</span>):</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">    <span class="comment"># 备忘录值为 -1 代表未曾计算</span></span><br><span class="line">memo = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，</span></span><br><span class="line"><span class="comment"># 最小的 ASCII 码之和为 dp(s1, i, s2, j)。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">s1, i, s2, j</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(s1):</span><br><span class="line">        <span class="comment"># 如果 s1 到头了，那么 s2 剩下的都得删除</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(s2)):</span><br><span class="line">            res += <span class="built_in">ord</span>(s2[j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> j == <span class="built_in">len</span>(s2):</span><br><span class="line">        <span class="comment"># 如果 s2 到头了，那么 s1 剩下的都得删除</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(s1)):</span><br><span class="line">            res += <span class="built_in">ord</span>(s1[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> memo[i][j] != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> memo[i][j]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 都是在 lcs 中的，不用删除</span></span><br><span class="line">        memo[i][j] = dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个</span></span><br><span class="line">        memo[i][j] = <span class="built_in">min</span>(</span><br><span class="line">            <span class="built_in">ord</span>(s1[i]) + dp(s1, i + <span class="number">1</span>, s2, j),</span><br><span class="line">            <span class="built_in">ord</span>(s2[j]) + dp(s1, i, s2, j + <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> memo[i][j]</span><br></pre></td></tr></table></figure><p>base case 有一定区别，计算<code>lcs</code>长度时，如果一个字符串为空，那么<code>lcs</code>长度必然是 0；但是这道题如果一个字符串为空，另一个字符串必然要被全部删除，所以需要计算另一个字符串所有字符的 ASCII 码之和。</p><p>关于状态转移，当<code>s1[i]</code>和<code>s2[j]</code>相同时不需要删除，不同时需要删除，所以可以利用<code>dp</code>函数计算两种情况，得出最优的结果。其他的大同小异，就不具体展开了。</p><p>也可以这样：思路一样：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210628220518.PNG" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumDeleteSum</span>(<span class="params">self, s1, s2</span>):</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (<span class="built_in">len</span>(s2) + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1) + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确定table的初始条件。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="built_in">len</span>(s2)] = dp[i+<span class="number">1</span>][<span class="built_in">len</span>(s2)] + <span class="built_in">ord</span>(s1[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[<span class="built_in">len</span>(s1)][j] = dp[<span class="built_in">len</span>(s1)][j+<span class="number">1</span>] + <span class="built_in">ord</span>(s2[j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j] + <span class="built_in">ord</span>(s1[i]),</span><br><span class="line">                                   dp[i][j+<span class="number">1</span>] + <span class="built_in">ord</span>(s2[j]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>至此，三道子序列问题就解决完了，关键在于将问题细化到字符，根据每两个字符是否相同来判断他们是否在结果子序列中，从而避免了对所有子序列进行穷举。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;动态规划之详解最长公共子序列&quot;&gt;&lt;a href=&quot;#动态规划之详解最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;动态规划之详解最长公共子序列&quot;&gt;&lt;/a&gt;动态规划之详解最长公共子序列&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文从「最长公共子序列问题」</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>00-二(N)叉树的深度遍历——递归&amp;迭代</title>
    <link href="https://xxren8218.github.io/20210627/00-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3.html"/>
    <id>https://xxren8218.github.io/20210627/00-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3.html</id>
    <published>2021-06-27T06:22:25.000Z</published>
    <updated>2021-07-01T11:01:32.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的深度遍历——递归-amp-迭代"><a href="#二叉树的深度遍历——递归-amp-迭代" class="headerlink" title="二叉树的深度遍历——递归&amp;迭代"></a>二叉树的深度遍历——递归&amp;迭代</h2><p>读完本文，你可以去力扣拿下：</p><p>144.二叉树的前序遍历：难度  <strong>Easy</strong></p><p>145.二叉树的后序遍历：难度 <strong>Easy</strong></p><p>94.二叉树的中序遍历 ：难度 <strong>Easy</strong></p><p>本文所讲的是：二叉树的深度遍历逻辑。一般分为递归版本和非递归的版本。说到递归，很多人不禁会想到一个词：<strong>‘谈归色变’</strong>，不知道进去后怎么处理。甚至不知道怎么进去的。递归其实没那么困难。这里介绍递归三部曲：</p><ul><li>确定递归的参数和返回值——参数一般<code>头结点指针（cur）</code>,<code>返回值一般为列表</code></li><li>确定递归终止条件——if cur == None: return</li><li>单层递归的逻辑<ul><li>前序：中左右<ul><li>中：res.append(cur.val)</li><li>左：traversal(cur.left)</li><li>右：traversal(cur.right)</li></ul></li><li>后序：左右中<ul><li>左：traversal(cur.left)</li><li>右：traversal(cur.right)</li><li>中：res.append(cur.val)</li></ul></li><li>中序：左中右<ul><li>左：traversal(cur.left)</li><li>中：res.append(cur.val)</li><li>右：traversal(cur.right)</li></ul></li></ul></li></ul><blockquote><h3 id="1-二叉树的遍历（递归法）"><a href="#1-二叉树的遍历（递归法）" class="headerlink" title="1.二叉树的遍历（递归法）"></a>1.二叉树的遍历（递归法）</h3></blockquote><h4 id="1-1-二叉树的前序遍历"><a href="#1-1-二叉树的前序遍历" class="headerlink" title="1.1 二叉树的前序遍历"></a>1.1 二叉树的前序遍历</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630202346.PNG" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br></pre></td></tr></table></figure><p>首先我们需要了解什么是二叉树的前序遍历：按照访问根节点——左子树——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。</p><p>递归的解题思路很简单，这里直接写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">prev</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">            res.append(root.val)</span><br><span class="line">            prev(root.left)</span><br><span class="line">            prev(root.right)</span><br><span class="line"></span><br><span class="line">        prev(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="1-2-二叉树的后序遍历"><a href="#1-2-二叉树的后序遍历" class="headerlink" title="1.2 二叉树的后序遍历"></a>1.2 二叉树的后序遍历</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630202402.PNG" alt=""></p><p>函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br></pre></td></tr></table></figure><p>按照我们前面的框架直接可以写出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">            postorder(root.left)</span><br><span class="line">            postorder(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        </span><br><span class="line">        postorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="1-3-二叉树的中序遍历"><a href="#1-3-二叉树的中序遍历" class="headerlink" title="1.3 二叉树的中序遍历"></a>1.3 二叉树的中序遍历</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630202415.PNG" alt=""></p><p>按照我们前面的框架直接可以写出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line"></span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><h3 id="2-二叉树的遍历（迭代法）"><a href="#2-二叉树的遍历（迭代法）" class="headerlink" title="2. 二叉树的遍历（迭代法）"></a>2. 二叉树的遍历（迭代法）</h3></blockquote><p>我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来。</p><p>因为函数本身调用就是基于栈实现的，原则上所有的递归都可以用栈来实现。所以这里用栈来实现。</p><h4 id="2-1-二叉树的前序遍历"><a href="#2-1-二叉树的前序遍历" class="headerlink" title="2.1 二叉树的前序遍历"></a>2.1 二叉树的前序遍历</h4><p>我们先看⼀下前序遍历。<br>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放⼊栈中，然后将右孩⼦加⼊栈，再加<br>⼊左孩⼦。<br>为什么要先加⼊ 右孩⼦，再加⼊左孩⼦呢？ 因为这样出栈的时候才是中左右的顺序。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630202431.gif" alt=""></p><p>不难写出如下代码: （注意代码中空节点不⼊栈）  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span>[]</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="comment"># 从栈中弹出node节点</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断node节点是否为空</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">            <span class="comment"># 若不为空，将node节点的值加入结果res列表中</span></span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 若为空，结束本次循环（他没有左右孩子）</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将右左孩子分别添加进stack中，因为是栈,所以先处理的是左</span></span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="2-2-二叉树的后序遍历"><a href="#2-2-二叉树的后序遍历" class="headerlink" title="2.2 二叉树的后序遍历"></a>2.2 二叉树的后序遍历</h4><p>对于后序遍历而言，我们很容易看出来。</p><ul><li>前序遍历为： <strong>中左右</strong></li><li>后序遍历为：<strong>左右中</strong></li></ul><p>发现他们的特点，我们可以执行这样的操作：将前序遍历的左右调换，成为<strong>中右左</strong>了，然后调用切片反转就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span>[]</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            stack.append(node.left)    <span class="comment">## 注意</span></span><br><span class="line">            stack.append(node.right)   <span class="comment">## 注意</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]  <span class="comment">## 注意  </span></span><br></pre></td></tr></table></figure><h4 id="2-3-二叉树的中序遍历"><a href="#2-3-二叉树的中序遍历" class="headerlink" title="2.3 二叉树的中序遍历"></a>2.3 二叉树的中序遍历</h4><p>此时是不是想改⼀点前序遍历代码顺序就把中序遍历搞出来了？<strong>其实还真不⾏！</strong><br>但接下来， 再⽤迭代法写中序遍历的时候，会发现套路⼜不⼀样了，⽬前的前序遍历的逻辑⽆法直接应<br>⽤到中序遍历上。  </p><p>为了解释清楚，我说明⼀下 刚刚在迭代的过程中，其实我们有两个操作：</p><ol><li>处理：将元素放进result数组中</li><li>访问：遍历节点</li></ol><p>分析⼀下为什么刚刚写的前序遍历的代码，不能和中序遍历通⽤呢，因为前序遍历的顺序是中左右，先<br>访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码， <strong>因为要访问<br>的元素和要处理的元素顺序是⼀致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是⼆叉树顶部的节点，然后⼀层⼀层向下访问，直<br>到到达树左⾯的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理<br>顺序和访问顺序是不⼀致的。  </strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><p>动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210630202638.gif" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当指针为空，且栈为空时停止</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="comment"># 若当前指针不为空，将当前访问元素加到栈内。</span></span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                <span class="comment"># 指针继续左走（左中右）,一路向左</span></span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment"># 若zcur为空，说明到达最左边了.</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 此时弹出栈顶元素——最左边的节点</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 遍历当前指针的右孩子</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>至此！迭代遍历的三种方法也已经得出了！</p><blockquote><h3 id="3-N叉树的遍历（迭代法）"><a href="#3-N叉树的遍历（迭代法）" class="headerlink" title="3. N叉树的遍历（迭代法）"></a>3. N叉树的遍历（迭代法）</h3></blockquote><h4 id="3-1-N叉树的前序遍历"><a href="#3-1-N叉树的前序遍历" class="headerlink" title="3.1 N叉树的前序遍历"></a>3.1 N叉树的前序遍历</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701190013.PNG" alt=""></p><p>思路和二叉树的差不多，比较简单直接写代码，注意点：写个for来遍历全部孩子即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">prev</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">                prev(child)</span><br><span class="line"></span><br><span class="line">        prev(root)    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="3-2-N叉树的后序遍历"><a href="#3-2-N叉树的后序遍历" class="headerlink" title="3.2 N叉树的后序遍历"></a>3.2 N叉树的后序遍历</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701190029.PNG" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">                post(child)</span><br><span class="line">            res.append(root.val)</span><br><span class="line"></span><br><span class="line">        post(root)    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><h3 id="4-N叉树的遍历（迭代法）"><a href="#4-N叉树的遍历（迭代法）" class="headerlink" title="4. N叉树的遍历（迭代法）"></a>4. N叉树的遍历（迭代法）</h3></blockquote><h4 id="4-1-N叉树的前序遍历"><a href="#4-1-N叉树的前序遍历" class="headerlink" title="4.1 N叉树的前序遍历"></a>4.1 N叉树的前序遍历</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701190013.PNG" alt=""></p><p>我们使用栈来帮助我们得到前序遍历，需要保证栈顶的节点就是我们当前遍历到的节点。</p><p>我们首先把根节点入栈，因为根节点是前序遍历中的第一个节点。随后每次我们从栈顶取出一个节点 u，它是我们当前遍历到的节点，并把 u 的所有子节点逆序推入栈中。例如 u 的子节点从左到右为 v1, v2, v3，那么推入栈的顺序应当为 v3, v2, v1，这样就保证了下一个遍历到的节点（即 u 的第一个子节点 v1）出现在栈顶的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            <span class="comment"># 注意append 和 extend 方法的区别：</span></span><br><span class="line">            <span class="comment">## a = []</span></span><br><span class="line">            <span class="comment">## a.extend[1,2,3,4] -&gt; [1,2,3,4]</span></span><br><span class="line">            <span class="comment">## a.append([1,2,3,4]) -&gt; [[1,2,3,4]]</span></span><br><span class="line">            stack.extend(cur.children[::-<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="4-2-N叉树的后序遍历"><a href="#4-2-N叉树的后序遍历" class="headerlink" title="4.2 N叉树的后序遍历"></a>4.2 N叉树的后序遍历</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210701190029.PNG" alt=""></p><p>通过观察结果，我们可以看到若是将后序遍历的结果进行反转可以得到<code>[1,4,2,3,6,5]</code>,即先遍历父节点，再从右往左遍历子节点。结果和前序遍历非常类似，只不过前序遍历中对子节点的遍历顺序是 v1, v2, v3，而这里是 v3, v2, v1。</p><p>因此我们可以使用和 <code>N叉树的前序遍历</code> 相同的方法，使用一个栈来得到后序遍历。我们首先把根节点入栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            stack.extend(cur.children[::<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3></blockquote><p>我们用普通的递归的方法来实现二叉树的前序、后序和中序遍历。还用迭代的方式实现三种遍历方法。其实二叉树不仅仅有深度优先遍历（DFS）还有一种遍历方式：广度优先遍历（BFS）。后面我们会开始BFS的探索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树的深度遍历——递归-amp-迭代&quot;&gt;&lt;a href=&quot;#二叉树的深度遍历——递归-amp-迭代&quot; class=&quot;headerlink&quot; title=&quot;二叉树的深度遍历——递归&amp;amp;迭代&quot;&gt;&lt;/a&gt;二叉树的深度遍历——递归&amp;amp;迭代&lt;/h2&gt;&lt;p&gt;读完</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>23-大数据产品与互联网产品结合</title>
    <link href="https://xxren8218.github.io/20210626/23-%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BA%A7%E5%93%81%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81%E7%BB%93%E5%90%88.html"/>
    <id>https://xxren8218.github.io/20210626/23-%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BA%A7%E5%93%81%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81%E7%BB%93%E5%90%88.html</id>
    <published>2021-06-25T16:53:04.000Z</published>
    <updated>2021-06-25T16:56:01.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-大数据产品与互联网产品结合"><a href="#1-大数据产品与互联网产品结合" class="headerlink" title="1. 大数据产品与互联网产品结合"></a>1. 大数据产品与互联网产品结合</h3><ul><li>分布式系统执行任务瓶颈: 延迟高 MapReduce 几分钟 Spark几秒钟</li><li>互联网产品要求<ul><li>毫秒级响应(1秒以内完成)</li><li>需要通过大数据实现 统计分析 数据挖掘 关联推荐 用户画像</li></ul></li><li>如何将他们结合起来?</li><li>大数据平台<ul><li>整合网站应用和大数据系统之间的差异, 将应用产生的数据导入到大数据系统, 经过处理计算后再导出给应用程序使用</li></ul></li><li>互联网大数据平台架构:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626005416.png" alt=""></p><ul><li>数据采集<ul><li>App/Web 产生的数据&amp;日志同步到大数据系统</li><li>数据库同步:Sqoop  日志同步:Flume 打点: Kafka</li><li>不同数据源产生的数据质量可能差别很大<ul><li>数据库 也许可以直接用</li><li>日志 爬虫 大量的清洗,转化处理 ETL</li></ul></li></ul></li><li><p>数据处理</p><ul><li>大数据存储与计算的核心</li><li>数据同步后导入HDFS</li><li>MapReduce Hive Spark 读取数据进行计算 结果再保存到HDFS</li><li>MapReduce Hive Spark 离线计算, HDFS 离线存储<ul><li>离线计算通常针对(某一类别)全体数据, 比如 历史上所有订单</li><li>离线计算特点: 数据规模大, 运行时间长</li></ul></li><li>流式计算<ul><li>淘宝双11 每秒产生订单数 监控宣传</li><li>Storm(毫秒) SparkStreaming(秒)</li></ul></li></ul></li><li><p>数据输出与展示</p><ul><li>HDFS需要把数据导出交给应用程序, 让用户实时展示  ECharts<ul><li>淘宝卖家量子魔方</li></ul></li><li>给运营和决策层提供各种统计报告, 数据需要写入数据库<ul><li>很多运营管理人员, 上班后就会登陆后台数据系统</li></ul></li></ul></li><li>任务调度系统<ul><li>将上面三个部分整合起来</li></ul></li></ul><h3 id="2-大数据应用—数据分析"><a href="#2-大数据应用—数据分析" class="headerlink" title="2. 大数据应用—数据分析"></a>2. 大数据应用—数据分析</h3><ul><li><p>通过数据分析指标监控企业运营状态, 及时调整运营和产品策略,是大数据技术的关键价值之一</p></li><li><p>大数据平台(互联网企业)运行的绝大多数大数据计算都是关于数据分析的</p><ul><li>统计指标</li><li>关联分析,</li><li>汇总报告,</li></ul></li><li><p>运营数据是公司管理的基础</p><ul><li>了解公司目前发展的状况</li><li>数据驱动运营: 调节指标对公司进行管理</li></ul></li><li><p>运营数据的获取需要大数据平台的支持</p><ul><li>埋点采集数据</li><li>数据库,日志 三方采集数据</li><li>对数据清洗 转换 存储 </li><li>利用SQL进行数据统计 汇总 分析</li><li>得到需要的运营数据报告</li></ul></li><li><p>运营常用数据指标</p><ul><li><p>新增用户数  UG  user growth 用户增长</p><ul><li>产品增长性的关键指标</li><li>新增访问网站(新下载APP)的用户数</li></ul></li><li><p>用户留存率</p><ul><li>用户留存率 = 留存用户数 / 当期新增用户数</li><li>3日留存  5日留存 7日留存</li></ul></li><li><p>活跃用户数</p><ul><li>打开使用产品的用户</li><li>日活</li><li>月活</li><li>提升活跃是网站运营的重要目标</li></ul></li><li><p>PV Page View</p><ul><li>打开产品就算活跃</li><li>打开以后是否频繁操作就用PV衡量, 每次点击, 页面跳转都记一次PV</li></ul></li><li><p>GMV</p><ul><li>成交总金额(Gross Merchandise Volume) 电商网站统计营业额, 反应网站营收能力的重要指标</li><li>GMV相关的指标: 订单量 客单价</li></ul></li><li><p>转化率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转化率 = 有购买行为的用户数 / 总访问用户数</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-数据分析案例"><a href="#3-数据分析案例" class="headerlink" title="3. 数据分析案例"></a>3. 数据分析案例</h3><ul><li><p>背景: 某电商网站, 垂直领域领头羊, 各项指标相对稳定</p></li><li><p>运营人员发现从 8 月 15 日开始，网站的订单量连续四天明显下跌</p></li><li><p>8 月 18 号早晨发现 8 月 17 号的订单量没有恢复正常，运营人员开始尝试寻找原因</p><ul><li>是否有负面报道被扩散</li><li>是否竞争对手在做活动</li><li>是否某类商品缺货</li><li>价格异常</li></ul></li><li><p>没有找到原因, 将问题交给数据分析团队</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626005454.png" alt=""></p></li><li><p>数据分析师分析可能性</p><ul><li>新增用户出现问题</li><li>查看日活数据, 发现日活没有明显下降<ul><li>基本判断, 用户在访问网站的过程中,转化出了问题</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626005512.png" alt=""></p></li><li><p>转化过程:</p><ul><li>打开APP</li><li>搜索关键词 浏览搜索结果列表</li><li>点击商品访问详情</li><li>有购买意向开始咨询</li><li>放入购物车</li><li>支付</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626005536.png" alt=""></p></li><li><p>订单活跃转化率 = 日订单量 / 打开用户数</p></li><li><p>搜索打开转化率 = 搜索用户数 / 打开用户数</p></li><li><p>有明显降幅的是咨询详情转化率</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626005548.png" alt=""></p><ul><li>对咨询信息分类统计后发现，新用户的咨询量几乎为 0</li><li>于是将问题提交给技术部门调查，工程师查看 8 月 15 日当天发布记录,发现有消息队列SDK更新</li></ul></li></ul><p><strong>Hadoop企业应用案例之消费大数据</strong></p><p>亚马逊提前发货系统</p><p><strong>Hadoop企业案例之商业零售大数据</strong></p><p>智能推荐</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-大数据产品与互联网产品结合&quot;&gt;&lt;a href=&quot;#1-大数据产品与互联网产品结合&quot; class=&quot;headerlink&quot; title=&quot;1. 大数据产品与互联网产品结合&quot;&gt;&lt;/a&gt;1. 大数据产品与互联网产品结合&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;分布式系统执行任务瓶</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>22-hadoop概念扩展——生态与HDFS的读写等</title>
    <link href="https://xxren8218.github.io/20210626/22-hadoop%E6%A6%82%E5%BF%B5%E6%89%A9%E5%B1%95%E2%80%94%E2%80%94%E7%94%9F%E6%80%81%E4%B8%8EHDFS%E7%9A%84%E8%AF%BB%E5%86%99%E7%AD%89.html"/>
    <id>https://xxren8218.github.io/20210626/22-hadoop%E6%A6%82%E5%BF%B5%E6%89%A9%E5%B1%95%E2%80%94%E2%80%94%E7%94%9F%E6%80%81%E4%B8%8EHDFS%E7%9A%84%E8%AF%BB%E5%86%99%E7%AD%89.html</id>
    <published>2021-06-25T16:43:34.000Z</published>
    <updated>2021-06-25T16:49:17.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hadoop概念扩展"><a href="#hadoop概念扩展" class="headerlink" title="hadoop概念扩展"></a>hadoop概念扩展</h2><p>课程目标：</p><ul><li>知道hadoop生态组成</li><li>了解hdfs读写流程</li><li>说出Hadoop发行版本的选择</li></ul><h3 id="1-Hadoop生态系统"><a href="#1-Hadoop生态系统" class="headerlink" title="1. Hadoop生态系统"></a>1. Hadoop生态系统</h3><p><strong>狭义的Hadoop VS 广义的Hadoop</strong></p><ul><li><p>狭义的Hadoop:HDFS、MapReduce、YARN。</p></li><li><p>广义的Hadoop：指的是Hadoop生态系统，Hadoop生态系统是一个很庞大的概念，hadoop是其中最重要最基础的一个部分，生态系统中每一子系统只解决某一个特定的问题域（甚至可能更窄），不搞统一型的全能系统，而是小而精的多个小系统；</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004500.png" alt=""></p><p>Hive:数据仓库——操作MapReuce来操作HDFS（我们的感觉是写SQL，Hive将SQL写成MapReduce的方式。）</p><p>R:数据分析</p><p>Mahout:机器学习库</p><p>pig：脚本语言，跟Hive类似</p><p>Oozie:工作流引擎，管理作业执行顺序</p><p>Zookeeper:用户无感知，主节点挂掉选择从节点作为主的。分布式集群协调工具。数据改变的同步。</p><p>Flume:日志收集框架——将特定目录日志放到HDFS中去。</p><p>Sqoop:数据交换框架，例如：关系型数据库（MySQL、Oracle）与HDFSorHBase之间的数据交换介质。</p><p>Hbase : ——<code>列式存储</code>（MySQL为<code>行式存储</code>——连续存放）海量数据中的查询，相当于分布式文件系统中的数据库</p><p>Spark: 分布式的计算框架基于内存 ——有python的API：pyspark scala写的（java的虚拟机语言）</p><ul><li>spark core——对应MapReduce</li><li>spark sql——对应Hive</li><li>spark streaming 准实时 不算是一个标准的流式计算 对应——storm flink</li><li>spark ML spark MLlib 机器学习的库</li></ul><p>Kafka: 消息队列</p><p>Storm: 分布式的流式计算框架  不适合用python操作storm </p><p>Flink: 分布式的流式计算框架</p><p><strong>Hadoop生态系统的特点</strong></p><ul><li><p>开源、社区活跃</p></li><li><p>囊括了大数据处理的方方面面</p></li><li>成熟的生态圈</li></ul><h3 id="2-HDFS-读写流程-amp-高可用"><a href="#2-HDFS-读写流程-amp-高可用" class="headerlink" title="2. HDFS 读写流程 &amp; 高可用"></a>2. HDFS 读写流程 &amp; 高可用</h3><ul><li><p>HDFS读写流程</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004557.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004627.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004645.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004701.jpg" alt=""></p><ul><li><p>客户端向NameNode发出写文件请求。</p></li><li><p>检查是否已存在文件、检查权限。若通过检查，直接先将操作写入EditLog，并返回输出流对象。<br>（注：WAL，write ahead log，先写Log，再写内存，因为EditLog记录的是最新的HDFS客户端执行所有的写操作。如果后续真实写操作失败了，由于在真实写操作之前，操作就被写入EditLog中了，故EditLog中仍会有记录，我们不用担心后续client读不到相应的数据块，因为在第5步中DataNode收到块后会有一返回确认信息，若没写成功，发送端没收到确认信息，会一直重试，直到成功）</p></li><li><p>client端按128MB的块切分文件。</p></li><li><p>client将NameNode返回的分配的可写的DataNode列表和Data数据一同发送给最近的第一个DataNode节点，此后client端和NameNode分配的多个DataNode构成pipeline管道，client端向输出流对象中写数据。client每向第一个DataNode写入一个packet，这个packet便会直接在pipeline里传给第二个、第三个…DataNode。<br>（注：并不是写好一个块或一整个文件后才向后分发）</p></li><li><p>每个DataNode写完一个块后，会返回确认信息。<br>（注：并不是每写完一个packet后就返回确认信息，个人觉得因为packet中的每个chunk都携带校验信息，没必要每写一个就汇报一下，这样效率太慢。正确的做法是写完一个block块后，对校验信息进行汇总分析，就能得出是否有块写错的情况发生）</p></li><li><p>写完数据，关闭输输出流。</p></li><li><p>发送完成信号给NameNode。</p><p>（注：发送完成信号的时机取决于集群是强一致性还是最终一致性，强一致性则需要所有DataNode写完后才向NameNode汇报。最终一致性则其中任意一个DataNode写完后就能单独向NameNode汇报，HDFS一般情况下都是强调强一致性） </p></li></ul></li><li><p>HDFS如何实现高可用(HA)</p><ul><li>数据存储故障容错<ul><li>磁盘介质在存储过程中受环境或者老化影响,数据可能错乱</li><li>对于存储在 DataNode 上的数据块，计算并存储校验和（CheckSum)</li><li>读取数据的时候, 重新计算读取出来的数据校验和, 校验不正确抛出异常, 从其它DataNode上读取备份数据</li></ul></li><li>磁盘故障容错<ul><li>DataNode 监测到本机的某块磁盘损坏</li><li>将该块磁盘上存储的所有 BlockID 报告给 NameNode</li><li>NameNode 检查这些数据块在哪些DataNode上有备份,</li><li>通知相应DataNode, 将数据复制到其他服务器上</li></ul></li><li>DataNode故障容错<ul><li>通过心跳和NameNode保持通讯</li><li>超时未发送心跳, NameNode会认为这个DataNode已经宕机</li><li>NameNode查找这个DataNode上有哪些数据块, 以及这些数据在其它DataNode服务器上的存储情况</li><li>从其它DataNode服务器上复制数据</li></ul></li><li>NameNode故障容错<ul><li>主从热备： 必须通过zookeeper  secondary namenode，对namenode数据的备份</li><li>zookeeper配合： ①master节点选举， ②负责数据一致性的保证。（namenode变化，其余保证也要变化。）</li></ul></li></ul></li></ul><h3 id="3-Hadoop发行版的选择"><a href="#3-Hadoop发行版的选择" class="headerlink" title="3. Hadoop发行版的选择"></a>3. Hadoop发行版的选择</h3><ul><li><p>Apache Hadoop</p><ul><li>开源社区版</li><li>最新的Hadoop版本都是从Apache Hadoop发布的</li><li>Hadoop Hive Flume  版本不兼容的问题 jar包  spark scala  Java-&gt;.class-&gt;.jar -&gt;JVM</li></ul></li><li><p>CDH: Cloudera Distributed Hadoop</p><ul><li><p>Cloudera 在社区版的基础上做了一些修改</p></li><li><p><a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004732.png" alt=""></p></li><li><p>hadoop-2.6.0-cdh-5.7.0 和 Flume<strong>*</strong>-cdh5.7.0 cdh版本一致 的各个组件配合是有不会有兼容性问题</p></li><li><p>CDH版本的这些组件 没有全部开源</p></li></ul></li><li><p>HDP: Hortonworks Data Platform</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hadoop概念扩展&quot;&gt;&lt;a href=&quot;#hadoop概念扩展&quot; class=&quot;headerlink&quot; title=&quot;hadoop概念扩展&quot;&gt;&lt;/a&gt;hadoop概念扩展&lt;/h2&gt;&lt;p&gt;课程目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;知道hadoop生态组成&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据的lambda架构" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84lambda%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>07-动态规划之子序列解题模板——最长回文子序列</title>
    <link href="https://xxren8218.github.io/20210626/07-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E8%A7%A3%E9%A2%98%E6%A8%A1%E6%9D%BF%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210626/07-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E8%A7%A3%E9%A2%98%E6%A8%A1%E6%9D%BF%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2021-06-25T16:38:51.000Z</published>
    <updated>2021-06-25T16:41:54.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子序列解题模板：最长回文子序列"><a href="#子序列解题模板：最长回文子序列" class="headerlink" title="子序列解题模板：最长回文子序列"></a>子序列解题模板：最长回文子序列</h2><p>子序列问题是常见的算法问题，而且并不好解决。</p><p>首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举都不容易，更别说求解相关的算法问题了。</p><p>而且，子序列问题很可能涉及到两个字符串，比如让你求两个字符串的 [最长公共子序列]，如果没有一定的处理经验，真的不容易想出来。所以本文就来扒一扒子序列问题的套路，<strong>其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。</strong></p><p>一般来说，这类问题都是让你求一个<strong>最长</strong>子序列，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，<strong>考察的是动态规划技巧，时间复杂度一般都是 O(n^2)</strong>。</p><p>原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着呢？</p><p>既然要用动态规划，那就要定义 dp 数组，找状态转移关系。我们说的两种思路模板，就是 dp 数组的定义思路。不同的问题可能需要不同的 dp 数组定义来解决。</p><blockquote><h3 id="一、两种思路"><a href="#一、两种思路" class="headerlink" title="一、两种思路"></a>一、两种思路</h3></blockquote><h4 id="1、第一种思路模板是一个一维的-dp-数组："><a href="#1、第一种思路模板是一个一维的-dp-数组：" class="headerlink" title="1、第一种思路模板是一个一维的 dp 数组："></a>1、第一种思路模板是一个一维的 dp 数组：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(s1 + <span class="number">1</span>)</span><br><span class="line">dp = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        dp[i] = 最值(dp[i], dp[j] + ...)</span><br></pre></td></tr></table></figure><p>举个我们写过的例子 [最长递增子序列]，在这个思路中 dp 数组的定义是：</p><p><strong>在子数组<code>array[0..i]</code>中，以<code>array[i]</code>结尾的目标子序列（最长递增子序列）的长度是<code>dp[i]</code></strong>。</p><p>为啥最长递增子序列需要这种思路呢？前文说得很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。</p><h4 id="2、第二种思路模板是一个二维的-dp-数组："><a href="#2、第二种思路模板是一个二维的-dp-数组：" class="headerlink" title="2、第二种思路模板是一个二维的 dp 数组："></a>2、第二种思路模板是一个二维的 dp 数组：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(s1 + <span class="number">1</span>)</span><br><span class="line">dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) </span><br><span class="line">            dp[i][j] = dp[i][j] + ...</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = 最值(...)</span><br></pre></td></tr></table></figure><p>这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列。本思路中 dp 数组含义又分为「只涉及一个字符串」和「涉及两个字符串」两种情况。</p><ul><li><p><strong>涉及两个字符串/数组时</strong>（比如最长公共子序列），dp 数组的含义如下：</p><ul><li><strong>在子数组<code>arr1[0..i]</code>和子数组<code>arr2[0..j]</code>中，我们要求的子序列（最长公共子序列）长度为<code>dp[i][j]</code></strong>。</li></ul></li><li><p><strong>只涉及一个字符串/数组时</strong>（比如本文要讲的最长回文子序列），dp 数组的含义如下：</p><ul><li><strong>在子数组<code>array[i..j]</code>中，我们要求的子序列（最长回文子序列）的长度为<code>dp[i][j]</code></strong>。</li></ul></li></ul><p>下面就借最长回文子序列这个问题，详解一下第二种情况下如何使用动态规划。</p><blockquote><h3 id="二、最长回文子序列"><a href="#二、最长回文子序列" class="headerlink" title="二、最长回文子序列"></a>二、最长回文子序列</h3></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004011.jpg" alt=""></p><p>我们说这个问题对 dp 数组的定义是：<strong>在子串<code>s[i..j]</code>中，最长回文子序列的长度为<code>dp[i][j]</code></strong>。一定要记住这个定义才能理解算法。</p><p>为啥这个问题要这样定义二维的 dp 数组呢？我们前文多次提到，<strong>找状态转移需要归纳思维，说白了就是如何从已知的结果推出未知的部分</strong>，这样定义容易归纳，容易发现状态转移关系。</p><p>具体来说，如果我们想求<code>dp[i][j]</code>，假设你知道了子问题<code>dp[i+1][j-1]</code>的结果（<code>s[i+1..j-1]</code>中最长回文子序列的长度），你是否能想办法算出<code>dp[i][j]</code>的值（<code>s[i..j]</code>中，最长回文子序列的长度）呢？</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004027.jpg" alt=""></p><p>可以！<strong>这取决于<code>s[i]</code>和<code>s[j]</code>的字符</strong>：</p><p><strong>如果它俩相等</strong>，那么它俩加上<code>s[i+1..j-1]</code>中的最长回文子序列就是<code>s[i..j]</code>的最长回文子序列：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004040.jpg" alt=""></p><p><strong>如果它俩不相等</strong>，说明它俩<strong>不可能同时</strong>出现在<code>s[i..j]</code>的最长回文子序列中，那么把它俩<strong>分别</strong>加入<code>s[i+1..j-1]</code>中，看看哪个子串产生的回文子序列更长即可：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004113.jpg" alt=""></p><p>以上两种情况写成代码就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">    <span class="comment"># 它俩一定在最长回文子序列中</span></span><br><span class="line">    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？</span></span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><blockquote><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3></blockquote><p>首先明确一下 base case，如果只有一个字符，显然最长回文子序列长度是 1，也就是<code>dp[i][j] = 1,(i == j)</code>。</p><p><strong>因为<code>i</code>肯定小于等于<code>j</code>，所以对于那些<code>i &gt; j</code>的位置，根本不存在什么子序列，应该初始化为 0。</strong></p><p>另外，看看刚才写的状态转移方程，想求<code>dp[i][j]</code>需要知道<code>dp[i+1][j-1]</code>，<code>dp[i+1][j]</code>，<code>dp[i][j-1]</code>这三个位置；再看看我们确定的 base case，填入 dp 数组之后是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004129.jpg" alt=""></p><p><strong>为了保证每次计算<code>dp[i][j]</code>，左、下、左下三个方向的位置已经被计算出来，只能斜着遍历或者反着遍历</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626004143.jpg" alt=""></p><p>我选择反着遍历，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">s</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment"># dp 数组全部初始化为 0</span></span><br><span class="line">    [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dp[i][i] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 反着遍历保证正确的状态转移</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">                </span><br><span class="line">    <span class="comment"># 整个 s 的最长回文子串长度</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>至此，最长回文子序列的问题就解决了。</p><p>主要还是正确定义 dp 数组的含义，遇到子序列问题，首先想到两种动态规划思路，然后根据实际问题看看哪种思路容易找到状态转移关系。</p><p>另外，找到状态转移和 base case 之后，<strong>一定要观察 DP table</strong>，看看怎么遍历才能保证通过已计算出来的结果解决新的问题</p><p>有了以上思路方向，子序列问题也不过如此嘛。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;子序列解题模板：最长回文子序列&quot;&gt;&lt;a href=&quot;#子序列解题模板：最长回文子序列&quot; class=&quot;headerlink&quot; title=&quot;子序列解题模板：最长回文子序列&quot;&gt;&lt;/a&gt;子序列解题模板：最长回文子序列&lt;/h2&gt;&lt;p&gt;子序列问题是常见的算法问题，而且并不</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>06-动态规划之最长公共子序列</title>
    <link href="https://xxren8218.github.io/20210626/06-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210626/06-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2021-06-25T16:35:11.000Z</published>
    <updated>2021-06-25T16:38:20.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划之最长公共子序列"><a href="#动态规划之最长公共子序列" class="headerlink" title="动态规划之最长公共子序列"></a>动态规划之最长公共子序列</h2><p>最长公共子序列（Longest Common Subsequence，简称 LCS）是一道非常经典的面试题目，因为它的解法是典型的二维动态规划，大部分比较困难的字符串问题都和这个问题一个套路，比如说编辑距离。而且，这个算法稍加改造就可以用于解决其他问题，所以说 LCS 算法是值得掌握的。</p><p>题目就是让我们求两个字符串的 LCS 长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: str1 = <span class="string">&quot;abcde&quot;</span>, str2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出: <span class="number">3</span>  </span><br><span class="line">解释: 最长公共子序列是 <span class="string">&quot;ace&quot;</span>，它的长度是 <span class="number">3</span></span><br></pre></td></tr></table></figure><p>为啥这个问题就是动态规划来解决呢？因为子序列类型的问题，穷举出所有可能的结果都不容易，而动态规划算法做的就是穷举 + 剪枝，它俩天生一对儿。所以可以说只要涉及子序列问题，十有八九都需要动态规划来解决，往这方面考虑就对了。</p><p>下面就来手把手分析一下，这道题目如何用动态规划技巧解决。</p><blockquote><h3 id="一、动态规划思路"><a href="#一、动态规划思路" class="headerlink" title="一、动态规划思路"></a>一、动态规划思路</h3></blockquote><p><strong>第一步，一定要明确<code>dp</code>数组的含义</strong>。</p><p>对于两个字符串的动态规划问题，套路是通用的。比如说对于字符串<code>s1</code>和<code>s2</code>，一般来说都要构造一个这样的 DP table：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626003608.jpg" alt=""></p><p>为了方便理解此表，我们暂时认为索引是从 1 开始的，待会的代码中只要稍作调整即可。其中，<code>dp[i][j]</code>的含义是：对于<code>s1[1..i]</code>和<code>s2[1..j]</code>，它们的 LCS 长度是<code>dp[i][j]</code>。</p><p>比如上图的例子，<code>dp</code> 的含义就是：对于<code>&quot;ac&quot;</code>和<code>&quot;babc&quot;</code>，它们的 LCS 长度是 2。我们最终想得到的答案应该是<code>dp[3][5]</code>。</p><p><strong>第二步，定义 base case。</strong></p><p>我们专门让索引为 0 的行和列表示空串，<code>dp[0][..]</code>和<code>dp[..][0]</code>都应该初始化为 0，这就是 base case。</p><p>比如说，按照刚才 dp 数组的定义，<code>dp[0][3]=0</code>的含义是：对于字符串<code>&quot;&quot;</code>和<code>&quot;bab&quot;</code>，其 LCS 的长度为 0。因为有一个字符串是空串，它们的最长公共子序列的长度显然应该是 0。</p><p><strong>第三步，找状态转移方程。</strong></p><p>这是动态规划最难的一步，不过好在这种字符串问题的套路都差不多，权且借这道题来聊聊处理这类问题的思路。</p><p>状态转移说简单些就是做选择，比如说这个问题，是求<code>s1</code>和<code>s2</code>的最长公共子序列，不妨称这个子序列为<code>lcs</code>。那么对于<code>s1</code>和<code>s2</code>中的每个字符，有什么选择？很简单，两种选择，要么在<code>lcs</code>中，要么不在。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626003635.jpg" alt=""></p><p>这个「在」和「不在」就是选择，关键是，应该如何选择呢？这个需要动点脑筋：如果某个字符应该在<code>lcs</code>中，那么这个字符肯定同时存在于<code>s1</code>和<code>s2</code>中，因为<code>lcs</code>是最长<strong>公共</strong>子序列嘛。所以本题的思路是这样：</p><p>用两个指针<code>i</code>和<code>j</code>从后往前遍历<code>s1</code>和<code>s2</code>，如果<code>s1[i]==s2[j]</code>，那么这个字符<strong>一定在<code>lcs</code>中</strong>；否则的话，<code>s1[i]</code>和<code>s2[j]</code>这两个字符<strong>至少有一个不在<code>lcs</code>中</strong>，需要丢弃一个。先看一下递归解法，比较容易理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">str1, str2</span>) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i, j</span>):</span></span><br><span class="line">        <span class="comment"># 空的 base case</span></span><br><span class="line">        <span class="keyword">if</span> i == -<span class="number">1</span> <span class="keyword">or</span> j == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> str1[i] == str2[j]:</span><br><span class="line">            <span class="comment"># 这边找到一个 lcs 的元素，继续往前找</span></span><br><span class="line">            <span class="keyword">return</span> dp(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 谁能让 lcs 最长，就听谁的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(dp(i - <span class="number">1</span>, j), dp(i, j - <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line"> <span class="comment"># i 和 j 初始化为最后一个索引</span></span><br><span class="line">    <span class="keyword">return</span> dp(<span class="built_in">len</span>(str1) - <span class="number">1</span>, <span class="built_in">len</span>(str2) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>对于第一种情况，找到一个<code>lcs</code>中的字符，同时将<code>i, j</code>向前移动一位，并给<code>lcs</code>的长度加一；对于后者，则尝试两种情况，取更大的结果。</p><p>其实这段代码就是暴力解法，我们可以通过备忘录或者 DP table 来优化时间复杂度，比如通过前文描述的 DP table 来解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">str1, str2</span>) -&gt; int:</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2)</span><br><span class="line">    <span class="comment"># 构建 DP table 和 base case</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>) ]</span><br><span class="line">    <span class="comment"># 进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 找到一个 lcs 中的字符</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">             </span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><h3 id="二、疑难解答"><a href="#二、疑难解答" class="headerlink" title="二、疑难解答"></a>二、疑难解答</h3></blockquote><p>对于<code>s1[i]</code>和<code>s2[j]</code>不相等的情况，<strong>至少有一个</strong>字符不在<code>lcs</code>中，会不会两个字符都不在呢？比如下面这种情况</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626003731.png" alt=""></p><p>所以代码是不是应该考虑这种情况，改成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]:</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], </span><br><span class="line">                   dp[i][j-<span class="number">1</span>],</span><br><span class="line">                   dp[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>我一开始也有这种怀疑，其实可以这样改，也能得到正确答案，但是多此一举，因为<code>dp[i-1][j-1]</code>永远是三者中最小的，max 根本不可能取到它。</p><p>原因在于我们对 dp 数组的定义：对于<code>s1[1..i]</code>和<code>s2[1..j]</code>，它们的 LCS 长度是<code>dp[i][j]</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626003749.jpg" alt=""></p><p>这样一看，显然<code>dp[i-1][j-1]</code>对应的<code>lcs</code>长度不可能比前两种情况大，所以没有必要参与比较。</p><blockquote><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3></blockquote><p>对于两个字符串的动态规划问题，一般来说都是像本文一样定义 DP table，因为这样定义有一个好处，就是容易写出状态转移方程，<code>dp[i][j]</code>的状态可以通过之前的状态推导出来：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210626003805.png" alt=""></p><p>找状态转移方程的方法是，思考每个状态有哪些「选择」，只要我们能用正确的逻辑做出正确的选择，算法就能够正确运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;动态规划之最长公共子序列&quot;&gt;&lt;a href=&quot;#动态规划之最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;动态规划之最长公共子序列&quot;&gt;&lt;/a&gt;动态规划之最长公共子序列&lt;/h2&gt;&lt;p&gt;最长公共子序列（Longest Common Subsequ</summary>
      
    
    
    
    <category term="动态规划" scheme="https://xxren8218.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
</feed>
