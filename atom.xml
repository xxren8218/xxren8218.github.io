<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-05-25T10:49:25.077Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>支持向量机</title>
    <link href="https://xxren8218.github.io/20210525/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html"/>
    <id>https://xxren8218.github.io/20210525/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html</id>
    <published>2021-05-25T10:42:17.000Z</published>
    <updated>2021-05-25T10:49:25.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="支持向量机（SVM）"><a href="#支持向量机（SVM）" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h1><ul><li>低纬不可分的东西转化为高纬可分割的东西</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"></span><br><span class="line"><span class="comment"># use seaborn plotting defaults</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns; sns.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><h3 id="支持向量基本原理"><a href="#支持向量基本原理" class="headerlink" title="支持向量基本原理"></a>支持向量基本原理</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184326.png" alt=""></p><p>如何解决这个线性不可分问题呢？咱们给它映射到高维来试试</p><p>$z=x^2+y^2$. </p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机来点数据</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">50</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">0.60</span>)  <span class="comment"># cluster_std=0.60 簇的离散程度。越小，越集中，越好分类</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1ba274e1ac8&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184358.png" alt=""></p><p>随便的画几条分割线，哪个好来这？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xfit = np.linspace(-<span class="number">1</span>, <span class="number">3.5</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">0.6</span>], [<span class="number">2.1</span>], <span class="string">&#x27;x&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, markeredgewidth=<span class="number">2</span>, markersize=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m, b <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0.65</span>), (<span class="number">0.5</span>, <span class="number">1.6</span>), (-<span class="number">0.2</span>, <span class="number">2.9</span>)]:</span><br><span class="line">    plt.plot(xfit, m * xfit + b, <span class="string">&#x27;-k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">1</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184415.png" alt=""></p><h2 id="Support-Vector-Machines-最小化-雷区"><a href="#Support-Vector-Machines-最小化-雷区" class="headerlink" title="Support Vector Machines: 最小化 雷区"></a>Support Vector Machines: 最小化 <em>雷区</em></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xfit = np.linspace(-<span class="number">1</span>, <span class="number">3.5</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m, b, d <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0.65</span>, <span class="number">0.33</span>), (<span class="number">0.5</span>, <span class="number">1.6</span>, <span class="number">0.55</span>), (-<span class="number">0.2</span>, <span class="number">2.9</span>, <span class="number">0.2</span>)]:</span><br><span class="line">    yfit = m * xfit + b</span><br><span class="line">    plt.plot(xfit, yfit, <span class="string">&#x27;-k&#x27;</span>)</span><br><span class="line">    plt.fill_between(xfit, yfit - d, yfit + d, edgecolor=<span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">                     color=<span class="string">&#x27;#AAAAAA&#x27;</span>, alpha=<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">1</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184433.png" alt=""></p><h3 id="训练一个基本的SVM"><a href="#训练一个基本的SVM" class="headerlink" title="训练一个基本的SVM"></a>训练一个基本的SVM</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC <span class="comment"># &quot;Support vector classifier&quot;</span></span><br><span class="line">model = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">model.fit(X, y)</span><br></pre></td></tr></table></figure><pre><code>SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,  decision_function_shape=None, degree=3, gamma=&#39;auto&#39;, kernel=&#39;linear&#39;,  max_iter=-1, probability=False, random_state=None, shrinking=True,  tol=0.001, verbose=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘图函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_svc_decision_function</span>(<span class="params">model, ax=<span class="literal">None</span>, plot_support=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Plot the decision function for a 2D SVC&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ax = plt.gca()</span><br><span class="line">    xlim = ax.get_xlim()</span><br><span class="line">    ylim = ax.get_ylim()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># create grid to evaluate model</span></span><br><span class="line">    x = np.linspace(xlim[<span class="number">0</span>], xlim[<span class="number">1</span>], <span class="number">30</span>)</span><br><span class="line">    y = np.linspace(ylim[<span class="number">0</span>], ylim[<span class="number">1</span>], <span class="number">30</span>)</span><br><span class="line">    Y, X = np.meshgrid(y, x)</span><br><span class="line">    xy = np.vstack([X.ravel(), Y.ravel()]).T</span><br><span class="line">    P = model.decision_function(xy).reshape(X.shape)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plot decision boundary and margins</span></span><br><span class="line">    ax.contour(X, Y, P, colors=<span class="string">&#x27;k&#x27;</span>,</span><br><span class="line">               levels=[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], alpha=<span class="number">0.5</span>,</span><br><span class="line">               linestyles=[<span class="string">&#x27;--&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;--&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plot support vectors</span></span><br><span class="line">    <span class="keyword">if</span> plot_support:</span><br><span class="line">        ax.scatter(model.support_vectors_[:, <span class="number">0</span>],</span><br><span class="line">                   model.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">                   s=<span class="number">300</span>, linewidth=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    ax.set_xlim(xlim)</span><br><span class="line">    ax.set_ylim(ylim)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plot_svc_decision_function(model);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184519.png" alt=""></p><ul><li><p>这条线就是我们希望得到的决策边界啦</p></li><li><p>观察发现有3个点做了特殊的标记，它们恰好都是边界上的点</p></li><li><p>它们就是我们的<em>support vectors</em>（支持向量）</p></li><li><p>在Scikit-Learn中, 它们存储在这个位置 <code>support_vectors_</code>（一个属性）</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.support_vectors_</span><br></pre></td></tr></table></figure><pre><code>array([[ 0.44359863,  3.11530945],       [ 2.33812285,  3.43116792],       [ 2.06156753,  1.96918596]])</code></pre><ul><li><p>观察可以发现，只需要支持向量我们就可以把模型构建出来</p></li><li><p>接下来我们尝试一下，用不同多的数据点，看看效果会不会发生变化</p></li><li><p>分别使用60个和120个数据点</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_svm</span>(<span class="params">N=<span class="number">10</span>, ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    X, y = make_blobs(n_samples=<span class="number">200</span>, centers=<span class="number">2</span>,</span><br><span class="line">                      random_state=<span class="number">0</span>, cluster_std=<span class="number">0.60</span>)</span><br><span class="line">    X = X[:N]</span><br><span class="line">    y = y[:N]</span><br><span class="line">    model = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>, C=<span class="number">1E10</span>)</span><br><span class="line">    model.fit(X, y)</span><br><span class="line">    </span><br><span class="line">    ax = ax <span class="keyword">or</span> plt.gca()</span><br><span class="line">    ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    ax.set_xlim(-<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    plot_svc_decision_function(model, ax)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">6</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.0625</span>, right=<span class="number">0.95</span>, wspace=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">for</span> axi, N <span class="keyword">in</span> <span class="built_in">zip</span>(ax, [<span class="number">60</span>, <span class="number">120</span>]):</span><br><span class="line">    plot_svm(N, axi)</span><br><span class="line">    axi.set_title(<span class="string">&#x27;N = &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(N))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184545.png" alt=""></p><ul><li>左边是60个点的结果，右边的是120个点的结果</li><li>观察发现，只要支持向量没变，其他的数据怎么加无所谓！</li></ul><h3 id="引入核函数的SVM"><a href="#引入核函数的SVM" class="headerlink" title="引入核函数的SVM"></a>引入核函数的SVM</h3><ul><li>首先我们先用线性的核来看一下在下面这样比较难的数据集上还能分了吗？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_circles</span><br><span class="line">X, y = make_circles(<span class="number">100</span>, factor=<span class="number">.1</span>, noise=<span class="number">.1</span>)</span><br><span class="line"></span><br><span class="line">clf = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>).fit(X, y)</span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plot_svc_decision_function(clf, plot_support=<span class="literal">False</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184607.png" alt=""></p><ul><li><p>坏菜喽，分不了了，那咋办呢？试试高维核变换吧！</p></li><li><p>We can visualize this extra data dimension using a three-dimensional plot:</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入了新的维度r</span></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line">r = np.exp(-(X ** <span class="number">2</span>).<span class="built_in">sum</span>(<span class="number">1</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_3D</span>(<span class="params">elev=<span class="number">30</span>, azim=<span class="number">30</span>, X=X, y=y</span>):</span></span><br><span class="line">    ax = plt.subplot(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">    ax.scatter3D(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], r, c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    ax.view_init(elev=elev, azim=azim)</span><br><span class="line">    ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    ax.set_zlabel(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plot_3D(elev=<span class="number">45</span>, azim=<span class="number">45</span>, X=X, y=y)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184628.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入径向基函数（高斯核函数或者RBF核函数都一样）</span></span><br><span class="line">clf = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, C=<span class="number">1E6</span>)</span><br><span class="line">clf.fit(X, y)</span><br></pre></td></tr></table></figure><pre><code>SVC(C=1000000.0, cache_size=200, class_weight=None, coef0=0.0,  decision_function_shape=None, degree=3, gamma=&#39;auto&#39;, kernel=&#39;rbf&#39;,  max_iter=-1, probability=False, random_state=None, shrinking=True,  tol=0.001, verbose=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这回牛逼了！</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plot_svc_decision_function(clf)</span><br><span class="line">plt.scatter(clf.support_vectors_[:, <span class="number">0</span>], clf.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">            s=<span class="number">300</span>, lw=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184658.png" alt=""></p><p>使用这种核支持向量机，我们学习一个合适的非线性决策边界。这种核变换策略在机器学习中经常被使用！</p><h3 id="调节SVM参数-Soft-Margin问题"><a href="#调节SVM参数-Soft-Margin问题" class="headerlink" title="调节SVM参数: Soft Margin问题"></a>调节SVM参数: Soft Margin问题</h3><h3 id="调节C参数"><a href="#调节C参数" class="headerlink" title="调节C参数"></a>调节C参数</h3><ul><li>当C趋近于无穷大时：意味着分类严格不能有错误</li><li>当C趋近于很小的时：意味着可以有更大的错误容忍</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">0.8</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184713.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">6</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.0625</span>, right=<span class="number">0.95</span>, wspace=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> axi, C <span class="keyword">in</span> <span class="built_in">zip</span>(ax, [<span class="number">10.0</span>, <span class="number">0.1</span>]):  <span class="comment"># 两个C参数 10.0和0.1</span></span><br><span class="line">    model = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>, C=C).fit(X, y)</span><br><span class="line">    axi.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    plot_svc_decision_function(model, axi)</span><br><span class="line">    axi.scatter(model.support_vectors_[:, <span class="number">0</span>],</span><br><span class="line">                model.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">                s=<span class="number">300</span>, lw=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    axi.set_title(<span class="string">&#x27;C = &#123;0:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(C), size=<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184732.png" alt=""></p><ul><li>左边的泛化能力小。</li><li>右边的泛化能力强一点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">1.1</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">6</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.0625</span>, right=<span class="number">0.95</span>, wspace=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> axi, gamma <span class="keyword">in</span> <span class="built_in">zip</span>(ax, [<span class="number">10.0</span>, <span class="number">0.1</span>]):</span><br><span class="line">    model = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, gamma=gamma).fit(X, y)  <span class="comment"># gamma越高模型越复杂。返还能力越弱。</span></span><br><span class="line">    axi.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    plot_svc_decision_function(model, axi)</span><br><span class="line">    axi.scatter(model.support_vectors_[:, <span class="number">0</span>],</span><br><span class="line">                model.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">                s=<span class="number">300</span>, lw=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    axi.set_title(<span class="string">&#x27;gamma = &#123;0:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(gamma), size=<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184758.png" alt=""></p><ul><li>越复杂的边界泛化能力越低。</li></ul><h2 id="Example-Face-Recognition"><a href="#Example-Face-Recognition" class="headerlink" title="Example: Face Recognition"></a>Example: Face Recognition</h2><p>As an example of support vector machines in action, let’s take a look at the facial recognition problem.<br>We will use the Labeled Faces in the Wild dataset, which consists of several thousand collated photos of various public figures.<br>A fetcher for the dataset is built into Scikit-Learn:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line">faces = fetch_lfw_people(min_faces_per_person=<span class="number">60</span>)</span><br><span class="line">print(faces.target_names)</span><br><span class="line">print(faces.images.shape)</span><br></pre></td></tr></table></figure><pre><code>[&#39;Ariel Sharon&#39; &#39;Colin Powell&#39; &#39;Donald Rumsfeld&#39; &#39;George W Bush&#39; &#39;Gerhard Schroeder&#39; &#39;Hugo Chavez&#39; &#39;Junichiro Koizumi&#39; &#39;Tony Blair&#39;](1348, 62, 47)</code></pre><p>Let’s plot a few of these faces to see what we’re working with:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i, axi <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.flat):</span><br><span class="line">    axi.imshow(faces.images[i], cmap=<span class="string">&#x27;bone&#x27;</span>)</span><br><span class="line">    axi.<span class="built_in">set</span>(xticks=[], yticks=[],</span><br><span class="line">            xlabel=faces.target_names[faces.target[i]])</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184821.png" alt=""></p><ul><li>每个图的大小是 [62×47] </li><li>在这里我们就把每一个像素点当成了一个特征，但是这样特征太多了，用PCA降维一下吧！</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="comment">#from sklearn.decomposition import RandomizedPCA</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"></span><br><span class="line">pca = PCA(n_components=<span class="number">150</span>, whiten=<span class="literal">True</span>, random_state=<span class="number">42</span>)</span><br><span class="line">svc = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, class_weight=<span class="string">&#x27;balanced&#x27;</span>)</span><br><span class="line">model = make_pipeline(pca, svc)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain, Xtest, ytrain, ytest = train_test_split(faces.data, faces.target,</span><br><span class="line">                                                random_state=<span class="number">40</span>)</span><br></pre></td></tr></table></figure><p>使用grid search cross-validation来选择我们的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">param_grid = &#123;<span class="string">&#x27;svc__C&#x27;</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">              <span class="string">&#x27;svc__gamma&#x27;</span>: [<span class="number">0.0001</span>, <span class="number">0.0005</span>, <span class="number">0.001</span>]&#125;</span><br><span class="line">grid = GridSearchCV(model, param_grid)</span><br><span class="line"></span><br><span class="line">%time grid.fit(Xtrain, ytrain)</span><br><span class="line">print(grid.best_params_)</span><br></pre></td></tr></table></figure><pre><code>Wall time: 51.5 s&#123;&#39;svc__C&#39;: 5, &#39;svc__gamma&#39;: 0.001&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = grid.best_estimator_</span><br><span class="line">yfit = model.predict(Xtest)</span><br><span class="line">yfit.shape</span><br></pre></td></tr></table></figure><pre><code>(337,)</code></pre><p>看看咋样吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> i, axi <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.flat):</span><br><span class="line">    axi.imshow(Xtest[i].reshape(<span class="number">62</span>, <span class="number">47</span>), cmap=<span class="string">&#x27;bone&#x27;</span>)</span><br><span class="line">    axi.<span class="built_in">set</span>(xticks=[], yticks=[])</span><br><span class="line">    axi.set_ylabel(faces.target_names[yfit[i]].split()[-<span class="number">1</span>],</span><br><span class="line">                   color=<span class="string">&#x27;black&#x27;</span> <span class="keyword">if</span> yfit[i] == ytest[i] <span class="keyword">else</span> <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">fig.suptitle(<span class="string">&#x27;Predicted Names; Incorrect Labels in Red&#x27;</span>, size=<span class="number">14</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184837.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line">print(classification_report(ytest, yfit,</span><br><span class="line">                            target_names=faces.target_names))</span><br></pre></td></tr></table></figure><pre><code>                   precision    recall  f1-score   support     Ariel Sharon       0.50      0.50      0.50        16     Colin Powell       0.69      0.81      0.75        54  Donald Rumsfeld       0.83      0.85      0.84        34    George W Bush       0.94      0.88      0.91       136Gerhard Schroeder       0.72      0.85      0.78        27      Hugo Chavez       0.81      0.72      0.76        18Junichiro Koizumi       0.87      0.87      0.87        15       Tony Blair       0.85      0.76      0.80        37      avg / total       0.83      0.82      0.82       337</code></pre><ul><li>精度(precision) = 正确预测的个数(TP)/被预测正确的个数(TP+FP)</li><li>召回率(recall)=正确预测的个数(TP)/预测个数(TP+FN)</li><li>F1 = 2<em>精度</em>召回率/(精度+召回率)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">mat = confusion_matrix(ytest, yfit)</span><br><span class="line">sns.heatmap(mat.T, square=<span class="literal">True</span>, annot=<span class="literal">True</span>, fmt=<span class="string">&#x27;d&#x27;</span>, cbar=<span class="literal">False</span>,</span><br><span class="line">            xticklabels=faces.target_names,</span><br><span class="line">            yticklabels=faces.target_names)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;true label&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;predicted label&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184906.png" alt=""></p><ul><li>这样显示出来能帮助我们查看哪些人更容易弄混</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;支持向量机（SVM）&quot;&gt;&lt;a href=&quot;#支持向量机（SVM）&quot; class=&quot;headerlink&quot; title=&quot;支持向量机（SVM）&quot;&gt;&lt;/a&gt;支持向量机（SVM）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;低纬不可分的东西转化为高纬可分割的东西&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三十二）：把数组排成最小的数</title>
    <link href="https://xxren8218.github.io/20210525/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210525/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html</id>
    <published>2021-05-25T10:40:41.000Z</published>
    <updated>2021-05-25T10:41:45.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>遇到这个题，全排列当然可以做，但是时间复杂度为O(n!)。在这里我们自己定义一个规则，对拼接后的字符串进行比较。</p><p>排序规则如下</p><ul><li>若ab &gt; ba 则 a 大于 b，</li><li>若ab &lt; ba 则 a 小于 b，</li><li>若ab = ba 则 a 等于 b；</li></ul><p>根据上述规则，我们需要先将数字转换成字符串再进行比较，因为需要串起来进行比较。比较完之后，按顺序输出即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        compare = <span class="keyword">lambda</span> a,b:cmp(<span class="built_in">str</span>(a)+<span class="built_in">str</span>(b),<span class="built_in">str</span>(b)+<span class="built_in">str</span>(a))   <span class="comment"># 注意 lambda 匿名函数的使用。python2中sorted（可迭代对象,key,cmp）的使用,以及为什么要比较字符串。</span></span><br><span class="line">        li = <span class="built_in">sorted</span>(numbers, cmp=compare)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> li)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="https://xxren8218.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="字符串" scheme="https://xxren8218.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="内置函数" scheme="https://xxren8218.github.io/tags/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三十）：连续子数组的最大和</title>
    <link href="https://xxren8218.github.io/20210525/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.html"/>
    <id>https://xxren8218.github.io/20210525/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.html</id>
    <published>2021-05-25T10:38:01.000Z</published>
    <updated>2021-05-25T10:40:21.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。(子向量的长度至少是1)</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525183934.PNG" alt=""></p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="built_in">max</span> = nums[<span class="number">0</span>]</span><br><span class="line">        cur = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> cur &lt; <span class="number">0</span>:</span><br><span class="line">                cur = i</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                cur += i</span><br><span class="line">            <span class="keyword">if</span> cur &gt; <span class="built_in">max</span>:</span><br><span class="line">                <span class="built_in">max</span> = cur</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span></span><br></pre></td></tr></table></figure><h2 id="思路二——动态规划"><a href="#思路二——动态规划" class="headerlink" title="思路二——动态规划"></a>思路二——动态规划</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525183958.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184006.PNG" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># dp[i]表示以num[i]结尾的最大的连续子数和</span></span><br><span class="line">        dp = [<span class="number">0</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 初始值</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 找出元素关系式</span></span><br><span class="line">            <span class="keyword">if</span> dp[i-<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp) </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。&lt;/p&gt;
&lt;p&gt;要求时间复杂度为O(n</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="动态规划" scheme="https://xxren8218.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（二十八）：数组中出现次数超过一半的数字</title>
    <link href="https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.html</id>
    <published>2021-05-24T10:51:43.000Z</published>
    <updated>2021-05-24T10:53:48.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0</p><h2 id="2-思路一——暴力解法"><a href="#2-思路一——暴力解法" class="headerlink" title="2.思路一——暴力解法"></a>2.思路一——暴力解法</h2><p>循环遍历所有的数字，调用方法count()，与数组的个数的1/2进行比较即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> numbers.count(i)&gt;<span class="built_in">len</span>(numbers)//<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><p>上述解法在力扣超时。有别的解法，<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524185306.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524185313.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524185318.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524185325.PNG" alt=""></p><h2 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        vote = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> vote == <span class="number">0</span>: x = num</span><br><span class="line">            <span class="keyword">if</span> num == x:</span><br><span class="line">                vote += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vote -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        hashable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> hashable:</span><br><span class="line">                hashable[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashable[num] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashable[num] &gt; <span class="built_in">len</span>(nums) / <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://xxren8218.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="辅助素组" scheme="https://xxren8218.github.io/tags/%E8%BE%85%E5%8A%A9%E7%B4%A0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十三）：调整数组顺序使奇数位于偶数前面</title>
    <link href="https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html"/>
    <id>https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html</id>
    <published>2021-05-24T10:49:25.000Z</published>
    <updated>2021-05-24T10:50:50.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h2 id="2-思路一——辅助数组"><a href="#2-思路一——辅助数组" class="headerlink" title="2.思路一——辅助数组"></a>2.思路一——辅助数组</h2><p>对数组中的数字进行遍历，判断奇偶，分别放在两个辅助列表中，最后将两个辅助列表合并即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span>(<span class="params">self , array</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        odd = []</span><br><span class="line">        even = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">            <span class="keyword">if</span> array[i] % <span class="number">2</span>: <span class="comment"># 1 为True, 0 为 False</span></span><br><span class="line">                odd.append(array[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                even.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> odd + even</span><br></pre></td></tr></table></figure><h2 id="别的思路：——首尾双指针"><a href="#别的思路：——首尾双指针" class="headerlink" title="别的思路：——首尾双指针"></a>别的思路：——首尾双指针</h2><ul><li>首尾双指针<br>定义头指针 left ，尾指针 right .<br>left 一直往右移，直到它指向的值为偶数<br>right 一直往左移， 直到它指向的值为奇数<br>交换 nums[left] 和 nums[right] .<br>重复上述操作，直到 left==right .</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> nums[left] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> nums[right] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h2 id="思路三——快慢双指针"><a href="#思路三——快慢双指针" class="headerlink" title="思路三——快慢双指针"></a>思路三——快慢双指针</h2><p>定义快慢双指针 fast 和 low ，fast 在前， low 在后 .<br>fast的作用是向前搜索奇数位置，low的作用是指向下一个奇数应当存放的位置<br>fast向前移动，当它搜索到奇数时，将它和 nums[low] 交换，此时 low 向前移动一个位置 .<br>重复上述操作，直到 fast 指向数组末尾 .</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        low, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                nums[low], nums[fast] = nums[fast], nums[low]</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="快慢指针" scheme="https://xxren8218.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（六）：旋转数组的最小数字</title>
    <link href="https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html"/>
    <id>https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html</id>
    <published>2021-05-24T10:46:50.000Z</published>
    <updated>2021-05-24T10:51:12.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 </p><p>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 </p><p>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 </p><p>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。    </p><h2 id="2-思路一：线性查找O-n"><a href="#2-思路一：线性查找O-n" class="headerlink" title="2.思路一：线性查找O(n)"></a>2.思路一：线性查找O(n)</h2><p>直接调用min()方法即可，时间复杂度O(n)</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(numbers)</span><br></pre></td></tr></table></figure><h2 id="思路二：二分查找O（logn）"><a href="#思路二：二分查找O（logn）" class="headerlink" title="思路二：二分查找O（logn）"></a>思路二：二分查找O（logn）</h2><ul><li>排序数组的查找问题首先考虑使用 二分法 解决，其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> 。<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524184757.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524184822.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210524184837.PNG" alt=""></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            m = (i + j) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[m] &gt; numbers[j]:i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[m] &lt; numbers[j]: j = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[i]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 &lt;/p&gt;
&lt;p&gt;输入一个非递减排序的数组的一个旋转，输出</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="二分法" scheme="https://xxren8218.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（一）：二维数组（排序数组）中的查找</title>
    <link href="https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%88%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%89%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html"/>
    <id>https://xxren8218.github.io/20210524/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%88%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%89%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html</id>
    <published>2021-05-24T10:44:43.000Z</published>
    <updated>2021-05-24T10:46:10.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p><p>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="2-思路一：暴力解法"><a href="#2-思路一：暴力解法" class="headerlink" title="2.思路一：暴力解法"></a>2.思路一：暴力解法</h2><p>依次遍历整个数组的每一个元素，如果存在返回True,否则返回False</p><ul><li>复杂度分析</li></ul><p>时间复杂度：O(nm)。二维数组中的每个元素都被遍历，因此时间复杂度为二维数组的大小。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span>(<span class="params">self, matrix, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> target == matrix[i][j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="思路二：线性查找"><a href="#思路二：线性查找" class="headerlink" title="思路二：线性查找"></a>思路二：线性查找</h2><p>首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；</p><p>如果该数字大于要查找的数组，剔除这个数字所在的列；</p><p>如果该数字小于要查找的数字，剔除这个数字所在的行。</p><p>也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p><ul><li>复杂度分析<br>时间复杂度：O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span>(<span class="params">self, matrix, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>]) </span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        col = cols - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] == target:<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][col] &gt; target:col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。&lt;/p&gt;
&lt;p&gt;请完成一个函数，输</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="查找" scheme="https://xxren8218.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十一）：二进制中1的个数</title>
    <link href="https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html</id>
    <published>2021-05-20T11:19:52.000Z</published>
    <updated>2021-05-20T11:23:18.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个二进制数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>先与1进行与运算，若为1，则该位为1，再判断前一位。</p><p>前一位的判断直接可以使用位运算 &gt;&gt; 向右移动一位。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += n &amp; <span class="number">1</span> <span class="comment"># 等价于 if n &amp; 1 == 1: res +=1，但是前一种判断次数更少。 </span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>将二进制转化为字符串，直接进行进行调用方法count</p><pre><code>- 由于输入的二进制比如1011，计算机不会将其对待为 0b1011,而是认为是一千零一十一，所以先转为二进制</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">bin</span>(n)).count(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路三-巧用-n-amp-n-1"><a href="#思路三-巧用-n-amp-n-1" class="headerlink" title="思路三 巧用 n&amp;(n-1)"></a>思路三 巧用 n&amp;(n-1)</h2><h2 id="此处若输入一个整数呢？注意消除负数位的影响。"><a href="#此处若输入一个整数呢？注意消除负数位的影响。" class="headerlink" title="此处若输入一个整数呢？注意消除负数位的影响。"></a>此处若输入一个整数呢？注意消除负数位的影响。</h2><div style="color: red;overflow: scroll;">如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</div><div style="color: red;overflow: scroll;">举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。    - 在Python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机是以补码存在的，往右移，符号位不变，符号位1往右移，最终可能会出现全1的情况，导致死循环。与0xffffffff相与，就可以消除负数的影响。</div><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: n = n &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= n-<span class="number">1</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个二进制数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;h2 id=&quot;2-思路&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串" scheme="https://xxren8218.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="位运算" scheme="https://xxren8218.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十二）：数值的整数次方</title>
    <link href="https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html"/>
    <id>https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html</id>
    <published>2021-05-20T11:09:11.000Z</published>
    <updated>2021-05-20T11:19:14.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个double类型的浮点数x和int类型的整数n。求x的n次方。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>正常思路是：</p><ul><li>若n&gt;0: x<em>x</em>x<em>…</em>x,一共乘n次</li><li>若n&lt;0: 1/x<em>x</em>x<em>…</em>x,一共乘n次。</li><li>若n=0：返回零，但是代码在力扣超时。时间复杂度O（n）<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = x</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &lt; n-<span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &lt; -n-<span class="number">1</span>:</span><br><span class="line">                    res *= x</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/res</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="下面介绍快速幂的方法——时间复杂度O（logn）"><a href="#下面介绍快速幂的方法——时间复杂度O（logn）" class="headerlink" title="下面介绍快速幂的方法——时间复杂度O（logn）"></a>下面介绍快速幂的方法——时间复杂度O（logn）</h2><ul><li>指数减半，底数平方的方法。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如13，我们可以转换成1101，则X<strong>13就等于x</strong>1101b,然后展开，如图一<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191438.JPG" alt=""><br>同样我们也将所给的数字进行转化。如图二<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191508.JPG" alt=""><br>当bi=0，其数值为0<br>当bi=1，值为x的2<strong>i次方，如图三<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191524.JPG" alt=""><br>我们可以发现x</strong>i的规律就是从右向左看，后一个数字都是前一个数字的平方。如图、五<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191541.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191556.JPG" alt=""><br>所以：采用循环<br>我们可以将n与1进行与运算，看当前位数为0与否：</p><ul><li>不为零时候（为1），则结果 res * x</li><li>为零时候，则给结果不变<br>而后进行位运算右移动，移动以后的 x*= x<br>当n&lt;0, 我们可以令 x = 1/x, n = -n，则可以用同样的方法进行计算。<br>当x=0,分母不能为0，直接返回0<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191636.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191705.JPG" alt=""><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            x,n = <span class="number">1</span>/x, -n</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">            x *= x</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;给定一个double类型的浮点数x和int类型的整数n。求x的n次方。&lt;/p&gt;
&lt;h2 id=&quot;2-思路&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="https://xxren8218.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="快速幂" scheme="https://xxren8218.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十九）：顺时针打印矩阵</title>
    <link href="https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.html"/>
    <id>https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.html</id>
    <published>2021-05-20T11:05:09.000Z</published>
    <updated>2021-05-24T10:58:33.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520190659.PNG" alt=""><br>则依次打印出数组：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>可以发现，顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。<br>定义四个变量来确定边界。top、bottom、right、left。——注意他们范围的确定。<br>然后进行循环判断即可。具体如图。——注意循环终止条件。<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520190718.JPG" alt=""></p><p><strong>注意：</strong></p><ul><li>对于range(a,b)，反向的话用range(b,a,-1)即可!(逗号)</li></ul><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> matrix == []: <span class="keyword">return</span> []</span><br><span class="line">        top = <span class="number">0</span></span><br><span class="line">        bottom = <span class="built_in">len</span>(matrix)-<span class="number">1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(matrix[<span class="number">0</span>])-<span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># →</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; bottom:<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ↓</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left:<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ←</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[bottom][i])</span><br><span class="line">            bottom -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> bottom &lt; top:<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ↑</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：&lt;br&gt;&lt;img src=&quot;https</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="多指针" scheme="https://xxren8218.github.io/tags/%E5%A4%9A%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统——协同过滤&amp;隐语义模型</title>
    <link href="https://xxren8218.github.io/20210520/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4-%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B.html"/>
    <id>https://xxren8218.github.io/20210520/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4-%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B.html</id>
    <published>2021-05-19T16:47:00.000Z</published>
    <updated>2021-05-20T11:03:56.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推荐系统——协同过滤—-gt-基于统计方法"><a href="#推荐系统——协同过滤—-gt-基于统计方法" class="headerlink" title="推荐系统——协同过滤—&gt;基于统计方法"></a>推荐系统——协同过滤—&gt;基于统计方法</h2><h3 id="本节需要用到-scikit-surprise-库"><a href="#本节需要用到-scikit-surprise-库" class="headerlink" title="本节需要用到 scikit-surprise 库"></a>本节需要用到 scikit-surprise 库</h3><ul><li>pip install surprise 进行安装（需要C++编译环境）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> KNNBasic,SVD <span class="comment"># KNNBasic最基础的协同过滤算法（可以基于用户或者物品） SVD是基于矩阵分解的！</span></span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> Dataset <span class="comment"># Dataset默认的数据库进行练习。基础的电影的数据。（下方网址）</span></span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> evaluate, print_perf</span><br><span class="line"><span class="comment"># http://surprise.readthedocs.io/en/stable/index.html</span></span><br><span class="line"><span class="comment"># http://files.grouplens.org/datasets/movielens/ml-100k-README.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the movielens-100k dataset (download it if needed),</span></span><br><span class="line"><span class="comment"># and split it into 3 folds for cross-validation.</span></span><br><span class="line">data = Dataset.load_builtin(<span class="string">&#x27;ml-100k&#x27;</span>) <span class="comment"># 拿到内置的数据集</span></span><br><span class="line">data.split(n_folds=<span class="number">3</span>)  <span class="comment"># 进行交叉验证的折数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We&#x27;ll use the famous KNNBasic algorithm.</span></span><br><span class="line">algo = KNNBasic()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Evaluate performances of our algorithm on the dataset.</span></span><br><span class="line">perf = evaluate(algo, data, measures=[<span class="string">&#x27;RMSE&#x27;</span>, <span class="string">&#x27;MAE&#x27;</span>])  </span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"><span class="comment"># 之前的基本是 fit 这里不一样，可以自己指定三个参数（算法名字，数据，评估方法）</span></span><br><span class="line"><span class="comment"># 这里制定了均方误差和绝对误差</span></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line">print_perf(perf)</span><br></pre></td></tr></table></figure><pre><code>Evaluating RMSE, MAE of algorithm KNNBasic.------------Fold 1Computing the msd similarity matrix...Done computing similarity matrix.RMSE: 0.9876MAE:  0.7807------------Fold 2Computing the msd similarity matrix...Done computing similarity matrix.RMSE: 0.9871MAE:  0.7796------------Fold 3Computing the msd similarity matrix...Done computing similarity matrix.RMSE: 0.9902MAE:  0.7818------------------------Mean RMSE: 0.9883Mean MAE : 0.7807------------------------        Fold 1  Fold 2  Fold 3  Mean    MAE     0.7807  0.7796  0.7818  0.7807  RMSE    0.9876  0.9871  0.9902  0.9883  </code></pre><h2 id="推荐系统——进行矩阵分解求解（隐语义模型）—-gt-基于模型"><a href="#推荐系统——进行矩阵分解求解（隐语义模型）—-gt-基于模型" class="headerlink" title="推荐系统——进行矩阵分解求解（隐语义模型）—&gt;基于模型"></a>推荐系统——进行矩阵分解求解（隐语义模型）—&gt;基于模型</h2><ul><li>需要进行迭代求解，需要传一些参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> GridSearch</span><br><span class="line"></span><br><span class="line">param_grid = &#123;<span class="string">&#x27;n_epochs&#x27;</span>: [<span class="number">5</span>, <span class="number">10</span>], <span class="string">&#x27;lr_all&#x27;</span>: [<span class="number">0.002</span>, <span class="number">0.005</span>],</span><br><span class="line">              <span class="string">&#x27;reg_all&#x27;</span>: [<span class="number">0.4</span>, <span class="number">0.6</span>]&#125;</span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line"><span class="comment"># 指定了三个值，迭代次数，学习率，正则化的强度</span></span><br><span class="line"><span class="comment"># 做其8种组合。</span></span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line">grid_search = GridSearch(SVD, param_grid, measures=[<span class="string">&#x27;RMSE&#x27;</span>, <span class="string">&#x27;FCP&#x27;</span>]) <span class="comment"># SVD 矩阵分解！</span></span><br><span class="line">data = Dataset.load_builtin(<span class="string">&#x27;ml-100k&#x27;</span>)</span><br><span class="line">data.split(n_folds=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">grid_search.evaluate(data)</span><br></pre></td></tr></table></figure><pre><code>------------Parameters combination 1 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9972Mean FCP : 0.6843------------------------Parameters combination 2 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9734Mean FCP : 0.6946------------------------Parameters combination 3 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9777Mean FCP : 0.6926------------------------Parameters combination 4 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9635Mean FCP : 0.6987------------------------Parameters combination 5 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 1.0029Mean FCP : 0.6875------------------------Parameters combination 6 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 0.9820Mean FCP : 0.6953------------------------Parameters combination 7 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 0.9860Mean FCP : 0.6943------------------------Parameters combination 8 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 0.9733Mean FCP : 0.6991------------</code></pre><p><strong>GridSearch会帮我们存一些函数值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># best RMSE score</span></span><br><span class="line">print(grid_search.best_score[<span class="string">&#x27;RMSE&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># combination of parameters that gave the best RMSE score</span></span><br><span class="line">print(grid_search.best_params[<span class="string">&#x27;RMSE&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># best FCP score</span></span><br><span class="line">print(grid_search.best_score[<span class="string">&#x27;FCP&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># combination of parameters that gave the best FCP score</span></span><br><span class="line">print(grid_search.best_params[<span class="string">&#x27;FCP&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>0.963501988854&#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.4&#125;0.699084153002&#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.6&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line"></span><br><span class="line">results_df = pd.DataFrame.from_dict(grid_search.cv_results) </span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line"><span class="comment"># pd.DataFrame.from_dict可以传字典进行数据查看</span></span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line">results_df</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>FCP</th>      <th>RMSE</th>      <th>lr_all</th>      <th>n_epochs</th>      <th>params</th>      <th>scores</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.684266</td>      <td>0.997160</td>      <td>0.002</td>      <td>5</td>      <td>{'lr_all': 0.002, 'n_epochs': 5, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.997160189649, 'FCP': 0.684266412476}</td>    </tr>    <tr>      <th>1</th>      <td>0.694552</td>      <td>0.973383</td>      <td>0.005</td>      <td>5</td>      <td>{'lr_all': 0.005, 'n_epochs': 5, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.973383132387, 'FCP': 0.694551932996}</td>    </tr>    <tr>      <th>2</th>      <td>0.692616</td>      <td>0.977697</td>      <td>0.002</td>      <td>10</td>      <td>{'lr_all': 0.002, 'n_epochs': 10, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.977696629511, 'FCP': 0.692615513155}</td>    </tr>    <tr>      <th>3</th>      <td>0.698722</td>      <td>0.963502</td>      <td>0.005</td>      <td>10</td>      <td>{'lr_all': 0.005, 'n_epochs': 10, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.963501988854, 'FCP': 0.698721750945}</td>    </tr>    <tr>      <th>4</th>      <td>0.687482</td>      <td>1.002855</td>      <td>0.002</td>      <td>5</td>      <td>{'lr_all': 0.002, 'n_epochs': 5, 'reg_all': 0.6}</td>      <td>{'RMSE': 1.00285516237, 'FCP': 0.687481665759}</td>    </tr>    <tr>      <th>5</th>      <td>0.695337</td>      <td>0.982047</td>      <td>0.005</td>      <td>5</td>      <td>{'lr_all': 0.005, 'n_epochs': 5, 'reg_all': 0.6}</td>      <td>{'RMSE': 0.98204676013, 'FCP': 0.695337489535}</td>    </tr>    <tr>      <th>6</th>      <td>0.694338</td>      <td>0.985981</td>      <td>0.002</td>      <td>10</td>      <td>{'lr_all': 0.002, 'n_epochs': 10, 'reg_all': 0.6}</td>      <td>{'RMSE': 0.985980855401, 'FCP': 0.694337564062}</td>    </tr>    <tr>      <th>7</th>      <td>0.699084</td>      <td>0.973282</td>      <td>0.005</td>      <td>10</td>      <td>{'lr_all': 0.005, 'n_epochs': 10, 'reg_all': 0.6}</td>      <td>{'RMSE': 0.973281870802, 'FCP': 0.699084153002}</td>    </tr>  </tbody></table></div><h3 id="模型搭建出来了，用它来推荐东西！"><a href="#模型搭建出来了，用它来推荐东西！" class="headerlink" title="模型搭建出来了，用它来推荐东西！"></a>模型搭建出来了，用它来推荐东西！</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> (absolute_import, division, print_function,</span><br><span class="line">                        unicode_literals)</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> KNNBaseline</span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_item_names</span>():</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot;把电影的名字做成了id的映射&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    file_name = (<span class="string">&#x27;./ml-100k/u.item&#x27;</span>)</span><br><span class="line">    rid_to_name = &#123;&#125;</span><br><span class="line">    name_to_rid = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> io.<span class="built_in">open</span>(file_name, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            line = line.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">            rid_to_name[line[<span class="number">0</span>]] = line[<span class="number">1</span>]</span><br><span class="line">            name_to_rid[line[<span class="number">1</span>]] = line[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rid_to_name, name_to_rid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.导入数据</span></span><br><span class="line">data = Dataset.load_builtin(<span class="string">&#x27;ml-100k&#x27;</span>)</span><br><span class="line"><span class="comment"># 2.数据是一行的，将其转换成矩阵（稀疏的）</span></span><br><span class="line">trainset = data.build_full_trainset()</span><br><span class="line"><span class="comment"># 3.指定相似度的方法——此处用了皮尔孙，指定了基于物品的相似度。</span></span><br><span class="line">sim_options = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;pearson_baseline&#x27;</span>, <span class="string">&#x27;user_based&#x27;</span>: <span class="literal">False</span>&#125;</span><br><span class="line">algo = KNNBaseline(sim_options=sim_options)</span><br><span class="line">algo.train(trainset)</span><br></pre></td></tr></table></figure><pre><code>Estimating biases using als...Computing the pearson_baseline similarity matrix...Done computing similarity matrix.</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rid_to_name, name_to_rid = read_item_names()</span><br><span class="line"></span><br><span class="line">toy_story_raw_id = name_to_rid[<span class="string">&#x27;Now and Then (1995)&#x27;</span>]</span><br><span class="line"><span class="comment"># 直接传电影名字不行，因为传的是id，先对其进行id的转换。</span></span><br><span class="line"></span><br><span class="line">toy_story_raw_id <span class="comment"># 在数据的id</span></span><br></pre></td></tr></table></figure><pre><code>&#39;1053&#39;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toy_story_inner_id = algo.trainset.to_inner_iid(toy_story_raw_id)</span><br><span class="line">toy_story_inner_id <span class="comment"># 在实际计算的(矩阵的)id</span></span><br></pre></td></tr></table></figure><pre><code>961</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toy_story_neighbors = algo.get_neighbors(toy_story_inner_id, k=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 找出最接近的10个电影id</span></span><br><span class="line">toy_story_neighbors</span><br></pre></td></tr></table></figure><pre><code>[291, 82, 366, 528, 179, 101, 556, 310, 431, 543]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">toy_story_neighbors = (algo.trainset.to_raw_iid(inner_id)</span><br><span class="line">                       <span class="keyword">for</span> inner_id <span class="keyword">in</span> toy_story_neighbors)</span><br><span class="line">toy_story_neighbors = (rid_to_name[rid]</span><br><span class="line">                       <span class="keyword">for</span> rid <span class="keyword">in</span> toy_story_neighbors)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(<span class="string">&#x27;The 10 nearest neighbors of Toy Story are:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> movie <span class="keyword">in</span> toy_story_neighbors:</span><br><span class="line">    print(movie)</span><br></pre></td></tr></table></figure><pre><code>The 10 nearest neighbors of Toy Story are:While You Were Sleeping (1995)Batman (1989)Dave (1993)Mrs. Doubtfire (1993)Groundhog Day (1993)Raiders of the Lost Ark (1981)Maverick (1994)French Kiss (1995)Stand by Me (1986)Net, The (1995)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;推荐系统——协同过滤—-gt-基于统计方法&quot;&gt;&lt;a href=&quot;#推荐系统——协同过滤—-gt-基于统计方法&quot; class=&quot;headerlink&quot; title=&quot;推荐系统——协同过滤—&amp;gt;基于统计方法&quot;&gt;&lt;/a&gt;推荐系统——协同过滤—&amp;gt;基于统计方法&lt;/</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>EM算法应用——GMM聚类</title>
    <link href="https://xxren8218.github.io/20210519/EM%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94GMM%E8%81%9A%E7%B1%BB.html"/>
    <id>https://xxren8218.github.io/20210519/EM%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94GMM%E8%81%9A%E7%B1%BB.html</id>
    <published>2021-05-18T16:55:06.000Z</published>
    <updated>2021-05-18T17:02:03.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GMM实例"><a href="#GMM实例" class="headerlink" title="GMM实例"></a>GMM实例</h1><ul><li>桥东西两个地方摆放了共享单车。统计使用共享单车的数量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv (<span class="string">&#x27;Fremont.csv&#x27;</span>, index_col=<span class="string">&#x27;Date&#x27;</span>, parse_dates=<span class="literal">True</span>)</span><br><span class="line">data.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Fremont Bridge West Sidewalk</th>      <th>Fremont Bridge East Sidewalk</th>    </tr>    <tr>      <th>Date</th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>2012-10-03 00:00:00</th>      <td>4.0</td>      <td>9.0</td>    </tr>    <tr>      <th>2012-10-03 01:00:00</th>      <td>4.0</td>      <td>6.0</td>    </tr>    <tr>      <th>2012-10-03 02:00:00</th>      <td>1.0</td>      <td>1.0</td>    </tr>    <tr>      <th>2012-10-03 03:00:00</th>      <td>2.0</td>      <td>3.0</td>    </tr>    <tr>      <th>2012-10-03 04:00:00</th>      <td>6.0</td>      <td>1.0</td>    </tr>  </tbody></table></div><h2 id="Visualizing-the-Dataset"><a href="#Visualizing-the-Dataset" class="headerlink" title="Visualizing the Dataset"></a>Visualizing the Dataset</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">data.plot();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010149.png" alt=""></p><p>可以看到数据太密集，因为是以小时为单位创建的，</p><ul><li>数据重采样，按周进行计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">data.resample(<span class="string">&#x27;w&#x27;</span>).<span class="built_in">sum</span>().plot(); <span class="comment"># 时间序列化</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010134.png" alt=""></p><p>可以看到东西边差别不大。<br>采用滑动窗口进行可视化——当前365天数据的总和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.resample(<span class="string">&#x27;D&#x27;</span>).<span class="built_in">sum</span>().rolling(<span class="number">365</span>).<span class="built_in">sum</span>().plot();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010117.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data.groupby(data.index.time).mean().plot();</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>)</span><br></pre></td></tr></table></figure><pre><code>(array([     0.,  10000.,  20000.,  30000.,  40000.,  50000.,  60000.,         70000.,  80000.,  90000.]), &lt;a list of 10 Text xticklabel objects&gt;)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010104.png" alt=""></p><ul><li>蓝线和绿线满足不同分布规则。</li><li>隐变量有两个。桥东和桥西。</li></ul><p>做GMM模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pivot table</span></span><br><span class="line">data.columns =[<span class="string">&#x27;West&#x27;</span>, <span class="string">&#x27;East&#x27;</span>]</span><br><span class="line">data [<span class="string">&#x27;Total&#x27;</span>] =data[<span class="string">&#x27;West&#x27;</span>]+data[<span class="string">&#x27;East&#x27;</span>]</span><br><span class="line">pivoted = data.pivot_table(<span class="string">&#x27;Total&#x27;</span>, index=data.index.time, columns=data.index.date) <span class="comment"># 做一个透视表</span></span><br><span class="line">pivoted.iloc[:<span class="number">5</span>,:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>2012-10-03</th>      <th>2012-10-04</th>      <th>2012-10-05</th>      <th>2012-10-06</th>      <th>2012-10-07</th>    </tr>  </thead>  <tbody>    <tr>      <th>00:00:00</th>      <td>13.0</td>      <td>18.0</td>      <td>11.0</td>      <td>15.0</td>      <td>11.0</td>    </tr>    <tr>      <th>01:00:00</th>      <td>10.0</td>      <td>3.0</td>      <td>8.0</td>      <td>15.0</td>      <td>17.0</td>    </tr>    <tr>      <th>02:00:00</th>      <td>2.0</td>      <td>9.0</td>      <td>7.0</td>      <td>9.0</td>      <td>3.0</td>    </tr>    <tr>      <th>03:00:00</th>      <td>5.0</td>      <td>3.0</td>      <td>4.0</td>      <td>3.0</td>      <td>6.0</td>    </tr>    <tr>      <th>04:00:00</th>      <td>7.0</td>      <td>8.0</td>      <td>9.0</td>      <td>5.0</td>      <td>3.0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pivoted.plot(legend=<span class="literal">False</span>, alpha =<span class="number">0.01</span>);</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>)</span><br></pre></td></tr></table></figure><pre><code>(array([     0.,  10000.,  20000.,  30000.,  40000.,  50000.,  60000.,         70000.,  80000.,  90000.]), &lt;a list of 10 Text xticklabel objects&gt;)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010042.png" alt=""></p><p><strong>可以看到有两种分布，能否用GMM进行聚类任务，然后分开呢？</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pivoted.shape</span><br></pre></td></tr></table></figure><pre><code>(24, 1763)</code></pre><p><strong>样本数24，特征数1763不合适</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = pivoted.fillna(<span class="number">0</span>).T.values</span><br><span class="line">X.shape</span><br></pre></td></tr></table></figure><pre><code>(1763, 24)</code></pre><p><strong>然后拿它GMM进行聚类的任务</strong></p><ul><li>拿到了1763个数据，以及它每天24小时的数据，我们想做个聚类，看他是东还是西。</li></ul><p>为了方便演示，将图像画在2D空间——进行PCA的降维</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">X2 = PCA(<span class="number">2</span>).fit_transform(X)</span><br><span class="line">X2.shape</span><br></pre></td></tr></table></figure><pre><code>(1763, 2)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X2[:,<span class="number">0</span>],X2[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1b92c86a630&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010015.png" alt=""></p><p><strong>PCA降维以后数据特征不存在具体物理意义、但是空间意义还在</strong></p><p>然后进行聚类分析：</p><ul><li>GMM聚类与KMEANS有些类似，因为kmeans需要知道K点个数。而此处需要知道隐变量的个数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line">gmm =GaussianMixture(<span class="number">2</span>)</span><br><span class="line">gmm.fit(X)</span><br><span class="line">labels = gmm.predict_proba(X) <span class="comment"># 得到的是概率值，即每一个样本属于（第一个类别【分布】的可能性，第二个类别【分布】的可能性）</span></span><br><span class="line">labels</span><br></pre></td></tr></table></figure><pre><code>array([[  1.00000000e+000,   4.27200703e-157],       [  1.00000000e+000,   2.97606604e-125],       [  1.00000000e+000,   1.00461289e-101],       ...,        [  2.50152395e-030,   1.00000000e+000],       [  2.49747986e-025,   1.00000000e+000],       [  1.00000000e+000,   1.79108465e-301]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">labels = gmm.predict(X) <span class="comment"># 得到的是概类别的标签</span></span><br><span class="line">labels</span><br></pre></td></tr></table></figure><pre><code>array([0, 0, 0, ..., 1, 1, 0], dtype=int64)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X2[:,<span class="number">0</span>],X2[:,<span class="number">1</span>], c=labels, cmap=<span class="string">&#x27;rainbow&#x27;</span>) </span><br><span class="line"><span class="comment">#plt.colorbar()</span></span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1b92cdd0f98&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005957.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize =(<span class="number">14</span>, <span class="number">6</span>))</span><br><span class="line">                      </span><br><span class="line">pivoted.T[labels == <span class="number">0</span>].T.plot(legend =<span class="literal">False</span>, alpha =<span class="number">0.1</span>, ax=ax[<span class="number">0</span>])  <span class="comment"># 进行数据的还原，显示数据的样子</span></span><br><span class="line">pivoted.T[labels == <span class="number">1</span>].T.plot(legend =<span class="literal">False</span>, alpha =<span class="number">0.1</span>, ax=ax[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].set_title (<span class="string">&#x27;Purple Cluster&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>].set_title (<span class="string">&#x27;Red Cluster&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.text.Text at 0x1b932208b38&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005941.png" alt=""></p><p><strong>来看看GMM和KMEANS的差异吧！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line">X, y_true = make_blobs(n_samples=<span class="number">800</span>, centers=<span class="number">4</span>, random_state=<span class="number">11</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005926.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">4</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">y_kmeans = kmeans.predict(X)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_kmeans, s=<span class="number">50</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">centers = kmeans.cluster_centers_</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005911.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line">gmm = GaussianMixture(n_components=<span class="number">4</span>).fit(X)</span><br><span class="line">labels = gmm.predict(X)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=labels, s=<span class="number">40</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005856.png" alt=""></p><p><strong>GMM和KMEANS在规则数据上基本一样！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">13</span>)</span><br><span class="line">X_stretched = np.dot(X, rng.randn(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">4</span>, random_state=<span class="number">1</span>)</span><br><span class="line">kmeans.fit(X_stretched)</span><br><span class="line">y_kmeans = kmeans.predict(X_stretched)</span><br><span class="line">plt.scatter(X_stretched[:, <span class="number">0</span>], X_stretched[:, <span class="number">1</span>], c=y_kmeans, s=<span class="number">50</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">centers = kmeans.cluster_centers_</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005837.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gmm = GaussianMixture(n_components=<span class="number">4</span>)        </span><br><span class="line">gmm.fit(X_stretched)</span><br><span class="line">y_gmm = gmm.predict(X_stretched)</span><br><span class="line">plt.scatter(X_stretched[:, <span class="number">0</span>], X_stretched[:, <span class="number">1</span>], c=y_gmm, s=<span class="number">50</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1b932008208&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005822.png" alt=""></p><p><strong> GMM比KMEANS好！ </strong></p><h2 id="所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好"><a href="#所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好" class="headerlink" title="所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好"></a>所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GMM实例&quot;&gt;&lt;a href=&quot;#GMM实例&quot; class=&quot;headerlink&quot; title=&quot;GMM实例&quot;&gt;&lt;/a&gt;GMM实例&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;桥东西两个地方摆放了共享单车。统计使用共享单车的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>力扣（一）：两数之和</title>
    <link href="https://xxren8218.github.io/20210518/%E5%8A%9B%E6%89%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html"/>
    <id>https://xxren8218.github.io/20210518/%E5%8A%9B%E6%89%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</id>
    <published>2021-05-18T10:00:40.000Z</published>
    <updated>2021-05-18T10:01:48.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h2 id="2-思路1"><a href="#2-思路1" class="headerlink" title="2.思路1"></a>2.思路1</h2><p>方法一：暴力枚举<br>思路及算法</p><p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p><p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>方法二：哈希表<br>思路及算法</p><p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。</p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums): </span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（二十）：包含min函数的栈</title>
    <link href="https://xxren8218.github.io/20210517/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.html"/>
    <id>https://xxren8218.github.io/20210517/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.html</id>
    <published>2021-05-17T10:05:38.000Z</published>
    <updated>2021-05-17T10:08:06.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>定义栈的数据结构，请在类型中实现一个能够得到栈最小元素的min函数。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>使用两个stack，一个为数据栈，另一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。</p><p>若加入的元素比辅助栈的栈顶元素小，则再辅助栈增加该元素，否则，增加辅助栈的栈顶元素。</p><p>Data = [1,2,-2,3,-4,6]<br>Min = [1,1,-2,-2,-4,-4]</p><p>在Data出栈的时候，同时将Data和Min出栈即可。</p><p>获得栈顶元素的时候：直接返回数据栈的栈顶元素。</p><p>栈最小元素：直接返回辅助栈的栈顶元素。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.Data = []</span><br><span class="line">        self.Min = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.Data.append(node)</span><br><span class="line">        <span class="keyword">if</span> self.Min:</span><br><span class="line">            <span class="keyword">if</span> self.Min[-<span class="number">1</span>] &gt; node:</span><br><span class="line">                self.Min.append(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.Min.append(self.Min[-<span class="number">1</span>])   <span class="comment">#保证Data出栈的时候Min也是出栈的，且最小数字不会改变。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Min.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.Min.pop()</span><br><span class="line">        <span class="keyword">return</span> self.Data.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Data[-<span class="number">1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.Min == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Min[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="还有一种思路——使用单调栈。"><a href="#还有一种思路——使用单调栈。" class="headerlink" title="还有一种思路——使用单调栈。"></a>还有一种思路——使用单调栈。</h2><p>入栈的时候：首先往空的数据栈里压入数字3，显然现在3是最小值，我们也把最小值压入辅助栈。接下来往数据栈里压入数字4。<br>由于4大于之前的最小值，因此我们只要入数据栈，不压入辅助栈。</p><p>出栈的时候：当数据栈和辅助栈的栈顶元素相同的时候，辅助栈的栈顶元素出栈。否则，数据栈的栈顶元素出栈。</p><p>Data = [1,2,-2,3,-4,6]<br>Min = [1,-2,-4]</p><p><strong>这个与上个不同的是：Data出栈时候需要判断是否为Min的栈顶元素,若是，则需要同时出栈。上面的方法不需要判断，只需要同时出栈</strong></p><p>获得栈顶元素的时候：直接返回数据栈的栈顶元素。</p><p>栈最小元素：直接返回辅助栈的栈顶元素。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.Data = []</span><br><span class="line">        self.Min = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.Data.append(x)</span><br><span class="line">        <span class="keyword">if</span> self.Min:</span><br><span class="line">            <span class="keyword">if</span> self.Min[-<span class="number">1</span>] &gt;= x:</span><br><span class="line">                self.Min.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Min.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.Data[-<span class="number">1</span>] == self.Min[-<span class="number">1</span>]: self.Min.pop()</span><br><span class="line">        self.Data.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Data[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.Min == []:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Min[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;定义栈的数据结构，请在类型中实现一个能够得到栈最小元素的min函数。&lt;/p&gt;
&lt;h2 id=&quot;2-思路&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="辅助栈" scheme="https://xxren8218.github.io/tags/%E8%BE%85%E5%8A%A9%E6%A0%88/"/>
    
    <category term="栈" scheme="https://xxren8218.github.io/tags/%E6%A0%88/"/>
    
    <category term="单调栈" scheme="https://xxren8218.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>降维算法——PCA(主成分分析)</title>
    <link href="https://xxren8218.github.io/20210515/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94PCA-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.html"/>
    <id>https://xxren8218.github.io/20210515/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94PCA-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.html</id>
    <published>2021-05-15T06:31:02.000Z</published>
    <updated>2021-05-15T06:39:58.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="鸢尾花数据集的降维——PCA"><a href="#鸢尾花数据集的降维——PCA" class="headerlink" title="鸢尾花数据集的降维——PCA"></a>鸢尾花数据集的降维——PCA</h1><ul><li>PCA的降维是不依赖标签（分类的），而是依赖样本的方差（协方差）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;iris.data&#x27;</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>5.1</th>      <th>3.5</th>      <th>1.4</th>      <th>0.2</th>      <th>Iris-setosa</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>4.9</td>      <td>3.0</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>1</th>      <td>4.7</td>      <td>3.2</td>      <td>1.3</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>2</th>      <td>4.6</td>      <td>3.1</td>      <td>1.5</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>3</th>      <td>5.0</td>      <td>3.6</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>4</th>      <td>5.4</td>      <td>3.9</td>      <td>1.7</td>      <td>0.4</td>      <td>Iris-setosa</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.columns=[<span class="string">&#x27;sepal_len&#x27;</span>, <span class="string">&#x27;sepal_wid&#x27;</span>, <span class="string">&#x27;petal_len&#x27;</span>, <span class="string">&#x27;petal_wid&#x27;</span>, <span class="string">&#x27;class&#x27;</span>]</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>sepal_len</th>      <th>sepal_wid</th>      <th>petal_len</th>      <th>petal_wid</th>      <th>class</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>4.9</td>      <td>3.0</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>1</th>      <td>4.7</td>      <td>3.2</td>      <td>1.3</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>2</th>      <td>4.6</td>      <td>3.1</td>      <td>1.5</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>3</th>      <td>5.0</td>      <td>3.6</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>4</th>      <td>5.4</td>      <td>3.9</td>      <td>1.7</td>      <td>0.4</td>      <td>Iris-setosa</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># split data table into data X and class labels y</span></span><br><span class="line"></span><br><span class="line">X = df.ix[:,<span class="number">0</span>:<span class="number">4</span>].values</span><br><span class="line">y = df.ix[:,<span class="number">4</span>].values</span><br></pre></td></tr></table></figure><p><strong> 数据的可视化 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">label_dict = &#123;<span class="number">1</span>: <span class="string">&#x27;Iris-Setosa&#x27;</span>,</span><br><span class="line">              <span class="number">2</span>: <span class="string">&#x27;Iris-Versicolor&#x27;</span>,</span><br><span class="line">              <span class="number">3</span>: <span class="string">&#x27;Iris-Virgnica&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">feature_dict = &#123;<span class="number">0</span>: <span class="string">&#x27;sepal length [cm]&#x27;</span>,</span><br><span class="line">                <span class="number">1</span>: <span class="string">&#x27;sepal width [cm]&#x27;</span>,</span><br><span class="line">                <span class="number">2</span>: <span class="string">&#x27;petal length [cm]&#x27;</span>,</span><br><span class="line">                <span class="number">3</span>: <span class="string">&#x27;petal width [cm]&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> cnt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, cnt+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> lab <span class="keyword">in</span> (<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>):</span><br><span class="line">        plt.hist(X[y==lab, cnt],</span><br><span class="line">                     label=lab,</span><br><span class="line">                     bins=<span class="number">10</span>,</span><br><span class="line">                     alpha=<span class="number">0.3</span>,)</span><br><span class="line">    plt.xlabel(feature_dict[cnt])</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>, fontsize=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143327.png" alt=""></p><p><strong> 一般要先进行数据的标准化，归一化，或正态化的预处理 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">X_std = StandardScaler().fit_transform(X)</span><br><span class="line"><span class="built_in">print</span> (X_std)</span><br></pre></td></tr></table></figure><pre><code>[[-1.1483555  -0.11805969 -1.35396443 -1.32506301] [-1.3905423   0.34485856 -1.41098555 -1.32506301] [-1.51163569  0.11339944 -1.29694332 -1.32506301] [-1.02726211  1.27069504 -1.35396443 -1.32506301] [-0.54288852  1.9650724  -1.18290109 -1.0614657 ] [-1.51163569  0.8077768  -1.35396443 -1.19326436] [-1.02726211  0.8077768  -1.29694332 -1.32506301] [-1.75382249 -0.34951881 -1.35396443 -1.32506301] [-1.1483555   0.11339944 -1.29694332 -1.45686167] [-0.54288852  1.50215416 -1.29694332 -1.32506301] [-1.2694489   0.8077768  -1.23992221 -1.32506301] [-1.2694489  -0.11805969 -1.35396443 -1.45686167] [-1.87491588 -0.11805969 -1.52502777 -1.45686167] [-0.05851493  2.19653152 -1.46800666 -1.32506301] ... [-0.54288852  1.9650724  -1.41098555 -1.0614657 ] [-0.90616871  1.03923592 -1.35396443 -1.19326436] [-0.17960833  1.73361328 -1.18290109 -1.19326436] [-0.90616871  1.73361328 -1.29694332 -1.19326436] [ 1.15241904  0.34485856  1.21198569  1.4427088 ] [ 1.03132564  0.57631768  1.09794346  1.70630611] [ 1.03132564 -0.11805969  0.81283789  1.4427088 ] [ 0.54695205 -1.27535529  0.69879566  0.91551417] [ 0.78913885 -0.11805969  0.81283789  1.04731282] [ 0.42585866  0.8077768   0.92688012  1.4427088 ] [ 0.06257847 -0.11805969  0.75581678  0.78371551]]</code></pre><p><strong> 手撕协方差 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean_vec = np.mean(X_std, axis=<span class="number">0</span>)</span><br><span class="line">cov_mat = (X_std - mean_vec).T.dot((X_std - mean_vec)) / (X_std.shape[<span class="number">0</span>]-<span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;Covariance matrix \n%s&#x27;</span> %cov_mat)</span><br></pre></td></tr></table></figure><pre><code>Covariance matrix [[ 1.00675676 -0.10448539  0.87716999  0.82249094] [-0.10448539  1.00675676 -0.41802325 -0.35310295] [ 0.87716999 -0.41802325  1.00675676  0.96881642] [ 0.82249094 -0.35310295  0.96881642  1.00675676]]</code></pre><p><strong> 直接可以在numpy中调用cov（）,协方差函数 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;NumPy covariance matrix: \n%s&#x27;</span> %np.cov(X_std.T))</span><br></pre></td></tr></table></figure><pre><code>NumPy covariance matrix: [[ 1.00675676 -0.10448539  0.87716999  0.82249094] [-0.10448539  1.00675676 -0.41802325 -0.35310295] [ 0.87716999 -0.41802325  1.00675676  0.96881642] [ 0.82249094 -0.35310295  0.96881642  1.00675676]]</code></pre><p>可以看到对角线上的都为1，因为自身与自身的协方差肯定是1</p><ul><li>标准化以后是1。——相关系数。</li><li>没有标准化的数据，仅仅是方差。</li></ul><h3 id="计算协方差矩阵的特征值和特征向量"><a href="#计算协方差矩阵的特征值和特征向量" class="headerlink" title="计算协方差矩阵的特征值和特征向量"></a>计算协方差矩阵的特征值和特征向量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cov_mat = np.cov(X_std.T)</span><br><span class="line"></span><br><span class="line">eig_vals, eig_vecs = np.linalg.eig(cov_mat)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Eigenvectors \n%s&#x27;</span> %eig_vecs)</span><br><span class="line">print(<span class="string">&#x27;\nEigenvalues \n%s&#x27;</span> %eig_vals)</span><br></pre></td></tr></table></figure><pre><code>Eigenvectors [[ 0.52308496 -0.36956962 -0.72154279  0.26301409] [-0.25956935 -0.92681168  0.2411952  -0.12437342] [ 0.58184289 -0.01912775  0.13962963 -0.80099722] [ 0.56609604 -0.06381646  0.63380158  0.52321917]]Eigenvalues [ 2.92442837  0.93215233  0.14946373  0.02098259]</code></pre><p><strong> 特征值的大小代表特征向量的重要程度 </strong></p><p>下面的代码将其进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Make a list of (eigenvalue, eigenvector) tuples</span></span><br><span class="line">eig_pairs = [(np.<span class="built_in">abs</span>(eig_vals[i]), eig_vecs[:,i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_vals))]</span><br><span class="line"><span class="built_in">print</span> (eig_pairs)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;----------&#x27;</span>)</span><br><span class="line"><span class="comment"># Sort the (eigenvalue, eigenvector) tuples from high to low</span></span><br><span class="line">eig_pairs.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visually confirm that the list is correctly sorted by decreasing eigenvalues</span></span><br><span class="line">print(<span class="string">&#x27;Eigenvalues in descending order:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eig_pairs:</span><br><span class="line">    print(i[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>[(2.9244283691111144, array([ 0.52308496, -0.25956935,  0.58184289,  0.56609604])), (0.93215233025350641, array([-0.36956962, -0.92681168, -0.01912775, -0.06381646])), (0.14946373489813314, array([-0.72154279,  0.2411952 ,  0.13962963,  0.63380158])), (0.020982592764270606, array([ 0.26301409, -0.12437342, -0.80099722,  0.52321917]))]----------Eigenvalues in descending order:2.924428369110.9321523302540.1494637348980.0209825927643</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tot = <span class="built_in">sum</span>(eig_vals)</span><br><span class="line">var_exp = [(i / tot)*<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(eig_vals, reverse=<span class="literal">True</span>)]</span><br><span class="line"><span class="built_in">print</span> (var_exp)</span><br><span class="line">cum_var_exp = np.cumsum(var_exp)  <span class="comment"># 来验证最后的和是否为100% 以及维度的选择——cumsum()的解释在下面。</span></span><br><span class="line">cum_var_exp</span><br></pre></td></tr></table></figure><pre><code>[72.620033326920336, 23.147406858644135, 3.7115155645845164, 0.52104424985101538]array([  72.62003333,   95.76744019,   99.47895575,  100.        ])</code></pre><h3 id="cumsum-函数的解释："><a href="#cumsum-函数的解释：" class="headerlink" title="cumsum()函数的解释："></a>cumsum()函数的解释：</h3><ul><li>为什么要用它呢？<ul><li>可以判断到底降维到几维。（设置阈值。比如百分之95%，那么降到2维即可）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;-----------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (np.cumsum(a))</span><br></pre></td></tr></table></figure><pre><code>[1 2 3 4]-----------[ 1  3  6 10]</code></pre><p><strong> 作图展示特征值所占的百分比 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">plt.bar(<span class="built_in">range</span>(<span class="number">4</span>), var_exp, alpha=<span class="number">0.5</span>, align=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">            label=<span class="string">&#x27;individual explained variance&#x27;</span>)</span><br><span class="line">plt.step(<span class="built_in">range</span>(<span class="number">4</span>), cum_var_exp, where=<span class="string">&#x27;mid&#x27;</span>,                <span class="comment"># 阶梯图。where，表示在哪里开始跳跃。</span></span><br><span class="line">             label=<span class="string">&#x27;cumulative explained variance&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Explained variance ratio&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Principal components&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.tight_layout() <span class="comment"># 最自动调整图的大小。使其填满图像区域。</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143458.png" alt=""></p><p><strong> 确定w的维度 </strong></p><ul><li>拿前两个特征向量。——基变换:w.T * x0 = x1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix_w = np.hstack((eig_pairs[<span class="number">0</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">                      eig_pairs[<span class="number">1</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Matrix W:\n&#x27;</span>, matrix_w)</span><br></pre></td></tr></table></figure><pre><code>Matrix W: [[ 0.52308496 -0.36956962] [-0.25956935 -0.92681168] [ 0.58184289 -0.01912775] [ 0.56609604 -0.06381646]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y = X_std.dot(matrix_w)</span><br><span class="line">Y</span><br></pre></td></tr></table></figure><pre><code>array([[-2.10795032,  0.64427554],       [-2.38797131,  0.30583307],       [-2.32487909,  0.56292316],       [-2.40508635, -0.687591  ],       [-2.08320351, -1.53025171],       [-2.4636848 , -0.08795413],       [-2.25174963, -0.25964365],       [-2.3645813 ,  1.08255676],       [-2.20946338,  0.43707676],       [-2.17862017, -1.08221046],       [-2.34525657, -0.17122946],       ...       [ 2.00701161, -0.60663655],       [ 1.89319854, -0.68227708],       [ 1.13831104,  0.70171953],       [ 2.03519535, -0.86076914],       [ 1.99464025, -1.04517619],       [ 1.85977129, -0.37934387],       [ 1.54200377,  0.90808604],       [ 1.50925493, -0.26460621],       [ 1.3690965 , -1.01583909],       [ 0.94680339,  0.02182097]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> lab, col <span class="keyword">in</span> <span class="built_in">zip</span>((<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>),</span><br><span class="line">                        (<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line">     plt.scatter(X[y==lab, <span class="number">0</span>],</span><br><span class="line">                X[y==lab, <span class="number">1</span>],</span><br><span class="line">                label=lab,</span><br><span class="line">                c=col)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;sepal_len&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;sepal_wid&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143541.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> lab, col <span class="keyword">in</span> <span class="built_in">zip</span>((<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>),</span><br><span class="line">                        (<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line">     plt.scatter(Y[y==lab, <span class="number">0</span>],</span><br><span class="line">                Y[y==lab, <span class="number">1</span>],</span><br><span class="line">                label=lab,</span><br><span class="line">                c=col)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Principal Component 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Principal Component 2&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower center&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143554.png" alt=""></p><h2 id="PCA使得结果更容易分类"><a href="#PCA使得结果更容易分类" class="headerlink" title="PCA使得结果更容易分类"></a>PCA使得结果更容易分类</h2><p><strong> 降维后数据的意义不存在了 </strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;鸢尾花数据集的降维——PCA&quot;&gt;&lt;a href=&quot;#鸢尾花数据集的降维——PCA&quot; class=&quot;headerlink&quot; title=&quot;鸢尾花数据集的降维——PCA&quot;&gt;&lt;/a&gt;鸢尾花数据集的降维——PCA&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;PCA的降维是不依赖标签（分类的</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>降维算法——LDA(线性判别分析)</title>
    <link href="https://xxren8218.github.io/20210515/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94LDA-%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90.html"/>
    <id>https://xxren8218.github.io/20210515/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94LDA-%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90.html</id>
    <published>2021-05-15T06:16:53.000Z</published>
    <updated>2021-05-15T06:29:10.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="鸢尾花的数据集进行降维"><a href="#鸢尾花的数据集进行降维" class="headerlink" title="鸢尾花的数据集进行降维"></a>鸢尾花的数据集进行降维</h1><ul><li>有四个维度，萼片的长度。萼片的宽度，花瓣的长度，花瓣的宽度——将其降低维度为2维</li><li>数据集大概有150条</li><li>数据集没有列名，给其进行指定，使用zip()函数，将其进行对应</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">feature_dict = &#123;i:label <span class="keyword">for</span> i,label <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">                <span class="built_in">range</span>(<span class="number">4</span>),</span><br><span class="line">                  (<span class="string">&#x27;sepal length in cm&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;sepal width in cm&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;petal length in cm&#x27;</span>,                <span class="comment"># 用到了字典推导式！</span></span><br><span class="line">                  <span class="string">&#x27;petal width in cm&#x27;</span>, ))&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># feature_dict = &#123;0: &#x27;sepal length in cm&#x27;, </span></span><br><span class="line"><span class="comment">#                 1: &#x27;sepal width in cm&#x27;, </span></span><br><span class="line"><span class="comment">#                 2: &#x27;petal length in cm&#x27;, </span></span><br><span class="line"><span class="comment">#                 3: &#x27;petal width in cm&#x27;&#125;</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.io.parsers.read_csv(</span><br><span class="line">    filepath_or_buffer=<span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span>,</span><br><span class="line">    header=<span class="literal">None</span>,</span><br><span class="line">    sep=<span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"><span class="comment"># 数据加列名</span></span><br><span class="line">df.columns = [l <span class="keyword">for</span> i,l <span class="keyword">in</span> <span class="built_in">sorted</span>(feature_dict.items())] + [<span class="string">&#x27;class label&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">sorted()得到的是一个列表，需要接收，而list.sort()原地排序。O(nlogn)</span></span><br><span class="line"><span class="string">若排序的是字典，会将字典的键值，放入元祖中，则可以通过 i,j 进行取元祖里的值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string">z = [i for i in sorted(feature_dict.items())]</span></span><br><span class="line"><span class="string"># [(0, &#x27;sepal length in cm&#x27;), (1, &#x27;sepal width in cm&#x27;), (2, &#x27;petal length in cm&#x27;), (3, &#x27;petal width in cm&#x27;)]</span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string">x = [l for i,l in sorted(feature_dict.items())]</span></span><br><span class="line"><span class="string"># [&#x27;sepal length in cm&#x27;, &#x27;sepal width in cm&#x27;, &#x27;petal length in cm&#x27;, &#x27;petal width in cm&#x27;]</span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">df.dropna(how=<span class="string">&quot;all&quot;</span>, inplace=<span class="literal">True</span>) <span class="comment"># to drop the empty line at file-end</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string">dropna()方法，能够找到DataFrame类型数据的空值（缺失值），将空值所在的行/列删除后，将新的DataFrame作为返回值返回。</span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">axis：轴。0或&#x27;index&#x27;，表示按行删除；1或&#x27;columns&#x27;，表示按列删除。</span></span><br><span class="line"><span class="string">how：筛选方式。‘any’，表示该行/列只要有一个以上的空值，就删除该行/列；</span></span><br><span class="line"><span class="string">    ‘all’，表示该行/列全部都为空值，就删除该行/列。</span></span><br><span class="line"><span class="string">thresh：非空元素最低数量。int型，默认为None。如果该行/列中，非空元素数量小于这个值，就删除该行/列</span></span><br><span class="line"><span class="string">inplace：是否原地替换。布尔值，默认为False。如果为True，则在原DataFrame上进行操作，返回值为None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">df.tail()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>sepal length in cm</th>      <th>sepal width in cm</th>      <th>petal length in cm</th>      <th>petal width in cm</th>      <th>class label</th>    </tr>  </thead>  <tbody>    <tr>      <th>145</th>      <td>6.7</td>      <td>3.0</td>      <td>5.2</td>      <td>2.3</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>146</th>      <td>6.3</td>      <td>2.5</td>      <td>5.0</td>      <td>1.9</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>147</th>      <td>6.5</td>      <td>3.0</td>      <td>5.2</td>      <td>2.0</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>148</th>      <td>6.2</td>      <td>3.4</td>      <td>5.4</td>      <td>2.3</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>149</th>      <td>5.9</td>      <td>3.0</td>      <td>5.1</td>      <td>1.8</td>      <td>Iris-virginica</td>    </tr>  </tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142217.png" alt=""></p><p><strong> 可以看到y数据的（lebal）是字符串，不好。可以将其转化成数字。</strong></p><ul><li>使用sklearn.preprocessing的LabelEncoder模块实现 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line">X = df[[<span class="string">&#x27;sepal length in cm&#x27;</span>,<span class="string">&#x27;sepal width in cm&#x27;</span>,<span class="string">&#x27;petal length in cm&#x27;</span>,<span class="string">&#x27;petal width in cm&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;class label&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">enc = LabelEncoder()</span><br><span class="line">label_encoder = enc.fit(y)  <span class="comment"># 与之前不同的是，它在y上进行 fit !</span></span><br><span class="line">y = label_encoder.transform(y) + <span class="number">1</span> <span class="comment"># 默认从零开始，可以改为从一开始，</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># label_dict = &#123;1: &#x27;Setosa&#x27;, 2: &#x27;Versicolor&#x27;, 3:&#x27;Virginica&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142251.png" alt=""></p><h3 id="分别求三种鸢尾花数据在不同特征维度上的均值向量-mi"><a href="#分别求三种鸢尾花数据在不同特征维度上的均值向量-mi" class="headerlink" title="分别求三种鸢尾花数据在不同特征维度上的均值向量 mi"></a>分别求三种鸢尾花数据在不同特征维度上的均值向量 mi</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142312.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.set_printoptions(precision=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 输出时，小数点后面四位，若没有四位的话，不输出。（0不输出！）</span></span><br><span class="line"></span><br><span class="line">mean_vectors = []</span><br><span class="line"><span class="keyword">for</span> cl <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">    mean_vectors.append(np.mean(X[y==cl], axis=<span class="number">0</span>))</span><br><span class="line">    print(<span class="string">&#x27;Mean Vector class %s: %s\n&#x27;</span> %(cl, mean_vectors[cl-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><pre><code>Mean Vector class 1: [ 5.006  3.418  1.464  0.244]Mean Vector class 2: [ 5.936  2.77   4.26   1.326]Mean Vector class 3: [ 6.588  2.974  5.552  2.026]</code></pre><h3 id="计算两个-4×4-维矩阵：类内散布矩阵和类间散布矩阵"><a href="#计算两个-4×4-维矩阵：类内散布矩阵和类间散布矩阵" class="headerlink" title="计算两个 4×4 维矩阵：类内散布矩阵和类间散布矩阵"></a>计算两个 4×4 维矩阵：类内散布矩阵和类间散布矩阵</h3><ul><li><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142459.png" alt=""></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">S_W = np.zeros((<span class="number">4</span>,<span class="number">4</span>))                               <span class="comment"># 每个类有4个特征值。即协方差矩阵——收藏的！</span></span><br><span class="line"><span class="keyword">for</span> cl,mv <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>), mean_vectors):         <span class="comment"># 3个类</span></span><br><span class="line">    class_sc_mat = np.zeros((<span class="number">4</span>,<span class="number">4</span>))                  <span class="comment"># scatter matrix for every class 由协方差决定其是4x4的！</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> X[y == cl]:                          <span class="comment"># 选取第 c1 类的 X</span></span><br><span class="line">        row, mv = row.reshape(<span class="number">4</span>,<span class="number">1</span>), mv.reshape(<span class="number">4</span>,<span class="number">1</span>) <span class="comment"># make column vectors 将矩阵组成 4x4 的形式！</span></span><br><span class="line">        class_sc_mat += (row-mv).dot((row-mv).T)</span><br><span class="line">    S_W += class_sc_mat                             <span class="comment"># sum class scatter matrices</span></span><br><span class="line">print(<span class="string">&#x27;within-class Scatter Matrix:\n&#x27;</span>, S_W)</span><br></pre></td></tr></table></figure><pre><code>within-class Scatter Matrix: [[ 38.9562  13.683   24.614    5.6556] [ 13.683   17.035    8.12     4.9132] [ 24.614    8.12    27.22     6.2536] [  5.6556   4.9132   6.2536   6.1756]]</code></pre><ul><li><p>类间的散布矩阵进行简化。不是m1-m2了，而是与全局均值的作比较</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142528.png" alt=""></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">overall_mean = np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">zip()和enumerate()类似，但是有所不同。</span></span><br><span class="line"><span class="string">zip()可以跟多对象，</span></span><br><span class="line"><span class="string">########################</span></span><br><span class="line"><span class="string">names = [&#x27;张三&#x27;,&#x27;李四&#x27;,&#x27;王五&#x27;]</span></span><br><span class="line"><span class="string">sexs = [&#x27;boy&#x27;,&#x27;girl&#x27;,&#x27;boy&#x27;]</span></span><br><span class="line"><span class="string">scores = [86, 92]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for name, sex, score in zip(names,sexs,scores):</span></span><br><span class="line"><span class="string">    print(&#x27;&#123;&#125;: &#123;&#125;, &#123;&#125;&#x27;.format(name, sex, score))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out[]:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">张三: boy, 86</span></span><br><span class="line"><span class="string">李四: girl, 92</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">########################</span></span><br><span class="line"><span class="string">enumerate()不可以。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">S_B = np.zeros((<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i,mean_vec <span class="keyword">in</span> <span class="built_in">enumerate</span>(mean_vectors):  </span><br><span class="line">    n = X[y==i+<span class="number">1</span>,:].shape[<span class="number">0</span>]  <span class="comment"># 获得数据的个数</span></span><br><span class="line">    mean_vec = mean_vec.reshape(<span class="number">4</span>,<span class="number">1</span>) <span class="comment"># make column vector</span></span><br><span class="line">    overall_mean = overall_mean.reshape(<span class="number">4</span>,<span class="number">1</span>) <span class="comment"># make column vector</span></span><br><span class="line">    S_B += n * (mean_vec - overall_mean).dot((mean_vec - overall_mean).T)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;between-class Scatter Matrix:\n&#x27;</span>, S_B)</span><br></pre></td></tr></table></figure><pre><code>between-class Scatter Matrix: [[  63.2121  -19.534   165.1647   71.3631] [ -19.534    10.9776  -56.0552  -22.4924] [ 165.1647  -56.0552  436.6437  186.9081] [  71.3631  -22.4924  186.9081   80.6041]]</code></pre><ul><li><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142553.png" alt=""></li></ul><p><strong> np.linalg.inv()可以求逆，np.linalg.eig()可以求特征值，特征向量 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eig_vals, eig_vecs = np.linalg.eig(np.linalg.inv(S_W).dot(S_B))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_vals)):</span><br><span class="line">    eigvec_sc = eig_vecs[:,i].reshape(<span class="number">4</span>,<span class="number">1</span>)   </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回的v是归一化后的特征向量（length为1）。特征向量v[:,i]对应特征值w[i]。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&#x27;\nEigenvector &#123;&#125;: \n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>, eigvec_sc.real))  <span class="comment"># 取实部</span></span><br><span class="line">    print(<span class="string">&#x27;Eigenvalue &#123;:&#125;: &#123;:.2e&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>, eig_vals[i].real))</span><br></pre></td></tr></table></figure><pre><code>Eigenvector 1: [[ 0.2049] [ 0.3871] [-0.5465] [-0.7138]]Eigenvalue 1: 3.23e+01Eigenvector 2: [[-0.009 ] [-0.589 ] [ 0.2543] [-0.767 ]]Eigenvalue 2: 2.78e-01Eigenvector 3: [[-0.7113] [ 0.0353] [-0.0267] [ 0.7015]]Eigenvalue 3: -5.76e-15Eigenvector 4: [[ 0.422 ] [-0.4364] [-0.4851] [ 0.6294]]Eigenvalue 4: 7.80e-15</code></pre><h3 id="特征值与特征向量："><a href="#特征值与特征向量：" class="headerlink" title="特征值与特征向量："></a>特征值与特征向量：</h3><ul><li>特征向量：表示映射方向</li><li>特征值：特征向量的重要程度</li><li>假设我们投影到的低维空间的维度为d，(n-&gt;d维的转换)对应的基向量为：W = (w1,w2,w3…wd)——收藏的！<ul><li>将x = W.T * x ((d,n) x (n,1)=(d,1))</li><li>这里是先求整体的四个映射方向，再进行筛选，选择两个，特征值大的。(具体看收藏的多分类LDA),然后进行降维。</li></ul></li></ul><p><strong>对本征值进行排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Make a list of (eigenvalue, eigenvector) tuples</span></span><br><span class="line">eig_pairs = [(np.<span class="built_in">abs</span>(eig_vals[i]), eig_vecs[:,i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_vals))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sort the (eigenvalue, eigenvector) tuples from high to low</span></span><br><span class="line">eig_pairs = <span class="built_in">sorted</span>(eig_pairs, key=<span class="keyword">lambda</span> k: k[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">key = lambda k:k[0]的意义：</span></span><br><span class="line"><span class="string">若可迭代对象是单个数字等，则可以直接排序。</span></span><br><span class="line"><span class="string">若是元祖，字典等，则需要指定根据什么进行排序了。即k[0]的第零个元素进行排序。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Visually confirm that the list is correctly sorted by decreasing eigenvalues</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Eigenvalues in decreasing order:\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eig_pairs:</span><br><span class="line">    print(i[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>Eigenvalues in decreasing order:32.27195779970.277566863847.7995841654e-155.76433252705e-15</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;Variance explained:\n&#x27;</span>)</span><br><span class="line">eigv_sum = <span class="built_in">sum</span>(eig_vals)</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(eig_pairs):</span><br><span class="line">    print(<span class="string">&#x27;eigenvalue &#123;0:&#125;: &#123;1:.2%&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>, (j[<span class="number">0</span>]/eigv_sum).real))</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">     print  &#x27;hello &#123;&#125; i am &#123;&#125;&#x27;.format(&#x27;Kevin&#x27;,&#x27;Tom&#x27;)</span></span><br><span class="line"><span class="string">                             </span></span><br><span class="line"><span class="string">     # hello Kevin i am Tom    </span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">     print  &#x27;&#123;0&#125; i am &#123;1&#125; . my name is &#123;0&#125;&#x27;.format(&#x27;Kevin&#x27;,&#x27;Tom&#x27;)</span></span><br><span class="line"><span class="string">                             </span></span><br><span class="line"><span class="string">     # hello Kevin i am Tom . my name is Kevin</span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">     &#123;0:&#125;冒号后面可以跟需要的操作，如保留两位小数</span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><pre><code>Variance explained:eigenvalue 1: 99.15%eigenvalue 2: 0.85%eigenvalue 3: 0.00%eigenvalue 4: 0.00%</code></pre><p>选择前两维特征</p><p>x ((1,n)-&gt;(1,d))</p><p>x1 = x0 * W ((1,n) x (n,d)) =&gt; 所以W为(n,d)，此题为(4,2) </p><ul><li>理解意思即可，此题x=(1,n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">W = np.hstack((eig_pairs[<span class="number">0</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>), eig_pairs[<span class="number">1</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>)))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">np.vstack():在竖直方向上堆叠</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">np.hstack():在水平方向上平铺</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">print(<span class="string">&#x27;Matrix W:\n&#x27;</span>, W.real)</span><br></pre></td></tr></table></figure><pre><code>Matrix W: [[ 0.2049 -0.009 ] [ 0.3871 -0.589 ] [-0.5465  0.2543] [-0.7138 -0.767 ]]</code></pre><h3 id="进行数据的降维"><a href="#进行数据的降维" class="headerlink" title="进行数据的降维"></a>进行数据的降维</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_lda = X.dot(W)</span><br><span class="line"><span class="keyword">assert</span> X_lda.shape == (<span class="number">150</span>,<span class="number">2</span>), <span class="string">&quot;The matrix is not 150x2 dimensional.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_step_lda</span>():</span></span><br><span class="line"></span><br><span class="line">    ax = plt.subplot(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">for</span> label,marker,color <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">        <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>),(<span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;o&#x27;</span>),(<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line"></span><br><span class="line">        plt.scatter(x=X_lda[:,<span class="number">0</span>].real[y == label],</span><br><span class="line">                y=X_lda[:,<span class="number">1</span>].real[y == label],</span><br><span class="line">                marker=marker,</span><br><span class="line">                color=color,</span><br><span class="line">                alpha=<span class="number">0.5</span>,</span><br><span class="line">                label=label_dict[label]</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;LD1&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;LD2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    leg = plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>)</span><br><span class="line">    leg.get_frame().set_alpha(<span class="number">0.5</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;LDA: Iris projection onto the first 2 linear discriminants&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hide axis ticks</span></span><br><span class="line">    plt.tick_params(axis=<span class="string">&quot;both&quot;</span>, which=<span class="string">&quot;both&quot;</span>, bottom=<span class="string">&quot;off&quot;</span>, top=<span class="string">&quot;off&quot;</span>,  </span><br><span class="line">            labelbottom=<span class="string">&quot;on&quot;</span>, left=<span class="string">&quot;off&quot;</span>, right=<span class="string">&quot;off&quot;</span>, labelleft=<span class="string">&quot;on&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove axis spines</span></span><br><span class="line">    ax.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)  </span><br><span class="line">    ax.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)    </span><br><span class="line"></span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.tight_layout</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_step_lda()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142652.png" alt=""></p><h3 id="sklearn-有LDA模块可以调用。"><a href="#sklearn-有LDA模块可以调用。" class="headerlink" title="sklearn 有LDA模块可以调用。"></a>sklearn 有LDA模块可以调用。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis <span class="keyword">as</span> LDA</span><br><span class="line"></span><br><span class="line"><span class="comment"># LDA</span></span><br><span class="line">sklearn_lda = LDA(n_components=<span class="number">2</span>) <span class="comment"># 降低成2D</span></span><br><span class="line">X_lda_sklearn = sklearn_lda.fit_transform(X, y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis <span class="keyword">as</span> LDA</span><br><span class="line"></span><br><span class="line"><span class="comment"># LDA</span></span><br><span class="line">sklearn_lda = LDA(n_components=<span class="number">2</span>)</span><br><span class="line">X_lda_sklearn = sklearn_lda.fit_transform(X, y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_scikit_lda</span>(<span class="params">X, title</span>):</span></span><br><span class="line"></span><br><span class="line">    ax = plt.subplot(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">for</span> label,marker,color <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">        <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>),(<span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;o&#x27;</span>),(<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line"></span><br><span class="line">        plt.scatter(x=X[:,<span class="number">0</span>][y == label],</span><br><span class="line">                    y=X[:,<span class="number">1</span>][y == label] * -<span class="number">1</span>, <span class="comment"># flip the figure</span></span><br><span class="line">                    marker=marker,</span><br><span class="line">                    color=color,</span><br><span class="line">                    alpha=<span class="number">0.5</span>,</span><br><span class="line">                    label=label_dict[label])</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;LD1&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;LD2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    leg = plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>)</span><br><span class="line">    leg.get_frame().set_alpha(<span class="number">0.5</span>)</span><br><span class="line">    plt.title(title)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hide axis ticks</span></span><br><span class="line">    plt.tick_params(axis=<span class="string">&quot;both&quot;</span>, which=<span class="string">&quot;both&quot;</span>, bottom=<span class="string">&quot;off&quot;</span>, top=<span class="string">&quot;off&quot;</span>,  </span><br><span class="line">            labelbottom=<span class="string">&quot;on&quot;</span>, left=<span class="string">&quot;off&quot;</span>, right=<span class="string">&quot;off&quot;</span>, labelleft=<span class="string">&quot;on&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove axis spines</span></span><br><span class="line">    ax.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)  </span><br><span class="line">    ax.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)    </span><br><span class="line"></span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.tight_layout</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot_step_lda()</span><br><span class="line">plot_scikit_lda(X_lda_sklearn, title=<span class="string">&#x27;Default LDA via scikit-learn&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142828.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142842.png" alt=""></p><p><strong> 可以看出来sklearn和自己做的效果是差不多的 </strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;鸢尾花的数据集进行降维&quot;&gt;&lt;a href=&quot;#鸢尾花的数据集进行降维&quot; class=&quot;headerlink&quot; title=&quot;鸢尾花的数据集进行降维&quot;&gt;&lt;/a&gt;鸢尾花的数据集进行降维&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;有四个维度，萼片的长度。萼片的宽度，花瓣的长度，花瓣的宽</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>聚类基础——KMEANS &amp; DBSCAN</title>
    <link href="https://xxren8218.github.io/20210513/%E8%81%9A%E7%B1%BB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94KMEANS-DBSCAN.html"/>
    <id>https://xxren8218.github.io/20210513/%E8%81%9A%E7%B1%BB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94KMEANS-DBSCAN.html</id>
    <published>2021-05-13T10:05:21.000Z</published>
    <updated>2021-05-13T10:34:24.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="聚类——啤酒分类"><a href="#聚类——啤酒分类" class="headerlink" title="聚类——啤酒分类"></a>聚类——啤酒分类</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># beer dataset</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">beer = pd.read_csv(<span class="string">&#x27;data.txt&#x27;</span>, sep=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">beer</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>name</th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Budweiser</td>      <td>144</td>      <td>15</td>      <td>4.7</td>      <td>0.43</td>    </tr>    <tr>      <th>1</th>      <td>Schlitz</td>      <td>151</td>      <td>19</td>      <td>4.9</td>      <td>0.43</td>    </tr>    <tr>      <th>2</th>      <td>Lowenbrau</td>      <td>157</td>      <td>15</td>      <td>0.9</td>      <td>0.48</td>    </tr>    <tr>      <th>3</th>      <td>Kronenbourg</td>      <td>170</td>      <td>7</td>      <td>5.2</td>      <td>0.73</td>    </tr>    <tr>      <th>4</th>      <td>Heineken</td>      <td>152</td>      <td>11</td>      <td>5.0</td>      <td>0.77</td>    </tr>    <tr>      <th>5</th>      <td>Old_Milwaukee</td>      <td>145</td>      <td>23</td>      <td>4.6</td>      <td>0.28</td>    </tr>    <tr>      <th>6</th>      <td>Augsberger</td>      <td>175</td>      <td>24</td>      <td>5.5</td>      <td>0.40</td>    </tr>    <tr>      <th>7</th>      <td>Srohs_Bohemian_Style</td>      <td>149</td>      <td>27</td>      <td>4.7</td>      <td>0.42</td>    </tr>    <tr>      <th>8</th>      <td>Miller_Lite</td>      <td>99</td>      <td>10</td>      <td>4.3</td>      <td>0.43</td>    </tr>    <tr>      <th>9</th>      <td>Budweiser_Light</td>      <td>113</td>      <td>8</td>      <td>3.7</td>      <td>0.40</td>    </tr>    <tr>      <th>10</th>      <td>Coors</td>      <td>140</td>      <td>18</td>      <td>4.6</td>      <td>0.44</td>    </tr>    <tr>      <th>11</th>      <td>Coors_Light</td>      <td>102</td>      <td>15</td>      <td>4.1</td>      <td>0.46</td>    </tr>    <tr>      <th>12</th>      <td>Michelob_Light</td>      <td>135</td>      <td>11</td>      <td>4.2</td>      <td>0.50</td>    </tr>    <tr>      <th>13</th>      <td>Becks</td>      <td>150</td>      <td>19</td>      <td>4.7</td>      <td>0.76</td>    </tr>    <tr>      <th>14</th>      <td>Kirin</td>      <td>149</td>      <td>6</td>      <td>5.0</td>      <td>0.79</td>    </tr>    <tr>      <th>15</th>      <td>Pabst_Extra_Light</td>      <td>68</td>      <td>15</td>      <td>2.3</td>      <td>0.38</td>    </tr>    <tr>      <th>16</th>      <td>Hamms</td>      <td>139</td>      <td>19</td>      <td>4.4</td>      <td>0.43</td>    </tr>    <tr>      <th>17</th>      <td>Heilemans_Old_Style</td>      <td>144</td>      <td>24</td>      <td>4.9</td>      <td>0.43</td>    </tr>    <tr>      <th>18</th>      <td>Olympia_Goled_Light</td>      <td>72</td>      <td>6</td>      <td>2.9</td>      <td>0.46</td>    </tr>    <tr>      <th>19</th>      <td>Schlitz_Light</td>      <td>97</td>      <td>7</td>      <td>4.2</td>      <td>0.47</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = beer[[<span class="string">&quot;calories&quot;</span>,<span class="string">&quot;sodium&quot;</span>,<span class="string">&quot;alcohol&quot;</span>,<span class="string">&quot;cost&quot;</span>]]</span><br></pre></td></tr></table></figure><h2 id="K-means-clustering"><a href="#K-means-clustering" class="headerlink" title="K-means clustering"></a>K-means clustering</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line">km = KMeans(n_clusters=<span class="number">3</span>).fit(X) <span class="comment"># n_cluster就是聚集成几个簇</span></span><br><span class="line">km2 = KMeans(n_clusters=<span class="number">2</span>).fit(X)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">km.labels_  <span class="comment"># 调用函数直接返回结果了！</span></span><br></pre></td></tr></table></figure><pre><code>array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 2, 0, 0, 2, 1])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beer[<span class="string">&#x27;cluster&#x27;</span>] = km.labels_</span><br><span class="line">beer[<span class="string">&#x27;cluster2&#x27;</span>] = km2.labels_</span><br><span class="line">beer.sort_values(<span class="string">&#x27;cluster&#x27;</span>)</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>name</th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>      <th>cluster2</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Budweiser</td>      <td>144</td>      <td>15</td>      <td>4.7</td>      <td>0.43</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>Schlitz</td>      <td>151</td>      <td>19</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>Lowenbrau</td>      <td>157</td>      <td>15</td>      <td>0.9</td>      <td>0.48</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>Kronenbourg</td>      <td>170</td>      <td>7</td>      <td>5.2</td>      <td>0.73</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>Heineken</td>      <td>152</td>      <td>11</td>      <td>5.0</td>      <td>0.77</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>5</th>      <td>Old_Milwaukee</td>      <td>145</td>      <td>23</td>      <td>4.6</td>      <td>0.28</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>6</th>      <td>Augsberger</td>      <td>175</td>      <td>24</td>      <td>5.5</td>      <td>0.40</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>7</th>      <td>Srohs_Bohemian_Style</td>      <td>149</td>      <td>27</td>      <td>4.7</td>      <td>0.42</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>17</th>      <td>Heilemans_Old_Style</td>      <td>144</td>      <td>24</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>16</th>      <td>Hamms</td>      <td>139</td>      <td>19</td>      <td>4.4</td>      <td>0.43</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>10</th>      <td>Coors</td>      <td>140</td>      <td>18</td>      <td>4.6</td>      <td>0.44</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>14</th>      <td>Kirin</td>      <td>149</td>      <td>6</td>      <td>5.0</td>      <td>0.79</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>12</th>      <td>Michelob_Light</td>      <td>135</td>      <td>11</td>      <td>4.2</td>      <td>0.50</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>13</th>      <td>Becks</td>      <td>150</td>      <td>19</td>      <td>4.7</td>      <td>0.76</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>9</th>      <td>Budweiser_Light</td>      <td>113</td>      <td>8</td>      <td>3.7</td>      <td>0.40</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>8</th>      <td>Miller_Lite</td>      <td>99</td>      <td>10</td>      <td>4.3</td>      <td>0.43</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>11</th>      <td>Coors_Light</td>      <td>102</td>      <td>15</td>      <td>4.1</td>      <td>0.46</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>19</th>      <td>Schlitz_Light</td>      <td>97</td>      <td>7</td>      <td>4.2</td>      <td>0.47</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>15</th>      <td>Pabst_Extra_Light</td>      <td>68</td>      <td>15</td>      <td>2.3</td>      <td>0.38</td>      <td>2</td>      <td>0</td>    </tr>    <tr>      <th>18</th>      <td>Olympia_Goled_Light</td>      <td>72</td>      <td>6</td>      <td>2.9</td>      <td>0.46</td>      <td>2</td>      <td>0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tools.plotting <span class="keyword">import</span> scatter_matrix  <span class="comment"># 导入scatter_matrix可以画多福图形。</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">cluster_centers = km.cluster_centers_</span><br><span class="line"></span><br><span class="line">cluster_centers_2 = km2.cluster_centers_</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beer.groupby(<span class="string">&quot;cluster&quot;</span>).mean()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster2</th>    </tr>    <tr>      <th>cluster</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>150.00</td>      <td>17.0</td>      <td>4.521429</td>      <td>0.520714</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>102.75</td>      <td>10.0</td>      <td>4.075000</td>      <td>0.440000</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>70.00</td>      <td>10.5</td>      <td>2.600000</td>      <td>0.420000</td>      <td>0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beer.groupby(<span class="string">&quot;cluster2&quot;</span>).mean()</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>    </tr>    <tr>      <th>cluster2</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>91.833333</td>      <td>10.166667</td>      <td>3.583333</td>      <td>0.433333</td>      <td>1.333333</td>    </tr>    <tr>      <th>1</th>      <td>150.000000</td>      <td>17.000000</td>      <td>4.521429</td>      <td>0.520714</td>      <td>0.000000</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centers = beer.groupby(<span class="string">&quot;cluster&quot;</span>).mean().reset_index() <span class="comment"># 中心点，为后面作图做准备！</span></span><br><span class="line">                                        <span class="comment"># reset_index(默认drop=False)，表示获取新的索引，并保留原来索引</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.size&#x27;</span>] = <span class="number">14</span>  <span class="comment"># rcParams 可以设置图形整体的字体大小等。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">colors = np.array([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>])</span><br></pre></td></tr></table></figure><p><strong> 先看其中两个特征的分布情况 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(beer[<span class="string">&quot;calories&quot;</span>], beer[<span class="string">&quot;alcohol&quot;</span>],c=colors[beer[<span class="string">&quot;cluster&quot;</span>]])</span><br><span class="line"></span><br><span class="line">plt.scatter(centers.calories, centers.alcohol, linewidths=<span class="number">3</span>, marker=<span class="string">&#x27;+&#x27;</span>, s=<span class="number">300</span>, c=<span class="string">&#x27;black&#x27;</span>) <span class="comment"># centers.calories获取质心</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;Calories&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Alcohol&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.text.Text at 0x18a25af4ac8&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181033.png" alt=""></p><p><strong> 再看其中各个维度特征的分布 </strong> scatter_matrix</p><ul><li><p>数据是多维的，要么PCA，要么这种方式进行可视化</p></li><li><p>条形图代表自身的特征的分布情况</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scatter_matrix(beer[[<span class="string">&quot;calories&quot;</span>,<span class="string">&quot;sodium&quot;</span>,<span class="string">&quot;alcohol&quot;</span>,<span class="string">&quot;cost&quot;</span>]],s=<span class="number">100</span>, alpha=<span class="number">1</span>, c=colors[beer[<span class="string">&quot;cluster&quot;</span>]], figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">plt.suptitle(<span class="string">&quot;With 3 centroids initialized&quot;</span>)</span><br></pre></td></tr></table></figure><div style="color: red">    C:\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: 'pandas.tools.plotting.scatter_matrix' is deprecated, import 'pandas.plotting.scatter_matrix' instead.      if __name__ == '__main__':</div><pre><code>&lt;matplotlib.text.Text at 0x18a25b67e80&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181104.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scatter_matrix(beer[[<span class="string">&quot;calories&quot;</span>,<span class="string">&quot;sodium&quot;</span>,<span class="string">&quot;alcohol&quot;</span>,<span class="string">&quot;cost&quot;</span>]],s=<span class="number">100</span>, alpha=<span class="number">1</span>, c=colors[beer[<span class="string">&quot;cluster2&quot;</span>]], figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">plt.suptitle(<span class="string">&quot;With 2 centroids initialized&quot;</span>)</span><br></pre></td></tr></table></figure><div style="color: red">    C:\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: 'pandas.tools.plotting.scatter_matrix' is deprecated, import 'pandas.plotting.scatter_matrix' instead.      if __name__ == '__main__':</div><pre><code>&lt;matplotlib.text.Text at 0x18a2613c710&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181130.png" alt=""></p><h3 id="Scaled-data"><a href="#Scaled-data" class="headerlink" title="Scaled data"></a>Scaled data</h3><p><strong> sklearn进行数据标准化 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_scaled = scaler.fit_transform(X)</span><br><span class="line">X_scaled</span><br></pre></td></tr></table></figure><pre><code>array([[ 0.38791334,  0.00779468,  0.43380786, -0.45682969],       [ 0.6250656 ,  0.63136906,  0.62241997, -0.45682969],       [ 0.82833896,  0.00779468, -3.14982226, -0.10269815],       [ 1.26876459, -1.23935408,  0.90533814,  1.66795955],       [ 0.65894449, -0.6157797 ,  0.71672602,  1.95126478],       [ 0.42179223,  1.25494344,  0.3395018 , -1.5192243 ],       [ 1.43815906,  1.41083704,  1.1882563 , -0.66930861],       [ 0.55730781,  1.87851782,  0.43380786, -0.52765599],       [-1.1366369 , -0.7716733 ,  0.05658363, -0.45682969],       [-0.66233238, -1.08346049, -0.5092527 , -0.66930861],       [ 0.25239776,  0.47547547,  0.3395018 , -0.38600338],       [-1.03500022,  0.00779468, -0.13202848, -0.24435076],       [ 0.08300329, -0.6157797 , -0.03772242,  0.03895447],       [ 0.59118671,  0.63136906,  0.43380786,  1.88043848],       [ 0.55730781, -1.39524768,  0.71672602,  2.0929174 ],       [-2.18688263,  0.00779468, -1.82953748, -0.81096123],       [ 0.21851887,  0.63136906,  0.15088969, -0.45682969],       [ 0.38791334,  1.41083704,  0.62241997, -0.45682969],       [-2.05136705, -1.39524768, -1.26370115, -0.24435076],       [-1.20439469, -1.23935408, -0.03772242, -0.17352445]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">km = KMeans(n_clusters=<span class="number">3</span>).fit(X_scaled)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beer[<span class="string">&quot;scaled_cluster&quot;</span>] = km.labels_</span><br><span class="line">beer.sort_values(<span class="string">&quot;scaled_cluster&quot;</span>)</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>name</th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>      <th>cluster2</th>      <th>scaled_cluster</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Budweiser</td>      <td>144</td>      <td>15</td>      <td>4.7</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>Schlitz</td>      <td>151</td>      <td>19</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>17</th>      <td>Heilemans_Old_Style</td>      <td>144</td>      <td>24</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>16</th>      <td>Hamms</td>      <td>139</td>      <td>19</td>      <td>4.4</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>5</th>      <td>Old_Milwaukee</td>      <td>145</td>      <td>23</td>      <td>4.6</td>      <td>0.28</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>6</th>      <td>Augsberger</td>      <td>175</td>      <td>24</td>      <td>5.5</td>      <td>0.40</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>7</th>      <td>Srohs_Bohemian_Style</td>      <td>149</td>      <td>27</td>      <td>4.7</td>      <td>0.42</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>10</th>      <td>Coors</td>      <td>140</td>      <td>18</td>      <td>4.6</td>      <td>0.44</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>15</th>      <td>Pabst_Extra_Light</td>      <td>68</td>      <td>15</td>      <td>2.3</td>      <td>0.38</td>      <td>2</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>12</th>      <td>Michelob_Light</td>      <td>135</td>      <td>11</td>      <td>4.2</td>      <td>0.50</td>      <td>0</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>11</th>      <td>Coors_Light</td>      <td>102</td>      <td>15</td>      <td>4.1</td>      <td>0.46</td>      <td>1</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>9</th>      <td>Budweiser_Light</td>      <td>113</td>      <td>8</td>      <td>3.7</td>      <td>0.40</td>      <td>1</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>8</th>      <td>Miller_Lite</td>      <td>99</td>      <td>10</td>      <td>4.3</td>      <td>0.43</td>      <td>1</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>Lowenbrau</td>      <td>157</td>      <td>15</td>      <td>0.9</td>      <td>0.48</td>      <td>0</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>18</th>      <td>Olympia_Goled_Light</td>      <td>72</td>      <td>6</td>      <td>2.9</td>      <td>0.46</td>      <td>2</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>19</th>      <td>Schlitz_Light</td>      <td>97</td>      <td>7</td>      <td>4.2</td>      <td>0.47</td>      <td>1</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>13</th>      <td>Becks</td>      <td>150</td>      <td>19</td>      <td>4.7</td>      <td>0.76</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>    <tr>      <th>14</th>      <td>Kirin</td>      <td>149</td>      <td>6</td>      <td>5.0</td>      <td>0.79</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>    <tr>      <th>4</th>      <td>Heineken</td>      <td>152</td>      <td>11</td>      <td>5.0</td>      <td>0.77</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>    <tr>      <th>3</th>      <td>Kronenbourg</td>      <td>170</td>      <td>7</td>      <td>5.2</td>      <td>0.73</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>  </tbody></table></div><p>What are the “characteristics” of each cluster?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beer.groupby(<span class="string">&quot;scaled_cluster&quot;</span>).mean()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>      <th>cluster2</th>    </tr>    <tr>      <th>scaled_cluster</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>148.375</td>      <td>21.125</td>      <td>4.7875</td>      <td>0.4075</td>      <td>0.0</td>      <td>1.00</td>    </tr>    <tr>      <th>1</th>      <td>105.375</td>      <td>10.875</td>      <td>3.3250</td>      <td>0.4475</td>      <td>1.0</td>      <td>0.25</td>    </tr>    <tr>      <th>2</th>      <td>155.250</td>      <td>10.750</td>      <td>4.9750</td>      <td>0.7625</td>      <td>0.0</td>      <td>1.00</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.scatter_matrix(X, c=colors[beer.scaled_cluster], alpha=<span class="number">1</span>, figsize=(<span class="number">10</span>,<span class="number">10</span>), s=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><div style="color: red">    C:\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: pandas.scatter_matrix is deprecated. Use pandas.plotting.scatter_matrix instead      if __name__ == '__main__':</div>    <pre><code>array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A279F8F28&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A282989B0&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27B5E2E8&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27B94F60&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27BE41D0&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27C19F28&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27C61F60&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27C71C88&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27CF1860&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27D3B7B8&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27D7C5C0&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27DC6F98&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27E02748&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27E4FEB8&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27E8D588&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27ED47B8&gt;]], dtype=object)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181223.png" alt=""></p><h2 id="聚类评估：轮廓系数（Silhouette-Coefficient-）（常用）"><a href="#聚类评估：轮廓系数（Silhouette-Coefficient-）（常用）" class="headerlink" title="聚类评估：轮廓系数（Silhouette Coefficient ）（常用）"></a>聚类评估：轮廓系数（Silhouette Coefficient ）（常用）</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513183410.png" alt=""></p><ul><li>计算样本i到同簇其他样本的平均距离ai。ai 越小，说明样本i越应该被聚类到该簇。将ai 称为样本i的簇内不相似度。越小越好。</li><li>计算样本i到其他某簇Cj 的所有样本的平均距离bij，称为样本i与簇Cj 的不相似度。定义为样本i的簇间不相似度：bi =min{bi1, bi2, …, bik}。越大越好。</li></ul><ul><li>si接近1，则说明样本i聚类合理</li><li>si接近-1，则说明样本i更应该分类到另外的簇</li><li>若si 近似为0，则说明样本i在两个簇的边界上。</li></ul><p><strong> 使用sklearn模块的metrics进行聚类评估 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">score_scaled = metrics.silhouette_score(X,beer.scaled_cluster) <span class="comment"># 做归一化的结果</span></span><br><span class="line">score = metrics.silhouette_score(X,beer.cluster) <span class="comment"># 不做归一化的结果</span></span><br><span class="line">print(score_scaled, score)</span><br></pre></td></tr></table></figure><pre><code>0.179780680894 0.673177504646</code></pre><p><strong> 做归一化的结果反而低了。</strong> 做归一化不一定会得到好结果。</p><h2 id="尝试计算不同的k值对结果的影响。"><a href="#尝试计算不同的k值对结果的影响。" class="headerlink" title="尝试计算不同的k值对结果的影响。"></a>尝试计算不同的k值对结果的影响。</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scores = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">20</span>):</span><br><span class="line">    labels = KMeans(n_clusters=k).fit(X).labels_</span><br><span class="line">    score = metrics.silhouette_score(X, labels)</span><br><span class="line">    scores.append(score)</span><br><span class="line"></span><br><span class="line">scores</span><br></pre></td></tr></table></figure><pre><code>[0.69176560340794857, 0.67317750464557957, 0.58570407211277953, 0.42254873351720201, 0.4559182167013377, 0.43776116697963124, 0.38946337473125997, 0.39746405172426014, 0.33061511213823314, 0.34131096180393328, 0.34597752371272478, 0.31221439248428434, 0.30707782144770296, 0.31834561839139497, 0.28495140011748982, 0.23498077333071996, 0.15880910174962809, 0.084230513801511767]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">20</span>)), scores)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Number of Clusters Initialized&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Sihouette Score&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.text.Text at 0x18a288239e8&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181248.png" alt=""></p><p><strong> 可以看出K=2的时候比较合适 </strong></p><h2 id="DBSCAN-clustering"><a href="#DBSCAN-clustering" class="headerlink" title="DBSCAN clustering"></a>DBSCAN clustering</h2><ul><li>在不规则的数据集上比较强大，简单数据集可能还不如kmeans.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line">db = DBSCAN(eps=<span class="number">10</span>, min_samples=<span class="number">2</span>).fit(X)  <span class="comment"># eps半径，min_samples指密度</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labels = db.labels_</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beer[<span class="string">&#x27;cluster_db&#x27;</span>] = labels</span><br><span class="line">beer.sort_values(<span class="string">&#x27;cluster_db&#x27;</span>)</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>name</th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>      <th>cluster2</th>      <th>scaled_cluster</th>      <th>cluster_db</th>    </tr>  </thead>  <tbody>    <tr>      <th>9</th>      <td>Budweiser_Light</td>      <td>113</td>      <td>8</td>      <td>3.7</td>      <td>0.40</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>-1</td>    </tr>    <tr>      <th>3</th>      <td>Kronenbourg</td>      <td>170</td>      <td>7</td>      <td>5.2</td>      <td>0.73</td>      <td>0</td>      <td>1</td>      <td>2</td>      <td>-1</td>    </tr>    <tr>      <th>6</th>      <td>Augsberger</td>      <td>175</td>      <td>24</td>      <td>5.5</td>      <td>0.40</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>-1</td>    </tr>    <tr>      <th>17</th>      <td>Heilemans_Old_Style</td>      <td>144</td>      <td>24</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>16</th>      <td>Hamms</td>      <td>139</td>      <td>19</td>      <td>4.4</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>14</th>      <td>Kirin</td>      <td>149</td>      <td>6</td>      <td>5.0</td>      <td>0.79</td>      <td>0</td>      <td>1</td>      <td>2</td>      <td>0</td>    </tr>    <tr>      <th>13</th>      <td>Becks</td>      <td>150</td>      <td>19</td>      <td>4.7</td>      <td>0.76</td>      <td>0</td>      <td>1</td>      <td>2</td>      <td>0</td>    </tr>    <tr>      <th>12</th>      <td>Michelob_Light</td>      <td>135</td>      <td>11</td>      <td>4.2</td>      <td>0.50</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>10</th>      <td>Coors</td>      <td>140</td>      <td>18</td>      <td>4.6</td>      <td>0.44</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>0</th>      <td>Budweiser</td>      <td>144</td>      <td>15</td>      <td>4.7</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>7</th>      <td>Srohs_Bohemian_Style</td>      <td>149</td>      <td>27</td>      <td>4.7</td>      <td>0.42</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>5</th>      <td>Old_Milwaukee</td>      <td>145</td>      <td>23</td>      <td>4.6</td>      <td>0.28</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>Heineken</td>      <td>152</td>      <td>11</td>      <td>5.0</td>      <td>0.77</td>      <td>0</td>      <td>1</td>      <td>2</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>Lowenbrau</td>      <td>157</td>      <td>15</td>      <td>0.9</td>      <td>0.48</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>Schlitz</td>      <td>151</td>      <td>19</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>8</th>      <td>Miller_Lite</td>      <td>99</td>      <td>10</td>      <td>4.3</td>      <td>0.43</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>11</th>      <td>Coors_Light</td>      <td>102</td>      <td>15</td>      <td>4.1</td>      <td>0.46</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>19</th>      <td>Schlitz_Light</td>      <td>97</td>      <td>7</td>      <td>4.2</td>      <td>0.47</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>15</th>      <td>Pabst_Extra_Light</td>      <td>68</td>      <td>15</td>      <td>2.3</td>      <td>0.38</td>      <td>2</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>    <tr>      <th>18</th>      <td>Olympia_Goled_Light</td>      <td>72</td>      <td>6</td>      <td>2.9</td>      <td>0.46</td>      <td>2</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beer.groupby(<span class="string">&#x27;cluster_db&#x27;</span>).mean()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>      <th>cluster2</th>      <th>scaled_cluster</th>    </tr>    <tr>      <th>cluster_db</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>-1</th>      <td>152.666667</td>      <td>13.000000</td>      <td>4.800000</td>      <td>0.510000</td>      <td>0.333333</td>      <td>0.666667</td>      <td>1.000000</td>    </tr>    <tr>      <th>0</th>      <td>146.250000</td>      <td>17.250000</td>      <td>4.383333</td>      <td>0.513333</td>      <td>0.000000</td>      <td>1.000000</td>      <td>0.666667</td>    </tr>    <tr>      <th>1</th>      <td>99.333333</td>      <td>10.666667</td>      <td>4.200000</td>      <td>0.453333</td>      <td>1.000000</td>      <td>0.000000</td>      <td>1.000000</td>    </tr>    <tr>      <th>2</th>      <td>70.000000</td>      <td>10.500000</td>      <td>2.600000</td>      <td>0.420000</td>      <td>2.000000</td>      <td>0.000000</td>      <td>1.000000</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.scatter_matrix(X, c=colors[beer.cluster_db], figsize=(<span class="number">10</span>,<span class="number">10</span>), s=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><div style="color: red">    C:\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: pandas.scatter_matrix is deprecated. Use pandas.plotting.scatter_matrix instead      if __name__ == '__main__':</div>    <div style="overflow: scroll;">    array([[<matplotlib.axes._subplots.AxesSubplot object at 0x0000018A278A3940>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A284C56D8>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A28501CF8>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A28550080>],           [<matplotlib.axes._subplots.AxesSubplot object at 0x0000018A2856C588>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A285D1F60>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A286211D0>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A2865AF98>],           [<matplotlib.axes._subplots.AxesSubplot object at 0x0000018A286AABA8>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A286E7278>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A2872E390>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A287396A0>],           [<matplotlib.axes._subplots.AxesSubplot object at 0x0000018A287BC358>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A28B356A0>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A28B71240>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A28BBC470>]], dtype=object)</div><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181312.png" alt=""></p><p><strong> DBSCAN的后续过程一样，可以用轮廓系数进行评估。for循环eps和min_samples。也可以做数据增强。（看哪个数据的维度对结果有比较好的影响） </strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;聚类——啤酒分类&quot;&gt;&lt;a href=&quot;#聚类——啤酒分类&quot; class=&quot;headerlink&quot; title=&quot;聚类——啤酒分类&quot;&gt;&lt;/a&gt;聚类——啤酒分类&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（六十七）：剪绳子</title>
    <link href="https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E5%89%AA%E7%BB%B3%E5%AD%90.html"/>
    <id>https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E5%89%AA%E7%BB%B3%E5%AD%90.html</id>
    <published>2021-05-12T08:49:55.000Z</published>
    <updated>2021-05-19T16:53:47.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><div style="color: red;">    给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1，m<=n），每段绳子的长度记为k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</div><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>这道题可以用数学的方法来解决——基本不等式。如下图<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512165604.JPG" alt=""><br>即将 x1+x2+…+xm=n 分成 m 份，然后求导得到极大值<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512170104.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512170218.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512170240.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512170257.JPG" alt=""><br>得到应该均分成3份，又分三种情况，能整除。余数为1时，（4=2+2=1+3），明显2x2&gt;1x3，余数为2时正常写（5的话2x3是最大的。）<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512170344.JPG" alt=""></p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> number-<span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        a, b = number//<span class="number">3</span>, number%<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>**a</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>**(a-<span class="number">1</span>)*<span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>**a*<span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;div style=&quot;color: red;&quot;&gt;
    给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数学" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（六十三）：数据流中的中位数</title>
    <link href="https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.html</id>
    <published>2021-05-12T08:38:58.000Z</published>
    <updated>2021-05-15T13:52:18.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><div style="color: red">    如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</div><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p><div style="color: red">    可以建立一个列表来append所给的数据    然后将列表排序，计算列表的长度。只需要区分奇数和偶数情况即可。</div></p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.s.append(num)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.s = <span class="built_in">sorted</span>(self.s)</span><br><span class="line">        n = <span class="built_in">len</span>(self.s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 奇数</span></span><br><span class="line">            <span class="keyword">return</span> self.s[n/<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 偶数</span></span><br><span class="line">            <span class="keyword">return</span> (self.s[n/<span class="number">2</span>]+self.s[n/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2.0</span> <span class="comment"># 注意如果这里写2的话，得到的是向下取整的整数，所以需要写成浮点型。</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure><h2 id="上述的代码虽然可以，但是在力扣上执行时间长。提出另一种思路——最大堆，最小堆。"><a href="#上述的代码虽然可以，但是在力扣上执行时间长。提出另一种思路——最大堆，最小堆。" class="headerlink" title="上述的代码虽然可以，但是在力扣上执行时间长。提出另一种思路——最大堆，最小堆。"></a>上述的代码虽然可以，但是在力扣上执行时间长。提出另一种思路——最大堆，最小堆。</h2><ol><li><p>如果我们可以对数据进行排序，分成小的一半和大的一半。找小的最大值和大的最小值即可。这个不就是最小、最大堆嘛！</p><ul><li>最大堆（找出最小的k个元素）</li><li>最小堆（找出最大的k个元素）</li></ul></li></ol><p>如图所示过程。用最大堆存最小的k个元素，最小堆存最大k个元素。我们就可以用O（1）的复杂度找到值max和min了<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515205757.JPG" alt=""></p><ol><li><p>在数据存放的时候我们可以这样，当最小堆和最大堆的尺寸相等时，存放进入最大堆maxheap，不等时，存放进最小堆minheap。<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515211539.JPG" alt=""></p></li><li><p>但是这存在一个问题，若将a1存放进入minheap的时候，若a1的值比maxheap的一些数字还要小，则不满足我们之前的假设——maxheap的数字比minheap的数字小；若将a2的存放到maxheap的时候，若a2比minheap的某些值还要大，那么也不符合我们的假定；那么我们可以这样做；</p><ul><li>将a1先插入到maxheap中，再将maxheap的队顶元素插入到minheap，这样就保证了maxheap始终为最小的元素。</li><li>同理，将a2先放入到minheap中，再将minheap的队顶元素放入maxheap中</li><li>python没有最大堆，只需要把最小堆取反。</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515211558.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515211618.JPG" alt=""></p><p><strong> heappushpop()相当于先推后弹出，这意味着堆大小可能会在进程中发生变化. </strong></p><p><strong> heapreplace()相当于先弹出，然后推送，附加的限制是保证堆大小在这个过程中不会改变。</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.maxheap = []</span><br><span class="line">        self.minheap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 为了使得数据平均分配到两个堆，当两个堆的尺寸一样时，将新增加的元素放到minheap中</span></span><br><span class="line">        <span class="comment"># 具体做法分两步：1.现将新元素放到maxheap中，2.再将maxheap的堆顶元素放入minheap</span></span><br><span class="line">        <span class="comment"># python没有最大堆，可以用最小堆取反实现</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.maxheap) == <span class="built_in">len</span>(self.minheap):</span><br><span class="line">            heapq.heappush(self.minheap,-heapq.heappushpop(self.maxheap,-num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self.maxheap,-heapq.heappushpop(self.minheap,num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.maxheap) == <span class="built_in">len</span>(self.minheap):</span><br><span class="line">            <span class="keyword">return</span> (-self.maxheap[<span class="number">0</span>]+self.minheap[<span class="number">0</span>])/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.minheap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MedianFinder()</span></span><br><span class="line"><span class="comment"># obj.addNum(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.findMedian()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;div style=&quot;color: red&quot;&gt;
    如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://xxren8218.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="最小堆" scheme="https://xxren8218.github.io/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（六十四）：滑动窗口的最大值</title>
    <link href="https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.html"/>
    <id>https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.html</id>
    <published>2021-05-12T08:25:59.000Z</published>
    <updated>2021-05-17T10:13:35.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><div style="color: red;">    给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}。</div><h2 id="2-思路—暴力解法"><a href="#2-思路—暴力解法" class="headerlink" title="2.思路—暴力解法"></a>2.思路—暴力解法</h2><div style="color: red">    创建一个列表res来存储最终结果    创建一个临时列表temp来存储目前窗口内的数字    python有内置的max()函数可以找出列表中的最大数字。将其放入结果列表中即可。    while循环，直到窗口的右边界到达给定列表长度时，停止。</div>  ## 3.代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span>(<span class="params">self, num, size</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num <span class="keyword">or</span> size &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = start + size</span><br><span class="line">        <span class="keyword">while</span> end &lt;= <span class="built_in">len</span>(num):</span><br><span class="line">            temp_list = num[start:end]</span><br><span class="line">            res.append(<span class="built_in">max</span>(temp_list)) <span class="comment"># 其实可以和上面一步的合并在一起。</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>- max的时间复杂度为O(n)<div style="color: red;">对于每个滑动窗口，我们可以使用 O(k)的时间遍历其中的每一个元素，找出其中的最大值。对于长度为 n 的数组 nums 而言，窗口的数量为 n-k+1，因此该算法的时间复杂度为 O((n-k+1)k)=O(nk)<br>会超出时间限制，因此我们需要进行一些优化。——需要将取最大值的操作进行降低时间复杂度。</div><h2 id="在力扣上提交时，超时，时间复杂度为O-nk-想办法对其进行改进。"><a href="#在力扣上提交时，超时，时间复杂度为O-nk-想办法对其进行改进。" class="headerlink" title="在力扣上提交时，超时，时间复杂度为O(nk),想办法对其进行改进。"></a>在力扣上提交时，超时，时间复杂度为O(nk),想办法对其进行改进。</h2><p>对于实现栈min函数的题目使用 单调栈 实现了随意入栈、出栈情况下的 O(1)时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，而 “窗口滑动” 删除的是 “列表首部元素” ——为单调递减队列。</p><p>** 理解了栈的min函数，再理解队的最大函数，再写这道题容易些。</p><p>队的最大函数的理解</p><p>入队顺序为：                 [5]-&gt;[5,-1]-&gt;[5,-1,3]-&gt;[5,-1,3,6]-&gt;[5,-1,3,6,2]<br>队的最大函数时的辅助队列：     [5]-&gt;[5,-1]-&gt;[5,3]   -&gt;[6]       -&gt;[6,2]<br>最大值为：                   [5]-&gt;[5]  -&gt;[5]     -&gt;[6]      -&gt;[6]</p><p>出队顺序为：(先进先出)。        [5,-1,3,6,2]-&gt;[-1,3,6,2]-&gt;[3,6,2]-&gt;[6,2]-&gt;[6]<br>队的最大函数时的辅助队列：       [6,2]      -&gt;[6,2]     -&gt;[6,2]  -&gt;[6,2]-&gt;[2]</p><ul><li>(若出队和辅助队的元素相同-删除)<br>最大值为：                    [6]        -&gt;[6]       -&gt;[6]    -&gt;[6]  -&gt;[2]</li></ul><p>还有一点不同的是：在未形成窗口时是不需要“出队操作”的</p><ol><li>未形成窗口时：相当于一直为进队的操作。并保障其单调.</li><li>形成窗口后：相当于进队和出队操作同时进行。需要用到双端队列。——能使得leftpop为O(1)<ul><li>在向右移动一次后，相当于最右边值入队，使新队列满足单调。</li><li>如果在移动一次后的最左边-1值等于队列的最大的值，则将其删除</li></ul></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 当窗口未形成的时候：将nums的元素加入双端队列中，并保证其单调（增减都可，只不过后面处理一个头一个尾而已，我这里取递减）</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> k &gt; n:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        dq = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> dq[-<span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                dq.pop()</span><br><span class="line">            dq.append(nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 此时窗口形成。因为加了k个数字到dq了</span></span><br><span class="line">        res.append(dq[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 窗口形成以后相当于队列的入队和出队同时进行了。需要进行两步</span></span><br><span class="line">        <span class="comment"># 1.移动以后的窗口的最左边值若等于dp[0]，则dp[0]需删除</span></span><br><span class="line">        <span class="comment"># 2.入队的元素与dp保证递减</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i-k] == dq[<span class="number">0</span>]:</span><br><span class="line">                dq.popleft()</span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> dq[-<span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                dq.pop()</span><br><span class="line">            dq.append(nums[i])</span><br><span class="line">            res.append(dq[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;div style=&quot;color: red;&quot;&gt;
    给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="双指针" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="双端队列" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="单调队列" scheme="https://xxren8218.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="辅助队列" scheme="https://xxren8218.github.io/tags/%E8%BE%85%E5%8A%A9%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
