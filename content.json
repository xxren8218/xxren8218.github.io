{"meta":{"title":"X.X.Ren","subtitle":"个人博客","description":"自学计算机的经历","author":"任晓雄","url":"https://xxren8218.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-02-28T16:13:27.840Z","updated":"2021-02-28T10:34:55.359Z","comments":false,"path":"/404.html","permalink":"https://xxren8218.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-02-28T16:13:27.852Z","updated":"2021-02-28T10:34:55.360Z","comments":false,"path":"books/index.html","permalink":"https://xxren8218.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-02-28T16:13:27.859Z","updated":"2021-02-28T10:34:55.361Z","comments":false,"path":"categories/index.html","permalink":"https://xxren8218.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-02-28T16:13:27.865Z","updated":"2021-02-28T10:34:55.361Z","comments":true,"path":"links/index.html","permalink":"https://xxren8218.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-02-28T16:13:27.871Z","updated":"2021-02-28T10:34:55.361Z","comments":false,"path":"repository/index.html","permalink":"https://xxren8218.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-28T16:13:27.877Z","updated":"2021-02-28T10:34:55.361Z","comments":false,"path":"tags/index.html","permalink":"https://xxren8218.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-01T16:55:45.748Z","updated":"2019-07-29T13:52:40.000Z","comments":true,"path":"about/502.html","permalink":"https://xxren8218.github.io/about/502.html","excerpt":"","text":"502 Bad Gateway html, body { padding: 0; margin: 0; width: 100%; height: 100%; } .icon { -webkit-user-select: none; user-select: none; display: inline-block; } .icon-offline { content: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABIAQMAAABvIyEEAAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAGxJREFUeF7tyMEJwkAQRuFf5ipMKxYQiJ3Z2nSwrWwBA0+DQZcdxEOueaePp9+dQZFB7GpUcURSVU66yVNFj6LFICatThZB6r/ko/pbRpUgilY0Cbw5sNmb9txGXUKyuH7eV25x39DtJXUNPQGJtWFV+BT/QAAAAABJRU5ErkJggg==\"); position: relative; } .hidden { display: none; } /* Offline page */ .offline .interstitial-wrapper { color: #2b2b2b; font-size: 1em; line-height: 1.55; margin: 0 auto; max-width: 600px; padding-top: 100px; width: 100%; } .offline .runner-container { height: 150px; max-width: 600px; overflow: hidden; position: absolute; top: 35px; width: 44px; } .offline .runner-canvas { height: 150px; max-width: 600px; opacity: 1; overflow: hidden; position: absolute; top: 0; z-index: 2; } .offline .controller { background: rgba(247, 247, 247, .1); height: 100vh; left: 0; position: absolute; top: 0; width: 100vw; z-index: 1; } #offline-resources { display: none; } #message h1 { font-size: 34px; color: #555; margin: 100px 0px 40px 0px; } #message p { color: #555; padding: 5px 0px; line-height: 36px; letter-spacing: 1px; font-size: 18px; } #message p a, p a:hover { color: #777; padding: 0px 8px; } #message p span { color: #777; margin: 0px 8px; padding: 1px 2px; background: #eee; border-radius: 0.3em; } #github { position: absolute; bottom: 0px; font-size: 12px !important; color: #aaa !important; } @media (max-width: 420px) { .suggested-left > #control-buttons, .suggested-right > #control-buttons { float: none; } .snackbar { left: 0; bottom: 0; width: 100%; border-radius: 0; } #message h1 { font-size: 22px; margin: 100px 20px 50px 20px; } #message p { padding: 20px; } } @media (max-height: 350px) { h1 { margin: 0 0 15px; } .icon-offline { margin: 0 0 10px; } .interstitial-wrapper { margin-top: 5%; } .nav-wrapper { margin-top: 30px; } } @media (min-width: 600px) and (max-width: 736px) and (orientation: landscape) { .offline .interstitial-wrapper { margin-left: 0; margin-right: 0; } } @media (min-width: 420px) and (max-width: 736px) and (min-height: 240px) and (max-height: 420px) and (orientation: landscape) { .interstitial-wrapper { margin-bottom: 100px; } } @media (min-height: 240px) and (orientation: landscape) { .offline .interstitial-wrapper { margin-bottom: 90px; } .icon-offline { margin-bottom: 20px; } } @media (max-height: 320px) and (orientation: landscape) { .icon-offline { margin-bottom: 0; } .offline .runner-container { top: 10px; } } @media (max-width: 240px) { .interstitial-wrapper { overflow: inherit; padding: 0 8px; } } eval(function(p,a,c,k,e,r){e=function(c){return(c35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('(j(){j c(a,b){V(c.4B)T c.4B;c.4B=i;i.1V=M.3t(a);i.8X=i.U=1t;i.6r=i.1V.3t(\"#8U-4v\");i.o=b||c.o;i.s=c.4p;i.1A=i.I=i.C=i.K=1t;i.28=i.1Q=i.2y=i.1N=0;i.1g=1F/60;i.1s=i.o.2M;i.1f=[];i.2l=i.2r=i.1a=i.1i=i.2s=!1;i.1M=0;i.2w=1t;i.3N=0;i.8T=1t;i.2j={};i.2K=1t;i.8R={};i.8Q=0;i.4L()?i.4M():i.4X()}j p(a,b){T N.2I(N.2C()*(b-a+1))+a}j z(a){B b=a.W/4*3;a=8P(a);B c=F 8M(b);c=F 8L(c);Y(B e=0;ei.s.A?(a=b*i.s.A/3A*i.o.6v,i.1s=a>b?b:a):a&&(i.1s=a)},1c:j(){M.3t(\".\"+c.1h.4V).1n.7b=\"5A\";i.43();i.3a();i.U=M.2D(\"48\");i.U.3s=c.1h.4P;B a=i.U,b=i.s.A,f=i.s.J,e=c.1h.7a,d=M.2D(\"K\");d.3s=e?c.1h.4d+\" \"+e:c.1h.4d;d.D=b;d.S=f;a.2A(d);i.K=d;i.C=i.K.1D(\"2d\");i.C.79=\"#77\";i.C.76();c.4a(i.K);i.2g=F u(i.K,i.2h,i.s,i.o.5M);i.1A=F k(i.K,i.2h.37,i.s.A);i.I=F g(i.K,i.2h.3R);i.1V.2A(i.U);r&&i.5I();i.5J();i.G();1k.Z(c.L.5y,i.5L.1v(i))},5I:j(){i.1U=M.2D(\"48\");i.1U.3s=c.1h.58;i.1V.2A(i.1U)},5L:j(){i.2w||(i.2w=74(i.43.1v(i),5O))},43:j(){6Y(i.2w);i.2w=1t;B a=1k.6X(i.1V);a=6O(a.5S.2X(0,a.5S.W-2));i.s.A=i.1V.6N-2*a;i.K&&(i.K.D=i.s.A,i.K.S=i.s.J,c.4a(i.K),i.1A.4e(i.s.A),i.3u(),i.2g.G(0,0,!0),i.I.G(0),i.1i||i.1a||i.2r?(i.U.1n.D=i.s.A+\"1z\",i.U.1n.S=i.s.J+\"1z\",i.1A.G(0,N.2c(i.1N)),i.3l()):i.I.Q(0,0),i.1a&&i.2a&&(i.2a.5Y(i.s.A),i.2a.Q()))},5Z:j(){V(i.2s||i.1a)i.1a&&i.3k();3h{i.1X=!0;i.I.1X=!0;B a=\"@-6L-6J 66 { 6I { D:\"+g.o.A+\"1z }6H { D: \"+i.s.A+\"1z }}\",b=M.2D(\"1n\");b.6G=a;M.6F.2A(b);i.U.Z(c.L.6n,i.6a.1v(i));i.U.1n.6b=\"66 .4s 6D-6C 1 6A\";i.U.1n.D=i.s.A+\"1z\";i.2s=i.1i=!0}},6a:j(){i.28=0;i.1X=!1;i.I.1X=!1;i.U.1n.6b=\"\";i.3N++;M.Z(c.L.4O,i.2N.1v(i));1k.Z(c.L.4Q,i.2N.1v(i));1k.Z(c.L.4S,i.2N.1v(i))},3u:j(){i.C.6y(0,0,i.s.A,i.s.J)},G:j(){i.4u=!1;B a=q(),b=a-(i.1Q||a);i.1Q=a;V(i.1i){i.3u();i.I.1H&&i.I.6i(b);i.28+=b;a=i.28>i.o.5D;1!=i.I.33||i.1X||i.5Z();i.1X?i.2g.G(0,i.1s,a):(b=i.2s?b:0,i.2g.G(b,i.1s,a,i.2l));V(a)a:{B f=i.2g.1f[0],e=i.I;a=F h(e.E+1,e.H+1,e.o.A-2,e.o.J-2);B d=F h(f.E+1,f.H+1,f.R.D*f.1r-2,f.R.S-2);V(y(a,d)){f=f.X;e=e.1u?g.X.1J:g.X.1I;Y(B w=0;w"},{"title":"关于","date":"2021-03-02T09:40:36.171Z","updated":"2021-03-02T09:40:36.171Z","comments":false,"path":"about/index.html","permalink":"https://xxren8218.github.io/about/index.html","excerpt":"","text":"个人简介： game html, body { padding: 0; margin: 0; width: 100%; height: 100%; } .icon { -webkit-user-select: none; user-select: none; display: inline-block; } .icon-offline { content: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABIAQMAAABvIyEEAAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAGxJREFUeF7tyMEJwkAQRuFf5ipMKxYQiJ3Z2nSwrWwBA0+DQZcdxEOueaePp9+dQZFB7GpUcURSVU66yVNFj6LFICatThZB6r/ko/pbRpUgilY0Cbw5sNmb9txGXUKyuH7eV25x39DtJXUNPQGJtWFV+BT/QAAAAABJRU5ErkJggg==\"); position: relative; } .hidden { display: none; } /* Offline page */ .offline .interstitial-wrapper { color: #2b2b2b; font-size: 1em; line-height: 1.55; margin: 0 auto; max-width: 600px; padding-top: 100px; width: 100%; } .offline .runner-container { height: 150px; max-width: 600px; overflow: hidden; position: absolute; top: 35px; width: 44px; } .offline .runner-canvas { height: 150px; max-width: 600px; opacity: 1; overflow: hidden; position: absolute; top: 0; z-index: 2; } .offline .controller { background: rgba(247, 247, 247, .1); height: 100vh; left: 0; position: absolute; top: 0; width: 100vw; z-index: 1; } #offline-resources { display: none; } #message h1 { font-size: 34px; color: #555; margin: 100px 0px 40px 0px; } #message p { color: #555; padding: 5px 0px; line-height: 36px; letter-spacing: 1px; font-size: 18px; } #message p a, p a:hover { color: #777; padding: 0px 8px; } #message p span { color: #777; margin: 0px 8px; padding: 1px 2px; background: #eee; border-radius: 0.3em; } #github { position: absolute; bottom: 0px; font-size: 12px !important; color: #aaa !important; } @media (max-width: 420px) { .suggested-left > #control-buttons, .suggested-right > #control-buttons { float: none; } .snackbar { left: 0; bottom: 0; width: 100%; border-radius: 0; } #message h1 { font-size: 22px; margin: 100px 20px 50px 20px; } #message p { padding: 20px; } } @media (max-height: 350px) { h1 { margin: 0 0 15px; } .icon-offline { margin: 0 0 10px; } .interstitial-wrapper { margin-top: 5%; } .nav-wrapper { margin-top: 30px; } } @media (min-width: 600px) and (max-width: 736px) and (orientation: landscape) { .offline .interstitial-wrapper { margin-left: 0; margin-right: 0; } } @media (min-width: 420px) and (max-width: 736px) and (min-height: 240px) and (max-height: 420px) and (orientation: landscape) { .interstitial-wrapper { margin-bottom: 100px; } } @media (min-height: 240px) and (orientation: landscape) { .offline .interstitial-wrapper { margin-bottom: 90px; } .icon-offline { margin-bottom: 20px; } } @media (max-height: 320px) and (orientation: landscape) { .icon-offline { margin-bottom: 0; } .offline .runner-container { top: 10px; } } @media (max-width: 240px) { .interstitial-wrapper { overflow: inherit; padding: 0 8px; } } eval(function(p,a,c,k,e,r){e=function(c){return(c35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('(j(){j c(a,b){V(c.4B)T c.4B;c.4B=i;i.1V=M.3t(a);i.8X=i.U=1t;i.6r=i.1V.3t(\"#8U-4v\");i.o=b||c.o;i.s=c.4p;i.1A=i.I=i.C=i.K=1t;i.28=i.1Q=i.2y=i.1N=0;i.1g=1F/60;i.1s=i.o.2M;i.1f=[];i.2l=i.2r=i.1a=i.1i=i.2s=!1;i.1M=0;i.2w=1t;i.3N=0;i.8T=1t;i.2j={};i.2K=1t;i.8R={};i.8Q=0;i.4L()?i.4M():i.4X()}j p(a,b){T N.2I(N.2C()*(b-a+1))+a}j z(a){B b=a.W/4*3;a=8P(a);B c=F 8M(b);c=F 8L(c);Y(B e=0;ei.s.A?(a=b*i.s.A/3A*i.o.6v,i.1s=a>b?b:a):a&&(i.1s=a)},1c:j(){M.3t(\".\"+c.1h.4V).1n.7b=\"5A\";i.43();i.3a();i.U=M.2D(\"48\");i.U.3s=c.1h.4P;B a=i.U,b=i.s.A,f=i.s.J,e=c.1h.7a,d=M.2D(\"K\");d.3s=e?c.1h.4d+\" \"+e:c.1h.4d;d.D=b;d.S=f;a.2A(d);i.K=d;i.C=i.K.1D(\"2d\");i.C.79=\"#77\";i.C.76();c.4a(i.K);i.2g=F u(i.K,i.2h,i.s,i.o.5M);i.1A=F k(i.K,i.2h.37,i.s.A);i.I=F g(i.K,i.2h.3R);i.1V.2A(i.U);r&&i.5I();i.5J();i.G();1k.Z(c.L.5y,i.5L.1v(i))},5I:j(){i.1U=M.2D(\"48\");i.1U.3s=c.1h.58;i.1V.2A(i.1U)},5L:j(){i.2w||(i.2w=74(i.43.1v(i),5O))},43:j(){6Y(i.2w);i.2w=1t;B a=1k.6X(i.1V);a=6O(a.5S.2X(0,a.5S.W-2));i.s.A=i.1V.6N-2*a;i.K&&(i.K.D=i.s.A,i.K.S=i.s.J,c.4a(i.K),i.1A.4e(i.s.A),i.3u(),i.2g.G(0,0,!0),i.I.G(0),i.1i||i.1a||i.2r?(i.U.1n.D=i.s.A+\"1z\",i.U.1n.S=i.s.J+\"1z\",i.1A.G(0,N.2c(i.1N)),i.3l()):i.I.Q(0,0),i.1a&&i.2a&&(i.2a.5Y(i.s.A),i.2a.Q()))},5Z:j(){V(i.2s||i.1a)i.1a&&i.3k();3h{i.1X=!0;i.I.1X=!0;B a=\"@-6L-6J 66 { 6I { D:\"+g.o.A+\"1z }6H { D: \"+i.s.A+\"1z }}\",b=M.2D(\"1n\");b.6G=a;M.6F.2A(b);i.U.Z(c.L.6n,i.6a.1v(i));i.U.1n.6b=\"66 .4s 6D-6C 1 6A\";i.U.1n.D=i.s.A+\"1z\";i.2s=i.1i=!0}},6a:j(){i.28=0;i.1X=!1;i.I.1X=!1;i.U.1n.6b=\"\";i.3N++;M.Z(c.L.4O,i.2N.1v(i));1k.Z(c.L.4Q,i.2N.1v(i));1k.Z(c.L.4S,i.2N.1v(i))},3u:j(){i.C.6y(0,0,i.s.A,i.s.J)},G:j(){i.4u=!1;B a=q(),b=a-(i.1Q||a);i.1Q=a;V(i.1i){i.3u();i.I.1H&&i.I.6i(b);i.28+=b;a=i.28>i.o.5D;1!=i.I.33||i.1X||i.5Z();i.1X?i.2g.G(0,i.1s,a):(b=i.2s?b:0,i.2g.G(b,i.1s,a,i.2l));V(a)a:{B f=i.2g.1f[0],e=i.I;a=F h(e.E+1,e.H+1,e.o.A-2,e.o.J-2);B d=F h(f.E+1,f.H+1,f.R.D*f.1r-2,f.R.S-2);V(y(a,d)){f=f.X;e=e.1u?g.X.1J:g.X.1I;Y(B w=0;w"}],"posts":[{"title":"逻辑回归实战--信用卡诈骗检测","slug":"逻辑回归基础实战","date":"2021-04-17T17:26:48.000Z","updated":"2021-04-17T18:39:40.919Z","comments":true,"path":"20210418/逻辑回归基础实战.html","link":"","permalink":"https://xxren8218.github.io/20210418/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98.html","excerpt":"","text":"信用卡诈骗预测——二分类的问题12345import pandas as pdimport matplotlib.pyplot as pltimport numpy as np%matplotlib inline 先来看看数据长什么样子吧12data = pd.read_csv(&quot;creditcard.csv&quot;)data.head() Time V1 V2 V3 V4 V5 V6 V7 V8 V9 ... V21 V22 V23 V24 V25 V26 V27 V28 Amount Class 0 0.0 -1.359807 -0.072781 2.536347 1.378155 -0.338321 0.462388 0.239599 0.098698 0.363787 ... -0.018307 0.277838 -0.110474 0.066928 0.128539 -0.189115 0.133558 -0.021053 149.62 0 1 0.0 1.191857 0.266151 0.166480 0.448154 0.060018 -0.082361 -0.078803 0.085102 -0.255425 ... -0.225775 -0.638672 0.101288 -0.339846 0.167170 0.125895 -0.008983 0.014724 2.69 0 2 1.0 -1.358354 -1.340163 1.773209 0.379780 -0.503198 1.800499 0.791461 0.247676 -1.514654 ... 0.247998 0.771679 0.909412 -0.689281 -0.327642 -0.139097 -0.055353 -0.059752 378.66 0 3 1.0 -0.966272 -0.185226 1.792993 -0.863291 -0.010309 1.247203 0.237609 0.377436 -1.387024 ... -0.108300 0.005274 -0.190321 -1.175575 0.647376 -0.221929 0.062723 0.061458 123.50 0 4 2.0 -1.158233 0.877737 1.548718 0.403034 -0.407193 0.095921 0.592941 -0.270533 0.817739 ... -0.009431 0.798278 -0.137458 0.141267 -0.206010 0.502292 0.219422 0.215153 69.99 0 5 rows × 31 columns 先来看看正负样本的分布情况吧！12345count_classes = pd.value_counts(data[&#x27;Class&#x27;], sort = True).sort_index() # values_counts可以根据值进行计数。sort_index()按行索引排序count_classes.plot(kind = &#x27;bar&#x27;) # 除了plt，pd也可以做一些简单的图plt.title(&quot;Fraud class histogram&quot;)plt.xlabel(&quot;Class&quot;)plt.ylabel(&quot;Frequency&quot;) &lt;matplotlib.text.Text at 0x216366d8860&gt; 样本数据极度不均匀，应该怎么做？ 下采样——对于不均衡的数据，让 1 和 0 的数据一样少 过采样——对于不均衡的数据，生成一些数据，让生成的数据与 0 样本一样多 Amount数据分布不均衡，为了保证特征之间的分布是差不多的。——即保证数据的重要性一样。 标准化 归一化 可以使用sklearn的预处理模块进行标准化 123456from sklearn.preprocessing import StandardScalerdata[&#x27;normAmount&#x27;] = StandardScaler().fit_transform(data[&#x27;Amount&#x27;].reshape(-1, 1)) # reshape(-1,1) # -1表示让python给它行数data = data.drop([&#x27;Time&#x27;,&#x27;Amount&#x27;],axis=1) # 有了新特征后，将没用的特征去掉。data.head() V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 ... V21 V22 V23 V24 V25 V26 V27 V28 Class normAmount 0 -1.359807 -0.072781 2.536347 1.378155 -0.338321 0.462388 0.239599 0.098698 0.363787 0.090794 ... -0.018307 0.277838 -0.110474 0.066928 0.128539 -0.189115 0.133558 -0.021053 0 0.244964 1 1.191857 0.266151 0.166480 0.448154 0.060018 -0.082361 -0.078803 0.085102 -0.255425 -0.166974 ... -0.225775 -0.638672 0.101288 -0.339846 0.167170 0.125895 -0.008983 0.014724 0 -0.342475 2 -1.358354 -1.340163 1.773209 0.379780 -0.503198 1.800499 0.791461 0.247676 -1.514654 0.207643 ... 0.247998 0.771679 0.909412 -0.689281 -0.327642 -0.139097 -0.055353 -0.059752 0 1.160686 3 -0.966272 -0.185226 1.792993 -0.863291 -0.010309 1.247203 0.237609 0.377436 -1.387024 -0.054952 ... -0.108300 0.005274 -0.190321 -1.175575 0.647376 -0.221929 0.062723 0.061458 0 0.140534 4 -1.158233 0.877737 1.548718 0.403034 -0.407193 0.095921 0.592941 -0.270533 0.817739 0.753074 ... -0.009431 0.798278 -0.137458 0.141267 -0.206010 0.502292 0.219422 0.215153 0 -0.073403 5 rows × 30 columns 先来进行下采样吧！123456789101112131415161718192021222324252627X = data.ix[:, data.columns != &#x27;Class&#x27;] # loc[标签] iloc[索引数字] 取值 ，ix[都可以] y = data.ix[:, data.columns == &#x27;Class&#x27;]# Number of data points in the minority classnumber_records_fraud = len(data[data.Class == 1]) # 计算异常样本的数目——采用bool索引的方式进行fraud_indices = np.array(data[data.Class == 1].index) # 通过.index函数拿出来异常样本的索引# Picking the indices of the normal classesnormal_indices = data[data.Class == 0].index # 拿出来所有正常样本的index，为了下面的随机选择。# Out of the indices we picked, randomly select &quot;x&quot; number (number_records_fraud)random_normal_indices = np.random.choice(normal_indices, number_records_fraud, replace = False)# np.random.choice(样本，选择数目)进行随机选择random_normal_indices = np.array(random_normal_indices) # 将拿出来的索引转化为np.array的类型# Appending the 2 indices ##合并两个样本的index进行合并under_sample_indices = np.concatenate([fraud_indices,random_normal_indices])# Under sample dataset ## 经过下采样以后拿到的数据under_sample_data = data.iloc[under_sample_indices,:]X_undersample = under_sample_data.ix[:, under_sample_data.columns != &#x27;Class&#x27;] # 下采样的数据分成两部分y_undersample = under_sample_data.ix[:, under_sample_data.columns == &#x27;Class&#x27;]# Showing ratioprint(&quot;Percentage of normal transactions: &quot;, len(under_sample_data[under_sample_data.Class == 0])/len(under_sample_data))print(&quot;Percentage of fraud transactions: &quot;, len(under_sample_data[under_sample_data.Class == 1])/len(under_sample_data))print(&quot;Total number of transactions in resampled data: &quot;, len(under_sample_data)) Percentage of normal transactions: 0.5 Percentage of fraud transactions: 0.5 Total number of transactions in resampled data: 984 下采样的数据少了，会出现什么问题呢？ 后面说。先来进行交叉验证的数据的切分。——交叉验证，说到底是为了选参！12345678910111213141516171819from sklearn.cross_validation import train_test_split # sklearn有交叉验证的工具，能镜像数据的划分。# from sklearn.model_selection import train_test_split# Whole dataset #【1】对原始的数据进行切分——（为了使用它的测试集进行测试）X_train, X_test, y_train, y_test = train_test_split(X,y,test_size = 0.3, random_state = 0) ## 注意顺序！ 数据洗牌print(&quot;Number transactions train dataset: &quot;, len(X_train))print(&quot;Number transactions test dataset: &quot;, len(X_test))print(&quot;Total number of transactions: &quot;, len(X_train)+len(X_test))# Undersampled dataset # 【2】 对下采样的数据进行切分。（下采样的测试集小，不具备原始数据的分布规则。）X_train_undersample, X_test_undersample, y_train_undersample, y_test_undersample = train_test_split(X_undersample ,y_undersample ,test_size = 0.3 ,random_state = 0)print(&quot;&quot;)print(&quot;Number transactions train dataset: &quot;, len(X_train_undersample))print(&quot;Number transactions test dataset: &quot;, len(X_test_undersample))print(&quot;Total number of transactions: &quot;, len(X_train_undersample)+len(X_test_undersample)) C:\\Anaconda3\\lib\\site-packages\\sklearn\\cross_validation.py:44: DeprecationWarning: This module was deprecated in version 0.18 in favor of the model_selection module into which all the refactored classes and functions are moved. Also note that the interface of the new CV iterators are different from that of this module. This module will be removed in 0.20. &quot;This module will be removed in 0.20.&quot;, DeprecationWarning) Number transactions train dataset: 199364 Number transactions test dataset: 85443 Total number of transactions: 284807 Number transactions train dataset: 688 Number transactions test dataset: 296 Total number of transactions: 984 现在数据切分完了，已经有数据了，可以进行建模了！——逻辑回归模型可以容易建立（如用sklearn），但是模型评估标准咋样呢？——精度骗人! 样本数目不均衡时，类偏移现象。100个人，99个正常(0)，1个得癌症(1)。那如果我的模型是y = 0,我的准确率是 99 %,但是检测不出来一个患有癌症的人。——所以希望我们的模型查的全一点。 查准率与查全率（召回率）1234#Recall = TP/(TP+FN) # 我判断得癌症的人/实际得癌症的人from sklearn.linear_model import LogisticRegressionfrom sklearn.cross_validation import KFold, cross_val_score # KFold 做几倍的交叉验证， cross_val_score交叉验证的结果from sklearn.metrics import confusion_matrix,recall_score,classification_report 交叉验证 正则化惩罚项——解决高偏差（欠拟合，数据误差大）&amp; 高方差（过拟合，泛化能力差） L1 惩罚项 L2 惩罚项 直接使用sklearn的逻辑回归库进行拟合 先实例化一个逻辑回归对象（传入正则化参数C，惩罚方式即可） 然后进行fit拟合 sklearn会返回预测结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657def printing_Kfold_scores(x_train_data,y_train_data): fold = KFold(5,shuffle=False) # 对（训练的）测试集的五倍交叉验证。 ### 返回值是一个列表是[[train1,test1],[train2,test2],...] # Different C parameters # C越大惩罚力度越大，即heta的权重就越小。可以用交叉验证来检测到底等于多少好。 c_param_range = [0.01,0.1,1,10,100] results_table = pd.DataFrame(index = range(len(c_param_range),2), columns = [&#x27;C_parameter&#x27;,&#x27;Mean recall score&#x27;]) results_table[&#x27;C_parameter&#x27;] = c_param_range # the k-fold will give 2 lists: train_indices = indices[0], test_indices = indices[1] ## k-fold会分成两个索引的列表：train_indices = indices[0], test_indices = indices[1] j = 0 &quot;&quot;&quot;来看哪个C好&quot;&quot;&quot; for c_param in c_param_range: print(&#x27;-------------------------------------------&#x27;) print(&#x27;C parameter: &#x27;, c_param) print(&#x27;-------------------------------------------&#x27;) print(&#x27;&#x27;) recall_accs = [] &quot;&quot;&quot;来进行交叉验证，1 3 训练 2验证，1 2 训练，3验证...&quot;&quot;&quot; for iteration, indices in enumerate(fold,start=1): ## 一般情况下，如果要对一个列表或者数组既要遍历索引又要遍历元素时，可以用enumerate # Call the logistic regression model with a certain C parameter lr = LogisticRegression(C = c_param, penalty = &#x27;l1&#x27;) ## C正则化，惩罚方式 L1惩罚。 # Use the training data to fit the model. In this case, we use the portion of the fold to train the model # with indices[0]. We then predict on the portion assigned as the &#x27;test cross validation&#x27; with indices[1] # 进行数据的拟合 lr.fit(x_train_data.iloc[indices[0],:],y_train_data.iloc[indices[0],:].values.ravel()) # Predict values using the test indices in the training data ## 比如在C = 0.01情况下，效果咋样 y_pred_undersample = lr.predict(x_train_data.iloc[indices[1],:].values) # Calculate the recall score and append it to a list for recall scores representing the current c_parameter recall_acc = recall_score(y_train_data.iloc[indices[1],:].values,y_pred_undersample) ## 召回率库自己生成 recall_score(实际值，预测值) recall_accs.append(recall_acc) print(&#x27;Iteration &#x27;, iteration,&#x27;: recall score = &#x27;, recall_acc) # The mean value of those recall scores is the metric we want to save and get hold of. results_table.ix[j,&#x27;Mean recall score&#x27;] = np.mean(recall_accs) j += 1 print(&#x27;&#x27;) print(&#x27;Mean recall score &#x27;, np.mean(recall_accs)) print(&#x27;&#x27;) best_c = results_table.loc[results_table[&#x27;Mean recall score&#x27;].idxmax()][&#x27;C_parameter&#x27;] # 定义能取到最大值得索引位置， # Finally, we can check which C parameter is the best amongst the chosen. print(&#x27;*********************************************************************************&#x27;) print(&#x27;Best model to choose from cross validation is with C parameter = &#x27;, best_c) print(&#x27;*********************************************************************************&#x27;) return best_c 1best_c = printing_Kfold_scores(X_train_undersample,y_train_undersample) ------------------------------------------- C parameter: 0.01 ------------------------------------------- Iteration 1 : recall score = 0.958904109589 Iteration 2 : recall score = 0.917808219178 Iteration 3 : recall score = 1.0 Iteration 4 : recall score = 0.972972972973 Iteration 5 : recall score = 0.954545454545 Mean recall score 0.960846151257 ------------------------------------------- C parameter: 0.1 ------------------------------------------- Iteration 1 : recall score = 0.835616438356 Iteration 2 : recall score = 0.86301369863 Iteration 3 : recall score = 0.915254237288 Iteration 4 : recall score = 0.932432432432 Iteration 5 : recall score = 0.878787878788 Mean recall score 0.885020937099 ------------------------------------------- C parameter: 1 ------------------------------------------- Iteration 1 : recall score = 0.835616438356 Iteration 2 : recall score = 0.86301369863 Iteration 3 : recall score = 0.966101694915 Iteration 4 : recall score = 0.945945945946 Iteration 5 : recall score = 0.893939393939 Mean recall score 0.900923434357 ------------------------------------------- C parameter: 10 ------------------------------------------- Iteration 1 : recall score = 0.849315068493 Iteration 2 : recall score = 0.86301369863 Iteration 3 : recall score = 0.966101694915 Iteration 4 : recall score = 0.959459459459 Iteration 5 : recall score = 0.893939393939 Mean recall score 0.906365863087 ------------------------------------------- C parameter: 100 ------------------------------------------- Iteration 1 : recall score = 0.86301369863 Iteration 2 : recall score = 0.86301369863 Iteration 3 : recall score = 0.966101694915 Iteration 4 : recall score = 0.959459459459 Iteration 5 : recall score = 0.893939393939 Mean recall score 0.909105589115 ********************************************************************************* Best model to choose from cross validation is with C parameter = 0.01 ********************************************************************************* 12345678910111213141516171819202122def plot_confusion_matrix(cm, classes, title=&#x27;Confusion matrix&#x27;, cmap=plt.cm.Blues): &quot;&quot;&quot; This function prints and plots the confusion matrix. &quot;&quot;&quot; plt.imshow(cm, interpolation=&#x27;nearest&#x27;, cmap=cmap) plt.title(title) plt.colorbar() tick_marks = np.arange(len(classes)) plt.xticks(tick_marks, classes, rotation=0) plt.yticks(tick_marks, classes) thresh = cm.max() / 2. for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])): plt.text(j, i, cm[i, j], horizontalalignment=&quot;center&quot;, color=&quot;white&quot; if cm[i, j] &gt; thresh else &quot;black&quot;) plt.tight_layout() plt.ylabel(&#x27;True label&#x27;) plt.xlabel(&#x27;Predicted label&#x27;) 123456789101112131415161718import itertoolslr = LogisticRegression(C = best_c, penalty = &#x27;l1&#x27;)lr.fit(X_train_undersample,y_train_undersample.values.ravel())y_pred_undersample = lr.predict(X_test_undersample.values)# Compute confusion matrixcnf_matrix = confusion_matrix(y_test_undersample,y_pred_undersample)np.set_printoptions(precision=2)print(&quot;Recall metric in the testing dataset: &quot;, cnf_matrix[1,1]/(cnf_matrix[1,0]+cnf_matrix[1,1]))# Plot non-normalized confusion matrixclass_names = [0,1]plt.figure()plot_confusion_matrix(cnf_matrix , classes=class_names , title=&#x27;Confusion matrix&#x27;)plt.show() Recall metric in the testing dataset: 0.931972789116 从下采样的测试集，可以看到召回率约为(137+10)/137≈90%1234567891011121314151617lr = LogisticRegression(C = best_c, penalty = &#x27;l1&#x27;)lr.fit(X_train_undersample,y_train_undersample.values.ravel())y_pred = lr.predict(X_test.values)# Compute confusion matrixcnf_matrix = confusion_matrix(y_test,y_pred)np.set_printoptions(precision=2)print(&quot;Recall metric in the testing dataset: &quot;, cnf_matrix[1,1]/(cnf_matrix[1,0]+cnf_matrix[1,1]))# Plot non-normalized confusion matrixclass_names = [0,1]plt.figure()plot_confusion_matrix(cnf_matrix , classes=class_names , title=&#x27;Confusion matrix&#x27;)plt.show() Recall metric in the testing dataset: 0.918367346939 可以看到下采样的预测应用到整体样本的测试集，虽然召回率约为90%，但有8581个误杀值，不是我们所希望的。对于原始数据集进行验证。会得到什么结果呢？——不进行上(下)采样1best_c = printing_Kfold_scores(X_train,y_train) ------------------------------------------- C parameter: 0.01 ------------------------------------------- Iteration 1 : recall score = 0.492537313433 Iteration 2 : recall score = 0.602739726027 Iteration 3 : recall score = 0.683333333333 Iteration 4 : recall score = 0.569230769231 Iteration 5 : recall score = 0.45 Mean recall score 0.559568228405 ------------------------------------------- C parameter: 0.1 ------------------------------------------- Iteration 1 : recall score = 0.567164179104 Iteration 2 : recall score = 0.616438356164 Iteration 3 : recall score = 0.683333333333 Iteration 4 : recall score = 0.584615384615 Iteration 5 : recall score = 0.525 Mean recall score 0.595310250644 ------------------------------------------- C parameter: 1 ------------------------------------------- Iteration 1 : recall score = 0.55223880597 Iteration 2 : recall score = 0.616438356164 Iteration 3 : recall score = 0.716666666667 Iteration 4 : recall score = 0.615384615385 Iteration 5 : recall score = 0.5625 Mean recall score 0.612645688837 ------------------------------------------- C parameter: 10 ------------------------------------------- Iteration 1 : recall score = 0.55223880597 Iteration 2 : recall score = 0.616438356164 Iteration 3 : recall score = 0.733333333333 Iteration 4 : recall score = 0.615384615385 Iteration 5 : recall score = 0.575 Mean recall score 0.61847902217 ------------------------------------------- C parameter: 100 ------------------------------------------- Iteration 1 : recall score = 0.55223880597 Iteration 2 : recall score = 0.616438356164 Iteration 3 : recall score = 0.733333333333 Iteration 4 : recall score = 0.615384615385 Iteration 5 : recall score = 0.575 Mean recall score 0.61847902217 ********************************************************************************* Best model to choose from cross validation is with C parameter = 10.0 ********************************************************************************* 1234567891011121314151617lr = LogisticRegression(C = best_c, penalty = &#x27;l1&#x27;)lr.fit(X_train,y_train.values.ravel())y_pred_undersample = lr.predict(X_test.values)# Compute confusion matrixcnf_matrix = confusion_matrix(y_test,y_pred_undersample)np.set_printoptions(precision=2)print(&quot;Recall metric in the testing dataset: &quot;, cnf_matrix[1,1]/(cnf_matrix[1,0]+cnf_matrix[1,1]))# Plot non-normalized confusion matrixclass_names = [0,1]plt.figure()plot_confusion_matrix(cnf_matrix , classes=class_names , title=&#x27;Confusion matrix&#x27;)plt.show() Recall metric in the testing dataset: 0.619047619048 可以看到拿原始数据进行预测得到的召回率是比较低的。接下来看看不同的阈值对模型的影响——划分正负样本的标准不是默认的0.5了123456789101112131415161718192021222324252627lr = LogisticRegression(C = 0.01, penalty = &#x27;l1&#x27;)lr.fit(X_train_undersample,y_train_undersample.values.ravel())y_pred_undersample_proba = lr.predict_proba(X_test_undersample.values) ## 之前拿的是predict()现在是另外一个函数了 # 之前预测是类别的值，现在预测是概率值thresholds = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9]plt.figure(figsize=(10,10))j = 1for i in thresholds: y_test_predictions_high_recall = y_pred_undersample_proba[:,1] &gt; i ## 这是关键，拿到概率后直接拿它与设定阈值比较 plt.subplot(3,3,j) j += 1 # Compute confusion matrix cnf_matrix = confusion_matrix(y_test_undersample,y_test_predictions_high_recall) np.set_printoptions(precision=2) print(&quot;Recall metric in the testing dataset: &quot;, cnf_matrix[1,1]/(cnf_matrix[1,0]+cnf_matrix[1,1])) # Plot non-normalized confusion matrix class_names = [0,1] plot_confusion_matrix(cnf_matrix , classes=class_names , title=&#x27;Threshold &gt;= %s&#x27;%i) Recall metric in the testing dataset: 1.0 Recall metric in the testing dataset: 1.0 Recall metric in the testing dataset: 1.0 Recall metric in the testing dataset: 0.986394557823 Recall metric in the testing dataset: 0.931972789116 Recall metric in the testing dataset: 0.884353741497 Recall metric in the testing dataset: 0.836734693878 Recall metric in the testing dataset: 0.748299319728 Recall metric in the testing dataset: 0.571428571429 可以看到随着阈值的上升，误杀值减小，但是召回率也是减小了。——实际建模时，应该根据实际情况来选择阈值！看完下采样的分析，我们来看看上采样的结果吧！ 上采样需要额外的数据，这里我们采用 SMOTE 方法来生成少数样本的数据。 12345import pandas as pdfrom imblearn.over_sampling import SMOTE # 需要安装 imblearn 库from sklearn.ensemble import RandomForestClassifierfrom sklearn.metrics import confusion_matrixfrom sklearn.model_selection import train_test_split 12345678credit_cards=pd.read_csv(&#x27;creditcard.csv&#x27;)columns=credit_cards.columns# The labels are in the last column (&#x27;Class&#x27;). Simply remove it to obtain features columnsfeatures_columns=columns.delete(len(columns)-1)features=credit_cards[features_columns]labels=credit_cards[&#x27;Class&#x27;] 1234features_train, features_test, labels_train, labels_test = train_test_split(features, labels, test_size=0.2, random_state=0) 12oversampler=SMOTE(random_state=0) # 每次生辰的随机数一样。os_features,os_labels=oversampler.fit_sample(features_train,labels_train) # 注意传入的是训练的x和y的值。没有测试部分的 1len(os_labels[os_labels==1]) # 自动会进行平衡。1:1平衡 227454 123os_features = pd.DataFrame(os_features)os_labels = pd.DataFrame(os_labels)best_c = printing_Kfold_scores(os_features,os_labels) ------------------------------------------- C parameter: 0.01 ------------------------------------------- Iteration 1 : recall score = 0.890322580645 Iteration 2 : recall score = 0.894736842105 Iteration 3 : recall score = 0.968861347792 Iteration 4 : recall score = 0.957595541926 Iteration 5 : recall score = 0.958430881173 Mean recall score 0.933989438728 ------------------------------------------- C parameter: 0.1 ------------------------------------------- Iteration 1 : recall score = 0.890322580645 Iteration 2 : recall score = 0.894736842105 Iteration 3 : recall score = 0.970410534469 Iteration 4 : recall score = 0.959980655302 Iteration 5 : recall score = 0.960178498807 Mean recall score 0.935125822266 ------------------------------------------- C parameter: 1 ------------------------------------------- Iteration 1 : recall score = 0.890322580645 Iteration 2 : recall score = 0.894736842105 Iteration 3 : recall score = 0.970454796946 Iteration 4 : recall score = 0.96014552489 Iteration 5 : recall score = 0.960596168431 Mean recall score 0.935251182603 ------------------------------------------- C parameter: 10 ------------------------------------------- Iteration 1 : recall score = 0.890322580645 Iteration 2 : recall score = 0.894736842105 Iteration 3 : recall score = 0.97065397809 Iteration 4 : recall score = 0.960343368396 Iteration 5 : recall score = 0.960530220596 Mean recall score 0.935317397966 ------------------------------------------- C parameter: 100 ------------------------------------------- Iteration 1 : recall score = 0.890322580645 Iteration 2 : recall score = 0.894736842105 Iteration 3 : recall score = 0.970543321899 Iteration 4 : recall score = 0.960211472725 Iteration 5 : recall score = 0.960903924995 Mean recall score 0.935343628474 ********************************************************************************* Best model to choose from cross validation is with C parameter = 100.0 ********************************************************************************* 1234567891011121314151617lr = LogisticRegression(C = best_c, penalty = &#x27;l1&#x27;)lr.fit(os_features,os_labels.values.ravel())y_pred = lr.predict(features_test.values)# Compute confusion matrixcnf_matrix = confusion_matrix(labels_test,y_pred)np.set_printoptions(precision=2)print(&quot;Recall metric in the testing dataset: &quot;, cnf_matrix[1,1]/(cnf_matrix[1,0]+cnf_matrix[1,1]))# Plot non-normalized confusion matrixclass_names = [0,1]plt.figure()plot_confusion_matrix(cnf_matrix , classes=class_names , title=&#x27;Confusion matrix&#x27;)plt.show() Recall metric in the testing dataset: 0.90099009901 召回率还可以，误杀率降下来——模型的精度变高。(56344+91)/(569344+91+517+10)总之，能用数据生成方式尽量用，上采样的结果更好！案例流程总结： 1. 数据的观察。 1.1 数据浮动情况： 归一化 标准化 1.2 数据分布均匀情况： 下采样 上采样 1.3 此处的案例的特征是处理过的，纯净的特征，不需要额外处理。很多时候需要特种工程处理特征数据—后面讲 2. 对于不同的模型有不同的参数，需要自己进行选择。 比如逻辑回归的正则化参数C的选择(解决过拟合【高方差】和欠拟合【高偏差】)。 采用交叉验证的方式来确定参数C（交叉验证多次来确定C的合适大小） 3. 混淆矩阵，召回率——解决类偏移问题 预测模型为 y=1 ,准确率达到90%这类问题。 4. 不同的阈值（评判分类的不概率标准） 对结果有一定的影响。如此题。阈值越大，误杀率越高，召回率降低。——实际建模的时候，根据需要来确定。","categories":[{"name":"机器学习基础实战","slug":"机器学习基础实战","permalink":"https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"机器学习基础实战","slug":"机器学习基础实战","permalink":"https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/"}]},{"title":"逻辑回归基础","slug":"逻辑回归基础","date":"2021-04-17T17:13:29.000Z","updated":"2021-04-17T18:06:11.080Z","comments":true,"path":"20210418/逻辑回归基础.html","link":"","permalink":"https://xxren8218.github.io/20210418/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%9F%BA%E7%A1%80.html","excerpt":"","text":"Logistic RegressionThe data我们将建立一个逻辑回归模型来预测一个学生是否被大学录取。假设你是一个大学系的管理员，你想根据两次考试的结果来决定每个申请人的录取机会。你有以前的申请人的历史数据，你可以用它作为逻辑回归的训练集。对于每一个培训例子，你有两个考试的申请人的分数和录取决定。为了做到这一点，我们将建立一个分类模型，根据考试成绩估计入学概率。 12345# 三大件 # 可以直接在你的python console里面生成图像。不需要plt.show()就可进行展示import numpy as npimport pandas as pdimport matplotlib.pyplot as plt%matplotlib inline 1234import ospath = &#x27;data&#x27; + os.sep + &#x27;LogiReg_data.txt&#x27; # 为了让代码在不同的平台上都能运行，路径应该写&#x27;\\&#x27;还是&#x27;/&#x27;无所谓。pdData = pd.read_csv(path, header=None, names=[&#x27;Exam 1&#x27;, &#x27;Exam 2&#x27;, &#x27;Admitted&#x27;]) # header = None自己制定列名pdData.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Exam 1 Exam 2 Admitted 0 34.623660 78.024693 0 1 30.286711 43.894998 0 2 35.847409 72.902198 0 3 60.182599 86.308552 1 4 79.032736 75.344376 1 1pdData.shape # 看数据的维度。 (100, 3) 12345678910positive = pdData[pdData[&#x27;Admitted&#x27;] == 1] # returns the subset of rows such Admitted = 1, i.e. the set of *positive* examplesnegative = pdData[pdData[&#x27;Admitted&#x27;] == 0] # returns the subset of rows such Admitted = 0, i.e. the set of *negative* examplesfig, ax = plt.subplots(figsize=(10,5))ax.scatter(positive[&#x27;Exam 1&#x27;], positive[&#x27;Exam 2&#x27;], s=30, c=&#x27;b&#x27;, marker=&#x27;o&#x27;, label=&#x27;Admitted&#x27;)ax.scatter(negative[&#x27;Exam 1&#x27;], negative[&#x27;Exam 2&#x27;], s=30, c=&#x27;r&#x27;, marker=&#x27;x&#x27;, label=&#x27;Not Admitted&#x27;)ax.legend() # legend（）有一个loc参数，用于控制图例的位置。 比如 plot.legend(loc=2) , 这个位置就是4象项中的第二象项，也就是左上角。 loc可以为1,2,3,4 这四个数字。 # 如果把那句legend() 的语句去掉，那么图形上的图例也就会消失了。ax.set_xlabel(&#x27;Exam 1 Score&#x27;)ax.set_ylabel(&#x27;Exam 2 Score&#x27;) Text(0,0.5,&#39;Exam 2 Score&#39;) The logistic regression目标：建立分类器—即决策边界（求解出三个参数 $\\theta_0 \\theta_1 \\theta_2 $） 设定阈值，根据阈值判断录取结果—就是分类的概率判断，一般为 0.5 要完成的模块 sigmoid : 映射到概率的函数 model : 返回预测结果值 cost : 根据参数计算损失 gradient : 计算每个参数的梯度方向 descent : 进行参数更新 accuracy: 计算精度 sigmoid 函数 g(z) = \\frac{1}{1+e^{-z}}12def sigmoid(z): return 1 / (1 + np.exp(-z)) # np.exp(-z)表示e的多少次幂 123nums = np.arange(-10, 10, step=1) #creates a vector containing 20 equally spaced values from -10 to 10fig, ax = plt.subplots(figsize=(12,4))ax.plot(nums, sigmoid(nums), &#x27;r&#x27;) [&lt;matplotlib.lines.Line2D at 0x244554b2b70&gt;] Sigmoid $g:\\mathbb{R} \\to [0,1]$ $g(0)=0.5$ $g(- \\infty)=0$ $g(+ \\infty)=1$ model 完成预测函数 $h_\\theta(x)$1234def model(X, theta): return sigmoid(np.dot(X, theta.T)) # np.dot是矩阵的乘法,也可以用 @ # 求出的 model是 m行1列.m--样本数目： \\begin{array}{ccc} \\begin{pmatrix}\\theta_{0} & \\theta_{1} & \\theta_{2}\\end{pmatrix} & \\times & \\begin{pmatrix}1\\\\ x_{1}\\\\ x_{2} \\end{pmatrix}\\end{array}=\\theta_{0}+\\theta_{1}x_{1}+\\theta_{2}x_{2}12345678910111213pdData.insert(0, &#x27;Ones&#x27;, 1) # 插入零的一列，列指标为 Ones# set X (training data) and y (target variable)orig_data = pdData.as_matrix() # 习惯性的操作。很多时候取得的数据是DataFrame的形式(直接转换csv格式的数据以后)，这个时候要记得转换成数组cols = orig_data.shape[1] # 看数据有几列。X = orig_data[:,0:cols-1]y = orig_data[:,cols-1:cols]# convert to numpy arrays and initalize the parameter array theta#X = np.matrix(X.values)#y = np.matrix(data.iloc[:,3:4].values) #np.array(y.values)theta = np.zeros([1, 3]) # 参数theta 一般先构造出来，用zero来占位，构造1行3列的数据。即三个theta参数 （1,3）[1,4]都可以。 来看看数据的样子吧 1X[:5] # 前 5 行的数据 array([[ 1. , 34.62365962, 78.02469282], [ 1. , 30.28671077, 43.89499752], [ 1. , 35.84740877, 72.90219803], [ 1. , 60.18259939, 86.3085521 ], [ 1. , 79.03273605, 75.34437644]]) 1y[:5] array([[0.], [0.], [0.], [1.], [1.]]) 1theta array([[0., 0., 0.]]) 1X.shape, y.shape, theta.shape ((100, 3), (100, 1), (1, 3)) 损失函数（代价函数）将对数似然函数去负号 D(h_\\theta(x), y) = -y\\log(h_\\theta(x)) - (1-y)\\log(1-h_\\theta(x))求平均损失 J(\\theta)=\\frac{1}{m}\\sum_{i=1}^{m} D(h_\\theta(x_i), y_i)1234def cost(X, y, theta): left = np.multiply(-y, np.log(model(X, theta))) # np.multiply对数据完成的乘的操作 right = np.multiply(1 - y, np.log(1 - model(X, theta))) return np.sum(left - right) / (len(X)) # np.sum完成对数据的加和 1cost(X, y, theta) 0.6931471805599453 计算梯度 — 最难的部分 \\frac{\\partial J}{\\partial \\theta_j}=-\\frac{1}{m}\\sum_{i=1}^n (y_i - h_\\theta (x_i))x_{ij}12345678def gradient(X, y, theta): grad = np.zeros(theta.shape) # 梯度计算需要考虑 theta 的个数（维度） error = (model(X, theta)- y).ravel() # 把负号提取到里面了，revel()将数据降为1维！(1,m) for j in range(len(theta.ravel())): # theta降低为 1 维度，[1,2,3,4]这样,就可以求theta的个数了，按列进行遍历 term = np.multiply(error, X[:,j]) # 矩阵的乘法，取第j列。 (1,m)@(m,1) grad[0, j] = np.sum(term) / len(X) # 每一个梯度j算一个值。取[0, j] return grad Gradient descent比较3种不同梯度下降方法—批量、随机、小批量 123456789STOP_ITER = 0 # 根据迭代次数停止STOP_COST = 1 # 根据损失值目标函数的变化停止STOP_GRAD = 2 # 根据梯度的变化（很小）停止def stopCriterion(type, value, threshold): &quot;&quot;&quot;设定三种不同的停止策略&quot;&quot;&quot; if type == STOP_ITER: return value &gt; threshold elif type == STOP_COST: return abs(value[-1]-value[-2]) &lt; threshold # abs()返回绝对值 elif type == STOP_GRAD: return np.linalg.norm(value) &lt; threshold # np.linalg.norm默认是 2 范数--平方和开根号。 12345678import numpy.random# 洗牌，将数据随机化，泛化能力变强def shuffleData(data): np.random.shuffle(data) # np.random.shuffle()将数据进行洗牌。 cols = data.shape[1] X = data[:, 0:cols-1] y = data[:, cols-1:] return X, y 123456789101112131415161718192021222324252627282930import timedef descent(data, theta, batchSize, stopType, thresh, alpha): &quot;&quot;&quot;梯度下降求解&quot;&quot;&quot; # 参数的初始化，第一次计算各个值。 init_time = time.time() i = 0 # 迭代次数 k = 0 # batch X, y = shuffleData(data) grad = np.zeros(theta.shape) # 计算的梯度 costs = [cost(X, y, theta)] # 损失值 while True: grad = gradient(X[k:k+batchSize], y[k:k+batchSize], theta) k += batchSize # 取batch个数据，每次取batchSize个数据进行计算。 if k &gt;= n: k = 0 X, y = shuffleData(data) # 重新洗牌 theta = theta - alpha*grad # 参数更新 costs.append(cost(X, y, theta)) # 计算新的损失 i += 1 if stopType == STOP_ITER: value = i elif stopType == STOP_COST: value = costs elif stopType == STOP_GRAD: value = grad if stopCriterion(stopType, value, thresh): break return theta, i-1, costs, grad, time.time() - init_time 123456789101112131415161718192021def runExpe(data, theta, batchSize, stopType, thresh, alpha): #import pdb; pdb.set_trace(); theta, iter, costs, grad, dur = descent(data, theta, batchSize, stopType, thresh, alpha) name = &quot;Original&quot; if (data[:,1]&gt;2).sum() &gt; 1 else &quot;Scaled&quot; # 归一化时的区分 name += &quot; data - learning rate: &#123;&#125; - &quot;.format(alpha) if batchSize==n: strDescType = &quot;Gradient&quot; elif batchSize==1: strDescType = &quot;Stochastic&quot; else: strDescType = &quot;Mini-batch (&#123;&#125;)&quot;.format(batchSize) name += strDescType + &quot; descent - Stop: &quot; if stopType == STOP_ITER: strStop = &quot;&#123;&#125; iterations&quot;.format(thresh) elif stopType == STOP_COST: strStop = &quot;costs change &lt; &#123;&#125;&quot;.format(thresh) else: strStop = &quot;gradient norm &lt; &#123;&#125;&quot;.format(thresh) name += strStop print (&quot;***&#123;&#125;\\nTheta: &#123;&#125; - Iter: &#123;&#125; - Last cost: &#123;:03.2f&#125; - Duration: &#123;:03.2f&#125;s&quot;.format( name, theta, iter, costs[-1], dur)) fig, ax = plt.subplots(figsize=(12,4)) ax.plot(np.arange(len(costs)), costs, &#x27;r&#x27;) ax.set_xlabel(&#x27;Iterations&#x27;) ax.set_ylabel(&#x27;Cost&#x27;) ax.set_title(name.upper() + &#x27; - Error vs. Iteration&#x27;) return theta 不同的停止策略设定迭代次数123#选择的梯度下降方法是基于所有样本的n=100runExpe(orig_data, theta, n, STOP_ITER, thresh=5000, alpha=0.000001) ***Original data - learning rate: 1e-06 - Gradient descent - Stop: 5000 iterations Theta: [[-0.00027127 0.00705232 0.00376711]] - Iter: 5000 - Last cost: 0.63 - Duration: 0.82s array([[-0.00027127, 0.00705232, 0.00376711]]) 根据损失值停止设定阈值 1E-6, 差不多需要110 000次迭代 1runExpe(orig_data, theta, n, STOP_COST, thresh=0.000001, alpha=0.001) ***Original data - learning rate: 0.001 - Gradient descent - Stop: costs change &lt; 1e-06 Theta: [[-5.13364014 0.04771429 0.04072397]] - Iter: 109901 - Last cost: 0.38 - Duration: 17.97s array([[-5.13364014, 0.04771429, 0.04072397]]) 根据梯度变化停止设定阈值 0.05,差不多需要40 000次迭代 1runExpe(orig_data, theta, n, STOP_GRAD, thresh=0.05, alpha=0.001) ***Original data - learning rate: 0.001 - Gradient descent - Stop: gradient norm &lt; 0.05 Theta: [[-2.37033409 0.02721692 0.01899456]] - Iter: 40045 - Last cost: 0.49 - Duration: 6.87s array([[-2.37033409, 0.02721692, 0.01899456]]) 对比不同的梯度下降方法Stochastic descent1runExpe(orig_data, theta, 1, STOP_ITER, thresh=5000, alpha=0.001) ***Original data - learning rate: 0.001 - Stochastic descent - Stop: 5000 iterations Theta: [[-0.39253059 0.04095984 -0.07371051]] - Iter: 5000 - Last cost: 1.84 - Duration: 0.27s array([[-0.39253059, 0.04095984, -0.07371051]]) 有点爆炸。。。很不稳定,再来试试把学习率调小一些 1runExpe(orig_data, theta, 1, STOP_ITER, thresh=15000, alpha=0.000002) ***Original data - learning rate: 2e-06 - Stochastic descent - Stop: 15000 iterations Theta: [[-0.00202238 0.00995606 0.00088035]] - Iter: 15000 - Last cost: 0.63 - Duration: 0.77s array([[-0.00202238, 0.00995606, 0.00088035]]) 速度快，但稳定性差，需要很小的学习率 Mini-batch descent1runExpe(orig_data, theta, 16, STOP_ITER, thresh=15000, alpha=0.001) ***Original data - learning rate: 0.001 - Mini-batch (16) descent - Stop: 15000 iterations Theta: [[-1.0364887 0.02542788 0.00549476]] - Iter: 15000 - Last cost: 0.57 - Duration: 1.04s array([[-1.0364887 , 0.02542788, 0.00549476]]) 浮动仍然比较大，我们来尝试下对数据进行标准化将数据按其属性(按列进行)减去其均值，然后除以其方差。最后得到的结果是，对每个属性/每列来说所有数据都聚集在0附近，方差值为1 123456from sklearn import preprocessing as ppscaled_data = orig_data.copy()scaled_data[:, 1:3] = pp.scale(orig_data[:, 1:3])runExpe(scaled_data, theta, n, STOP_ITER, thresh=5000, alpha=0.001) ***Scaled data - learning rate: 0.001 - Gradient descent - Stop: 5000 iterations Theta: [[0.3080807 0.86494967 0.77367651]] - Iter: 5000 - Last cost: 0.38 - Duration: 0.88s array([[0.3080807 , 0.86494967, 0.77367651]]) 它好多了！原始数据，只能达到达到0.61，而我们得到了0.38个在这里！所以对数据做预处理是非常重要的 1runExpe(scaled_data, theta, n, STOP_GRAD, thresh=0.02, alpha=0.001) ***Scaled data - learning rate: 0.001 - Gradient descent - Stop: gradient norm &lt; 0.02 Theta: [[1.0707921 2.63030842 2.41079787]] - Iter: 59422 - Last cost: 0.22 - Duration: 10.67s array([[1.0707921 , 2.63030842, 2.41079787]]) 更多的迭代次数会使得损失下降的更多！ 1theta = runExpe(scaled_data, theta, 1, STOP_GRAD, thresh=0.002/5, alpha=0.001) ***Scaled data - learning rate: 0.001 - Stochastic descent - Stop: gradient norm &lt; 0.0004 Theta: [[1.14814786 2.79253048 2.56596963]] - Iter: 72591 - Last cost: 0.22 - Duration: 4.82s 随机梯度下降更快，但是我们需要迭代的次数也需要更多，所以还是用batch的比较合适！！！ 1runExpe(scaled_data, theta, 16, STOP_GRAD, thresh=0.002*2, alpha=0.001) ***Scaled data - learning rate: 0.001 - Mini-batch (16) descent - Stop: gradient norm &lt; 0.004 Theta: [[1.14982001 2.79586036 2.56934533]] - Iter: 307 - Last cost: 0.22 - Duration: 0.03s array([[1.14982001, 2.79586036, 2.56934533]]) 精度123# 设定阈值def predict(X, theta): return [1 if x &gt;= 0.5 else 0 for x in model(X, theta)] 123456789101112scaled_X = scaled_data[:, :3]y = scaled_data[:, 3]predictions = predict(scaled_X, theta)correct = [1 if ((a == 1 and b == 1) or (a == 0 and b == 0)) else 0 for (a, b) in zip(predictions, y)] &quot;&quot;&quot; zip(itertion1, iteration2) A[1,2,3] B[4,5,6] zip[A,B] = [(1,4),(2,5),(3,6)] 可用list()进行转换&quot;&quot;&quot;accuracy = (sum(map(int, correct)) / len(correct)) # map (func, iterations)print (&#x27;accuracy = &#123;&#125;%&#x27;.format(accuracy*100)) accuracy = 89.0% 逻辑回归到这里就结束了！","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习基础","slug":"机器学习基础","permalink":"https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}]},{"title":"机器学习数学基础-线性代数","slug":"机器学习数学基础-线性代数","date":"2021-04-04T17:11:14.000Z","updated":"2021-04-17T18:10:24.541Z","comments":true,"path":"20210405/机器学习数学基础-线性代数.html","link":"","permalink":"https://xxren8218.github.io/20210405/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html","excerpt":"","text":"线性代数复习和参考1. 基础概念和符号线性代数提供了一种紧凑地表示和操作线性方程组的方法。 例如，以下方程组： 4x_1 − 5x_2 = −13 −2x_1 + 3x_2 = 9这是两个方程和两个变量，正如你从高中代数中所知，你可以找到 $x_1$ 和 $x_2$ 的唯一解（除非方程以某种方式退化，例如，如果第二个方程只是第一个的倍数，但在上面的情况下，实际上只有一个唯一解）。 在矩阵表示法中，我们可以更紧凑地表达： Ax= b \\text { with } A=\\left[\\begin{array}{cc}{4} & {-5} \\\\ {-2} & {3}\\end{array}\\right], b=\\left[\\begin{array}{c}{-13} \\\\ {9}\\end{array}\\right]我们可以看到，这种形式的线性方程有许多优点（比如明显地节省空间）。 1.1 基本符号我们使用以下符号： $A \\in \\mathbb{R}^{m \\times n}$，表示 $A$ 为由实数组成具有$m$行和$n$列的矩阵。 $x \\in \\mathbb{R}^{ n}$，表示具有$n$个元素的向量。 通常，向量$x$将表示列向量: 即，具有$n$行和$1$列的矩阵。 如果我们想要明确地表示行向量: 具有 $1$ 行和$n$列的矩阵 - 我们通常写$x^T$（这里$x^T$$x$的转置）。 $x_i$表示向量$x$的第$i$个元素 x=\\left[\\begin{array}{c}{x_{1}} \\\\ {x_{2}} \\\\ {\\vdots} \\\\ {x_{n}}\\end{array}\\right] 我们使用符号 $a_{ij}$（或$A_{ij}$,$A_{i,j}$等）来表示第 $i$ 行和第$j$列中的 $A$ 的元素： A=\\left[\\begin{array}{cccc}{a_{11}} & {a_{12}} & {\\cdots} & {a_{1 n}} \\\\ {a_{21}} & {a_{22}} & {\\cdots} & {a_{2 n}} \\\\ {\\vdots} & {\\vdots} & {\\ddots} & {\\vdots} \\\\ {a_{m 1}} & {a_{m 2}} & {\\cdots} & {a_{m n}}\\end{array}\\right] 我们用$a^j$或者$A_{:,j}$表示矩阵$A$的第$j$列： A=\\left[\\begin{array}{llll}{ |} & { |} & {} & { |} \\\\ {a^{1}} & {a^{2}} & {\\cdots} & {a^{n}} \\\\ { |} & { |} & {} & { |}\\end{array}\\right] 我们用$a^T_i$或者$A_{i,:}$表示矩阵$A$的第$i$行： A=\\left[\\begin{array}{c}{-a_{1}^{T}-} \\\\ {-a_{2}^{T}-} \\\\ {\\vdots} \\\\ {-a_{m}^{T}-}\\end{array}\\right] 在许多情况下，将矩阵视为列向量或行向量的集合非常重要且方便。 通常，在向量而不是标量上操作在数学上（和概念上）更清晰。只要明确定义了符号，用于矩阵的列或行的表示方式并没有通用约定。 2.矩阵乘法两个矩阵相乘，其中 $A \\in \\mathbb{R}^{m \\times n}$ and $B \\in \\mathbb{R}^{n \\times p}$ ，则： C = AB \\in \\mathbb{R}^{m \\times p}其中： C_{i j}=\\sum_{k=1}^{n} A_{i k} B_{k j}请注意，为了使矩阵乘积存在，$A$中的列数必须等于$B$中的行数。有很多方法可以查看矩阵乘法，我们将从检查一些特殊情况开始。 2.1 向量-向量乘法给定两个向量$x, y \\in \\mathbb{R}^{n}$,$x^T y$通常称为向量内积或者点积，结果是个实数。 x^{T} y \\in \\mathbb{R}=\\left[\\begin{array}{llll}{x_{1}} & {x_{2}} & {\\cdots} & {x_{n}}\\end{array}\\right]\\left[\\begin{array}{c}{y_{1}} \\\\ {y_{2}} \\\\ {\\vdots} \\\\ {y_{n}}\\end{array}\\right]=\\sum_{i=1}^{n} x_{i} y_{i}注意：$x^T y = y^Tx$ 始终成立。 给定向量 $x \\in \\mathbb{R}^{m}$, $y \\in \\mathbb{R}^{n}$ (他们的维度是否相同都没关系)，$xy^T \\in \\mathbb{R}^{m \\times n}$叫做向量外积 , 当 $(xy^T)_{ij} = x_iy_j$ 的时候，它是一个矩阵。 x y^{T} \\in \\mathbb{R}^{m \\times n}=\\left[\\begin{array}{c}{x_{1}} \\\\ {x_{2}} \\\\ {\\vdots} \\\\ {x_{m}}\\end{array}\\right]\\left[\\begin{array}{llll}{y_{1}} & {y_{2}} & {\\cdots} & {y_{n}}\\end{array}\\right]=\\left[\\begin{array}{cccc}{x_{1} y_{1}} & {x_{1} y_{2}} & {\\cdots} & {x_{1} y_{n}} \\\\ {x_{2} y_{1}} & {x_{2} y_{2}} & {\\cdots} & {x_{2} y_{n}} \\\\ {\\vdots} & {\\vdots} & {\\ddots} & {\\vdots} \\\\ {x_{m} y_{1}} & {x_{m} y_{2}} & {\\cdots} & {x_{m} y_{n}}\\end{array}\\right]举一个外积如何使用的一个例子：让$1\\in R^{n}$表示一个$n$维向量，其元素都等于1，此外，考虑矩阵$A \\in R^{m \\times n}$，其列全部等于某个向量 $x \\in R^{m}$。 我们可以使用外积紧凑地表示矩阵 $A$: A=\\left[\\begin{array}{llll}{ |} & { |} & {} & { |} \\\\ {x} & {x} & {\\cdots} & {x} \\\\ { |} & { |} & {} & { |}\\end{array}\\right]=\\left[\\begin{array}{cccc}{x_{1}} & {x_{1}} & {\\cdots} & {x_{1}} \\\\ {x_{2}} & {x_{2}} & {\\cdots} & {x_{2}} \\\\ {\\vdots} & {\\vdots} & {\\ddots} & {\\vdots} \\\\ {x_{m}} & {x_{m}} & {\\cdots} & {x_{m}}\\end{array}\\right]=\\left[\\begin{array}{c}{x_{1}} \\\\ {x_{2}} \\\\ {\\vdots} \\\\ {x_{m}}\\end{array}\\right]\\left[\\begin{array}{lll}{1} & {1} & {\\cdots} & {1}\\end{array}\\right]=x \\mathbf{1}^{T}2.2 矩阵-向量乘法给定矩阵 $A \\in \\mathbb{R}^{m \\times n}$，向量 $x \\in \\mathbb{R}^{n}$ , 它们的积是一个向量 $y = Ax \\in R^{m}$。 有几种方法可以查看矩阵向量乘法，我们将依次查看它们中的每一种。 如果我们按行写$A$，那么我们可以表示$Ax$为： y=A x=\\left[\\begin{array}{ccc}{-} & {a_{1}^{T}} & {-} \\\\ {-} & {a_{2}^{T}} & {-} \\\\ {} & {\\vdots} & {} \\\\ {-} & {a_{m}^{T}} & {-}\\end{array}\\right] x=\\left[\\begin{array}{c}{a_{1}^{T} x} \\\\ {a_{2}^{T} x} \\\\ {\\vdots} \\\\ {a_{m}^{T} x}\\end{array}\\right]换句话说，第$i$个$y$是$A$的第$i$行和$x$的内积，即：$y_i = y_{i}=a_{i}^{T} x$。 同样的， 可以把 $A$ 写成列的方式，则公式如下： y=A x=\\left[\\begin{array}{cccc}{ |} & { |} & {} & { |} \\\\ {a^{1}} & {a^{2}} & {\\cdots} & {a^{n}} \\\\ { |} & { |} & {} & { |}\\end{array}\\right]\\left[\\begin{array}{c}{x_{1}} \\\\ {x_{2}} \\\\ {\\vdots} \\\\ {x_{n}}\\end{array}\\right]=\\left[\\begin{array}{c}{ } \\\\ {a^{1}{ } \\\\ }\\end{array}\\right] x_{1}+\\left[\\begin{array}{c}{ } \\\\ {a^{2}{ } \\\\ }\\end{array}\\right] x_{2}+{\\cdots} +\\left[\\begin{array}{c}{ } \\\\ {a^{n}{ } \\\\ }\\end{array}\\right] x_{n}换句话说，$y$是$A$的列的线性组合，其中线性组合的系数由$x$的元素给出。 到目前为止，我们一直在右侧乘以列向量，但也可以在左侧乘以行向量。 这是写的，$y^T = x^TA$ 表示$A \\in \\mathbb{R}^{m \\times n}$，$x \\in \\mathbb{R}^{m}$，$y \\in \\mathbb{R}^{n}$。 和以前一样，我们可以用两种可行的方式表达$y^T$，这取决于我们是否根据行或列表达$A$. 第一种情况，我们把$A$用列表示： y^{T}=x^{T} A=x^{T}\\left[\\begin{array}{cccc}{ |} & { |} & {} & { |} \\\\ {a^{1}} & {a^{2}} & {\\cdots} & {a^{n}} \\\\ { |} & { |} & {} & { |}\\end{array}\\right]=\\left[\\begin{array}{cccc}{x^{T} a^{1}} & {x^{T} a^{2}} & {\\dots} & {x^{T} a^{n}}\\end{array}\\right]这表明$y^T$的第$i$个元素等于$x$和$A$的第$i$列的内积。 最后，根据行表示$A$，我们得到了向量-矩阵乘积的最终表示: y^T=x^TA =\\left[\\begin{array}{llll}{x_{1}} & {x_{2}} & {\\cdots} & {x_{n}}\\end{array}\\right]\\left[\\begin{array}{c}{-a_{1}^{T}-} \\\\ {-a_{2}^{T}-} \\\\ {\\vdots} \\\\ {-a_{m}^{T}-}\\end{array}\\right] =x_{1}\\left[-a_{1}^{T}-\\right]+x_{2}\\left[-a_{2}^{T}-\\right]+\\ldots+x_{n}\\left[-a_{n}^{T}-\\right]所以我们看到$y^T$是$A$的行的线性组合，其中线性组合的系数由$x$的元素给出。 2.3 矩阵-矩阵乘法有了这些知识，我们现在可以看看四种不同的（形式不同，但结果是相同的）矩阵-矩阵乘法：也就是本节开头所定义的$C=AB$的乘法。 首先，我们可以将矩阵 - 矩阵乘法视为一组向量-向量乘积。 从定义中可以得出：最明显的观点是$C $的$( i，j )$元素等于$A$的第$i$行和$B$的的$j$列的内积。如下面的公式所示： C=A B=\\left[\\begin{array}{cc}{-} & {a_{1}^{T}} &{-} \\\\ {-} & {a_{2}^{T}} &{-} \\\\ {} & {\\vdots} \\\\ {-} & {a_{m}^{T}} &{-} \\end{array}\\right]\\left[\\begin{array}{cccc}{ |} & { |} & {} & { |} \\\\ {b_{1}} & {b_{2}} & {\\cdots} & {b_{p}} \\\\ { |} & { |} & {} & { |}\\end{array}\\right]=\\left[\\begin{array}{cccc}{a_{1}^{T} b_{1}} & {a_{1}^{T} b_{2}} & {\\cdots} & {a_{1}^{T} b_{p}} \\\\ {a_{2}^{T} b_{1}} & {a_{2}^{T} b_{2}} & {\\cdots} & {a_{2}^{T} b_{p}} \\\\ {\\vdots} & {\\vdots} & {\\ddots} & {\\vdots} \\\\ {a_{m}^{T} b_{1}} & {a_{m}^{T} b_{2}} & {\\cdots} & {a_{m}^{T} b_{p}}\\end{array}\\right]这里的$ A \\in \\mathbb{R}^{m\\times n}$ ，$B \\in \\mathbb{R}^{n \\times p}$， $a_i \\in \\mathbb{R}^n$ ，$b^j \\in \\mathbb{R}^{n \\times p}$， 这里的$ A \\in \\mathbb{R}^ {m \\times n}，$ $B \\in \\mathbb{R}^ {n \\times p} $， $a_i \\in \\mathbb{R} ^ n $，$ b ^ j \\in \\mathbb{R} ^ {n \\times p} $，所以它们可以计算内积。 我们用通常用行表示$ A $而用列表示$B$。或者，我们可以用列表示$ A$，用行表示$B $，这时$AB$是求外积的和。公式如下： C=A B=\\left[\\begin{array}{cccc}{ |} & { |} & {} & { |} \\\\ {a_{1}} & {a_{2}} & {\\cdots} & {a_{n}} \\\\ { |} & { |} & {} & { |}\\end{array}\\right]\\left[\\begin{array}{c}{-}& {b_{1}^{T}}&{-} \\\\ {-}& {b_{2}^{T}}&{-} \\\\ {\\vdots} \\\\{-}& {b_{n}^{T}}&{-}\\end{array}\\right]=\\sum_{i=1}^{n} a_{i} b_{i}^{T}换句话说，$AB$等于所有的$A$的第$i$列和$B$第$i$行的外积的和。因此，在这种情况下， $a_i \\in \\mathbb{R}^ m $和$b_i \\in \\mathbb{R}^p$， 外积$a^ib_i^T$的维度是$m×p$，与$C$的维度一致。 其次，我们还可以将矩阵 - 矩阵乘法视为一组矩阵向量积。如果我们把$B$用列表示，我们可以将$C$的列视为$A$和$B$的列的矩阵向量积。公式如下： C=A B=A\\left[\\begin{array}{cccc}{ |} & { |} & {} & { |} \\\\ {b_{1}} & {b_{2}} & {\\cdots} & {b_{p}} \\\\ { |} & { |} & {} & { |}\\end{array}\\right]=\\left[\\begin{array}{cccc}{ |} & { |} & {} & { |} \\\\ {A b_{1}} & {A b_{2}} & {\\cdots} & {A b_{p}} \\\\ { |} & { |} & {} & { |}\\end{array}\\right]这里$C$的第$i$列由矩阵向量乘积给出，右边的向量为$c_i = Ab_i$。 这些矩阵向量乘积可以使用前一小节中给出的两个观点来解释。最后，我们有类似的观点，我们用行表示$A$，$C$的行作为$A$和$C$行之间的矩阵向量积。公式如下： C=A B=\\left[\\begin{array}{ccc}{-} & {a_{1}^{T}} & {-} \\\\ {-} & {a_{2}^{T}} & {-} \\\\ {} & {\\vdots} & {} \\\\ {-} & {a_{m}^{T}} & {-}\\end{array}\\right] B=\\left[\\begin{array}{c} {-} & {a_{1}^{T} B} & {-}\\\\ {-} & {a_{2}^{T} B} & {-} \\\\ {\\vdots} \\\\ {-} & {a_{m}^{T} B}& {-}\\end{array}\\right]这里第$i$行的$C$由左边的向量的矩阵向量乘积给出：$c_i^T = a_i^T B$ 将矩阵乘法剖析到如此大的程度似乎有点过分，特别是当所有这些观点都紧跟在我们在本节开头给出的初始定义（在一行数学中）之后。 这些不同方法的直接优势在于它们允许您在向量的级别/单位而不是标量上进行操作。 为了完全理解线性代数而不会迷失在复杂的索引操作中，关键是要用尽可能多的概念进行操作。 实际上所有的线性代数都处理某种矩阵乘法，花一些时间对这里提出的观点进行直观的理解是非常必要的。 除此之外，了解一些更高级别的矩阵乘法的基本属性是很有必要的： 矩阵乘法结合律: $(AB)C = A(BC)$ 矩阵乘法分配律: $A(B + C) = AB + AC$ 矩阵乘法通常不是可交换的; 也就是说，通常$AB \\ne BA$。 （例如，假设$ A \\in \\mathbb{R}^ {m \\times n}，$ $B \\in \\mathbb{R}^ {n \\times p} $，如果$m$和$q$不相等，矩阵乘积$BA$甚至不存在！） 如果您不熟悉这些属性，请花点时间自己验证它们。 例如，为了检查矩阵乘法的相关性，假设$A \\in \\mathbb{R}^ {m \\times n}，$ $B \\in \\mathbb{R}^ {n \\times p} $，$C \\in \\mathbb{R}^ {p \\times q}$。 注意$AB \\in \\mathbb{R}^ {m \\times p}$，所以$(AB)C \\in \\mathbb{R}^ {m \\times q}$。 类似地，$BC \\in \\mathbb{R}^ {n \\times q}$，所以$A(BC) \\in \\mathbb{R}^ {m \\times q}$。 因此，所得矩阵的维度一致。 为了表明矩阵乘法是相关的，足以检查$(AB)C $的第$(i,j)$个元素是否等于$A(BC)$的第$(i,j)$个元素。 我们可以使用矩阵乘法的定义直接验证这一点： \\begin{aligned}((A B) C)_{i j} &=\\sum_{k=1}^{p}(A B)_{i k} C_{k j}=\\sum_{k=1}^{p}\\left(\\sum_{l=1}^{n} A_{i l} B_{l k}\\right) C_{k j} \\\\ &=\\sum_{k=1}^{p}\\left(\\sum_{l=1}^{n} A_{i l} B_{l k} C_{k j}\\right)=\\sum_{l=1}^{n}\\left(\\sum_{k=1}^{p} A_{i l} B_{l k} C_{k j}\\right) \\\\ &=\\sum_{l=1}^{n} A_{i l}\\left(\\sum_{k=1}^{p} B_{l k} C_{k j}\\right)=\\sum_{l=1}^{n} A_{i l}(B C)_{l j}=(A(B C))_{i j} \\end{aligned}3 运算和属性在本节中，我们介绍矩阵和向量的几种运算和属性。 希望能够为您复习大量此类内容，这些笔记可以作为这些主题的参考。 3.1 单位矩阵和对角矩阵单位矩阵,$I \\in \\mathbb{R}^{n \\times n} $，它是一个方阵，对角线的元素是1，其余元素都是0： I_{i j}=\\left\\{\\begin{array}{ll}{1} & {i=j} \\\\ {0} & {i \\neq j}\\end{array}\\right.对于所有$A \\in \\mathbb{R}^ {m \\times n}$，有： AI = A = IA注意，在某种意义上，单位矩阵的表示法是不明确的，因为它没有指定$I$的维数。通常，$I$的维数是从上下文推断出来的，以便使矩阵乘法成为可能。 例如，在上面的等式中，$AI = A$中的I是$n\\times n$矩阵，而$A = IA$中的$I$是$m\\times m$矩阵。 对角矩阵是一种这样的矩阵：对角线之外的元素全为0。对角阵通常表示为：$D= diag(d_1, d_2, . . . , d_n)$，其中： D_{i j}=\\left\\{\\begin{array}{ll}{d_{i}} & {i=j} \\\\ {0} & {i \\neq j}\\end{array}\\right.很明显：单位矩阵$ I = diag(1, 1, . . . , 1)$。 3.2 转置矩阵的转置是指翻转矩阵的行和列。 给定一个矩阵： $A \\in \\mathbb{R}^ {m \\times n}$, 它的转置为$n \\times m$的矩阵$A^T \\in \\mathbb{R}^ {n \\times m}$ ，其中的元素为： (A^T)_{ij} = A_{ji}事实上，我们在描述行向量时已经使用了转置，因为列向量的转置自然是行向量。 转置的以下属性很容易验证： $(A^T )^T = A$ $ (AB)^T = B^T A^T$ $(A + B)^T = A^T + B^T$ 3.3 对称矩阵如果$A = A^T$，则矩阵$A \\in \\mathbb{R}^ {n \\times n}$是对称矩阵。 如果$ A = - A^T$，它是反对称的。 很容易证明，对于任何矩阵$A \\in \\mathbb{R}^ {n \\times n}$，矩阵$A + A^ T$是对称的，矩阵$A -A^T$是反对称的。 由此得出，任何方矩阵$A \\in \\mathbb{R}^ {n \\times n}$可以表示为对称矩阵和反对称矩阵的和，所以： A=\\frac{1}{2}(A+A^T)+\\frac{1}{2}(A-A^T)上面公式的右边的第一个矩阵是对称矩阵，而第二个矩阵是反对称矩阵。 事实证明，对称矩阵在实践中用到很多，它们有很多很好的属性，我们很快就会看到它们。通常将大小为$n$的所有对称矩阵的集合表示为$\\mathbb{S}^n$，因此$A \\in \\mathbb{S}^n$意味着$A$是对称的$n\\times n$矩阵; 3.4 矩阵的迹方矩阵$A \\in \\mathbb{R}^ {n \\times n}$的迹，表示为$\\operatorname{tr} (A)$（或者只是$\\operatorname{tr} A$，如果括号显然是隐含的），是矩阵中对角元素的总和： \\operatorname{tr} A=\\sum_{i=1}^{n} A_{i i}如CS229讲义中所述，迹具有以下属性（如下所示）： 对于矩阵$A \\in \\mathbb{R}^ {n \\times n}$，则：$\\operatorname{tr}A =\\operatorname{tr}A^T$ 对于矩阵$A,B \\in \\mathbb{R}^ {n \\times n}$，则：$\\operatorname{tr}(A + B) = \\operatorname{tr}A + \\operatorname{tr}B$ 对于矩阵$A \\in \\mathbb{R}^ {n \\times n}$，$ t \\in \\mathbb{R}$，则：$\\operatorname{tr}(tA) = t\\operatorname{tr}A$. 对于矩阵 $A$, $B$，$AB$ 为方阵, 则：$\\operatorname{tr}AB = \\operatorname{tr}BA$ 对于矩阵 $A$, $B$, $C$, $ABC$为方阵, 则：$\\operatorname{tr}ABC = \\operatorname{tr}BCA=\\operatorname{tr}CAB$, 同理，更多矩阵的积也是有这个性质。 作为如何证明这些属性的示例，我们将考虑上面给出的第四个属性。 假设$A \\in \\mathbb{R}^ {m \\times n}$和$B \\in \\mathbb{R}^ {n \\times m}$（因此$AB \\in \\mathbb{R}^ {m \\times m}$是方阵）。 观察到$BA \\in \\mathbb{R}^ {n \\times n}$也是一个方阵，因此对它们进行迹的运算是有意义的。 要证明$\\operatorname{tr}AB = \\operatorname{tr}BA$，请注意： \\begin{aligned} \\operatorname{tr} A B &=\\sum_{i=1}^{m}(A B)_{i i}=\\sum_{i=1}^{m}\\left(\\sum_{j=1}^{n} A_{i j} B_{j i}\\right) \\\\ &=\\sum_{i=1}^{m} \\sum_{j=1}^{n} A_{i j} B_{j i}=\\sum_{j=1}^{n} \\sum_{i=1}^{m} B_{j i} A_{i j} \\\\ &=\\sum_{j=1}^{n}\\left(\\sum_{i=1}^{m} B_{j i} A_{i j}\\right)=\\sum_{j=1}^{n}(B A)_{j j}=\\operatorname{tr} B A \\end{aligned}这里，第一个和最后两个等式使用迹运算符和矩阵乘法的定义，重点在第四个等式，使用标量乘法的可交换性来反转每个乘积中的项的顺序，以及标量加法的可交换性和相关性，以便重新排列求和的顺序。 3.5 范数向量的范数$|x|$是非正式度量的向量的“长度” 。 例如，我们有常用的欧几里德或$\\ell_{2}$范数， \\|x\\|_{2}=\\sqrt{\\sum_{i=1}^{n} x_{i}^{2}}注意：$|x|_{2}^{2}=x^{T} x$ 更正式地，范数是满足4个属性的函数（$f : \\mathbb{R}^{n} \\rightarrow \\mathbb{R}$）： 对于所有的 $x \\in \\mathbb{R}^ {n}$, $f(x) \\geq 0 $(非负). 当且仅当$x = 0$ 时，$f(x) = 0$ (明确性). 对于所有$x \\in \\mathbb{R}^ {n}$,$t\\in \\mathbb{R}$，则 $f(tx) = \\left| t \\right|f(x)$ (正齐次性). 对于所有 $x,y \\in \\mathbb{R}^ {n}$, $f(x + y) \\leq f(x) + f(y)$ (三角不等式) 其他范数的例子是$\\ell_1$范数: \\|x\\|_{1}=\\sum_{i=1}^{n}\\left|x_{i}\\right|和$\\ell_{\\infty }$范数： \\|x\\|_{\\infty}=\\max _{i}\\left|x_{i}\\right|事实上，到目前为止所提出的所有三个范数都是$\\ell_p$范数族的例子，它们由实数$p \\geq 1$参数化，并定义为： \\|x\\|_{p}=\\left(\\sum_{i=1}^{n}\\left|x_{i}\\right|^{p}\\right)^{1 / p}也可以为矩阵定义范数，例如Frobenius范数: \\|A\\|_{F}=\\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n} A_{i j}^{2}}=\\sqrt{\\operatorname{tr}\\left(A^{T} A\\right)}许多其他更多的范数，但它们超出了这个复习材料的范围。 3.6 线性相关性和秩一组向量${x_1,x_2, \\cdots x_n} \\in \\mathbb{R}$， 如果没有向量可以表示为其余向量的线性组合，则称称该向量是线性无相关的。 相反，如果属于该组的一个向量可以表示为其余向量的线性组合，则称该向量是线性相关的。 也就是说，如果： x_{n}=\\sum_{i=1}^{n-1} \\alpha_{i} x_{i}对于某些标量值$\\alpha_1,\\cdots \\alpha_n-1 \\in \\mathbb{R}$，要么向量$x_1,x_2, \\cdots x_n$是线性相关的; 否则，向量是线性无关的。 例如，向量： x_{1}=\\left[\\begin{array}{l}{1} \\\\ {2} \\\\ {3}\\end{array}\\right] \\quad x_{2}=\\left[\\begin{array}{c}{4} \\\\ {1} \\\\ {5}\\end{array}\\right] \\quad x_{3}=\\left[\\begin{array}{c}{2} \\\\ {-3} \\\\ {-1}\\end{array}\\right]是线性相关的，因为：$x_3=-2x_1+x_2$。 矩阵$A \\in \\mathbb{R}^{m \\times n}$的列秩是构成线性无关集合的$A$的最大列子集的大小。 由于术语的多样性，这通常简称为$A$的线性无关列的数量。同样，行秩是构成线性无关集合的$A$的最大行数。 对于任何矩阵$A \\in \\mathbb{R}^{m \\times n}$，事实证明$A$的列秩等于$A$的行秩（尽管我们不会证明这一点），因此两个量统称为$A$的秩，用 $\\text{rank}(A)$表示。 以下是秩的一些基本属性： 对于 $A \\in \\mathbb{R}^{m \\times n}$，$\\text{rank}(A) \\leq min(m, n)$，如果$ \\text(A) = \\text{min} (m, n)$，则： $A$ 被称作满秩。 对于 $A \\in \\mathbb{R}^{m \\times n}$， $\\text{rank}(A) = \\text{rank}(A^T)$ 对于 $A \\in \\mathbb{R}^{m \\times n}$,$B \\in \\mathbb{R}^{n \\times p}$ ,$\\text{rank}(AB) \\leq \\text{min} ( \\text{rank}(A), \\text{rank}(B))$ 对于 $A,B \\in \\mathbb{R}^{m \\times n}$，$\\text{rank}(A + B) \\leq \\text{rank}(A) + \\text{rank}(B)$ 3.7 方阵的逆方阵$A \\in \\mathbb{R}^{n \\times n}$的倒数表示为$A^{-1}$，并且是这样的独特矩阵: A^{-1}A=I=AA^{-1}请注意，并非所有矩阵都具有逆。 例如，非方形矩阵根据定义没有逆。 然而，对于一些方形矩阵$A$，可能仍然存在$A^{-1}$可能不存在的情况。 特别是，如果$A^{-1}$存在，我们说$A$是可逆的或非奇异的，否则就是不可逆或奇异的。为了使方阵A具有逆$A^{-1}$，则$A$必须是满秩。 我们很快就会发现，除了满秩之外，还有许多其它的充分必要条件。以下是逆的属性; 假设$A,B \\in \\mathbb{R}^{n \\times n}$，而且是非奇异的： $(A^{-1})^{-1} = A$ $(AB)^{-1} = B^{-1}A^{-1}$ $(A^{-1})^{T} =(A^{T})^{-1} $因此，该矩阵通常表示为$A^{-T}$。作为如何使用逆的示例，考虑线性方程组，$Ax = b$，其中$A \\in \\mathbb{R}^{n \\times n}$，$x,b\\in \\mathbb{R}$， 如果$A$是非奇异的（即可逆的），那么$x = A^{-1}b$。 （如果$A \\in \\mathbb{R}^{m \\times n}$不是方阵，这公式还有用吗？） 3.8 正交阵如果 $x^Ty=0$，则两个向量$x,y\\in \\mathbb{R}^{n}$ 是正交的。如果$|x|_2=1$，则向量$x\\in \\mathbb{R}^{n}$ 被归一化。如果一个方阵$U\\in \\mathbb{R}^{n \\times n}$的所有列彼此正交并被归一化（这些列然后被称为正交），则方阵$U$是正交阵（注意在讨论向量时的意义不一样）。 它可以从正交性和正态性的定义中得出: U^ TU = I = U U^T换句话说，正交矩阵的逆是其转置。 注意，如果$U$不是方阵 :即，$U\\in \\mathbb{R}^{m \\times n}$，$n &lt;m$ ，但其列仍然是正交的，则$U^TU = I$，但是$UU^T \\neq I$。我们通常只使用术语”正交”来描述先前的情况 ，其中$U$是方阵。正交矩阵的另一个好的特性是在具有正交矩阵的向量上操作不会改变其欧几里德范数，即: \\|U x\\|_{2}=\\|x\\|_{2}对于任何 $x\\in \\mathbb{R}$ , $U\\in \\mathbb{R}^{n}$是正交的。 3.9 矩阵的值域和零空间一组向量$\\{x_{1}, \\ldots x_{n}\\}$是可以表示为$\\{x_{1}, \\ldots x_{n}\\}$的线性组合的所有向量的集合。 即： \\operatorname{span}\\left(\\left\\{x_{1}, \\ldots x_{n}\\right\\}\\right)=\\left\\{v : v=\\sum_{i=1}^{n} \\alpha_{i} x_{i}, \\quad \\alpha_{i} \\in \\mathbb{R}\\right\\}可以证明，如果$\\{x_{1}, \\ldots x_{n}\\}$是一组$n$个线性无关的向量，其中每个$x_i \\in \\mathbb{R}^{n}$，则$\\text{span}(\\{x_{1}, \\ldots x_{n}\\})=\\mathbb{R}^{n}$。 换句话说，任何向量$v\\in \\mathbb{R}^{n}$都可以写成$x_1$到$x_n$的线性组合。 向量$y\\in \\mathbb{R}^{m}$投影到$\\{x_{1}, \\ldots x_{n}\\}$（这里我们假设$x_i \\in \\mathbb{R}^{m}$）得到向量$v \\in \\operatorname{span}(\\{x_{1}, \\ldots, x_{n}\\})$，由欧几里德范数$|v - y|_2$可以得知，这样$v$尽可能接近$y$。 我们将投影表示为$\\operatorname{Proj}\\left(y ;\\left\\{x_{1}, \\ldots x_{n}\\right\\}\\right)$，并且可以将其正式定义为: \\operatorname{Proj}\\left(y ;\\left\\{x_{1}, \\ldots x_{n}\\right\\}\\right)=\\operatorname{argmin}_{v \\in \\operatorname{span}\\left(\\left\\{x_{1}, \\ldots, x_{n}\\right\\}\\right)}\\|y-v\\|_{2}矩阵$A\\in \\mathbb{R}^{m \\times n}$的值域（有时也称为列空间），表示为$\\mathcal{R}(A)$，是$A$列的跨度。换句话说， \\mathcal{R}(A)=\\left\\{v \\in \\mathbb{R}^{m} : v=A x, x \\in \\mathbb{R}^{n}\\right\\}做一些技术性的假设（即$A$是满秩且$n &lt;m$），向量$y \\in \\mathbb{R}^{m}$到$A$的范围的投影由下式给出: \\operatorname{Proj}(y ; A)=\\operatorname{argmin}_{v \\in \\mathcal{R}(A)}\\|v-y\\|_{2}=A\\left(A^{T} A\\right)^{-1} A^{T} y这个最后的方程应该看起来非常熟悉，因为它几乎与我们在课程中（我们将很快再次得出）得到的公式：用于参数的最小二乘估计一样。 看一下投影的定义，显而易见，这实际上是我们在最小二乘问题中最小化的目标（除了范数的平方这里有点不一样，这不会影响找到最优解），所以这些问题自然是非常相关的。 当$A$只包含一列时，$a \\in \\mathbb{R}^{m}$，这给出了向量投影到一条线上的特殊情况： \\operatorname{Proj}(y ; a)=\\frac{a a^{T}}{a^{T} a} y一个矩阵$A\\in \\mathbb{R}^{m \\times n}$的零空间 $\\mathcal{N}(A)$ 是所有乘以$A$时等于0向量的集合，即： \\mathcal{N}(A)=\\left\\{x \\in \\mathbb{R}^{n} : A x=0\\right\\}注意，$\\mathcal{R}(A)$中的向量的大小为$m$，而 $\\mathcal{N}(A)$ 中的向量的大小为$n$，因此$\\mathcal{R}(A^T)$和 $\\mathcal{N}(A)$ 中的向量的大小均为$\\mathbb{R}^{n}$。 事实上，还有很多例子。 证明： \\left\\{w : w=u+v, u \\in \\mathcal{R}\\left(A^{T}\\right), v \\in \\mathcal{N}(A)\\right\\}=\\mathbb{R}^{n} \\text { and } \\mathcal{R}\\left(A^{T}\\right) \\cap \\mathcal{N}(A)=\\{\\mathbf{0}\\}换句话说，$\\mathcal{R}(A^T)$和 $\\mathcal{N}(A)$ 是不相交的子集，它们一起跨越$\\mathbb{R}^{n}$的整个空间。 这种类型的集合称为正交补，我们用$\\mathcal{R}(A^T)= \\mathcal{N}(A)^{\\perp}$表示。 3.10 行列式一个方阵$A \\in \\mathbb{R}^{n \\times n}$的行列式是函数$\\text {det}$：$\\mathbb{R}^{n \\times n} \\rightarrow \\mathbb{R}^{n} $，并且表示为$\\left| A \\right|$。 或者$\\text{det} A$（有点像迹运算符，我们通常省略括号）。 从代数的角度来说，我们可以写出一个关于$A$行列式的显式公式。 因此，我们首先提供行列式的几何解释，然后探讨它的一些特定的代数性质。 给定一个矩阵： \\left[\\begin{array}{cccc}{-} & {a_{1}^{T}} & {-} \\\\ {-} & {a_{2}^{T}} & {-} \\\\ {} & {\\vdots} & {} \\\\ {-} & {a_{n}^{T}} & {-}\\end{array}\\right]考虑通过采用$A$行向量$a_{1}, \\ldots a_{n}\\in \\mathbb{R}^{n}$的所有可能线性组合形成的点$S \\subset \\mathbb{R}^{n}$的集合，其中线性组合的系数都在0和1之间; 也就是说，集合$S$是$\\text{span}(\\{a_{1}, \\ldots a_{n}\\})$受到系数$a_{1}, \\ldots a_{n}$的限制的线性组合，$\\alpha_1, \\cdots ,\\alpha_n$满足$0 \\leq \\alpha_{i} \\leq 1, i=1, \\ldots, n$。从形式上看， S=\\left\\{v \\in \\mathbb{R}^{n} : v=\\sum_{i=1}^{n} \\alpha_{i} a_{i} \\text { where } 0 \\leq \\alpha_{i} \\leq 1, i=1, \\ldots, n\\right\\}事实证明，$A$的行列式的绝对值是对集合$S$的“体积”的度量。 比方说：一个$2 \\times2$的矩阵(4)： A=\\left[\\begin{array}{ll}{1} & {3} \\\\ {3} & {2}\\end{array}\\right]它的矩阵的行是： a_{1}=\\left[\\begin{array}{l}{1} \\\\ {3}\\end{array}\\right] \\quad a_{2}=\\left[\\begin{array}{l}{3} \\\\ {2}\\end{array}\\right]对应于这些行对应的集合$S$如图1所示。对于二维矩阵，$S$通常具有平行四边形的形状。 在我们的例子中，行列式的值是$\\left| A \\right| = -7$（可以使用本节后面显示的公式计算），因此平行四边形的面积为7。（请自己验证！） 在三维中，集合$S$对应于一个称为平行六面体的对象（一个有倾斜边的三维框，这样每个面都有一个平行四边形）。行定义$S$的$3×3$矩阵S的行列式的绝对值给出了平行六面体的三维体积。在更高的维度中，集合$S$是一个称为$n$维平行切的对象。 图1：（4）中给出的$2×2$矩阵$A$的行列式的图示。 这里，$a_1$和$a_2$是对应于$A$行的向量，并且集合$S$对应于阴影区域（即，平行四边形）。 这个行列式的绝对值，$\\left| \\text{det} A \\right| = 7$，即平行四边形的面积。 在代数上，行列式满足以下三个属性（所有其他属性都遵循这些属性，包括通用公式）： 恒等式的行列式为1, $\\left| I \\right|= 1$（几何上，单位超立方体的体积为1）。 给定一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$, 如果我们将$A$中的一行乘上一个标量$t \\in \\mathbb{R}$，那么新矩阵的行列式是$t\\left| A \\right|$ \\left|\\left[\\begin{array}{ccc}{-} & {t a_{1}^{T}} & {-} \\\\ {-} & {a_{2}^{T}} & {-} \\\\ {} & {\\vdots} & {} \\\\ {} & {a_{m}^{T}} & {-}\\end{array}\\right]\\right|=t|A|几何上，将集合$S$的一个边乘以系数$t$，体积也会增加一个系数$t$。 如果我们交换任意两行在$a_i^T$和$a_j^T$，那么新矩阵的行列式是$-\\left| A \\right|$，例如： \\left|\\left[\\begin{array}{ccc}{-} & {a_{2}^{T}} & {-} \\\\ {-} & {a_{1}^{T}} & {-} \\\\ {} & {\\vdots} & {} \\\\ {-} & {a_{m}^{T}} & {-}\\end{array}\\right]\\right|=-|A|你一定很奇怪，满足上述三个属性的函数的存在并不多。事实上，这样的函数确实存在，而且是唯一的（我们在这里不再证明了）。 从上述三个属性中得出的几个属性包括： 对于 $A \\in \\mathbb{R}^{n \\times n}$, $\\left| A \\right| = \\left| A^T \\right|$ 对于 $A,B \\in \\mathbb{R}^{n \\times n}$, $\\left| AB \\right|= \\left| A \\right|\\left| B \\right|$ 对于 $A \\in \\mathbb{R}^{n \\times n}$, 有且只有当$A$是奇异的（比如不可逆） ，则：$\\left| A \\right|= 0$ 对于 $A \\in \\mathbb{R}^{n \\times n}$ 同时，$A$为非奇异的，则：$\\left| A ^{−1}\\right| = 1/\\left| A \\right|$ 在给出行列式的一般定义之前，我们定义，对于$A \\in \\mathbb{R}^{n \\times n}$，$A_{\\backslash i, \\backslash j}\\in \\mathbb{R}^{(n-1) \\times (n-1)}$是由于删除第$i$行和第$j$列而产生的矩阵。 行列式的一般（递归）公式是： \\begin{aligned}|A| &=\\sum_{i=1}^{n}(-1)^{i+j} a_{i j}\\left|A_{\\backslash i, \\backslash j}\\right| \\quad(\\text { for any } j \\in 1, \\ldots, n) \\\\ &=\\sum_{j=1}^{n}(-1)^{i+j} a_{i j}\\left|A_{\\backslash i, \\backslash j}\\right| \\quad(\\text { for any } i \\in 1, \\ldots, n) \\end{aligned}对于 $A \\in \\mathbb{R}^{1 \\times 1}$，初始情况为$\\left| A \\right|= a_{11}$。如果我们把这个公式完全展开为 $A \\in \\mathbb{R}^{n \\times n}$，就等于$n!$（$n$阶乘）不同的项。因此，对于大于$3×3$的矩阵，我们几乎没有明确地写出完整的行列式方程。然而，$3×3$大小的矩阵的行列式方程是相当常见的，建议好好地了解它们： \\left|\\left[a_{11}\\right]\\right|=a_{11} \\left|\\left[\\begin{array}{ll}{a_{11}} & {a_{12}} \\\\ {a_{21}} & {a_{22}}\\end{array}\\right]\\right|=a_{11} a_{22}-a_{12} a_{21} \\left|\\left[\\begin{array}{l}{a_{11}} & {a_{12}} & {a_{13}} \\\\ {a_{21}} & {a_{22}} & {a_{23}} \\\\ {a_{31}} & {a_{32}} & {a_{33}}\\end{array}\\right]\\right|=\\quad \\begin{array}{c}{a_{11} a_{22} a_{33}+a_{12} a_{23} a_{31}+a_{13} a_{21} a_{32}} \\\\\\quad \\quad {-a_{11} a_{23} a_{32}-a_{12} a_{21} a_{33}-a_{13} a_{22} a_{31}} \\\\ {}\\end{array}矩阵$A \\in \\mathbb{R}^{n \\times n}$的经典伴随矩阵（通常称为伴随矩阵）表示为$\\operatorname{adj}(A)$，并定义为： \\operatorname{adj}(A) \\in \\mathbb{R}^{n \\times n}, \\quad(\\operatorname{adj}(A))_{i j}=(-1)^{i+j}\\left|A_{\\backslash j, \\backslash i}\\right|（注意索引$A_{\\backslash j, \\backslash i}$中的变化）。可以看出，对于任何非奇异$A \\in \\mathbb{R}^{n \\times n}$， A^{-1}=\\frac{1}{|A|} \\operatorname{adj}(A)虽然这是一个很好的“显式”的逆矩阵公式，但我们应该注意，从数字上讲，有很多更有效的方法来计算逆矩阵。 3.11 二次型和半正定矩阵给定方矩阵$A \\in \\mathbb{R}^{n \\times n}$和向量$x \\in \\mathbb{R}^{n}$，标量值$x^T Ax$被称为二次型。 写得清楚些，我们可以看到： x^{T} A x=\\sum_{i=1}^{n} x_{i}(A x)_{i}=\\sum_{i=1}^{n} x_{i}\\left(\\sum_{j=1}^{n} A_{i j} x_{j}\\right)=\\sum_{i=1}^{n} \\sum_{j=1}^{n} A_{i j} x_{i} x_{j}注意： x^{T} A x=\\left(x^{T} A x\\right)^{T}=x^{T} A^{T} x=x^{T}\\left(\\frac{1}{2} A+\\frac{1}{2} A^{T}\\right) x第一个等号的是因为是标量的转置与自身相等，而第二个等号是因为是我们平均两个本身相等的量。 由此，我们可以得出结论，只有$A$的对称部分有助于形成二次型。 出于这个原因，我们经常隐含地假设以二次型出现的矩阵是对称阵。我们给出以下定义： 对于所有非零向量$x \\in \\mathbb{R}^n$，$x^TAx&gt;0$，对称阵$A \\in \\mathbb{S}^n$为正定（positive definite,PD）。这通常表示为$A\\succ0$（或$A&gt;0$），并且通常将所有正定矩阵的集合表示为$\\mathbb{S}_{++}^n$。 对于所有向量$x^TAx\\geq 0$，对称矩阵$A \\in \\mathbb{S}^n$是半正定(positive semidefinite ,PSD)。 这写为（或$A \\succeq 0$仅$A≥0$），并且所有半正定矩阵的集合通常表示为$\\mathbb{S}_+^n$。 同样，对称矩阵$A \\in \\mathbb{S}^n$是负定（negative definite,ND），如果对于所有非零$x \\in \\mathbb{R}^n$，则$x^TAx &lt;0$表示为$A\\prec0$（或$A &lt;0$）。 类似地，对称矩阵$A \\in \\mathbb{S}^n$是半负定(negative semidefinite,NSD），如果对于所有$x \\in \\mathbb{R}^n$，则$x^TAx \\leq 0$表示为$A\\preceq 0$（或$A≤0$）。 最后，对称矩阵$A \\in \\mathbb{S}^n$是不定的，如果它既不是正半定也不是负半定，即，如果存在$x_1,x_2 \\in \\mathbb{R}^n$，那么$x_1^TAx_1&gt;0$且$x_2^TAx_2&lt;0$。 很明显，如果$A$是正定的，那么$−A$是负定的，反之亦然。同样，如果$A$是半正定的，那么$−A$是是半负定的，反之亦然。如果果$A$是不定的，那么$−A$是也是不定的。 正定矩阵和负定矩阵的一个重要性质是它们总是满秩，因此是可逆的。为了了解这是为什么，假设某个矩阵$A \\in \\mathbb{S}^n$不是满秩。然后，假设$A$的第$j$列可以表示为其他$n-1$列的线性组合： a_{j}=\\sum_{i \\neq j} x_{i} a_{i}对于某些$x_1,\\cdots x_{j-1},x_{j + 1} ,\\cdots ,x_n\\in \\mathbb{R}$。设$x_j = -1$，则： Ax=\\sum_{i \\neq j} x_{i} a_{i}=0但这意味着对于某些非零向量$x$，$x^T Ax = 0$，因此$A$必须既不是正定也不是负定。如果$A$是正定或负定，则必须是满秩。最后，有一种类型的正定矩阵经常出现，因此值得特别提及。 给定矩阵$A \\in \\mathbb{R}^{m \\times n}$（不一定是对称或偶数平方），矩阵$G = A^T A$（有时称为Gram矩阵）总是半正定的。 此外，如果$m\\geq n$（同时为了方便起见，我们假设$A$是满秩），则$G = A^T A$是正定的。 3.12 特征值和特征向量给定一个方阵$A \\in\\mathbb{R}^{n\\times n}$，我们认为在以下条件下，$\\lambda \\in\\mathbb{C}$是$A$的特征值，$x\\in\\mathbb{C}^n$是相应的特征向量： Ax=\\lambda x,x \\ne 0直观地说，这个定义意味着将$A$乘以向量$x$会得到一个新的向量，该向量指向与$x$相同的方向，但按系数$\\lambda$缩放。值得注意的是，对于任何特征向量$x\\in\\mathbb{C}^n$和标量$t\\in\\mathbb{C}$，$A(cx)=cAx=c\\lambda x=\\lambda(cx)$，$cx$也是一个特征向量。因此，当我们讨论与$\\lambda$相关的特征向量时，我们通常假设特征向量被标准化为长度为1（这仍然会造成一些歧义，因为$x$和$−x$都是特征向量，但我们必须接受这一点）。 我们可以重写上面的等式来说明$(\\lambda,x)$是$A$的特征值和特征向量的组合： (\\lambda I-A)x=0,x \\ne 0但是$(\\lambda I-A)x=0$只有当$(\\lambda I-A)$有一个非空零空间时，同时$(\\lambda I-A)$是奇异的，$x$才具有非零解，即： |(\\lambda I-A)|=0现在，我们可以使用行列式的先前定义将表达式$|(\\lambda I-A)|$扩展为$\\lambda$中的（非常大的）多项式，其中，$\\lambda$的度为$n$。它通常被称为矩阵$A$的特征多项式。 然后我们找到这个特征多项式的$n$（可能是复数）根，并用$\\lambda_1,\\cdots,\\lambda_n$表示。这些都是矩阵$A$的特征值，但我们注意到它们可能不明显。为了找到特征值$\\lambda_i$对应的特征向量，我们只需解线性方程$(\\lambda I-A)x=0$，因为$(\\lambda I-A)$是奇异的，所以保证有一个非零解（但也可能有多个或无穷多个解）。 应该注意的是，这不是实际用于数值计算特征值和特征向量的方法（记住行列式的完全展开式有$n!$项），这是一个数学上的争议。 以下是特征值和特征向量的属性（所有假设在$A \\in\\mathbb{R}^{n\\times n}$具有特征值$\\lambda_1,\\cdots,\\lambda_n$的前提下）： $A$的迹等于其特征值之和 \\operatorname{tr} A=\\sum_{i=1}^{n} \\lambda_{i} $A$的行列式等于其特征值的乘积 |A|=\\prod_{i=1}^{n} \\lambda_{i} $A$的秩等于$A$的非零特征值的个数 假设$A$非奇异，其特征值为$\\lambda$和特征向量为$x$。那么$1/\\lambda$是具有相关特征向量$x$的$A^{-1}$的特征值，即$A^{-1}x=(1/\\lambda)x$。（要证明这一点，取特征向量方程，$Ax=\\lambda x$，两边都左乘$A^{-1}$） 对角阵的特征值$d=diag(d_1，\\cdots,d_n)$实际上就是对角元素$d_1，\\cdots,d_n$ 3.13 对称矩阵的特征值和特征向量通常情况下，一般的方阵的特征值和特征向量的结构可以很细微地表示出来。值得庆幸的是，在机器学习的大多数场景下，处理对称实矩阵就足够了，其处理的对称实矩阵的特征值和特征向量具有显着的特性。 在本节中，我们假设$A$是实对称矩阵, 具有以下属性： $A$的所有特征值都是实数。 我们用用$\\lambda_1,\\cdots,\\lambda_n$表示。 存在一组特征向量$u_1，\\cdots u_n$，对于所有$i$，$u_i$是具有特征值$\\lambda_{i}$和$b$的特征向量。$u_1，\\cdots u_n$是单位向量并且彼此正交。 设$U$是包含$u_i$作为列的正交矩阵： U=\\left[\\begin{array}{cccc}{ |} & { |} & {} & { |} \\\\ {u_{1}} & {u_{2}} & {\\cdots} & {u_{n}} \\\\ { |} & { |} & {} & { |}\\end{array}\\right]设$\\Lambda= diag(\\lambda_1,\\cdots,\\lambda_n)$是包含$\\lambda_1,\\cdots,\\lambda_n$作为对角线上的元素的对角矩阵。 使用2.3节的方程（2）中的矩阵 - 矩阵向量乘法的方法，我们可以验证： A U=\\left[\\begin{array}{cccc}{ |} & { |} & {} & { |} \\\\ {A u_{1}} & {A u_{2}} & {\\cdots} & {A u_{n}} \\\\ { |} & { |} & {} & { |}\\end{array}\\right]=\\left[\\begin{array}{ccc}{ |} & { |} & { |} & { |}\\\\ {\\lambda_{1} u_{1}} & {\\lambda_{2} u_{2}} & {\\cdots} & {\\lambda_{n} u_{n}} \\\\ { |} & { |} & {|} & { |}\\end{array}\\right]=U \\operatorname{diag}\\left(\\lambda_{1}, \\ldots, \\lambda_{n}\\right)=U \\Lambda考虑到正交矩阵$U$满足$UU^T=I$，利用上面的方程，我们得到： A=AUU^T=U\\Lambda U^T这种$A$的新的表示形式为$U\\Lambda U^T$，通常称为矩阵$A$的对角化。术语对角化是这样来的：通过这种表示，我们通常可以有效地将对称矩阵$A$视为对角矩阵 , 这更容易理解。关于由特征向量$U$定义的基础， 我们将通过几个例子详细说明。 背景知识：代表另一个基的向量。 任何正交矩阵$U=\\left[\\begin{array}{cccc}{ |} &amp; { |} &amp; {} &amp; { |} \\ {u_{1}} &amp; {u_{2}} &amp; {\\cdots} &amp; {u_{n}} \\ { |} &amp; { |} &amp; {} &amp; { |}\\end{array}\\right]$定义了一个新的属于$\\mathbb {R}^{n}$的基（坐标系），意义如下：对于任何向量$x \\in\\mathbb{R}^{n}$都可以表示为$u_1，\\cdots u_n$的线性组合，其系数为$x_1,\\cdots x_n$： x=\\hat x_1u_1+\\cdots +\\cdots \\hat x_nu_n=U\\hat x在第二个等式中，我们使用矩阵和向量相乘的方法。 实际上，这种$\\hat x$是唯一存在的: x=U \\hat{x} \\Leftrightarrow U^{T} x=\\hat{x}换句话说，向量$\\hat x=U^Tx$可以作为向量$x$的另一种表示，与$U$定义的基有关。 “对角化”矩阵向量乘法。 通过上面的设置，我们将看到左乘矩阵$A$可以被视为左乘以对角矩阵关于特征向量的基。 假设$x$是一个向量，$\\hat x$表示$U$的基。设$z=Ax$为矩阵向量积。现在让我们计算关于$U$的基$z$：然后，再利用$UU^T=U^T=I$和方程$A=AUU^T=U\\Lambda U^T$，我们得到： \\hat{z}=U^{T} z=U^{T} A x=U^{T} U \\Lambda U^{T} x=\\Lambda \\hat{x}=\\left[\\begin{array}{c}{\\lambda_{1} \\hat{x}_{1}} \\\\ {\\lambda_{2} \\hat{x}_{2}} \\\\ {\\vdots} \\\\ {\\lambda_{n} \\hat{x}_{n}}\\end{array}\\right]我们可以看到，原始空间中的左乘矩阵$A$等于左乘对角矩阵$\\Lambda$相对于新的基，即仅将每个坐标缩放相应的特征值。在新的基上，矩阵多次相乘也变得简单多了。例如，假设$q=AAAx$。根据$A$的元素导出$q$的分析形式，使用原始的基可能是一场噩梦，但使用新的基就容易多了： \\hat{q}=U^{T} q=U^{T} AAA x=U^{T} U \\Lambda U^{T} U \\Lambda U^{T} U \\Lambda U^{T} x=\\Lambda^{3} \\hat{x}=\\left[\\begin{array}{c}{\\lambda_{1}^{3} \\hat{x}_{1}} \\\\ {\\lambda_{2}^{3} \\hat{x}_{2}} \\\\ {\\vdots} \\\\ {\\lambda_{n}^{3} \\hat{x}_{n}}\\end{array}\\right]“对角化”二次型。作为直接的推论，二次型$x^TAx$也可以在新的基上简化。 x^{T} A x=x^{T} U \\Lambda U^{T} x=\\hat{x} \\Lambda \\hat{x}=\\sum_{i=1}^{n} \\lambda_{i} \\hat{x}_{i}^{2}(回想一下，在旧的表示法中，$x^{T} A x=\\sum_{i=1, j=1}^{n} x_{i} x_{j} A_{i j}$涉及一个$n^2$项的和，而不是上面等式中的$n$项。)利用这个观点，我们还可以证明矩阵$A$的正定性完全取决于其特征值的符号： 如果所有的$\\lambda_i&gt;0$，则矩阵$A$正定的，因为对于任意的$\\hat x \\ne 0$,$x^{T} A x=\\sum_{i=1}^{n} \\lambda_{i} \\hat{x}_{i}^{2}&gt;0$ 如果所有的$\\lambda_i\\geq 0$，则矩阵$A$是为正半定，因为对于任意的$\\hat x $,$x^{T} A x=\\sum_{i=1}^{n} \\lambda_{i} \\hat{x}_{i}^{2} \\geq 0$ 同样，如果所有$\\lambda_i&lt;0$或$\\lambda_i\\leq 0$，则矩阵$A$分别为负定或半负定。 最后，如果$A$同时具有正特征值和负特征值，比如λ$\\lambda_i&gt;0$和$\\lambda_j0$ ,我们让$\\hat x$满足$\\hat x_i=1$和$\\hat x_k=0$，同时所有的$k\\ne i$，那么$x^{T} A x=\\sum_{i=1}^{n} \\lambda_{i} \\hat{x}_{i}^{2}&lt;0$ 特征值和特征向量经常出现的应用是最大化矩阵的某些函数。特别是对于矩阵$A \\in \\mathbb{S}^{n}$，考虑以下最大化问题： \\max _{x \\in \\mathbb{R}^{n}} \\ x^{T} A x=\\sum_{i=1}^{n} \\lambda_{i} \\hat{x}_{i}^{2} \\quad \\text { subject to }\\|x\\|_{2}^{2}=1也就是说，我们要找到（范数1）的向量，它使二次型最大化。假设特征值的阶数为$\\lambda_1 \\geq \\lambda _2 \\geq \\cdots \\lambda_n$，此优化问题的最优值为$\\lambda_1$，且与$\\lambda_1$对应的任何特征向量$u_1$都是最大值之一。（如果$\\lambda_1 &gt; \\lambda_2$，那么有一个与特征值$\\lambda_1$对应的唯一特征向量，它是上面那个优化问题的唯一最大值。）我们可以通过使用对角化技术来证明这一点：注意，通过公式$|U x|_{2}=|x|_{2}$推出$|x|_{2}=|\\hat{x}|_{2}$，并利用公式： $x^{T} A x=x^{T} U \\Lambda U^{T} x=\\hat{x} \\Lambda \\hat{x}=\\sum_{i=1}^{n} \\lambda_{i} \\hat{x}_{i}^{2}$，我们可以将上面那个优化问题改写为： \\max _{\\hat{x} \\in \\mathbb{R}^{n}}\\ \\hat{x}^{T} \\Lambda \\hat{x}=\\sum_{i=1}^{n} \\lambda_{i} \\hat{x}_{i}^{2} \\quad \\text { subject to }\\|\\hat{x}\\|_{2}^{2}=1然后，我们得到目标的上界为$\\lambda_1$： \\hat{x}^{T} \\Lambda \\hat{x}=\\sum_{i=1}^{n} \\lambda_{i} \\hat{x}_{i}^{2} \\leq \\sum_{i=1}^{n} \\lambda_{1} \\hat{x}_{i}^{2}=\\lambda_{1}此外，设置$\\hat{x}=\\left[\\begin{array}{c}{1} \\ {0} \\ {\\vdots} \\ {0}\\end{array}\\right]$可让上述等式成立，这与设置$x=u_1$相对应。 4.矩阵微积分虽然前面章节中的主题通常包含在线性代数的标准课程中，但似乎很少涉及（我们将广泛使用）的一个主题是微积分扩展到向量设置展。尽管我们使用的所有实际微积分都是相对微不足道的，但是符号通常会使事情看起来比实际困难得多。 在本节中，我们将介绍矩阵微积分的一些基本定义，并提供一些示例。 4.1 梯度假设$f: \\mathbb{R}^{m \\times n} \\rightarrow \\mathbb{R}$是将维度为$m \\times n$的矩阵$A\\in \\mathbb{R}^{m \\times n}$作为输入并返回实数值的函数。 然后$f$的梯度（相对于$A\\in \\mathbb{R}^{m \\times n}$）是偏导数矩阵，定义如下： \\nabla_{A} f(A) \\in \\mathbb{R}^{m \\times n}=\\left[\\begin{array}{cccc}{\\frac{\\partial f(A)}{\\partial A_{11}}} & {\\frac{\\partial f(A)}{\\partial A_{12}}} & {\\cdots} & {\\frac{\\partial f(A)}{\\partial A_{1n}}} \\\\ {\\frac{\\partial f(A)}{\\partial A_{21}}} & {\\frac{\\partial f(A)}{\\partial A_{22}}} & {\\cdots} & {\\frac{\\partial f(A)}{\\partial A_{2 n}}} \\\\ {\\vdots} & {\\vdots} & {\\ddots} & {\\vdots} \\\\ {\\frac{\\partial f(A)}{\\partial A_{m 1}}} & {\\frac{\\partial f(A)}{\\partial A_{m 2}}} & {\\cdots} & {\\frac{\\partial f(A)}{\\partial A_{m n}}}\\end{array}\\right]即，$m \\times n$矩阵: \\left(\\nabla_{A} f(A)\\right)_{i j}=\\frac{\\partial f(A)}{\\partial A_{i j}}请注意，$\\nabla_{A} f(A) $的维度始终与$A$的维度相同。特殊情况，如果$A$只是向量$A\\in \\mathbb{R}^{n}$，则 \\nabla_{x} f(x)=\\left[\\begin{array}{c}{\\frac{\\partial f(x)}{\\partial x_{1}}} \\\\ {\\frac{\\partial f(x)}{\\partial x_{2}}} \\\\ {\\vdots} \\\\ {\\frac{\\partial f(x)}{\\partial x_{n}}}\\end{array}\\right]重要的是要记住，只有当函数是实值时，即如果函数返回标量值，才定义函数的梯度。例如，$A\\in \\mathbb{R}^{m \\times n}$相对于$x$，我们不能取$Ax$的梯度，因为这个量是向量值。它直接从偏导数的等价性质得出： $\\nabla_{x}(f(x)+g(x))=\\nabla_{x} f(x)+\\nabla_{x} g(x)$ 对于$t \\in \\mathbb{R}$ ，$\\nabla_{x}(t f(x))=t \\nabla_{x} f(x)$ 原则上，梯度是偏导数对多变量函数的自然延伸。然而，在实践中，由于符号的原因，使用梯度有时是很困难的。例如，假设$A\\in \\mathbb{R}^{m \\times n}$是一个固定系数矩阵，假设$b\\in \\mathbb{R}^{m}$是一个固定系数向量。设$f: \\mathbb{R}^{m \\times n} \\rightarrow \\mathbb{R}$为$f(z)=z^Tz$定义的函数，因此$\\nabla_{z}f(z)=2z$。但现在考虑表达式， \\nabla f(Ax)该表达式应该如何解释？ 至少有两种可能性：1.在第一个解释中，回想起$\\nabla_{z}f(z)=2z$。 在这里，我们将$\\nabla f(Ax)$解释为评估点$Ax$处的梯度，因此: \\nabla f(A x)=2(A x)=2 A x \\in \\mathbb{R}^{m}2.在第二种解释中，我们将数量$f(Ax)$视为输入变量$x$的函数。 更正式地说，设$g(x) =f(Ax)$。 然后在这个解释中: \\nabla f(A x)=\\nabla_{x} g(x) \\in \\mathbb{R}^{n}在这里，我们可以看到这两种解释确实不同。 一种解释产生$m$维向量作为结果，而另一种解释产生$n$维向量作为结果！ 我们怎么解决这个问题？ 这里，关键是要明确我们要区分的变量。在第一种情况下，我们将函数$f$与其参数$z$进行区分，然后替换参数$Ax$。在第二种情况下，我们将复合函数$g(x)=f(Ax)$直接与$x$进行微分。 我们将第一种情况表示为$\\nabla zf(Ax)$，第二种情况表示为$\\nabla xf(Ax)$。 保持符号清晰是非常重要的，以后完成课程作业时候你就会发现。 4.2 黑塞矩阵假设$f: \\mathbb{R}^{n} \\rightarrow \\mathbb{R}$是一个函数，它接受$\\mathbb{R}^{n}$中的向量并返回实数。那么关于$x$的黑塞矩阵（也有翻译作海森矩阵），写做：$\\nabla_x ^2 f(A x)$，或者简单地说，$H$是$n \\times n$矩阵的偏导数： \\nabla_{x}^{2} f(x) \\in \\mathbb{R}^{n \\times n}=\\left[\\begin{array}{cccc}{\\frac{\\partial^{2} f(x)}{\\partial x_{1}^{2}}} & {\\frac{\\partial^{2} f(x)}{\\partial x_{1} \\partial x_{2}}} & {\\cdots} & {\\frac{\\partial^{2} f(x)}{\\partial x_{1} \\partial x_{n}}} \\\\ {\\frac{\\partial^{2} f(x)}{\\partial x_{2} \\partial x_{1}}} & {\\frac{\\partial^{2} f(x)}{\\partial x_{2}^{2}}} & {\\cdots} & {\\frac{\\partial^{2} f(x)}{\\partial x_{2} \\partial x_{n}}} \\\\ {\\vdots} & {\\vdots} & {\\ddots} & {\\vdots} \\\\ {\\frac{\\partial^{2} f(x)}{\\partial x_{n} \\partial x_{1}}} & {\\frac{\\partial^{2} f(x)}{\\partial x_{n} \\partial x_{2}}} & {\\cdots} & {\\frac{\\partial^{2} f(x)}{\\partial x_{n}^{2}}}\\end{array}\\right]换句话说，$\\nabla_{x}^{2} f(x) \\in \\mathbb{R}^{n \\times n}$，其： \\left(\\nabla_{x}^{2} f(x)\\right)_{i j}=\\frac{\\partial^{2} f(x)}{\\partial x_{i} \\partial x_{j}}注意：黑塞矩阵通常是对称阵： \\frac{\\partial^{2} f(x)}{\\partial x_{i} \\partial x_{j}}=\\frac{\\partial^{2} f(x)}{\\partial x_{j} \\partial x_{i}}与梯度相似，只有当$f(x)$为实值时才定义黑塞矩阵。 很自然地认为梯度与向量函数的一阶导数的相似，而黑塞矩阵与二阶导数的相似（我们使用的符号也暗示了这种关系）。 这种直觉通常是正确的，但需要记住以下几个注意事项。首先，对于一个变量$f: \\mathbb{R} \\rightarrow \\mathbb{R}$的实值函数，它的基本定义：二阶导数是一阶导数的导数，即： \\frac{\\partial^{2} f(x)}{\\partial x^{2}}=\\frac{\\partial}{\\partial x} \\frac{\\partial}{\\partial x} f(x)然而，对于向量的函数，函数的梯度是一个向量，我们不能取向量的梯度，即: \\nabla_{x} \\nabla_{x} f(x)=\\nabla_{x}\\left[\\begin{array}{c}{\\frac{\\partial f(x)}{\\partial x_{1}}} \\\\ {\\frac{\\partial f(x)}{\\partial x_{2}}} \\\\ {\\vdots} \\\\ {\\frac{\\partial f(x)}{\\partial x_{n}}}\\end{array}\\right]上面这个表达式没有意义。 因此，黑塞矩阵不是梯度的梯度。 然而，下面这种情况却这几乎是正确的：如果我们看一下梯度$\\left(\\nabla_{x} f(x)\\right)_{i}=\\partial f(x) / \\partial x_{i}$的第$i$个元素，并取关于于$x$的梯度我们得到： \\nabla_{x} \\frac{\\partial f(x)}{\\partial x_{i}}=\\left[\\begin{array}{c}{\\frac{\\partial^{2} f(x)}{\\partial x_{i} \\partial x_{1}}} \\\\ {\\frac{\\partial^{2} f(x)}{\\partial x_{2} \\partial x_{2}}} \\\\ {\\vdots} \\\\ {\\frac{\\partial f(x)}{\\partial x_{i} \\partial x_{n}}}\\end{array}\\right]这是黑塞矩阵第$i$行（列）,所以： \\nabla_{x}^{2} f(x)=\\left[\\nabla_{x}\\left(\\nabla_{x} f(x)\\right)_{1} \\quad \\nabla_{x}\\left(\\nabla_{x} f(x)\\right)_{2} \\quad \\cdots \\quad \\nabla_{x}\\left(\\nabla_{x} f(x)\\right)_{n}\\right]简单地说：我们可以说由于：$\\nabla_{x}^{2} f(x)=\\nabla_{x}\\left(\\nabla_{x} f(x)\\right)^{T}$，只要我们理解，这实际上是取$\\nabla_{x} f(x)$的每个元素的梯度，而不是整个向量的梯度。 最后，请注意，虽然我们可以对矩阵$A\\in \\mathbb{R}^{n}$取梯度，但对于这门课，我们只考虑对向量$x \\in \\mathbb{R}^{n}$取黑塞矩阵。这会方便很多（事实上，我们所做的任何计算都不要求我们找到关于矩阵的黑森方程），因为关于矩阵的黑塞方程就必须对矩阵所有元素求偏导数$\\partial^{2} f(A) /\\left(\\partial A_{i j} \\partial A_{k \\ell}\\right)$，将其表示为矩阵相当麻烦。 4.3 二次函数和线性函数的梯度和黑塞矩阵现在让我们尝试确定几个简单函数的梯度和黑塞矩阵。 应该注意的是，这里给出的所有梯度都是CS229讲义中给出的梯度的特殊情况。 对于$x \\in \\mathbb{R}^{n}$, 设$f(x)=b^Tx$ 的某些已知向量$b \\in \\mathbb{R}^{n}$ ，则： f(x)=\\sum_{i=1}^{n} b_{i} x_{i}所以： \\frac{\\partial f(x)}{\\partial x_{k}}=\\frac{\\partial}{\\partial x_{k}} \\sum_{i=1}^{n} b_{i} x_{i}=b_{k}由此我们可以很容易地看出$\\nabla_{x} b^{T} x=b$。 这应该与单变量微积分中的类似情况进行比较，其中$\\partial /(\\partial x) a x=a$。现在考虑$A\\in \\mathbb{S}^{n}$的二次函数$f(x)=x^TAx$。 记住这一点： f(x)=\\sum_{i=1}^{n} \\sum_{j=1}^{n} A_{i j} x_{i} x_{j}为了取偏导数，我们将分别考虑包括$x_k$和$x_2^k$因子的项： \\begin{aligned} \\frac{\\partial f(x)}{\\partial x_{k}} &=\\frac{\\partial}{\\partial x_{k}} \\sum_{i=1}^{n} \\sum_{j=1}^{n} A_{i j} x_{i} x_{j} \\\\ &=\\frac{\\partial}{\\partial x_{k}}\\left[\\sum_{i \\neq k} \\sum_{j \\neq k} A_{i j} x_{i} x_{j}+\\sum_{i \\neq k} A_{i k} x_{i} x_{k}+\\sum_{j \\neq k} A_{k j} x_{k} x_{j}+A_{k k} x_{k}^{2}\\right] \\\\ &=\\sum_{i \\neq k} A_{i k} x_{i}+\\sum_{j \\neq k} A_{k j} x_{j}+2 A_{k k} x_{k} \\\\ &=\\sum_{i=1}^{n} A_{i k} x_{i}+\\sum_{j=1}^{n} A_{k j} x_{j}=2 \\sum_{i=1}^{n} A_{k i} x_{i} \\end{aligned}最后一个等式，是因为$A$是对称的（我们可以安全地假设，因为它以二次形式出现）。 注意，$\\nabla_{x} f(x)$的第$k$个元素是$A$和$x$的第$k$行的内积。 因此，$\\nabla_{x} x^{T} A x=2 A x$。 同样，这应该提醒你单变量微积分中的类似事实，即$\\partial /(\\partial x) a x^{2}=2 a x$。 最后，让我们来看看二次函数$f(x)=x^TAx$黑塞矩阵（显然，线性函数$b^Tx$的黑塞矩阵为零）。在这种情况下: \\frac{\\partial^{2} f(x)}{\\partial x_{k} \\partial x_{\\ell}}=\\frac{\\partial}{\\partial x_{k}}\\left[\\frac{\\partial f(x)}{\\partial x_{\\ell}}\\right]=\\frac{\\partial}{\\partial x_{k}}\\left[2 \\sum_{i=1}^{n} A_{\\ell i} x_{i}\\right]=2 A_{\\ell k}=2 A_{k \\ell}因此，应该很清楚$\\nabla_{x}^2 x^{T} A x=2 A$，这应该是完全可以理解的（同样类似于$\\partial^2 /(\\partial x^2) a x^{2}=2a$的单变量事实）。 简要概括起来： $\\nabla_{x} b^{T} x=b$ $\\nabla_{x} x^{T} A x=2 A x$ (如果$A$是对称阵) $\\nabla_{x}^2 x^{T} A x=2 A $ (如果$A$是对称阵) 4.4 最小二乘法让我们应用上一节中得到的方程来推导最小二乘方程。假设我们得到矩阵$A\\in \\mathbb{R}^{m \\times n}$（为了简单起见，我们假设$A$是满秩）和向量$b\\in \\mathbb{R}^{m}$，从而使$b \\notin \\mathcal{R}(A)$。在这种情况下，我们将无法找到向量$x\\in \\mathbb{R}^{n}$，由于$Ax = b$，因此我们想要找到一个向量$x$，使得$Ax$尽可能接近 $b$，用欧几里德范数的平方$|A x-b|_{2}^{2} $来衡量。 使用公式$|x|^{2}=x^Tx$，我们可以得到： \\begin{aligned}\\|A x-b\\|_{2}^{2} &=(A x-b)^{T}(A x-b) \\\\ &=x^{T} A^{T} A x-2 b^{T} A x+b^{T} b \\end{aligned}根据$x$的梯度，并利用上一节中推导的性质： \\begin{aligned} \\nabla_{x}\\left(x^{T} A^{T} A x-2 b^{T} A x+b^{T} b\\right) &=\\nabla_{x} x^{T} A^{T} A x-\\nabla_{x} 2 b^{T} A x+\\nabla_{x} b^{T} b \\\\ &=2 A^{T} A x-2 A^{T} b \\end{aligned}将最后一个表达式设置为零，然后解出$x$，得到了正规方程： x = (A^TA)^{-1}A^Tb这和我们在课堂上得到的相同。 4.5 行列式的梯度现在让我们考虑一种情况，我们找到一个函数相对于矩阵的梯度，也就是说，对于$A\\in \\mathbb{R}^{n \\times n}$，我们要找到$\\nabla_{A}|A|$。回想一下我们对行列式的讨论： |A|=\\sum_{i=1}^{n}(-1)^{i+j} A_{i j}\\left|A_{\\backslash i, \\backslash j}\\right| \\quad(\\text { for any } j \\in 1, \\ldots, n)所以： \\frac{\\partial}{\\partial A_{k \\ell}}|A|=\\frac{\\partial}{\\partial A_{k \\ell}} \\sum_{i=1}^{n}(-1)^{i+j} A_{i j}\\left|A_{\\backslash i, \\backslash j}\\right|=(-1)^{k+\\ell}\\left|A_{\\backslash k,\\backslash \\ell}\\right|=(\\operatorname{adj}(A))_{\\ell k}从这里可以知道，它直接从伴随矩阵的性质得出： \\nabla_{A}|A|=(\\operatorname{adj}(A))^{T}=|A| A^{-T}现在我们来考虑函数$f : \\mathbb{S}_{++}^{n} \\rightarrow \\mathbb{R}$，$f(A)=\\log |A|$。注意，我们必须将$f$的域限制为正定矩阵，因为这确保了$|A|&gt;0$，因此$|A|$的对数是实数。在这种情况下，我们可以使用链式法则（没什么奇怪的，只是单变量演算中的普通链式法则）来看看： \\frac{\\partial \\log |A|}{\\partial A_{i j}}=\\frac{\\partial \\log |A|}{\\partial|A|} \\frac{\\partial|A|}{\\partial A_{i j}}=\\frac{1}{|A|} \\frac{\\partial|A|}{\\partial A_{i j}}从这一点可以明显看出： \\nabla_{A} \\log |A|=\\frac{1}{|A|} \\nabla_{A}|A|=A^{-1}我们可以在最后一个表达式中删除转置，因为$A$是对称的。注意与单值情况的相似性，其中$\\partial /(\\partial x) \\log x=1 / x$。 4.6 特征值优化最后，我们使用矩阵演算以直接导致特征值/特征向量分析的方式求解优化问题。 考虑以下等式约束优化问题： \\max _{x \\in \\mathbb{R}^{n}} x^{T} A x \\quad \\text { subject to }\\|x\\|_{2}^{2}=1对于对称矩阵$A\\in \\mathbb{S}^{n}$。求解等式约束优化问题的标准方法是采用拉格朗日形式，一种包含等式约束的目标函数，在这种情况下，拉格朗日函数可由以下公式给出： \\mathcal{L}(x, \\lambda)=x^{T} A x-\\lambda x^{T} x其中，$\\lambda $被称为与等式约束关联的拉格朗日乘子。可以确定，要使$x^$成为问题的最佳点，拉格朗日的梯度必须在$x^$处为零（这不是唯一的条件，但它是必需的）。也就是说， \\nabla_{x} \\mathcal{L}(x, \\lambda)=\\nabla_{x}\\left(x^{T} A x-\\lambda x^{T} x\\right)=2 A^{T} x-2 \\lambda x=0请注意，这只是线性方程$Ax =\\lambda x$。 这表明假设$x^T x = 1$，可能最大化（或最小化）$x^T Ax$的唯一点是$A$的特征向量。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习基础","slug":"机器学习基础","permalink":"https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"}]},{"title":"函数进阶","slug":"函数进阶","date":"2021-03-05T12:29:09.000Z","updated":"2021-03-05T12:30:03.128Z","comments":true,"path":"20210305/函数进阶.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6.html","excerpt":"","text":"函数进阶目标 函数参数和返回值的作用 函数的返回值 进阶 函数的参数 进阶 递归函数 01. 函数参数和返回值的作用函数根据 有没有参数 以及 有没有返回值，可以 相互组合，一共有 4 种 组合形式 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 定义函数时，是否接收参数，或者是否返回结果，是根据 实际的功能需求 来决定的！ 如果函数 内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部 如果希望一个函数 执行完成后，向外界汇报执行结果，就可以增加函数的返回值 1.1 无参数，无返回值此类函数，不接收参数，也没有返回值，应用场景如下： 只是单纯地做一件事情，例如 显示菜单 在函数内部 针对全局变量进行操作，例如：新建名片，最终结果 记录在全局变量 中 注意： 如果全局变量的数据类型是一个 可变类型，在函数内部可以使用 方法 修改全局变量的内容 —— 变量的引用不会改变 在函数内部，使用赋值语句 才会 修改变量的引用 1.2 无参数，有返回值此类函数，不接收参数，但是有返回值，应用场景如下： 采集数据，例如 温度计，返回结果就是当前的温度，而不需要传递任何的参数 1.3 有参数，无返回值此类函数，接收参数，没有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据 例如 名片管理系统 针对 找到的名片 做 修改、删除 操作 1.4 有参数，有返回值此类函数，接收参数，同时有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据，并且 返回期望的处理结果 例如 名片管理系统 使用 字典默认值 和 提示信息 提示用户输入内容 如果输入，返回输入内容 如果没有输入，返回字典默认值 02. 函数的返回值 进阶 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 问题：一个函数执行后能否返回多个结果？ 示例 —— 温度和湿度测量 假设要开发一个函数能够同时返回当前的温度和湿度 先完成返回温度的功能如下： 1234567891011def measure(): &quot;&quot;&quot;返回当前的温度&quot;&quot;&quot; print(&quot;开始测量...&quot;) temp = 39 print(&quot;测量结束...&quot;) return tempresult = measure()print(result) 在利用 元组 在返回温度的同时，也能够返回 湿度 改造如下： 123456789def measure(): &quot;&quot;&quot;返回当前的温度&quot;&quot;&quot; print(&quot;开始测量...&quot;) temp = 39 wetness = 10 print(&quot;测量结束...&quot;) return (temp, wetness) 提示：如果一个函数返回的是元组，括号可以省略 技巧 在 Python 中，可以 将一个元组 使用 赋值语句 同时赋值给 多个变量 注意：变量的数量需要和元组中的元素数量保持一致 1result = temp, wetness = measure() 面试题 —— 交换两个数字题目要求 有两个整数变量 a = 6, b = 100 不使用其他变量，交换两个变量的值 解法 1 —— 使用其他变量1234# 解法 1 - 使用临时变量c = bb = aa = c 解法 2 —— 不使用临时变量1234# 解法 2 - 不使用临时变量a = a + bb = a - ba = a - b 解法 3 —— Python 专有，利用元组1a, b = b, a 03. 函数的参数 进阶3.1. 不可变和可变的参数 问题 1：在函数内部，针对参数使用 赋值语句，会不会影响调用函数时传递的 实参变量？ —— 不会！ 无论传递的参数是 可变 还是 不可变 只要 针对参数 使用 赋值语句，会在 函数内部 修改 局部变量的引用，不会影响到 外部变量的引用 1234567891011121314151617181920def demo(num, num_list): print(&quot;函数内部&quot;) # 赋值语句 num = 200 num_list = [1, 2, 3] print(num) print(num_list) print(&quot;函数代码完成&quot;)gl_num = 99gl_list = [4, 5, 6]demo(gl_num, gl_list)print(gl_num)print(gl_list) 问题 2：如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据 12345678910def mutable(num_list): # num_list = [1, 2, 3] num_list.extend([1, 2, 3]) print(num_list)gl_list = [6, 7, 8]mutable(gl_list)print(gl_list) 面试题 —— += 在 python 中，列表变量调用 += 本质上是在执行列表变量的 extend 方法，不会修改变量的引用 123456789101112131415161718192021def demo(num, num_list): print(&quot;函数内部代码&quot;) # num = num + num num += num # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用 # 函数执行结束后，外部数据同样会发生变化 num_list += num_list print(num) print(num_list) print(&quot;函数代码完成&quot;)gl_num = 9gl_list = [1, 2, 3]demo(gl_num, gl_list)print(gl_num)print(gl_list) 3.2 缺省参数 定义函数时，可以给 某个参数 指定一个默认值，具有默认值的参数就叫做 缺省参数 调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值 函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用 例如：对列表排序的方法 123456789gl_num_list = [6, 3, 9]# 默认就是升序排序，因为这种应用需求更多gl_num_list.sort()print(gl_num_list)# 只有当需要降序排序时，才需要传递 `reverse` 参数gl_num_list.sort(reverse=True)print(gl_num_list) 指定函数的缺省参数 在参数后使用赋值语句，可以指定参数的缺省值 1234567def print_info(name, gender=True): gender_text = &quot;男生&quot; if not gender: gender_text = &quot;女生&quot; print(&quot;%s 是 %s&quot; % (name, gender_text)) 提示 缺省参数，需要使用 最常见的值 作为默认值！ 如果一个参数的值 不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！ 缺省参数的注意事项1) 缺省参数的定义位置 必须保证 带有默认值的缺省参数 在参数列表末尾 所以，以下定义是错误的！ 1def print_info(name, gender=True, title): 2) 调用带有多个缺省参数的函数 在 调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！ 123456789101112131415161718192021def print_info(name, title=&quot;&quot;, gender=True): &quot;&quot;&quot; :param title: 职位 :param name: 班上同学的姓名 :param gender: True 男生 False 女生 &quot;&quot;&quot; gender_text = &quot;男生&quot; if not gender: gender_text = &quot;女生&quot; print(&quot;%s%s 是 %s&quot; % (title, name, gender_text))# 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！print_info(&quot;小明&quot;)print_info(&quot;老王&quot;, title=&quot;班长&quot;)print_info(&quot;小美&quot;, gender=False) 3.3 多值参数（知道）定义支持多值参数的函数 有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数 python 中有 两种 多值参数： 参数名前增加 一个 * 可以接收 元组 参数名前增加 两个 * 可以接收 字典 一般在给多值参数命名时，习惯使用以下两个名字 *args —— 存放 元组 参数，前面有一个 * **kwargs —— 存放 字典 参数，前面有两个 * args 是 arguments 的缩写，有变量的含义 kw 是 keyword 的缩写，kwargs 可以记忆 键值对参数 123456789def demo(num, *args, **kwargs): print(num) print(args) print(kwargs)demo(1, 2, 3, 4, 5, name=&quot;小明&quot;, age=18, gender=True) 提示：多值参数 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们能够读懂大牛的代码 多值参数案例 —— 计算任意多个数字的和需求 定义一个函数 sum_numbers，可以接收的 任意多个整数 功能要求：将传递的 所有数字累加 并且返回累加结果 12345678910def sum_numbers(*args): num = 0 # 遍历 args 元组顺序求和 for n in args: num += n return numprint(sum_numbers(1, 2, 3)) 元组和字典的拆包（知道） 在调用带有多值参数的函数时，如果希望： 将一个 元组变量，直接传递给 args 将一个 字典变量，直接传递给 kwargs 就可以使用 拆包，简化参数的传递，拆包 的方式是： 在 元组变量前，增加 一个 * 在 字典变量前，增加 两个 * 1234567891011121314def demo(*args, **kwargs): print(args) print(kwargs)# 需要将一个元组变量/字典变量传递给函数对应的参数gl_nums = (1, 2, 3)gl_xiaoming = &#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 18&#125;# 会把 num_tuple 和 xiaoming 作为元组传递个 args# demo(gl_nums, gl_xiaoming)demo(*gl_nums, **gl_xiaoming) 04. 函数的递归 函数调用自身的 编程技巧 称为递归 4.1 递归函数的特点特点 一个函数 内部 调用自己 函数内部可以调用其他函数，当然在函数内部也可以调用自己 代码特点 函数内部的 代码 是相同的，只是针对 参数 不同，处理的结果不同 当 参数满足一个条件 时，函数不再执行 这个非常重要，通常被称为递归的出口，否则 会出现死循环！ 示例代码 123456789101112def sum_numbers(num): print(num) # 递归的出口很重要，否则会出现死循环 if num == 1: return sum_numbers(num - 1) sum_numbers(3) 4.2 递归案例 —— 计算数字累加需求 定义一个函数 sum_numbers 能够接收一个 num 的整数参数 计算 1 + 2 + … num 的结果 12345678910111213def sum_numbers(num): if num == 1: return 1 # 假设 sum_numbers 能够完成 num - 1 的累加 temp = sum_numbers(num - 1) # 函数内部的核心算法就是 两个数字的相加 return num + tempprint(sum_numbers(2)) 提示：递归是一个 编程技巧，初次接触递归会感觉有些吃力！在处理 不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"变量进阶","slug":"变量进阶","date":"2021-03-05T12:26:02.000Z","updated":"2021-03-05T12:26:18.120Z","comments":true,"path":"20210305/变量进阶.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6.html","excerpt":"","text":"变量进阶（理解）目标 变量的引用 可变和不可变类型 局部变量和全局变量 01. 变量的引用 变量 和 数据 都是保存在 内存 中的 在 Python 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的 1.1 引用的概念在 Python 中 变量 和 数据 是分开存储的 数据 保存在内存中的一个位置 变量 中保存着数据在内存中的地址 变量 中 记录数据的地址，就叫做 引用 使用 id() 函数可以查看变量中保存数据所在的 内存地址 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 1.2 变量引用 的示例在 Python 中，变量的名字类似于 便签纸 贴在 数据 上 定义一个整数变量 a，并且赋值为 1 代码 图示 a = 1 将变量 a 赋值为 2 代码 图示 a = 2 定义一个整数变量 b，并且将变量 a 的值赋值给 b 代码 图示 b = a 变量 b 是第 2 个贴在数字 2 上的标签 1.3 函数的参数和返回值的传递在 Python 中，函数的 实参/返回值 都是是靠 引用 来传递来的 1234567891011121314151617181920def test(num): print(&quot;-&quot; * 50) print(&quot;%d 在函数内的内存地址是 %x&quot; % (num, id(num))) result = 100 print(&quot;返回值 %d 在内存中的地址是 %x&quot; % (result, id(result))) print(&quot;-&quot; * 50) return resulta = 10print(&quot;调用函数前 内存地址是 %x&quot; % id(a))r = test(a)print(&quot;调用函数后 实参内存地址是 %x&quot; % id(a))print(&quot;调用函数后 返回值内存地址是 %x&quot; % id(r)) 02. 可变和不可变类型 不可变类型，内存中的数据不允许被修改： 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 可变类型，内存中的数据可以被修改： 列表 list 字典 dict 1234a = 1a = &quot;hello&quot;a = [1, 2, 3]a = [3, 2, 1] 123456789101112131415161718192021demo_list = [1, 2, 3]print(&quot;定义列表后的内存地址 %d&quot; % id(demo_list))demo_list.append(999)demo_list.pop(0)demo_list.remove(2)demo_list[0] = 10print(&quot;修改数据后的内存地址 %d&quot; % id(demo_list))demo_dict = &#123;&quot;name&quot;: &quot;小明&quot;&#125;print(&quot;定义字典后的内存地址 %d&quot; % id(demo_dict))demo_dict[&quot;age&quot;] = 18demo_dict.pop(&quot;name&quot;)demo_dict[&quot;name&quot;] = &quot;老王&quot;print(&quot;修改数据后的内存地址 %d&quot; % id(demo_dict)) 注意：字典的 key 只能使用不可变类型的数据 注意 可变类型的数据变化，是通过 方法 来实现的 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 哈希 (hash) Python 中内置有一个名字叫做 hash(o) 的函数 接收一个 不可变类型 的数据作为 参数 返回 结果是一个 整数 哈希 是一种 算法，其作用就是提取数据的 特征码（指纹） 相同的内容 得到 相同的结果 不同的内容 得到 不同的结果 在 Python 中，设置字典的 键值对 时，会首先对 key 进行 hash 已决定如何在内存中保存字典的数据，以方便 后续 对字典的操作：增、删、改、查 键值对的 key 必须是不可变类型数据 键值对的 value 可以是任意类型的数据 03. 局部变量和全局变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 3.1 局部变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 函数执行结束后，函数内部的局部变量，会被系统回收 不同的函数，可以定义相同的名字的局部变量，但是 彼此之间 不会产生影响 局部变量的作用 在函数内部使用，临时 保存 函数内部需要使用的数据 12345678910111213141516171819202122def demo1(): num = 10 print(num) num = 20 print(&quot;修改后 %d&quot; % num)def demo2(): num = 100 print(num)demo1()demo2()print(&quot;over&quot;) 局部变量的生命周期 所谓 生命周期 就是变量从 被创建 到 被系统回收 的过程 局部变量 在 函数执行时 才会被创建 函数执行结束后 局部变量 被系统回收 局部变量在生命周期 内，可以用来存储 函数内部临时使用到的数据 3.2 全局变量 全局变量 是在 函数外部定义 的变量，所有函数内部都可以使用这个变量 123456789101112131415161718# 定义一个全局变量num = 10def demo1(): print(num)def demo2(): print(num)demo1()demo2()print(&quot;over&quot;) 注意：函数执行时，需要处理变量时 会： 首先 查找 函数内部 是否存在 指定名称 的局部变量，如果有，直接使用 如果没有，查找 函数外部 是否存在 指定名称 的全局变量，如果有，直接使用 如果还没有，程序报错！ 1) 函数不能直接修改 全局变量的引用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 在函数内部，可以 通过全局变量的引用获取对应的数据 但是，不允许直接修改全局变量的引用 —— 使用赋值语句修改全局变量的值 12345678910111213141516171819202122num = 10def demo1(): print(&quot;demo1&quot; + &quot;-&quot; * 50) # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num)def demo2(): print(&quot;demo2&quot; + &quot;-&quot; * 50) print(num)demo1()demo2()print(&quot;over&quot;) 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值 2) 在函数内部修改全局变量的值 如果在函数中需要修改全局变量，需要使用 global 进行声明 123456789101112131415161718192021222324num = 10def demo1(): print(&quot;demo1&quot; + &quot;-&quot; * 50) # global 关键字，告诉 Python 解释器 num 是一个全局变量 global num # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num)def demo2(): print(&quot;demo2&quot; + &quot;-&quot; * 50) print(num)demo1()demo2()print(&quot;over&quot;) 3) 全局变量定义的位置 为了保证所有的函数都能够正确使用到全局变量，应该 将全局变量定义在其他函数的上方 123456789101112a = 10def demo(): print(&quot;%d&quot; % a) print(&quot;%d&quot; % b) print(&quot;%d&quot; % c)b = 20demo()c = 30 注意 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！ 代码结构示意图如下 4) 全局变量命名的建议 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如： 全局变量名前应该增加 g_ 或者 gl_ 的前缀 提示：具体的要求格式，各公司要求可能会有些差异","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"综合应用--名片管理系统","slug":"综合应用-名片管理系统","date":"2021-03-05T12:20:08.000Z","updated":"2021-03-05T12:20:24.542Z","comments":true,"path":"20210305/综合应用-名片管理系统.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8-%E5%90%8D%E7%89%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html","excerpt":"","text":"综合应用 —— 名片管理系统目标综合应用已经学习过的知识点： 变量 流程控制 函数 模块 开发 名片管理系统 系统需求 程序启动，显示名片管理系统欢迎界面，并显示功能菜单 123456789**************************************************欢迎使用【名片管理系统】V1.01. 新建名片2. 显示全部3. 查询名片0. 退出系统************************************************** 用户用数字选择不同的功能 根据功能选择，执行不同的功能 用户名片需要记录用户的 姓名、电话、QQ、邮件 如果查询到指定的名片，用户可以选择 修改 或者 删除 名片 步骤 框架搭建 新增名片 显示所有名片 查询名片 查询成功后修改、删除名片 让 Python 程序能够直接运行 01. 框架搭建目标 搭建名片管理系统 框架结构 准备文件，确定文件名，保证能够 在需要的位置 编写代码 编写 主运行循环，实现基本的 用户输入和判断 1.1 文件准备 新建 cards_main.py 保存 主程序功能代码 程序的入口 每一次启动名片管理系统都通过 main 这个文件启动 新建 cards_tools.py 保存 所有名片功能函数 将对名片的 新增、查询、修改、删除 等功能封装在不同的函数中 1.2 编写主运行循环 在 cards_main 中添加一个 无限循环 12345678910111213141516171819while True: # TODO(小明) 显示系统菜单 action = input(&quot;请选择操作功能：&quot;) print(&quot;您选择的操作是：%s&quot; % action) # 根据用户输入决定后续的操作 if action in [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]: pass elif action == &quot;0&quot;: print(&quot;欢迎再次使用【名片管理系统】&quot;) break else: print(&quot;输入错误，请重新输入&quot;) 字符串判断1if action in [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]: 1if action == &quot;1&quot; or action == &quot;2&quot; or action == &quot;3&quot;: 使用 in 针对 列表 判断，避免使用 or 拼接复杂的逻辑条件 没有使用 int 转换用户输入，可以避免 一旦用户输入的不是数字，导致程序运行出错 pass pass 就是一个空语句，不做任何事情，一般用做占位语句 是为了保持程序结构的完整性 无限循环 在开发软件时，如果 不希望程序执行后 立即退出 可以在程序中增加一个 无限循环 由用户来决定 退出程序的时机 TODO 注释 在 # 后跟上 TODO，用于标记需要去做的工作 1# TODO(作者/邮件) 显示系统菜单 1.3 在 cards_tools 中增加四个新函数1234567891011121314151617181920212223242526272829def show_menu(): &quot;&quot;&quot;显示菜单 &quot;&quot;&quot; passdef new_card(): &quot;&quot;&quot;新建名片 &quot;&quot;&quot; print(&quot;-&quot; * 50) print(&quot;功能：新建名片&quot;)def show_all(): &quot;&quot;&quot;显示全部 &quot;&quot;&quot; print(&quot;-&quot; * 50) print(&quot;功能：显示全部&quot;)def search_card(): &quot;&quot;&quot;搜索名片 &quot;&quot;&quot; print(&quot;-&quot; * 50) print(&quot;功能：搜索名片&quot;) 1.4 导入模块 在 cards_main.py 中使用 import 导入 cards_tools 模块 1import cards_tools 修改 while 循环的代码如下： 1234567891011121314151617181920212223242526272829import cards_toolswhile True: cards_tools.show_menu() action = input(&quot;请选择操作功能：&quot;) print(&quot;您选择的操作是：%s&quot; % action) # 根据用户输入决定后续的操作 if action in [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]: if action == &quot;1&quot;: cards_tools.new_card() elif action == &quot;2&quot;: cards_tools.show_all() elif action == &quot;3&quot;: cards_tools.search_card() elif action == &quot;0&quot;: print(&quot;欢迎再次使用【名片管理系统】&quot;) break else: print(&quot;输入错误，请重新输入：&quot;) 至此：cards_main 中的所有代码全部开发完毕！ 1.5 完成 show_menu 函数1234567891011121314def show_menu(): &quot;&quot;&quot;显示菜单 &quot;&quot;&quot; print(&quot;*&quot; * 50) print(&quot;欢迎使用【菜单管理系统】V1.0&quot;) print(&quot;&quot;) print(&quot;1. 新建名片&quot;) print(&quot;2. 显示全部&quot;) print(&quot;3. 查询名片&quot;) print(&quot;&quot;) print(&quot;0. 退出系统&quot;) print(&quot;*&quot; * 50) 02. 保存名片数据的结构程序就是用来处理数据的，而变量就是用来存储数据的 使用 字典 记录 每一张名片 的详细信息 使用 列表 统一记录所有的 名片字典 定义名片列表变量 在 cards_tools 文件的顶部增加一个 列表变量 12# 所有名片记录的列表card_list = [] 注意 所有名片相关操作，都需要使用这个列表，所以应该 定义在程序的顶部 程序刚运行时，没有数据，所以是 空列表 03. 新增名片3.1 功能分析 提示用户依次输入名片信息 将名片信息保存到一个字典 将字典添加到名片列表 提示名片添加完成 3.2 实现 new_card 方法 根据步骤实现代码 123456789101112131415161718192021222324252627def new_card(): &quot;&quot;&quot;新建名片 &quot;&quot;&quot; print(&quot;-&quot; * 50) print(&quot;功能：新建名片&quot;) # 1. 提示用户输入名片信息 name = input(&quot;请输入姓名：&quot;) phone = input(&quot;请输入电话：&quot;) qq = input(&quot;请输入 QQ 号码：&quot;) email = input(&quot;请输入邮箱：&quot;) # 2. 将用户信息保存到一个字典 card_dict = &#123;&quot;name&quot;: name, &quot;phone&quot;: phone, &quot;qq&quot;: qq, &quot;email&quot;: email&#125; # 3. 将用户字典添加到名片列表 card_list.append(card_dict) print(card_list) # 4. 提示添加成功信息 print(&quot;成功添加 %s 的名片&quot; % card_dict[&quot;name&quot;]) 技巧：在 PyCharm 中，可以使用 SHIFT + F6 统一修改变量名 04. 显示所有名片4.1 功能分析 循环遍历名片列表，顺序显示每一个字典的信息 4.2 基础代码实现1234567891011def show_all(): &quot;&quot;&quot;显示全部 &quot;&quot;&quot; print(&quot;-&quot; * 50) print(&quot;功能：显示全部&quot;) for card_dict in card_list: print(card_dict) 显示效果不好！ 4.3 增加标题和使用 \\t 显示123456789101112131415161718192021def show_all(): &quot;&quot;&quot;显示全部 &quot;&quot;&quot; print(&quot;-&quot; * 50) print(&quot;功能：显示全部&quot;) # 打印表头 for name in [&quot;姓名&quot;, &quot;电话&quot;, &quot;QQ&quot;, &quot;邮箱&quot;]: print(name, end=&quot;\\t\\t&quot;) print(&quot;&quot;) # 打印分隔线 print(&quot;=&quot; * 50) for card_dict in card_list: print(&quot;%s\\t\\t%s\\t\\t%s\\t\\t%s&quot; % (card_dict[&quot;name&quot;], card_dict[&quot;phone&quot;], card_dict[&quot;qq&quot;], card_dict[&quot;email&quot;])) 4.4 增加没有名片记录判断123456789101112def show_all(): &quot;&quot;&quot;显示全部 &quot;&quot;&quot; print(&quot;-&quot; * 50) print(&quot;功能：显示全部&quot;) # 1. 判断是否有名片记录 if len(card_list) == 0: print(&quot;提示：没有任何名片记录&quot;) return 注意 在函数中使用 return 表示返回 如果在 return 后没有跟任何内容，只是表示该函数执行到此就不再执行后续的代码 05. 查询名片5.1 功能分析 提示用户要搜索的姓名 根据用户输入的姓名遍历列表 搜索到指定的名片后，再执行后续的操作 5.2 代码实现 查询功能实现 1234567891011121314151617181920212223242526272829303132def search_card(): &quot;&quot;&quot;搜索名片 &quot;&quot;&quot; print(&quot;-&quot; * 50) print(&quot;功能：搜索名片&quot;) # 1. 提示要搜索的姓名 find_name = input(&quot;请输入要搜索的姓名：&quot;) # 2. 遍历字典 for card_dict in card_list: if card_dict[&quot;name&quot;] == find_name: print(&quot;姓名\\t\\t\\t电话\\t\\t\\tQQ\\t\\t\\t邮箱&quot;) print(&quot;-&quot; * 40) print(&quot;%s\\t\\t\\t%s\\t\\t\\t%s\\t\\t\\t%s&quot; % ( card_dict[&quot;name&quot;], card_dict[&quot;phone&quot;], card_dict[&quot;qq&quot;], card_dict[&quot;email&quot;])) print(&quot;-&quot; * 40) # TODO(小明) 针对找到的字典进行后续操作：修改/删除 break else: print(&quot;没有找到 %s&quot; % find_name) 增加名片操作函数：修改/删除/返回主菜单 12345678910111213141516def deal_card(find_dict): &quot;&quot;&quot;操作搜索到的名片字典 :param find_dict:找到的名片字典 &quot;&quot;&quot; print(find_dict) action_str = input(&quot;请选择要执行的操作 &quot; &quot;[1] 修改 [2] 删除 [0] 返回上级菜单&quot;) if action == &quot;1&quot;: print(&quot;修改&quot;) elif action == &quot;2&quot;: print(&quot;删除&quot;) 06. 修改和删除6.1 查询成功后删除名片 由于找到的字典记录已经在列表中保存 要删除名片记录，只需要把列表中对应的字典删除即可 1234elif action == &quot;2&quot;: card_list.remove(find_dict) print(&quot;删除成功&quot;) 6.2 修改名片 由于找到的字典记录已经在列表中保存 要修改名片记录，只需要把列表中对应的字典中每一个键值对的数据修改即可 123456789if action == &quot;1&quot;: find_dict[&quot;name&quot;] = input(&quot;请输入姓名：&quot;) find_dict[&quot;phone&quot;] = input(&quot;请输入电话：&quot;) find_dict[&quot;qq&quot;] = input(&quot;请输入QQ：&quot;) find_dict[&quot;email&quot;] = input(&quot;请输入邮件：&quot;) print(&quot;%s 的名片修改成功&quot; % find_dict[&quot;name&quot;]) 修改名片细化 如果用户在使用时，某些名片内容并不想修改，应该如何做呢？—— 既然系统提供的 input 函数不能满足需求，那么就新定义一个函数 input_card_info 对系统的 input 函数进行扩展 1234567891011121314151617181920def input_card_info(dict_value, tip_message): &quot;&quot;&quot;输入名片信息 :param dict_value: 字典原有值 :param tip_message: 输入提示信息 :return: 如果输入，返回输入内容，否则返回字典原有值 &quot;&quot;&quot; # 1. 提示用户输入内容 result_str = input(tip_message) # 2. 针对用户的输入进行判断，如果用户输入了内容，直接返回结果 if len(result_str) &gt; 0: return result_str # 3. 如果用户没有输入内容，返回 `字典中原有的值` else: return dict_value 07. LINUX 上的 Shebang 符号(#!) #!这个符号叫做 Shebang 或者 Sha-bang Shebang 通常在 Unix 系统脚本的中 第一行开头 使用 指明 执行这个脚本文件 的 解释程序 使用 Shebang 的步骤 使用 which 查询 python3 解释器所在路径 1$ which python3 修改要运行的 主 python 文件，在第一行增加以下内容 1#! /usr/bin/python3 修改 主 python 文件 的文件权限，增加执行权限 1$ chmod +x cards_main.py 在需要时执行程序即可 1./cards_main.py","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"高级变量类型","slug":"高级变量类型","date":"2021-03-05T12:17:20.000Z","updated":"2021-03-05T12:17:36.209Z","comments":true,"path":"20210305/高级变量类型.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E9%AB%98%E7%BA%A7%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B.html","excerpt":"","text":"高级变量类型目标 列表 元组 字典 字符串 公共方法 变量高级 知识点回顾 Python 中数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 在 Python 中，所有 非数字型变量 都支持以下特点： 都是一个 序列 sequence，也可以理解为 容器 取值 [] 遍历 for in 计算长度、最大/最小值、比较、删除 链接 + 和 重复 * 切片 01. 列表1.1 列表的定义 List（列表） 是 Python 中使用 最频繁 的数据类型，在其他语言中通常叫做 数组 专门用于存储 一串 信息 列表用 [] 定义，数据 之间使用 , 分隔 列表的 索引 从 0 开始 索引 就是数据在 列表 中的位置编号，索引 又可以被称为 下标 注意：从列表中取值时，如果 超出索引范围，程序会报错 1name_list = [&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;] 1.2 列表常用操作 在 ipython3 中定义一个 列表，例如：name_list = [] 输入 name_list. 按下 TAB 键，ipython 会提示 列表 能够使用的 方法 如下： 1234In [1]: name_list.name_list.append name_list.count name_list.insert name_list.reversename_list.clear name_list.extend name_list.pop name_list.sortname_list.copy name_list.index name_list.remove 序号 分类 关键字 / 函数 / 方法 说明 1 增加 列表.insert(索引, 数据) 在指定位置插入数据 列表.append(数据) 在末尾追加数据 列表.extend(列表2) 将列表2 的数据追加到列表 2 修改 列表[索引] = 数据 修改指定索引的数据 3 删除 del 列表[索引] 删除指定索引的数据 列表.remove[数据] 删除第一个出现的指定数据 列表.pop 删除末尾数据 列表.pop(索引) 删除指定索引数据 列表.clear 清空列表 4 统计 len(列表) 列表长度 列表.count(数据) 数据在列表中出现的次数 5 排序 列表.sort() 升序排序 列表.sort(reverse=True) 降序排序 列表.reverse() 逆序、反转 del 关键字（科普） 使用 del 关键字(delete) 同样可以删除列表中元素 del 关键字本质上是用来 将一个变量从内存中删除的 如果使用 del 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了 1del name_list[1] 在日常开发中，要从列表删除数据，建议 使用列表提供的方法 关键字、函数和方法（科普） 关键字 是 Python 内置的、具有特殊意义的标识符 123In [1]: import keywordIn [2]: print(keyword.kwlist)In [3]: print(len(keyword.kwlist)) 关键字后面不需要使用括号 函数 封装了独立功能，可以直接调用 1函数名(参数) 函数需要死记硬背 方法 和函数类似，同样是封装了独立的功能 方法 需要通过 对象 来调用，表示针对这个 对象 要做的操作 1对象.方法名(参数) 在变量后面输入 .，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多 1.3 循环遍历 遍历 就是 从头到尾 依次 从 列表 中获取数据 在 循环体内部 针对 每一个元素，执行相同的操作 在 Python 中为了提高列表的遍历效率，专门提供的 迭代 iteration 遍历 使用 for 就能够实现迭代遍历 123456# for 循环内部使用的变量 in 列表for name in name_list: 循环内部针对列表元素进行操作 print(name) 1.4 应用场景 尽管 Python 的 列表 中可以 存储不同类型的数据 但是在开发中，更多的应用场景是 列表 存储相同类型的数据 通过 迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作 02. 元组2.1 元组的定义 Tuple（元组）与列表类似，不同之处在于元组的 元素不能修改 元组 表示多个元素组成的序列 元组 在 Python 开发中，有特定的应用场景 用于存储 一串 信息，数据 之间使用 , 分隔 元组用 () 定义 元组的 索引 从 0 开始 索引 就是数据在 元组 中的位置编号 1info_tuple = (&quot;zhangsan&quot;, 18, 1.75) 创建空元组1info_tuple = () 元组中 只包含一个元素 时，需要 在元素后面添加逗号1info_tuple = (50, ) 2.2 元组常用操作 在 ipython3 中定义一个 元组，例如：info = () 输入 info. 按下 TAB 键，ipython 会提示 元组 能够使用的函数如下： 1info.count info.index 有关 元组 的 常用操作 可以参照上图练习 2.3 循环遍历 取值 就是从 元组 中获取存储在指定位置的数据 遍历 就是 从头到尾 依次 从 元组 中获取数据 123456# for 循环内部使用的变量 in 元组for item in info: 循环内部针对元组元素进行操作 print(item) 在 Python 中，可以使用 for 循环遍历所有非数字型类型的变量：列表、元组、字典 以及 字符串 提示：在实际开发中，除非 能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多 2.4 应用场景 尽管可以使用 for in 遍历 元组 但是在开发中，更多的应用场景是： 函数的 参数 和 返回值，一个函数可以接收 任意多个参数，或者 一次返回多个数据 有关 函数的参数 和 返回值，在后续 函数高级 给大家介绍 格式字符串，格式化字符串后面的 () 本质上就是一个元组 让列表不可以被修改，以保护数据安全 1234info = (&quot;zhangsan&quot;, 18)print(&quot;%s 的年龄是 %d&quot; % info) 元组和列表之间的转换 使用 list 函数可以把元组转换成列表 1list(元组) 使用 tuple 函数可以把列表转换成元组 1tuple(列表) 03. 字典3.1 字典的定义 dictionary（字典） 是 除列表以外 Python 之中 最灵活 的数据类型 字典同样可以用来 存储多个数据 通常用于存储 描述一个 物体 的相关信息 和列表的区别 列表 是 有序 的对象集合 字典 是 无序 的对象集合 字典用 &#123;&#125; 定义 字典使用 键值对 存储数据，键值对之间使用 , 分隔 键 key 是索引 值 value 是数据 键 和 值 之间使用 : 分隔 键必须是唯一的 值 可以取任何数据类型，但 键 只能使用 字符串、数字或 元组 1234xiaoming = &#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 18, &quot;gender&quot;: True, &quot;height&quot;: 1.75&#125; 3.2 字典常用操作 在 ipython3 中定义一个 字典，例如：xiaoming = &#123;&#125; 输入 xiaoming. 按下 TAB 键，ipython 会提示 字典 能够使用的函数如下： 12345In [1]: xiaoming.xiaoming.clear xiaoming.items xiaoming.setdefaultxiaoming.copy xiaoming.keys xiaoming.updatexiaoming.fromkeys xiaoming.pop xiaoming.valuesxiaoming.get xiaoming.popitem 有关 字典 的 常用操作 可以参照上图练习 3.3 循环遍历 遍历 就是 依次 从 字典 中获取所有键值对 1234# for 循环内部使用的 `key 的变量` in 字典for k in xiaoming: print(&quot;%s: %s&quot; % (k, xiaoming[k])) 提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多 3.4 应用场景 尽管可以使用 for in 遍历 字典 但是在开发中，更多的应用场景是： 使用 多个键值对，存储 描述一个 物体 的相关信息 —— 描述更复杂的数据信息 将 多个字典 放在 一个列表 中，再进行遍历，在循环体内部针对每一个字典进行 相同的处理 12345678card_list = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;qq&quot;: &quot;12345&quot;, &quot;phone&quot;: &quot;110&quot;&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;qq&quot;: &quot;54321&quot;, &quot;phone&quot;: &quot;10086&quot;&#125; ] 04. 字符串4.1 字符串的定义 字符串 就是 一串字符，是编程语言中表示文本的数据类型 在 Python 中可以使用 一对双引号 &quot; 或者 一对单引号 &#39; 定义一个字符串 虽然可以使用 \\&quot; 或者 \\&#39; 做字符串的转义，但是在实际开发中： 如果字符串内部需要使用 &quot;，可以使用 &#39; 定义字符串 如果字符串内部需要使用 &#39;，可以使用 &quot; 定义字符串 可以使用 索引 获取一个字符串中 指定位置的字符，索引计数从 0 开始 也可以使用 for 循环遍历 字符串中每一个字符 大多数编程语言都是用 &quot; 来定义字符串 12345string = &quot;Hello Python&quot;for c in string: print(c) 4.2 字符串的常用操作 在 ipython3 中定义一个 字符串，例如：hello_str = &quot;&quot; 输入 hello_str. 按下 TAB 键，ipython 会提示 字符串 能够使用的 方法 如下： 12345678910111213141516In [1]: hello_str.hello_str.capitalize hello_str.isidentifier hello_str.rindexhello_str.casefold hello_str.islower hello_str.rjusthello_str.center hello_str.isnumeric hello_str.rpartitionhello_str.count hello_str.isprintable hello_str.rsplithello_str.encode hello_str.isspace hello_str.rstriphello_str.endswith hello_str.istitle hello_str.splithello_str.expandtabs hello_str.isupper hello_str.splitlineshello_str.find hello_str.join hello_str.startswithhello_str.format hello_str.ljust hello_str.striphello_str.format_map hello_str.lower hello_str.swapcasehello_str.index hello_str.lstrip hello_str.titlehello_str.isalnum hello_str.maketrans hello_str.translatehello_str.isalpha hello_str.partition hello_str.upperhello_str.isdecimal hello_str.replace hello_str.zfillhello_str.isdigit hello_str.rfind 提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！ 1) 判断类型 - 9 方法 说明 string.isspace() 如果 string 中只包含空格，则返回 True string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True string.isdecimal() 如果 string 只包含数字则返回 True，全角数字 string.isdigit() 如果 string 只包含数字则返回 True，全角数字、⑴、\\u00b2 string.isnumeric() 如果 string 只包含数字则返回 True，全角数字，汉字数字 string.istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 2) 查找和替换 - 7 方法 说明 string.startswith(str) 检查字符串是否是以 str 开头，是则返回 True string.endswith(str) 检查字符串是否是以 str 结束，是则返回 True string.find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 string.rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 string.index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 string.rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 string.replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 3) 大小写转换 - 5 方法 说明 string.capitalize() 把字符串的第一个字符大写 string.title() 把字符串的每个单词首字母大写 string.lower() 转换 string 中所有大写字符为小写 string.upper() 转换 string 中的小写字母为大写 string.swapcase() 翻转 string 中的大小写 4) 文本对齐 - 3 方法 说明 string.ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 string.rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 string.center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 5) 去除空白字符 - 3 方法 说明 string.lstrip() 截掉 string 左边（开始）的空白字符 string.rstrip() 截掉 string 右边（末尾）的空白字符 string.strip() 截掉 string 左右两边的空白字符 6) 拆分和连接 - 5 方法 说明 string.partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) string.rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 string.split(str=””, num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\\r’, ‘\\t’, ‘\\n’ 和空格 string.splitlines() 按照行(‘\\r’, ‘\\n’, ‘\\r\\n’)分隔，返回一个包含各行作为元素的列表 string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 4.3 字符串的切片 切片 方法适用于 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 1字符串[开始索引:结束索引:步长] 注意： 指定的区间属于 左闭右开 型 [开始索引, 结束索引) =&gt; 开始索引 &gt;= 范围 &lt; 结束索引 从 起始 位开始，到 结束位的前一位 结束（不包含结束位本身) 从头开始，开始索引 数字可以省略，冒号不能省略 到末尾结束，结束索引 数字可以省略，冒号不能省略 步长默认为 1，如果连续切片，数字和冒号都可以省略 索引的顺序和倒序 在 Python 中不仅支持 顺序索引，同时还支持 倒序索引 所谓倒序索引就是 从右向左 计算索引 最右边的索引值是 -1，依次递减 演练需求 截取从 2 ~ 5 位置 的字符串 截取从 2 ~ 末尾 的字符串 截取从 开始 ~ 5 位置 的字符串 截取完整的字符串 从开始位置，每隔一个字符截取字符串 从索引 1 开始，每隔一个取一个 截取从 2 ~ 末尾 - 1 的字符串 截取字符串末尾两个字符 字符串的逆序（面试题） 答案 123456789101112131415161718192021222324252627282930313233num_str = &quot;0123456789&quot;# 1. 截取从 2 ~ 5 位置 的字符串print(num_str[2:6])# 2. 截取从 2 ~ `末尾` 的字符串print(num_str[2:])# 3. 截取从 `开始` ~ 5 位置 的字符串print(num_str[:6])# 4. 截取完整的字符串print(num_str[:])# 5. 从开始位置，每隔一个字符截取字符串print(num_str[::2])# 6. 从索引 1 开始，每隔一个取一个print(num_str[1::2])# 倒序切片# -1 表示倒数第一个字符print(num_str[-1])# 7. 截取从 2 ~ `末尾 - 1` 的字符串print(num_str[2:-1])# 8. 截取字符串末尾两个字符print(num_str[-2:])# 9. 字符串的逆序（面试题）print(num_str[::-1]) 05. 公共方法5.1 Python 内置函数Python 包含了以下内置函数： 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key 比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key 比较 cmp(item1, item2) 比较两个值，-1 小于/0 相等/1 大于 Python 3.x 取消了 cmp 函数 注意 字符串 比较符合以下规则： “0” &lt; “A” &lt; “a” 5.2 切片 描述 Python 表达式 结果 支持的数据类型 切片 “0123456789”[::-2] “97531” 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 5.3 运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * [“Hi!”] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 &gt; &gt;= == &lt; &lt;= (1, 2, 3) &lt; (2, 2, 3) True 元素比较 字符串、列表、元组 注意 in 在对 字典 操作时，判断的是 字典的键 in 和 not in 被称为 成员运算符 成员运算符成员运算符用于 测试 序列中是否包含指定的 成员 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意：在对 字典 操作时，判断的是 字典的键 5.4 完整的 for 循环语法 在 Python 中完整的 for 循环 的语法如下： 12345for 变量 in 集合: 循环体代码else: 没有通过 break 退出循环，循环结束后，会执行的代码 应用场景 在 迭代遍历 嵌套的数据类型时，例如 一个列表包含了多个字典 需求：要判断 某一个字典中 是否存在 指定的 值 如果 存在，提示并且退出循环 如果 不存在，在 循环整体结束 后，希望 得到一个统一的提示 12345678910111213141516171819202122232425262728293031students = [ &#123;&quot;name&quot;: &quot;阿土&quot;, &quot;age&quot;: 20, &quot;gender&quot;: True, &quot;height&quot;: 1.7, &quot;weight&quot;: 75.0&#125;, &#123;&quot;name&quot;: &quot;小美&quot;, &quot;age&quot;: 19, &quot;gender&quot;: False, &quot;height&quot;: 1.6, &quot;weight&quot;: 45.0&#125;,]find_name = &quot;阿土&quot;for stu_dict in students: print(stu_dict) # 判断当前遍历的字典中姓名是否为find_name if stu_dict[&quot;name&quot;] == find_name: print(&quot;找到了&quot;) # 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较 breakelse: print(&quot;没有找到&quot;)print(&quot;循环结束&quot;)","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"函数基础","slug":"函数基础","date":"2021-03-05T12:10:58.000Z","updated":"2021-03-05T12:11:15.055Z","comments":true,"path":"20210305/函数基础.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80.html","excerpt":"","text":"函数基础目标 函数的快速体验 函数的基本使用 函数的参数 函数的返回值 函数的嵌套调用 在模块中定义函数 01. 函数的快速体验1.1 快速体验 所谓函数，就是把 具有独立功能的代码块 组织为一个小模块，在需要的时候 调用 函数的使用包含两个步骤： 定义函数 —— 封装 独立的功能 调用函数 —— 享受 封装 的成果 函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的 重用 演练步骤 新建 04_函数 项目 复制之前完成的 乘法表 文件 修改文件，增加函数定义 multiple_table(): 新建另外一个文件，使用 import 导入并且调用函数 02. 函数基本使用2.1 函数的定义定义函数的格式如下： 1234def 函数名(): 函数封装的代码 …… def 是英文 define 的缩写 函数名称 应该能够表达 函数封装代码 的功能，方便后续的调用 函数名称 的命名应该 符合 标识符的命名规则 可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 2.2 函数调用调用函数很简单的，通过 函数名() 即可完成对函数的调用 2.3 第一个函数演练需求 编写一个打招呼 say_hello 的函数，封装三行打招呼的代码 在函数下方调用打招呼的代码 12345678910111213141516name = &quot;小明&quot;# 解释器知道这里定义了一个函数def say_hello(): print(&quot;hello 1&quot;) print(&quot;hello 2&quot;) print(&quot;hello 3&quot;)print(name)# 只有在调用函数时，之前定义的函数才会被执行# 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码say_hello()print(name) 用 单步执行 F8 和 F7 观察以下代码的执行过程 定义好函数之后，只表示这个函数封装了一段代码而已 如果不主动调用函数，函数是不会主动执行的 思考 能否将 函数调用 放在 函数定义 的上方？ 不能！ 因为在 使用函数名 调用函数之前，必须要保证 Python 已经知道函数的存在 否则控制台会提示 NameError: name &#39;say_hello&#39; is not defined (名称错误：say_hello 这个名字没有被定义) 2.4 PyCharm 的调试工具 F8 Step Over 可以单步执行代码，会把函数调用看作是一行代码直接执行 F7 Step Into 可以单步执行代码，如果是函数，会进入函数内部 2.5 函数的文档注释 在开发中，如果希望给函数添加注释，应该在 定义函数 的下方，使用 连续的三对引号 在 连续的三对引号 之间编写对函数的说明文字 在 函数调用 位置，使用快捷键 CTRL + Q 可以查看函数的说明信息 注意：因为 函数体相对比较独立，函数定义的上方，应该和其他代码（包括注释）保留 两个空行 03. 函数的参数演练需求 开发一个 sum_2_num 的函数 函数能够实现 两个数字的求和 功能 演练代码如下： 12345678910def sum_2_num(): num1 = 10 num2 = 20 result = num1 + num2 print(&quot;%d + %d = %d&quot; % (num1, num2, result))sum_2_num() 思考一下存在什么问题 函数只能处理 固定数值 的相加 如何解决？ 如果能够把需要计算的数字，在调用函数时，传递到函数内部就好了！ 3.1 函数参数的使用 在函数名的后面的小括号内部填写 参数 多个参数之间使用 , 分隔 12345678def sum_2_num(num1, num2): result = num1 + num2 print(&quot;%d + %d = %d&quot; % (num1, num2, result))sum_2_num(50, 20) 3.2 参数的作用 函数，把 具有独立功能的代码块 组织为一个小模块，在需要的时候 调用 函数的参数，增加函数的 通用性，针对 相同的数据处理逻辑，能够 适应更多的数据 在函数 内部，把参数当做 变量 使用，进行需要的数据处理 函数调用时，按照函数定义的参数顺序，把 希望在函数内部处理的数据，通过参数 传递 3.3 形参和实参 形参：定义 函数时，小括号中的参数，是用来接收参数用的，在函数内部 作为变量使用 实参：调用 函数时，小括号中的参数，是用来把数据传递到 函数内部 用的 04. 函数的返回值 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 注意：return 表示返回，后续的代码都不会被执行 12345678910def sum_2_num(num1, num2): &quot;&quot;&quot;对两个数字的求和&quot;&quot;&quot; return num1 + num2# 调用函数，并使用 result 变量接收计算结果result = sum_2_num(10, 20)print(&quot;计算结果是 %d&quot; % result) 05. 函数的嵌套调用 一个函数里面 又调用 了 另外一个函数，这就是 函数嵌套调用 如果函数 test2 中，调用了另外一个函数 test1 那么执行到调用 test1 函数时，会先把函数 test1 中的任务都执行完 才会回到 test2 中调用函数 test1 的位置，继续执行后续的代码 123456789101112131415161718def test1(): print(&quot;*&quot; * 50) print(&quot;test 1&quot;) print(&quot;*&quot; * 50)def test2(): print(&quot;-&quot; * 50) print(&quot;test 2&quot;) test1() print(&quot;-&quot; * 50)test2() 函数嵌套的演练 —— 打印分隔线 体会一下工作中 需求是多变 的 需求 1 定义一个 print_line 函数能够打印 * 组成的 一条分隔线 1234def print_line(char): print(&quot;*&quot; * 50) 需求 2 定义一个函数能够打印 由任意字符组成 的分隔线 1234def print_line(char): print(char * 50) 需求 3 定义一个函数能够打印 任意重复次数 的分隔线 1234def print_line(char, times): print(char * times) 需求 4 定义一个函数能够打印 5 行 的分隔线，分隔线要求符合需求 3 提示：工作中针对需求的变化，应该冷静思考，不要轻易修改之前已经完成的，能够正常执行的函数！ 1234567891011121314def print_line(char, times): print(char * times)def print_lines(char, times): row = 0 while row &lt; 5: print_line(char, times) row += 1 06. 使用模块中的函数 模块是 Python 程序架构的一个核心概念 模块 就好比是 工具包，要想使用这个工具包中的工具，就需要 导入 import 这个模块 每一个以扩展名 py 结尾的 Python 源代码文件都是一个 模块 在模块中定义的 全局变量 、 函数 都是模块能够提供给外界直接使用的工具 6.1 第一个模块体验步骤 新建 hm_10_分隔线模块.py 复制 hm_09_打印多条分隔线.py 中的内容，最后一行 print 代码除外 增加一个字符串变量 1name = &quot;黑马程序员&quot; 新建 hm_10_体验模块.py 文件，并且编写以下代码： 1234import hm_10_分隔线模块hm_10_分隔线模块.print_line(&quot;-&quot;, 80)print(hm_10_分隔线模块.name) 体验小结 可以 在一个 Python 文件 中 定义 变量 或者 函数 然后在 另外一个文件中 使用 import 导入这个模块 导入之后，就可以使用 模块名.变量 / 模块名.函数 的方式，使用这个模块中定义的变量或者函数 模块可以让 曾经编写过的代码 方便的被 复用！ 6.2 模块名也是一个标识符 标示符可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 注意：如果在给 Python 文件起名时，以数字开头 是无法在 PyCharm 中通过导入这个模块的 6.3 Pyc 文件（了解） C 是 compiled 编译过 的意思 操作步骤 浏览程序目录会发现一个 __pycache__ 的目录 目录下会有一个 hm_10_分隔线模块.cpython-35.pyc 文件，cpython-35 表示 Python 解释器的版本 这个 pyc 文件是由 Python 解释器将 模块的源码 转换为 字节码 Python 这样保存 字节码 是作为一种启动 速度的优化 字节码 Python 在解释源程序时是分成两个步骤的 首先处理源代码，编译 生成一个二进制 字节码 再对 字节码 进行处理，才会生成 CPU 能够识别的 机器码 有了模块的字节码文件之后，下一次运行程序时，如果在 上次保存字节码之后 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤 当 Python 重编译时，它会自动检查源文件和字节码文件的时间戳 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建 提示：有关模块以及模块的其他导入方式，后续课程还会逐渐展开！ 模块是 Python 程序架构的一个核心概念","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"循环","slug":"循环","date":"2021-03-05T12:09:45.000Z","updated":"2021-03-05T12:10:02.592Z","comments":true,"path":"20210305/循环.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E5%BE%AA%E7%8E%AF.html","excerpt":"","text":"循环目标 程序的三大流程 while 循环基本使用 break 和 continue while 循环嵌套 01. 程序的三大流程 在程序开发中，一共有三种流程方式： 顺序 —— 从上向下，顺序执行代码 分支 —— 根据条件判断，决定执行代码的 分支 循环 —— 让 特定代码 重复 执行 02. while 循环基本使用 循环的作用就是让 指定的代码 重复的执行 while 循环最常用的应用场景就是 让执行的代码 按照 指定的次数 重复 执行 需求 —— 打印 5 遍 Hello Python 思考 —— 如果要求打印 100 遍怎么办？ 2.1 while 语句基本语法123456789初始条件设置 —— 通常是重复执行的 计数器while 条件(判断 计数器 是否达到 目标次数): 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件(计数器 + 1) 注意： while 语句以及缩进部分是一个 完整的代码块 第一个 while 循环需求 打印 5 遍 Hello Python 123456789101112# 1. 定义重复次数计数器i &#x3D; 1# 2. 使用 while 判断条件while i &lt;&#x3D; 5: # 要重复执行的代码 print(&quot;Hello Python&quot;) # 处理计数器 i i &#x3D; i + 1print(&quot;循环结束后的 i &#x3D; %d&quot; % i) 注意：循环结束后，之前定义的计数器条件的数值是依旧存在的 死循环 由于程序员的原因，忘记 在循环内部 修改循环的判断条件，导致循环持续执行，程序无法终止！ 2.2 赋值运算符 在 Python 中，使用 = 可以给变量赋值 在算术运算时，为了简化代码的编写，Python 还提供了一系列的 与 算术运算符 对应的 赋值运算符 注意：赋值运算符中间不能使用空格 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取 模 (余数)赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a 2.3 Python 中的计数方法常见的计数方法有两种，可以分别称为： 自然计数法（从 1 开始）—— 更符合人类的习惯 程序计数法（从 0 开始）—— 几乎所有的程序语言都选择从 0 开始计数 因此，大家在编写程序时，应该尽量养成习惯：除非需求的特殊要求，否则 循环 的计数都从 0 开始 2.4 循环计算 在程序开发中，通常会遇到 利用循环 重复计算 的需求 遇到这种需求，可以： 在 while 上方定义一个变量，用于 存放最终计算结果 在循环体内部，每次循环都用 最新的计算结果，更新 之前定义的变量 需求 计算 0 ~ 100 之间所有数字的累计求和结果 12345678910111213141516171819# 计算 0 ~ 100 之间所有数字的累计求和结果# 0. 定义最终结果的变量result = 0# 1. 定义一个整数的变量记录循环的次数i = 0# 2. 开始循环while i &lt;= 100: print(i) # 每一次循环，都让 result 这个变量和 i 这个计数器相加 result += i # 处理计数器 i += 1print(&quot;0~100之间的数字求和结果 = %d&quot; % result) 需求进阶 计算 0 ~ 100 之间 所有 偶数 的累计求和结果 开发步骤 编写循环 确认 要计算的数字 添加 结果 变量，在循环内部 处理计算结果 12345678910111213141516171819# 0. 最终结果result = 0# 1. 计数器i = 0# 2. 开始循环while i &lt;= 100: # 判断偶数 if i % 2 == 0: print(i) result += i # 处理计数器 i += 1print(&quot;0~100之间偶数求和结果 = %d&quot; % result) 03. break 和 continue break 和 continue 是专门在循环中使用的关键字 break 某一条件满足时，退出循环，不再执行后续重复的代码 continue 某一条件满足时，不执行后续重复的代码 break 和 continue 只针对 当前所在循环 有效 3.1 break 在循环过程中，如果 某一个条件满足后，不 再希望 循环继续执行，可以使用 break 退出循环 1234567891011121314i = 0while i &lt; 10: # break 某一条件满足时，退出循环，不再执行后续重复的代码 # i == 3 if i == 3: break print(i) i += 1print(&quot;over&quot;) break 只针对当前所在循环有效 3.2 continue 在循环过程中，如果 某一个条件满足后，不 希望 执行循环代码，但是又不希望退出循环，可以使用 continue 也就是：在整个循环中，只有某些条件，不需要执行循环代码，而其他条件都需要执行 1234567891011121314151617i = 0while i &lt; 10: # 当 i == 7 时，不希望执行需要重复执行的代码 if i == 7: # 在使用 continue 之前，同样应该修改计数器 # 否则会出现死循环 i += 1 continue # 重复执行的代码 print(i) i += 1 需要注意：使用 continue 时，条件处理部分的代码，需要特别注意，不小心会出现 死循环 continue 只针对当前所在循环有效 04. while 循环嵌套4.1 循环嵌套 while 嵌套就是：while 里面还有 while 123456789101112131415while 条件 1: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... while 条件 2: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件 2 处理条件 1 4.2 循环嵌套演练 —— 九九乘法表第 1 步：用嵌套打印小星星需求 在控制台连续输出五行 *，每一行星号的数量依次递增 12345*************** 使用字符串 * 打印 123456789# 1. 定义一个计数器变量，从数字1开始，循环会比较方便row = 1while row &lt;= 5: print(&quot;*&quot; * row) row += 1 第 2 步：使用循环嵌套打印小星星知识点 对 print 函数的使用做一个增强 在默认情况下，print 函数输出内容之后，会自动在内容末尾增加换行 如果不希望末尾增加换行，可以在 print 函数输出内容的后面增加 , end=&quot;&quot; 其中 &quot;&quot; 中间可以指定 print 函数输出内容之后，继续希望显示的内容 语法格式如下： 12345# 向控制台输出内容结束之后，不会换行print(&quot;*&quot;, end=&quot;&quot;)# 单纯的换行print(&quot;&quot;) end=&quot;&quot; 表示向控制台输出内容结束之后，不会换行 假设 Python 没有提供 字符串的 * 操作 拼接字符串 需求 在控制台连续输出五行 *，每一行星号的数量依次递增 12345*************** 开发步骤 1&gt; 完成 5 行内容的简单输出 2&gt; 分析每行内部的 * 应该如何处理？ 每行显示的星星和当前所在的行数是一致的 嵌套一个小的循环，专门处理每一行中 列 的星星显示 123456789101112131415161718row = 1while row &lt;= 5: # 假设 python 没有提供字符串 * 操作 # 在循环内部，再增加一个循环，实现每一行的 星星 打印 col = 1 while col &lt;= row: print(&quot;*&quot;, end=&quot;&quot;) col += 1 # 每一行星号输出完成后，再增加一个换行 print(&quot;&quot;) row += 1 第 3 步： 九九乘法表需求 输出 九九乘法表，格式如下： 123456789101 * 1 &#x3D; 1 1 * 2 &#x3D; 2 2 * 2 &#x3D; 4 1 * 3 &#x3D; 3 2 * 3 &#x3D; 6 3 * 3 &#x3D; 9 1 * 4 &#x3D; 4 2 * 4 &#x3D; 8 3 * 4 &#x3D; 12 4 * 4 &#x3D; 16 1 * 5 &#x3D; 5 2 * 5 &#x3D; 10 3 * 5 &#x3D; 15 4 * 5 &#x3D; 20 5 * 5 &#x3D; 25 1 * 6 &#x3D; 6 2 * 6 &#x3D; 12 3 * 6 &#x3D; 18 4 * 6 &#x3D; 24 5 * 6 &#x3D; 30 6 * 6 &#x3D; 36 1 * 7 &#x3D; 7 2 * 7 &#x3D; 14 3 * 7 &#x3D; 21 4 * 7 &#x3D; 28 5 * 7 &#x3D; 35 6 * 7 &#x3D; 42 7 * 7 &#x3D; 49 1 * 8 &#x3D; 8 2 * 8 &#x3D; 16 3 * 8 &#x3D; 24 4 * 8 &#x3D; 32 5 * 8 &#x3D; 40 6 * 8 &#x3D; 48 7 * 8 &#x3D; 56 8 * 8 &#x3D; 64 1 * 9 &#x3D; 9 2 * 9 &#x3D; 18 3 * 9 &#x3D; 27 4 * 9 &#x3D; 36 5 * 9 &#x3D; 45 6 * 9 &#x3D; 54 7 * 9 &#x3D; 63 8 * 9 &#x3D; 72 9 * 9 &#x3D; 81 开发步骤 打印 9 行小星星 123456789********************************************* 将每一个 * 替换成对应的行与列相乘 123456789101112131415161718192021222324# 定义起始行row = 1# 最大打印 9 行while row &lt;= 9: # 定义起始列 col = 1 # 最大打印 row 列 while col &lt;= row: # end = &quot;&quot;，表示输出结束后，不换行 # &quot;\\t&quot; 可以在控制台输出一个制表符，协助在输出文本时对齐 print(&quot;%d * %d = %d&quot; % (col, row, row * col), end=&quot;\\t&quot;) # 列数 + 1 col += 1 # 一行打印完成的换行 print(&quot;&quot;) # 行数 + 1 row += 1 字符串中的转义字符 \\t 在控制台输出一个 制表符，协助在输出文本时 垂直方向 保持对齐 \\n 在控制台输出一个 换行符 制表符 的功能是在不使用表格的情况下在 垂直方向 按列对齐文本 转义字符 描述 \\\\\\\\ 反斜杠符号 \\\\’ 单引号 \\\\” 双引号 \\n 换行 \\t 横向制表符 \\r 回车","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"运算符","slug":"运算符","date":"2021-03-05T12:06:31.000Z","updated":"2021-03-05T12:06:46.905Z","comments":true,"path":"20210305/运算符.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E8%BF%90%E7%AE%97%E7%AC%A6.html","excerpt":"","text":"运算符目标 算数运算符 比较（关系）运算符 逻辑运算符 赋值运算符 运算符的优先级 数学符号表链接：https://zh.wikipedia.org/wiki/数学符号表 01. 算数运算符 是完成基本的算术运算使用的符号，用来处理四则运算 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 12In [1]: &quot;-&quot; * 50Out[1]: &#x27;----------------------------------------&#x27; 02. 比较（关系）运算符 运算符 描述 == 检查两个操作数的值是否 相等，如果是，则条件成立，返回 True != 检查两个操作数的值是否 不相等，如果是，则条件成立，返回 True &gt; 检查左操作数的值是否 大于 右操作数的值，如果是，则条件成立，返回 True &lt; 检查左操作数的值是否 小于 右操作数的值，如果是，则条件成立，返回 True &gt;= 检查左操作数的值是否 大于或等于 右操作数的值，如果是，则条件成立，返回 True &lt;= 检查左操作数的值是否 小于或等于 右操作数的值，如果是，则条件成立，返回 True Python 2.x 中判断 不等于 还可以使用 &lt;&gt; 运算符 != 在 Python 2.x 中同样可以用来判断 不等于 03. 逻辑运算符 运算符 逻辑表达式 描述 and x and y 只有 x 和 y 的值都为 True，才会返回 True否则只要 x 或者 y 有一个值为 False，就返回 False or x or y 只要 x 或者 y 有一个值为 True，就返回 True只有 x 和 y 的值都为 False，才会返回 False not not x 如果 x 为 True，返回 False如果 x 为 False，返回 True 04. 赋值运算符 在 Python 中，使用 = 可以给变量赋值 在算术运算时，为了简化代码的编写，Python 还提供了一系列的 与 算术运算符 对应的 赋值运算符 注意：赋值运算符中间不能使用空格 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取 模 (余数)赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a 05. 运算符的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 &lt;= &lt; &gt; &gt;= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 not or and 逻辑运算符","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"判断（if）语句","slug":"判断（if）语句","date":"2021-03-05T11:59:15.000Z","updated":"2021-03-05T12:05:39.367Z","comments":true,"path":"20210305/判断（if）语句.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E5%88%A4%E6%96%AD%EF%BC%88if%EF%BC%89%E8%AF%AD%E5%8F%A5.html","excerpt":"","text":"判断（if）语句目标 开发中的应用场景 if 语句体验 if 语句进阶 综合应用 01. 开发中的应用场景生活中的判断几乎是无所不在的，我们每天都在做各种各样的选择，如果这样？如果那样？…… 程序中的判断 1234567891011121314if 今天发工资: 先还信用卡的钱 if 有剩余: 又可以happy了，O(∩_∩)O哈哈~ else: 噢，no。。。还的等30天else: 盼着发工资 判断的定义 如果 条件满足，才能做某件事情， 如果 条件不满足，就做另外一件事情，或者什么也不做 正是因为有了判断，才使得程序世界丰富多彩，充满变化！ 判断语句 又被称为 “分支语句”，正是因为有了判断，才让程序有了很多的分支 02. if 语句体验2.1 if 判断语句基本语法在 Python 中，if 语句 就是用来进行判断的，格式如下： 123if 要判断的条件: 条件成立时，要做的事情 …… 注意：代码的缩进为一个 tab 键，或者 4 个空格 —— 建议使用空格 在 Python 开发中，Tab 和空格不要混用！ 我们可以把整个 if 语句看成一个完整的代码块 2.2 判断语句演练 —— 判断年龄需求 定义一个整数变量记录年龄 判断是否满 18 岁 （&gt;=） 如果满 18 岁，允许进网吧嗨皮 12345678910# 1. 定义年龄变量age = 18# 2. 判断是否满 18 岁# if 语句以及缩进部分的代码是一个完整的代码块if age &gt;= 18: print(&quot;可以进网吧嗨皮……&quot;)# 3. 思考！- 无论条件是否满足都会执行print(&quot;这句代码什么时候执行?&quot;) 注意： if 语句以及缩进部分是一个 完整的代码块 2.3 else 处理条件不满足的情况思考 在使用 if 判断时，只能做到满足条件时要做的事情。那如果需要在 不满足条件的时候，做某些事情，该如何做呢？ 答案 else，格式如下： 123456if 要判断的条件: 条件成立时，要做的事情 ……else: 条件不成立时，要做的事情 …… 注意： if 和 else 语句以及各自的缩进部分共同是一个 完整的代码块 2.4 判断语句演练 —— 判断年龄改进需求 输入用户年龄 判断是否满 18 岁 （&gt;=） 如果满 18 岁，允许进网吧嗨皮 如果未满 18 岁，提示回家写作业 123456789101112# 1. 输入用户年龄age = int(input(&quot;今年多大了？&quot;))# 2. 判断是否满 18 岁# if 语句以及缩进部分的代码是一个完整的语法块if age &gt;= 18: print(&quot;可以进网吧嗨皮……&quot;)else: print(&quot;你还没长大，应该回家写作业！&quot;)# 3. 思考！- 无论条件是否满足都会执行print(&quot;这句代码什么时候执行?&quot;) 03. 逻辑运算 在程序开发中，通常 在判断条件时，会需要同时判断多个条件 只有多个条件都满足，才能够执行后续代码，这个时候需要使用到 逻辑运算符 逻辑运算符 可以把 多个条件 按照 逻辑 进行 连接，变成 更复杂的条件 Python 中的 逻辑运算符 包括：与 and／或 or／非 not 三种 3.1 and1条件1 and 条件2 与／并且 两个条件同时满足，返回 True 只要有一个不满足，就返回 False 条件 1 条件 2 结果 成立 成立 成立 成立 不成立 不成立 不成立 成立 不成立 不成立 不成立 不成立 3.2 or1条件1 or 条件2 或／或者 两个条件只要有一个满足，返回 True 两个条件都不满足，返回 False 条件 1 条件 2 结果 成立 成立 成立 成立 不成立 成立 不成立 成立 成立 不成立 不成立 不成立 3.3 not1not 条件 非／不是 条件 结果 成立 不成立 不成立 成立 逻辑运算演练 练习1: 定义一个整数变量 age，编写代码判断年龄是否正确 要求人的年龄在 0-120 之间 练习2: 定义两个整数变量 python_score、c_score，编写代码判断成绩 要求只要有一门成绩 &gt; 60 分就算合格 练习3: 定义一个布尔型变量 is_employee，编写代码判断是否是本公司员工 如果不是提示不允许入内 答案 1： 123456789# 练习1: 定义一个整数变量 age，编写代码判断年龄是否正确age = 100# 要求人的年龄在 0-120 之间if age &gt;= 0 and age &lt;= 120: print(&quot;年龄正确&quot;)else: print(&quot;年龄不正确&quot;) 答案 2： 123456789# 练习2: 定义两个整数变量 python_score、c_score，编写代码判断成绩python_score = 50c_score = 50# 要求只要有一门成绩 &gt; 60 分就算合格if python_score &gt; 60 or c_score &gt; 60: print(&quot;考试通过&quot;)else: print(&quot;再接再厉！&quot;) 答案 3： 123456# 练习3: 定义一个布尔型变量 `is_employee`，编写代码判断是否是本公司员工is_employee = True# 如果不是提示不允许入内if not is_employee: print(&quot;非公勿内&quot;) 04. if 语句进阶4.1 elif 在开发中，使用 if 可以 判断条件 使用 else 可以处理 条件不成立 的情况 但是，如果希望 再增加一些条件，条件不同，需要执行的代码也不同 时，就可以使用 elif 语法格式如下： 123456789101112if 条件1: 条件1满足执行的代码 ……elif 条件2: 条件2满足时，执行的代码 ……elif 条件3: 条件3满足时，执行的代码 ……else: 以上条件都不满足时，执行的代码 …… 对比逻辑运算符的代码 123if 条件1 and 条件2: 条件1满足 并且 条件2满足 执行的代码 …… 注意 elif 和 else 都必须和 if 联合使用，而不能单独使用 可以将 if、elif 和 else 以及各自缩进的代码，看成一个 完整的代码块 elif 演练 —— 女友的节日需求 定义 holiday_name 字符串变量记录节日名称 如果是 情人节 应该 买玫瑰／看电影 如果是 平安夜 应该 买苹果／吃大餐 如果是 生日 应该 买蛋糕 其他的日子每天都是节日啊…… 12345678910111213holiday_name &#x3D; &quot;平安夜&quot;if holiday_name &#x3D;&#x3D; &quot;情人节&quot;: print(&quot;买玫瑰&quot;) print(&quot;看电影&quot;)elif holiday_name &#x3D;&#x3D; &quot;平安夜&quot;: print(&quot;买苹果&quot;) print(&quot;吃大餐&quot;)elif holiday_name &#x3D;&#x3D; &quot;生日&quot;: print(&quot;买蛋糕&quot;)else: print(&quot;每天都是节日啊……&quot;) 4.2 if 的嵌套 elif 的应用场景是：同时 判断 多个条件，所有的条件是 平级 的 在开发中，使用 if 进行条件判断，如果希望 在条件成立的执行语句中 再 增加条件判断，就可以使用 if 的嵌套 if 的嵌套 的应用场景就是：在之前条件满足的前提下，再增加额外的判断 if 的嵌套 的语法格式，除了缩进之外 和之前的没有区别 语法格式如下： 12345678910111213141516if 条件 1: 条件 1 满足执行的代码 …… if 条件 1 基础上的条件 2: 条件 2 满足时，执行的代码 …… # 条件 2 不满足的处理 else: 条件 2 不满足时，执行的代码 # 条件 1 不满足的处理else: 条件1 不满足时，执行的代码 …… if 的嵌套 演练 —— 火车站安检需求 定义布尔型变量 has_ticket 表示是否有车票 定义整型变量 knife_length 表示刀的长度，单位：厘米 首先检查是否有车票，如果有，才允许进行 安检 安检时，需要检查刀的长度，判断是否超过 20 厘米 如果超过 20 厘米，提示刀的长度，不允许上车 如果不超过 20 厘米，安检通过 如果没有车票，不允许进门 12345678910111213141516171819202122# 定义布尔型变量 has_ticket 表示是否有车票has_ticket = True# 定义整数型变量 knife_length 表示刀的长度，单位：厘米knife_length = 20# 首先检查是否有车票，如果有，才允许进行 安检if has_ticket: print(&quot;有车票，可以开始安检...&quot;) # 安检时，需要检查刀的长度，判断是否超过 20 厘米 # 如果超过 20 厘米，提示刀的长度，不允许上车 if knife_length &gt;= 20: print(&quot;不允许携带 %d 厘米长的刀上车&quot; % knife_length) # 如果不超过 20 厘米，安检通过 else: print(&quot;安检通过，祝您旅途愉快……&quot;)# 如果没有车票，不允许进门else: print(&quot;大哥，您要先买票啊&quot;) 05. 综合应用 —— 石头剪刀布目标 强化 多个条件 的 逻辑运算 体会 import 导入模块（“工具包”）的使用 需求 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3） 电脑 随机 出拳 —— 先假定电脑只会出石头，完成整体代码功能 比较胜负 序号 规则 1 石头 胜 剪刀 2 剪刀 胜 布 3 布 胜 石头 5.1 基础代码实现 先 假定电脑就只会出石头，完成整体代码功能 12345678910111213141516171819# 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）player = int(input(&quot;请出拳 石头（1）／剪刀（2）／布（3）：&quot;))# 电脑 随机 出拳 - 假定电脑永远出石头computer = 1# 比较胜负# 如果条件判断的内容太长，可以在最外侧的条件增加一对大括号# 再在每一个条件之间，使用回车，PyCharm 可以自动增加 8 个空格if ((player == 1 and computer == 2) or (player == 2 and computer == 3) or (player == 3 and computer == 1)): print(&quot;噢耶！！！电脑弱爆了！！！&quot;)elif player == computer: print(&quot;心有灵犀，再来一盘！&quot;)else: print(&quot;不行，我要和你决战到天亮！&quot;) 5.2 随机数的处理 在 Python 中，要使用随机数，首先需要导入 随机数 的 模块 —— “工具包” 1import random 导入模块后，可以直接在 模块名称 后面敲一个 . 然后按 Tab 键，会提示该模块中包含的所有函数 random.randint(a, b) ，返回 [a, b] 之间的整数，包含 a 和 b 例如： 123random.randint(12, 20) # 生成的随机数n: 12 &lt;= n &lt;= 20 random.randint(20, 20) # 结果永远是 20 random.randint(20, 10) # 该语句是错误的，下限必须小于上限","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"变量的命名","slug":"变量的命名","date":"2021-03-05T05:58:41.000Z","updated":"2021-03-05T05:59:00.568Z","comments":true,"path":"20210305/变量的命名.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D.html","excerpt":"","text":"变量的命名目标 标识符和关键字 变量的命名规则 0.1 标识符和关键字1.1 标识符 标示符就是程序员定义的 变量名、函数名 名字 需要有 见名知义 的效果，见下图： 标示符可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 思考：下面的标示符哪些是正确的，哪些不正确为什么？ 123456789101112131415fromNo12from#12my_Booleanmy-BooleanObj22ndObjmyIntMy_tExt_testtest!32haha(da)ttjack_rosejack&amp;roseGUIG.U.I 1.2 关键字 关键字 就是在 Python 内部已经使用的标识符 关键字 具有特殊的功能和含义 开发者 不允许定义和关键字相同的名字的标示符 通过以下命令可以查看 Python 中的关键字 12In [1]: import keywordIn [2]: print(keyword.kwlist) 提示：关键字的学习及使用，会在后面的课程中不断介绍 import 关键字 可以导入一个 “工具包” 在 Python 中不同的工具包，提供有不同的工具 02. 变量的命名规则 命名规则 可以被视为一种 惯例，并无绝对与强制目的是为了 增加代码的识别和可读性 注意 Python 中的 标识符 是 区分大小写的 在定义变量时，为了保证代码格式，= 的左右应该各保留一个空格 在 Python 中，如果 变量名 需要由 二个 或 多个单词 组成时，可以按照以下方式命名 每个单词都使用小写字母 单词与单词之间使用 _下划线 连接 例如：first_name、last_name、qq_number、qq_password 驼峰命名法 当 变量名 是由二个或多个单词组成时，还可以利用驼峰命名法来命名 小驼峰式命名法 第一个单词以小写字母开始，后续单词的首字母大写 例如：firstName、lastName 大驼峰式命名法 每一个单词的首字母都采用大写字母 例如：FirstName、LastName、CamelCase","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"变量的基本使用","slug":"变量的基本使用","date":"2021-03-05T05:57:22.000Z","updated":"2021-03-05T05:58:06.303Z","comments":true,"path":"20210305/变量的基本使用.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html","excerpt":"","text":"变量的基本使用 程序就是用来处理数据的，而变量就是用来存储数据的 目标 变量定义 变量的类型 变量的命名 01. 变量定义 在 Python 中，每个变量 在使用前都必须赋值，变量 赋值以后 该变量 才会被创建 等号（=）用来给变量赋值 = 左边是一个变量名 = 右边是存储在变量中的值 1变量名 = 值 变量定义之后，后续就可以直接使用了 1) 变量演练1 —— iPython12345678910111213# 定义 qq_number 的变量用来保存 qq 号码In [1]: qq_number = &quot;1234567&quot;# 输出 qq_number 中保存的内容In [2]: qq_numberOut[2]: &#x27;1234567&#x27;# 定义 qq_password 的变量用来保存 qq 密码In [3]: qq_password = &quot;123&quot;# 输出 qq_password 中保存的内容In [4]: qq_passwordOut[4]: &#x27;123&#x27; 使用交互式方式，如果要查看变量内容，直接输入变量名即可，不需要使用 print 函数 2) 变量演练 2 —— PyCharm123456789# 定义 qq 号码变量qq_number = &quot;1234567&quot;# 定义 qq 密码变量qq_password = &quot;123&quot;# 在程序中，如果要输出变量的内容，需要使用 print 函数print(qq_number)print(qq_password) 使用解释器执行，如果要输出变量的内容，必须要要使用 print 函数 3) 变量演练 3 —— 超市买苹果 可以用 其他变量的计算结果 来定义变量 变量定义之后，后续就可以直接使用了 需求 苹果的价格是 8.5 元/斤 买了 7.5 斤 苹果 计算付款金额 12345678910# 定义苹果价格变量price = 8.5# 定义购买重量weight = 7.5# 计算金额money = price * weightprint(money) 思考题 如果 只要买苹果，就返 5 块钱 请重新计算购买金额 123456789101112# 定义苹果价格变量price = 8.5# 定义购买重量weight = 7.5# 计算金额money = price * weight# 只要买苹果就返 5 元money = money - 5print(money) 提问 上述代码中，一共定义有几个变量？ 三个：price／weight／money money = money - 5 是在定义新的变量还是在使用变量？ 直接使用之前已经定义的变量 变量名 只有在 第一次出现 才是 定义变量 变量名 再次出现，不是定义变量，而是直接使用之前定义过的变量 在程序开发中，可以修改之前定义变量中保存的值吗？ 可以 变量中存储的值，就是可以 变 的 02. 变量的类型 在内存中创建一个变量，会包括： 变量的名称 变量保存的数据 变量存储数据的类型 变量的地址（标示） 2.1 变量类型的演练 —— 个人信息需求 定义变量保存小明的个人信息 姓名：小明 年龄：18 岁 性别：是男生 身高：1.75 米 体重：75.0 公斤 利用 单步调试 确认变量中保存数据的类型 提问 在演练中，一共有几种数据类型？ 4 种 str —— 字符串 bool —— 布尔（真假） int —— 整数 float —— 浮点数（小数） 在 Python 中定义变量时需要指定类型吗？ 不需要 Python 可以根据 = 等号右侧的值，自动推导出变量中存储数据的类型 2.2 变量的类型 在 Python 中定义变量是 不需要指定类型（在其他很多高级语言中都需要） 数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 提示：在 Python 2.x 中，整数 根据保存数值的长度还分为： int（整数） long（长整数） 使用 type 函数可以查看一个变量的类型 1In [1]: type(name) 2.3 不同类型变量之间的计算1) 数字型变量 之间可以直接计算 在 Python 中，两个数字型变量是可以直接进行 算数运算的 如果变量是 bool 型，在计算时 True 对应的数字是 1 False 对应的数字是 0 演练步骤 定义整数 i = 10 定义浮点数 f = 10.5 定义布尔型 b = True 在 iPython 中，使用上述三个变量相互进行算术运算 2) 字符串变量 之间使用 + 拼接字符串 在 Python 中，字符串之间可以使用 + 拼接生成新的字符串 123456In [1]: first_name = &quot;三&quot;In [2]: last_name = &quot;张&quot;In [3]: first_name + last_nameOut[3]: &#x27;三张&#x27; 3) 字符串变量 可以和 整数 使用 * 重复拼接相同的字符串12In [1]: &quot;-&quot; * 50Out[1]: &#x27;--------------------------------------------------&#x27; 4) 数字型变量 和 字符串 之间 不能进行其他计算12345678In [1]: first_name = &quot;zhang&quot;In [2]: x = 10In [3]: x + first_name---------------------------------------------------------------------------TypeError: unsupported operand type(s) for +: &#x27;int&#x27; and &#x27;str&#x27;类型错误：`+` 不支持的操作类型：`int` 和 `str` 2.4 变量的输入 所谓 输入，就是 用代码 获取 用户通过 键盘 输入的信息 例如：去银行取钱，在 ATM 上输入密码 在 Python 中，如果要获取用户在 键盘 上的输入信息，需要使用到 input 函数 1) 关于函数 一个 提前准备好的功能(别人或者自己写的代码)，可以直接使用，而 不用关心内部的细节 目前已经学习过的函数 函数 说明 print(x) 将 x 输出到控制台 type(x) 查看 x 的变量类型 2) input 函数实现键盘输入 在 Python 中可以使用 input 函数从键盘等待用户的输入 用户输入的 任何内容 Python 都认为是一个 字符串 语法如下： 1字符串变量 = input(&quot;提示信息：&quot;) 3) 类型转换函数 函数 说明 int(x) 将 x 转换为一个整数 float(x) 将 x 转换到一个浮点数 4) 变量输入演练 —— 超市买苹果增强版需求 收银员输入 苹果的价格，单位：元／斤 收银员输入 用户购买苹果的重量，单位：斤 计算并且 输出 付款金额 演练方式 11234567891011121314151617# 1. 输入苹果单价price_str = input(&quot;请输入苹果价格：&quot;)# 2. 要求苹果重量weight_str = input(&quot;请输入苹果重量：&quot;)# 3. 计算金额# 1&gt; 将苹果单价转换成小数price = float(price_str)# 2&gt; 将苹果重量转换成小数weight = float(weight_str)# 3&gt; 计算付款金额money = price * weightprint(money) 提问 演练中，针对 价格 定义了几个变量？ 两个 price_str 记录用户输入的价格字符串 price 记录转换后的价格数值 思考 —— 如果开发中，需要用户通过控制台 输入 很多个 数字，针对每一个数字都要定义两个变量，方便吗？ 演练方式 2 —— 买苹果改进版 定义 一个 浮点变量 接收用户输入的同时，就使用 float 函数进行转换 1price = float(input(&quot;请输入价格:&quot;)) 改进后的好处： 节约空间，只需要为一个变量分配空间 起名字方便，不需要为中间变量起名字 改进后的“缺点”： 初学者需要知道，两个函数能够嵌套使用，稍微有一些难度 提示 如果输入的不是一个数字，程序执行时会出错，有关数据转换的高级话题，后续会讲！ 2.5 变量的格式化输出 苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元 在 Python 中可以使用 print 函数将信息输出到控制台 如果希望输出文字信息的同时，一起输出 数据，就需要使用到 格式化操作符 % 被称为 格式化操作符，专门用于处理字符串中的格式 包含 % 的字符串，被称为 格式化字符串 % 和不同的 字符 连用，不同类型的数据 需要使用 不同的格式化字符 格式化字符 含义 %s 字符串 %d 有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全 %f 浮点数，%.2f 表示小数点后只显示两位 %% 输出 % 语法格式如下： 123print(&quot;格式化字符串&quot; % 变量1)print(&quot;格式化字符串&quot; % (变量1, 变量2...)) 格式化输出演练 —— 基本练习需求 定义字符串变量 name，输出 我的名字叫 小明，请多多关照！ 定义整数变量 student_no，输出 我的学号是 000001 定义小数 price、weight、money，输出 苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元 定义一个小数 scale，输出 数据比例是 10.00% 1234print(&quot;我的名字叫 %s，请多多关照！&quot; % name)print(&quot;我的学号是 %06d&quot; % student_no)print(&quot;苹果单价 %.02f 元／斤，购买 %.02f 斤，需要支付 %.02f 元&quot; % (price, weight, money))print(&quot;数据比例是 %.02f%%&quot; % (scale * 100)) 课后练习 —— 个人名片需求 在控制台依次提示用户输入：姓名、公司、职位、电话、邮箱 按照以下格式输出： 12345678**************************************************公司名称姓名 (职位)电话：电话邮箱：邮箱************************************************** 实现代码如下： ```python“””在控制台依次提示用户输入：姓名、公司、职位、电话、电子邮箱“””name = input(“请输入姓名：”)company = input(“请输入公司：”)title = input(“请输入职位：”)phone = input(“请输入电话：”)email = input(“请输入邮箱：”) print(““ 50)print(company)print()print(“%s (%s)” % (name, title))print()print(“电话：%s” % phone)","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"程序执行原理","slug":"程序执行原理","date":"2021-03-05T05:56:15.000Z","updated":"2021-03-05T05:56:41.145Z","comments":true,"path":"20210305/程序执行原理.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.html","excerpt":"","text":"程序执行原理（科普）目标 计算机中的 三大件 程序执行的原理 程序的作用 01. 计算机中的三大件计算机中包含有较多的硬件，但是一个程序要运行，有 三个 核心的硬件，分别是： CPU 中央处理器，是一块超大规模的集成电路 负责 处理数据／计算 内存 临时 存储数据（断电之后，数据会消失） 速度快 空间小（单位价格高） 硬盘 永久 存储数据 速度慢 空间大（单位价格低） CPU 内存 硬盘 思考题 计算机中哪一个硬件设备负责执行程序？ CPU 内存 的速度快还是 硬盘 的速度快？ 内存 我们的程序是安装在内存中的，还是安装在硬盘中的？ 硬盘 我买了一个内存条，有 500G 的空间！！！，这句话对吗？ 不对，内存条通常只有 4G / 8G / 16G / 32G 计算机关机之后，内存中的数据都会消失，这句话对吗？ 正确 02. 程序执行的原理 程序 运行之前，程序是 保存在硬盘 中的 当要运行一个程序时 操作系统会首先让 CPU 把程序复制到 内存 中 CPU 执行 内存 中的 程序代码 程序要执行，首先要被加载到内存 2.1 Python 程序执行原理 操作系统会首先让 CPU 把 Python 解释器 的程序复制到 内存 中 Python 解释器 根据语法规则，从上向下 让 CPU 翻译 Python 程序中的代码 CPU 负责执行翻译完成的代码 Python 的解释器有多大？ 执行以下终端命令可以查看 Python 解释器的大小 12345678# 1. 确认解释器所在位置$ which python# 2. 查看 python 文件大小(只是一个软链接)$ ls -lh /usr/bin/python# 3. 查看具体文件大小$ ls -lh /usr/bin/python2.7 提示：建立 软链接 的目的，是为了方便使用者不用记住使用的解释器是 哪一个具体版本 03. 程序的作用 程序就是 用来处理数据 的！ 新闻软件 提供的 新闻内容、评论…… 是数据 电商软件 提供的 商品信息、配送信息…… 是数据 运动类软件 提供的 运动数据…… 是数据 地图类软件 提供的 地图信息、定位信息、车辆信息…… 是数据 即时通讯软件 提供的 聊天信息、好友信息…… 是数据 …… 3.1 思考 QQ 程序的启动过程 QQ 在运行之前，是保存在 硬盘 中的 运行之后，QQ 程序就会被加载到 内存 中了 3.2 思考 QQ 程序的 登录 过程 读取用户输入的 QQ 号码 读取用户输入的 QQ 密码 将 QQ 号码 和 QQ 密码 发送给腾讯的服务器，等待服务器确认用户信息 思考 1 在 QQ 这个程序将 QQ 号码 和 QQ 密码 发送给服务器之前，是否需要先存储一下 QQ 号码 和 密码? 答案 肯定需要！—— 否则 QQ 这个程序就不知道把什么内容发送给服务器了！ 思考 2 QQ 这个程序把 QQ 号码 和 QQ 密码 保存在哪里？ 答案 保存在 内存 中，因为 QQ 程序自己就在内存中 思考 3 QQ 这个程序是怎么保存用户的 QQ 号码 和 QQ 密码 的？ 答案 在内存中为 QQ 号码 和 QQ 密码 各自分配一块空间 在 QQ 程序结束之前，这两块空间是由 QQ 程序负责管理的，其他任何程序都不允许使用 在 QQ 自己使用完成之前，这两块空间始终都只负责保存 QQ 号码 和 QQ 密码 使用一个 别名 标记 QQ 号码 和 QQ 密码 在内存中的位置 在程序内部，为 QQ 号码 和 QQ 密码 在内存中分配的空间就叫做 变量 程序就是用来处理数据的，而变量就是用来存储数据的","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"算数运算符","slug":"算数运算符","date":"2021-03-05T05:54:25.000Z","updated":"2021-03-05T05:54:58.023Z","comments":true,"path":"20210305/算数运算符.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6.html","excerpt":"","text":"算数运算符计算机，顾名思义就是负责进行 数学计算 并且 存储计算结果 的电子设备 目标 算术运算符的基本使用 01. 算数运算符 算数运算符是 运算符的一种 是完成基本的算术运算使用的符号，用来处理四则运算 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 12In [1]: &quot;-&quot; * 50Out[1]: &#x27;----------------------------------------&#x27; 02. 算数运算符的优先级 和数学中的运算符的优先级一致，在 Python 中进行数学计算时，同样也是： 先乘除后加减 同级运算符是 从左至右 计算 可以使用 () 调整计算的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 例如： 2 + 3 * 5 = 17 (2 + 3) * 5 = 25 2 * 3 + 5 = 11 2 * (3 + 5) = 16","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"注释","slug":"注释","date":"2021-03-05T05:53:10.000Z","updated":"2021-03-05T05:53:31.647Z","comments":true,"path":"20210305/注释.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E6%B3%A8%E9%87%8A.html","excerpt":"","text":"注释目标 注释的作用 单行注释（行注释） 多行注释（块注释） 01. 注释的作用 使用用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性 02. 单行注释(行注释) 以 # 开头，# 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用 示例代码如下： 12# 这是第一个单行注释print(&quot;hello python&quot;) 为了保证代码的可读性，# 后面建议先添加一个空格，然后再编写相应的说明文字 在代码后面增加的单行注释 在程序开发时，同样可以使用 # 在代码的后面（旁边）增加说明性的文字 但是，需要注意的是，为了保证代码的可读性，注释和代码之间 至少要有 两个空格 示例代码如下： 1print(&quot;hello python&quot;) # 输出 `hello python` 03. 多行注释（块注释） 如果希望编写的 注释信息很多，一行无法显示，就可以使用多行注释 要在 Python 程序中使用多行注释，可以用 一对 连续的 三个 引号(单引号和双引号都可以) 示例代码如下： 123456&quot;&quot;&quot;这是一个多行注释在多行注释之间，可以写很多很多的内容……&quot;&quot;&quot; print(&quot;hello python&quot;) 什么时候需要使用注释？ 注释不是越多越好，对于一目了然的代码，不需要添加注释 对于 复杂的操作，应该在操作开始前写上若干行注释 对于 不是一目了然的代码，应在其行尾添加注释（为了提高可读性，注释应该至少离开代码 2 个空格） 绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么 在一些正规的开发团队，通常会有 代码审核 的惯例，就是一个团队中彼此阅读对方的代码 关于代码规范 Python 官方提供有一系列 PEP（Python Enhancement Proposals） 文档 其中第 8 篇文档专门针对 Python 的代码格式 给出了建议，也就是俗称的 PEP 8 文档地址：https://www.python.org/dev/peps/pep-0008/ 谷歌有对应的中文文档：http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/ 任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"多文件项目的演练","slug":"多文件项目的演练","date":"2021-03-05T05:49:51.000Z","updated":"2021-03-05T05:50:25.330Z","comments":true,"path":"20210305/多文件项目的演练.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E5%A4%9A%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%BC%94%E7%BB%83.html","excerpt":"","text":"多文件项目的演练 开发 项目 就是开发一个 专门解决一个复杂业务功能的软件 通常每 一个项目 就具有一个 独立专属的目录，用于保存 所有和项目相关的文件 一个项目通常会包含 很多源文件 目标 在项目中添加多个文件，并且设置文件的执行 多文件项目演练 在 01_Python基础 项目中新建一个 hm_02_第2个Python程序.py 在 hm_02_第2个Python程序.py 文件中添加一句 print(&quot;hello&quot;) 点击右键执行 hm_02_第2个Python程序.py 提示 在 PyCharm 中，要想让哪一个 Python 程序能够执行，必须首先通过 鼠标右键的方式执行 一下 对于初学者而言，在一个项目中设置多个程序可以执行，是非常方便的，可以方便对不同知识点的练习和测试 对于商业项目而言，通常在一个项目中，只有一个 可以直接执行的 Python 源程序","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"python的初始设置","slug":"python的初始设置","date":"2021-03-05T05:48:27.000Z","updated":"2021-03-05T05:49:01.701Z","comments":true,"path":"20210305/python的初始设置.html","link":"","permalink":"https://xxren8218.github.io/20210305/python%E7%9A%84%E5%88%9D%E5%A7%8B%E8%AE%BE%E7%BD%AE.html","excerpt":"","text":"PyCharm 的初始设置（知道）目标 恢复 PyCharm 的初始设置 第一次启动 PyCharm 新建一个 Python 项目 设置 PyCharm 的字体显示 PyCharm 的升级以及其他 PyCharm 的官方网站地址是：https://www.jetbrains.com/pycharm/ 01. 恢复 PyCharm 的初始设置PyCharm 的 配置信息 是保存在 用户家目录下 的 .PyCharmxxxx.x 目录下的，xxxx.x 表示当前使用的 PyCharm 的版本号 如果要恢复 PyCharm 的初始设置，可以按照以下步骤进行： 关闭正在运行的 PyCharm 在终端中执行以下终端命令，删除 PyCharm 的配置信息目录： 1$ rm -r ~/.PyCharm2016.3 重新启动 PyCharm 02. 第一次启动 PyCharm 导入配置信息 选择许可协议 配置初始界面 2.1 导入配置信息 在第一次启动 PyCharm 时，会首先提示用户是否导入 之前的配置信息 如果是第一次使用，直接点击 OK 按钮 2.2 选择许可协议 PyCharm 是一个付费软件，购买费用为 199$ / 年 或者 19.90$ ／ 月 不过 PyCharm 提供了对 学生和教师免费使用的版本 下载地址是：https://www.jetbrains.com/pycharm-edu/download/#section=linux 商业版本会提示输入注册信息，或者选择免费评估 2.3 PyCharm 的配置初始界面 在初始配置界面，可以通过 Editor colors and fonts 选择 编辑器的配色方案 2.4 欢迎界面 所有基础配置工作结束之后，就可以看到 PyCharm 的 欢迎界面了，通过 欢迎界面 就可以开始开发 Python 项目了 03. 新建/打开一个 Python 项目3.1 项目简介 开发 项目 就是开发一个 专门解决一个复杂业务功能的软件 通常每 一个项目 就具有一个 独立专属的目录，用于保存 所有和项目相关的文件 一个项目通常会包含 很多源文件 3.2 打开 Python 项目 直接点击 Open 按钮，然后浏览到之前保存 Python 文件的目录，既可以打开项目 打开之后，会在目录下新建一个 .idea 的目录，用于保存 项目相关的信息，例如：解释器版本、项目包含的文件等等 第一次打开项目，需要耐心等待 PyCharm 对项目进行初始设置 设置项目使用的解释器版本 打开的目录如果不是由 PyCharm 建立的项目目录，有的时候 使用的解释器版本是 Python 2.x 的，需要单独设置解释器的版本 通过 File / Settings… 可以打开设置窗口，如下图所示： 3.3 新建项目1) 命名规则 以后 项目名 前面都以 数字编号，随着知识点递增，编号递增 例如：01_Python 基础、02_分支、03_循环… 每个项目下的 文件名 都以 hm_xx_知识点 方式来命名 其中 xx 是演练文件的序号 注意 命名文件名时建议只使用 小写字母、数字 和 下划线 文件名不能以数字开始 通过 欢迎界面 或者菜单 File / New Project 可以新建项目 2) 演练步骤 新建 01_Python基础 项目，使用 Python 3.x 解释器 在项目下新建 hm_01_hello.py Python 文件 编写 print(&quot;Hello Python&quot;) 代码 04. 设置 PyCharm 的字体显示 05. PyCharm 的升级以及其他 PyCharm 提供了对 学生和教师免费使用的版本 教育版下载地址：https://www.jetbrains.com/pycharm-edu/download/#section=linux 专业版下载地址：https://www.jetbrains.com/pycharm/download/#section=linux 5.1 安装和启动步骤 执行以下终端命令，解压缩下载后的安装包 1$ tar -zxvf pycharm-professional-2017.1.3.tar.gz 将解压缩后的目录移动到 /opt 目录下，可以方便其他用户使用 /opt 目录用户存放给主机额外安装的软件 1$ sudo mv pycharm-2017.1.3/ /opt/ 切换工作目录 1$ cd /opt/pycharm-2017.1.3/bin 启动 PyCharm 1$ ./pycharm.sh 5.2 设置专业版启动图标 在专业版中，选择菜单 Tools / Create Desktop Entry… 可以设置任务栏启动图标 注意：设置图标时，需要勾选 Create the entry for all users 5.3 卸载之前版本的 PyCharm1) 程序安装 程序文件目录 将安装包解压缩，并且移动到 /opt 目录下 所有的相关文件都保存在解压缩的目录中 配置文件目录 启动 PyCharm 后，会在用户家目录下建立一个 .PyCharmxxx 的隐藏目录 保存 PyCharm 相关的配置信息 快捷方式文件 /usr/share/applications/jetbrains-pycharm.desktop 在 ubuntu 中，应用程序启动的快捷方式通常都保存在 /usr/share/applications 目录下 2) 程序卸载 要卸载 PyCharm 只需要做以下两步工作： 删除解压缩目录 1$ sudo rm -r /opt/pycharm-2016.3.1/ 删除家目录下用于保存配置信息的隐藏目录 1$ rm -r ~/.PyCharm2016.3/ 如果不再使用 PyCharm 还需要将 /usr/share/applications/ 下的 jetbrains-pycharm.desktop 删掉 5.4 教育版安装演练12345678# 1. 解压缩下载后的安装包$ tar -zxvf pycharm-edu-3.5.1.tar.gz# 2. 将解压缩后的目录移动到 `/opt` 目录下，可以方便其他用户使用$ sudo mv pycharm-edu-3.5.1/ /opt/# 3. 启动 `PyCharm`/opt/pycharm-edu-3.5.1/bin/pycharm.sh 后续课程都使用专业版本演练 设置启动图标 编辑快捷方式文件 1$ sudo gedit /usr/share/applications/jetbrains-pycharm.desktop 按照以下内容修改文件内容，需要注意指定正确的 pycharm 目录 12345678910[Desktop Entry]Version=1.0Type=ApplicationName=PyCharmIcon=/opt/pycharm-edu-3.5.1/bin/pycharm.pngExec=&quot;/opt/pycharm-edu-3.5.1/bin/pycharm.sh&quot; %fComment=The Drive to DevelopCategories=Development;IDE;Terminal=falseStartupWMClass=jetbrains-pycharm","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"第一个python程序","slug":"第一个python程序","date":"2021-03-05T05:46:26.000Z","updated":"2021-03-05T05:47:11.023Z","comments":true,"path":"20210305/第一个python程序.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E7%AC%AC%E4%B8%80%E4%B8%AApython%E7%A8%8B%E5%BA%8F.html","excerpt":"","text":"第一个 Python 程序目标 第一个 HelloPython 程序 Python 2.x 与 3.x 版本简介 执行 Python 程序的三种方式 解释器 —— python / python3 交互式 —— ipython 集成开发环境 —— PyCharm 01. 第一个 HelloPython 程序1.1 Python 源程序的基本概念 Python 源程序就是一个特殊格式的文本文件，可以使用任意文本编辑软件做 Python 的开发 Python 程序的 文件扩展名 通常都是 .py 1.2 演练步骤 在桌面下，新建 认识Python 目录 在 认识Python 目录下新建 01-HelloPython.py 文件 使用 gedit 编辑 01-HelloPython.py 并且输入以下内容： 12print(&quot;hello python&quot;)print(&quot;hello world&quot;) 在终端中输入以下命令执行 01-HelloPython.py 1$ python 01-HelloPython.py print 是 python 中我们学习的第一个 函数 print 函数的作用，可以把 “” 内部的内容，输出到屏幕上 1.3 演练扩展 —— 认识错误（BUG）关于错误 编写的程序不能正常执行，或者执行的结果不是我们期望的 俗称 BUG，是程序员在开发时非常常见的，初学者常见错误的原因包括： 手误 对已经学习过的知识理解还存在不足 对语言还有需要学习和提升的内容 在学习语言时，不仅要学会语言的语法，而且还要学会如何认识错误和解决错误的方法 每一个程序员都是在不断地修改错误中成长的 第一个演练中的常见错误 1&gt; 手误，例如使用 pirnt(&quot;Hello world&quot;) 123NameError: name &#x27;pirnt&#x27; is not defined名称错误：&#x27;pirnt&#x27; 名字没有定义 2&gt; 将多条 print 写在一行 123SyntaxError: invalid syntax语法错误：语法无效 每行代码负责完成一个动作 3&gt; 缩进错误 123IndentationError: unexpected indent缩进错误：不期望出现的缩进 Python 是一个格式非常严格的程序设计语言 目前而言，大家记住每行代码前面都不要增加空格 4&gt; python 2.x 默认不支持中文 目前市场上有两个 Python 的版本并存着，分别是 Python 2.x 和 Python 3.x Python 2.x 默认不支持中文，具体原因，等到介绍 字符编码 时给大家讲解 Python 2.x 的解释器名称是 python Python 3.x 的解释器名称是 python3 123456SyntaxError: Non-ASCII character &#x27;\\xe4&#x27; in file 01-HelloPython.py on line 3, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details语法错误： 在 01-HelloPython.py 中第 3 行出现了非 ASCII 字符 &#x27;\\xe4&#x27;，但是没有声明文件编码请访问 http://python.org/dev/peps/pep-0263/ 了解详细信息 ASCII 字符只包含 256 个字符，不支持中文 有关字符编码的问题，后续会讲 单词列表12345678910111213* error 错误* name 名字* defined 已经定义* syntax 语法* invalid 无效* Indentation 索引* unexpected 意外的，不期望的* character 字符* line 行* encoding 编码* declared 声明* details 细节，详细信息* ASCII 一种字符编码 02. Python 2.x 与 3​​.x 版本简介目前市场上有两个 Python 的版本并存着，分别是 Python 2.x 和 Python 3.x 新的 Python 程序建议使用 Python 3.0 版本的语法 Python 2.x 是 过去的版本 解释器名称是 python Python 3.x 是 现在和未来 主流的版本 解释器名称是 python3 相对于 Python 的早期版本，这是一个 较大的升级 为了不带入过多的累赘，Python 3.0 在设计的时候 没有考虑向下兼容 许多早期 Python 版本设计的程序都无法在 Python 3.0 上正常执行 Python 3.0 发布于 2008 年 到目前为止，Python 3.0 的稳定版本已经有很多年了 Python 3.3 发布于 2012 Python 3.4 发布于 2014 Python 3.5 发布于 2015 Python 3.6 发布于 2016 为了照顾现有的程序，官方提供了一个过渡版本 —— Python 2.6 基本使用了 Python 2.x 的语法和库 同时考虑了向 Python 3.0 的迁移，允许使用部分 Python 3.0 的语法与函数 2010 年中推出的 Python 2.7 被确定为 最后一个Python 2.x 版本 提示：如果开发时，无法立即使用 Python 3.0（还有极少的第三方库不支持 3.0 的语法），建议 先使用 Python 3.0 版本进行开发 然后使用 Python 2.6、Python 2.7 来执行，并且做一些兼容性的处理 03. 执行 Python 程序的三种方式3.1. 解释器 python / python3Python 的解释器12345# 使用 python 2.x 解释器$ python xxx.py# 使用 python 3.x 解释器$ python3 xxx.py 其他解释器（知道）Python 的解释器 如今有多个语言的实现，包括： CPython —— 官方版本的 C 语言实现 Jython —— 可以运行在 Java 平台 IronPython —— 可以运行在 .NET 和 Mono 平台 PyPy —— Python 实现的，支持 JIT 即时编译 3.2. 交互式运行 Python 程序 直接在终端中运行解释器，而不输入要执行的文件名 在 Python 的 Shell 中直接输入 Python 的代码，会立即看到程序执行结果 1) 交互式运行 Python 的优缺点优点 适合于学习/验证 Python 语法或者局部代码 缺点 代码不能保存 不适合运行太大的程序 2) 退出 官方的解释器1&gt; 直接输入 exit()1&gt;&gt;&gt; exit() 2&gt; 使用热键退出在 python 解释器中，按热键 ctrl + d 可以退出解释器 3) IPython IPython 中 的 “I” 代表 交互 interactive 特点 IPython 是一个 python 的 交互式 shell，比默认的 python shell 好用得多 支持自动补全 自动缩进 支持 bash shell 命令 内置了许多很有用的功能和函数 IPython 是基于 BSD 开源的 版本 Python 2.x 使用的解释器是 ipython Python 3.x 使用的解释器是 ipython3 要退出解释器可以有以下两种方式： 1&gt; 直接输入 exit1In [1]: exit 2&gt; 使用热键退出在 IPython 解释器中，按热键 ctrl + d，IPython 会询问是否退出解释器 IPython 的安装1$ sudo apt install ipython 3.3. Python 的 IDE —— PyCharm1） 集成开发环境（IDE）集成开发环境（IDE，Integrated Development Environment）—— 集成了开发软件需要的所有工具，一般包括以下工具： 图形用户界面 代码编辑器（支持 代码补全／自动缩进） 编译器／解释器 调试器（断点／单步执行） …… 2）PyCharm 介绍 PyCharm 是 Python 的一款非常优秀的集成开发环境 PyCharm 除了具有一般 IDE 所必备功能外，还可以在 Windows、Linux、macOS 下使用 PyCharm 适合开发大型项目 一个项目通常会包含 很多源文件 每个 源文件 的代码行数是有限的，通常在几百行之内 每个 源文件 各司其职，共同完成复杂的业务功能 3）PyCharm 快速体验 文件导航区域 能够 浏览／定位／打开 项目文件 文件编辑区域 能够 编辑 当前打开的文件 控制台区域 能够： 输出程序执行内容 跟踪调试代码的执行 右上角的 工具栏 能够 执行(SHIFT + F10) / 调试(SHIFT + F9) 代码 通过控制台上方的单步执行按钮(F8)，可以单步执行代码","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"认识puthon","slug":"认识puthon","date":"2021-03-05T05:45:12.000Z","updated":"2021-03-05T05:45:41.469Z","comments":true,"path":"20210305/认识puthon.html","link":"","permalink":"https://xxren8218.github.io/20210305/%E8%AE%A4%E8%AF%86puthon.html","excerpt":"","text":"认识 Python 人生苦短，我用 Python —— Life is short, you need Python 目标 Python 的起源 为什么要用 Python？ Python 的特点 Python 的优缺点 01. Python 的起源 Python 的创始人为吉多·范罗苏姆（Guido van Rossum） 1989 年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的解释程序，作为 ABC 语言的一种继承（感觉下什么叫牛人） ABC 是由吉多参加设计的一种教学语言，就吉多本人看来，ABC 这种语言非常优美和强大，是专门为非专业程序员设计的。但是 ABC 语言并没有成功，究其原因，吉多认为是非开放造成的。吉多决心在 Python 中避免这一错误，并获取了非常好的效果 之所以选中 Python（蟒蛇） 作为程序的名字，是因为他是 BBC 电视剧——蒙提·派森的飞行马戏团（Monty Python’s Flying Circus）的爱好者 1991 年，第一个 Python 解释器 诞生，它是用 C 语言实现的，并能够调用 C 语言的库文件 1.1 解释器（科普）计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。将其他语言翻译成机器语言的工具，被称为编译器 编译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译时间点的不同。当编译器以解释方式运行的时候，也称之为解释器 编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++ 解释型语言：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行 编译型语言和解释型语言对比 速度 —— 编译型语言比解释型语言执行速度快 跨平台性 —— 解释型语言比编译型语言跨平台性好 1.2 Python 的设计目标1999 年，吉多·范罗苏姆向 DARPA 提交了一条名为 “Computer Programming for Everybody” 的资金申请，并在后来说明了他对 Python 的目标： 一门简单直观的语言并与主要竞争者一样强大 开源，以便任何人都可以为它做贡献 代码像纯英语那样容易理解 适用于短期开发的日常任务 这些想法中的基本都已经成为现实，Python 已经成为一门流行的编程语言 1.3 Python 的设计哲学 优雅 明确 简单 Python 开发者的哲学是：用一种方法，最好是只有一种方法来做一件事 如果面临多种选择，Python 开发者一般会拒绝花俏的语法，而选择明确没有或者很少有歧义的语法 在 Python 社区，吉多被称为“仁慈的独裁者” 02. 为什么选择 Python？ 代码量少 …… 同一样问题，用不同的语言解决，代码量差距还是很多的，一般情况下 Python 是 Java 的 1/5，所以说 人生苦短，我用 Python 03. Python 特点 Python 是完全面向对象的语言 函数、模块、数字、字符串都是对象，在 Python 中一切皆对象 完全支持继承、重载、多重继承 支持重载运算符，也支持泛型设计 Python 拥有一个强大的标准库，Python 语言的核心只包含 数字、字符串、列表、字典、文件 等常见类型和函数，而由 Python 标准库提供了 系统管理、网络通信、文本处理、数据库接口、图形系统、XML 处理 等额外的功能 Python 社区提供了大量的第三方模块，使用方式与标准库类似。它们的功能覆盖 科学计算、人工智能、机器学习、Web 开发、数据库接口、图形系统 多个领域 面向对象的思维方式 面向对象 是一种 思维方式，也是一门 程序设计技术 要解决一个问题前，首先考虑 由谁 来做，怎么做事情是 谁 的职责，最后把事情做好就行！ 对象 就是 谁 要解决复杂的问题，就可以找多个不同的对象，各司其职，共同实现，最终完成需求 04. Python 的优缺点4.1 优点 简单、易学 免费、开源 面向对象 丰富的库 可扩展性 如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 C 或 C++ 编写，然后在 Python 程序中使用它们 …… 4.2 缺点 运行速度 国内市场较小 中文资料匮乏","categories":[{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"vi-终端中的编辑器","slug":"vi-终端中的编辑器","date":"2021-03-05T05:33:14.000Z","updated":"2021-03-05T05:38:24.231Z","comments":true,"path":"20210305/vi-终端中的编辑器.html","link":"","permalink":"https://xxren8218.github.io/20210305/vi-%E7%BB%88%E7%AB%AF%E4%B8%AD%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8.html","excerpt":"摘要：vim的笔记。","text":"摘要：vim的笔记。 目标 vi 简介 打开和新建文件 三种工作模式 常用命令 分屏命令 常用命令速查图 01. vi 简介1.1 学习 vi 的目的 在工作中，要对 服务器 上的文件进行 简单 的修改，可以使用 ssh 远程登录到服务器上，并且使用 vi 进行快速的编辑即可 常见需要修改的文件包括： 源程序 配置文件，例如 ssh 的配置文件 ~/.ssh/config 在没有图形界面的环境下，要编辑文件，vi 是最佳选择！ 每一个要使用 Linux 的程序员，都应该或多或少的学习一些 vi 的常用命令 1.2 vi 和 vim 在很多 Linux 发行版中，直接把 vi 做成 vim 的软连接 vi vi 是 Visual interface 的简称，是 Linux 中 最经典 的文本编辑器 vi 的核心设计思想 —— 让程序员的手指始终保持在键盘的核心区域，就能完成所有的编辑操作 vi 的特点： 没有图形界面 的 功能强大 的编辑器 只能是编辑 文本内容，不能对字体、段落进行排版 不支持鼠标操作 没有菜单 只有命令 vi 编辑器在 系统管理、服务器管理 编辑文件时，其功能永远不是图形界面的编辑器能比拟的 vimvim = vi improved vim 是从 vi 发展出来的一个文本编辑器，支持 代码补全、编译 及 错误跳转 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 编辑器之神 查询软连接命令（知道） 在很多 Linux 发行版中直接把 vi 做成 vim 的软连接 123456789101112# 查找 vi 的运行文件$ which vi$ ls -l /usr/bin/vi$ ls -l /etc/alternatives/vi$ ls -l /usr/bin/vim.basic# 查找 vim 的运行文件$ which vim$ ls -l /usr/bin/vim$ ls -l /etc/alternatives/vim$ ls -l /usr/bin/vim.basic 02. 打开和新建文件 在终端中输入 vi 在后面跟上文件名 即可 1$ vi 文件名 如果文件已经存在，会直接打开该文件 如果文件不存在，会新建一个文件 2.1 打开文件并且定位行 在日常工作中，有可能会遇到 打开一个文件，并定位到指定行 的情况 例如：在开发时，知道某一行代码有错误，可以 快速定位 到出错代码的位置 这个时候，可以使用以下命令打开文件 1$ vi 文件名 +行数 提示：如果只带上 + 而不指定行号，会直接定位到文件末尾 2.2 异常处理 如果 vi 异常退出，在磁盘上可能会保存有 交换文件 下次再使用 vi 编辑该文件时，会看到以下屏幕信息，按下字母 d 可以 删除交换文件 即可 提示：按下键盘时，注意关闭输入法 03. 三种工作模式 vi 有三种基本工作模式： 命令模式 打开文件首先进入命令模式，是使用 vi 的 入口 通过 命令 对文件进行常规的编辑操作，例如：定位、翻页、复制、粘贴、删除…… 在其他图形编辑器下，通过 快捷键 或者 鼠标 实现的操作，都在 命令模式 下实现 末行模式 —— 执行 保存、退出 等操作 要退出 vi 返回到控制台，需要在末行模式下输入命令 末行模式 是 vi 的 出口 编辑模式 —— 正常的编辑文字 提示：在 Touch Bar 的 Mac 电脑上 ，按 ESC 不方便，可以使用 CTRL + [ 替代 末行模式命令 命令 英文 功能 w write 保存 q quit 退出，如果没有保存，不允许退出 q! quit 强行退出，不保存退出 wq write &amp; quit 保存并退出 x 保存并退出 04. 常用命令命令线路图 重复次数 在命令模式下，先输入一个数字，再跟上一个命令，可以让该命令 重复执行指定次数 移动和选择（多练） vi 之所以快，关键在于 能够快速定位到要编辑的代码行 移动命令 能够 和 编辑操作 命令 组合使用 编辑操作 删除、复制、粘贴、替换、缩排 撤销和重复 查找替换 编辑 学习提示 vi 的命令较多，不要期望一下子全部记住，个别命令忘记了，只是会影响编辑速度而已 在使用 vi 命令时，注意 关闭中文输入法 4.1 移动（基本） 要熟练使用 vi，首先应该学会怎么在 命令模式 下样快速移动光标 编辑操作命令，能够和 移动命令 结合在一起使用 1) 上、下、左、右 命令 功能 手指 h 向左 食指 j 向下 食指 k 向上 中指 l 向右 无名指 2) 行内移动 命令 英文 功能 w word 向后移动一个单词 b back 向前移动一个单词 0 行首 ^ 行首，第一个不是空白字符的位置 $ 行尾 3) 行数移动 命令 英文 功能 gg go 文件顶部 G go 文件末尾 数字gg go 移动到 数字 对应行数 数字G go 移动到 数字 对应行数 :数字 移动到 数字 对应行数 4) 屏幕移动 命令 英文 功能 Ctrl + b back 向上翻页 Ctrl + f forward 向下翻页 H Head 屏幕顶部 M Middle 屏幕中间 L Low 屏幕底部 4.2 移动（程序）1) 段落移动 vi 中使用 空行 来区分段落 在程序开发时，通常 一段功能相关的代码会写在一起 —— 之间没有空行 命令 功能 { 上一段 } 下一段 2) 括号切换 在程序世界中，()、[]、&#123;&#125; 使用频率很高，而且 都是成对出现的 命令 功能 % 括号匹配及切换 3) 标记 在开发时，某一块代码可能需要稍后处理，例如：编辑、查看 此时先使用 m 增加一个标记，这样可以 在需要时快速地跳转回来 或者 执行其他编辑操作 标记名称 可以是 a~z 或者 A~Z 之间的任意 一个 字母 添加了标记的 行如果被删除，标记同时被删除 如果 在其他行添加了相同名称的标记，之前添加的标记也会被替换掉 命令 英文 功能 mx mark 添加标记 x，x 是 a~z 或者 A~Z 之间的任意一个字母 ‘x 直接定位到标记 x 所在位置 4.3 选中文本（可视模式） 学习 复制 命令前，应该先学会 怎么样选中 要复制的代码 在 vi 中要选择文本，需要先使用 Visual 命令切换到 可视模式 vi 中提供了 三种 可视模式，可以方便程序员选择 选中文本的方式 按 ESC 可以放弃选中，返回到 命令模式 命令 模式 功能 v 可视模式 从光标位置开始按照正常模式选择文本 V 可视行模式 选中光标经过的完整行 Ctrl + v 可视块模式 垂直方向选中文本 可视模式下，可以和 移动命令 连用，例如：ggVG 能够选中所有内容 4.4 撤销和恢复撤销 在学习编辑命令之前，先要知道怎样撤销之前一次 错误的 编辑动作！ 命令 英文 功能 u undo 撤销上次命令 CTRL + r redo 恢复撤销的命令 4.5 删除文本 命令 英文 功能 x cut 删除光标所在字符，或者选中文字 d(移动命令) delete 删除移动命令对应的内容 dd delete 删除光标所在行，可以 ndd 复制多行 D delete 删除至行尾 提示：如果使用 可视模式 已经选中了一段文本，那么无论使用 d 还是 x，都可以删除选中文本 删除命令可以和 移动命令 连用，以下是常见的组合命令： 123456* dw # 从光标位置删除到单词末尾* d0 # 从光标位置删除到一行的起始位置* d&#125; # 从光标位置删除到段落结尾* ndd # 从光标位置向下连续删除 n 行* d代码行G # 从光标所在行 删除到 指定代码行 之间的所有代码* d&#x27;a # 从光标所在行 删除到 标记a 之间的所有代码 4.6 复制、粘贴 vi 中提供有一个 被复制文本的缓冲区 复制 命令会将选中的文字保存在缓冲区 删除 命令删除的文字会被保存在缓冲区 在需要的位置，使用 粘贴 命令可以将缓冲区的文字插入到光标所在位置 命令 英文 功能 y(移动命令) copy 复制 yy copy 复制一行，可以 nyy 复制多行 p paste 粘贴 提示 命令 d、x 类似于图形界面的 剪切操作 —— CTRL + X 命令 y 类似于图形界面的 复制操作 —— CTRL + C 命令 p 类似于图形界面的 粘贴操作 —— CTRL + V vi 中的 文本缓冲区同样只有一个，如果后续做过 复制、剪切 操作，之前缓冲区中的内容会被替换 注意 vi 中的 文本缓冲区 和系统的 剪贴板 不是同一个 所以在其他软件中使用 CTRL + C 复制的内容，不能在 vi 中通过 P 命令粘贴 可以在 编辑模式 下使用 鼠标右键粘贴 4.7 替换 命令 英文 功能 工作模式 r replace 替换当前字符 命令模式 R replace 替换当前行光标后的字符 替换模式 R 命令可以进入 替换模式，替换完成后，按下 ESC 可以回到 命令模式 替换命令 的作用就是不用进入 编辑模式，对文件进行 轻量级的修改 4.8 缩排和重复执行 命令 功能 &gt;&gt; 向右增加缩进 &lt;&lt; 向左减少缩进 . 重复上次命令 缩排命令 在开发程序时，统一增加代码的缩进 比较有用！ 一次性 在选中代码前增加 4 个空格，就叫做 增加缩进 一次性 在选中代码前删除 4 个空格，就叫做 减少缩进 在 可视模式 下，缩排命令只需要使用 一个 &gt; 或者 &lt; 在程序中，缩进 通常用来表示代码的归属关系 前面空格越少，代码的级别越高 前面空格越多，代码的级别越低 4.9 查找常规查找 命令 功能 /str 查找 str 查找到指定内容之后，使用 Next 查找下一个出现的位置： n: 查找下一个 N: 查找上一个 如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可 单词快速匹配 命令 功能 * 向后查找当前光标所在单词 # 向前查找当前光标所在单词 在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过 4.10 查找并替换 在 vi 中查找和替换命令需要在 末行模式 下执行 记忆命令格式： 1:%s&#x2F;&#x2F;&#x2F;g 1) 全局替换 一次性替换文件中的 所有出现的旧文本 命令格式如下： 1:%s&#x2F;旧文本&#x2F;新文本&#x2F;g 2) 可视区域替换 先选中 要替换文字的 范围 命令格式如下： 1:s&#x2F;旧文本&#x2F;新文本&#x2F;g 3) 确认替换 如果把末尾的 g 改成 gc 在替换的时候，会有提示！推荐使用！ 1:%s&#x2F;旧文本&#x2F;新文本&#x2F;gc y - yes 替换 n - no 不替换 a - all 替换所有 q - quit 退出替换 l - last 最后一个，并把光标移动到行首 ^E 向下滚屏 ^Y 向上滚屏 4.11 插入命令 在 vi 中除了常用的 i 进入 编辑模式 外，还提供了以下命令同样可以进入编辑模式： 命令 英文 功能 常用 i insert 在当前字符前插入文本 常用 I insert 在行首插入文本 较常用 a append 在当前字符后添加文本 A append 在行末添加文本 较常用 o 在当前行后面插入一空行 常用 O 在当前行前面插入一空行 常用 演练 1 —— 编辑命令和数字连用 在开发中，可能会遇到连续输入 N 个同样的字符 在 Python 中有简单的方法，但是其他语言中通常需要自己输入 例如：********** 连续 10 个星号 要实现这个效果可以在 命令模式 下 输入 10，表示要重复 10 次 输入 i 进入 编辑模式 输入 * 也就是重复的文字 按下 ESC 返回到 命令模式，返回之后 vi 就会把第 2、3 两步的操作重复 10 次 提示：正常开发时，在 进入编辑模式之前，不要按数字 演练 2 —— 利用 可视块 给多行代码增加注释 在开发中，可能会遇到一次性给多行代码 增加注释 的情况 在 Python 中，要给代码增加注释，可以在代码前增加一个 # 要实现这个效果可以在 命令模式 下 移动到要添加注释的 第 1 行代码，按 ^ 来到行首 按 CTRL + v 进入 可视块 模式 使用 j 向下连续选中要添加的代码行 输入 I 进入 编辑模式，并在 行首插入，注意：一定要使用 I 输入 # 也就是注释符号 按下 ESC 返回到 命令模式，返回之后 vi 会在之前选中的每一行代码 前 插入 # 05. 分屏命令 属于 vi 的高级命令 —— 可以 同时编辑和查看多个文件 5.1 末行命令扩展末行命令 主要是针对文件进行操作的：保存、退出、保存&amp;退出、搜索&amp;替换、另存、新建、浏览文件 命令 英文 功能 :e . edit 会打开内置的文件浏览器，浏览要当前目录下的文件 :n 文件名 new 新建文件 :w 文件名 write 另存为，但是仍然编辑当前文件，并不会切换文件 提示：切换文件之前，必须保证当前这个文件已经被保存！ 已经学习过的 末行命令： 命令 英文 功能 :w write 保存 :q quit 退出，如果没有保存，不允许退出 :q! quit 强行退出，不保存退出 :wq write &amp; quit 保存并退出 :x 保存并退出 :%s///gc 确认搜索并替换 在实际开发中，可以使用 w 命令 阶段性的备份代码 5.2 分屏命令 使用 分屏命令，可以 同时编辑和查看多个文件 命令 英文 功能 :sp [文件名] split 横向增加分屏 :vsp [文件名] vertical split 纵向增加分屏 1) 切换分屏窗口 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 w window 切换到下一个窗口 r reverse 互换窗口 c close 关闭当前窗口，但是不能关闭最后一个窗口 q quit 退出当前窗口，如果是最后一个窗口，则关闭 vi o other 关闭其他窗口 2) 调整窗口大小 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 + 增加窗口高度 - 减少窗口高度 &gt; 增加窗口宽度 &lt; 减少窗口宽度 = 等分窗口大小 调整窗口宽高的命令可以和数字连用，例如：5 CTRL + W + 连续 5 次增加高度 06. 常用命令速查图 vimrc vimrc 是 vim 的配置文件，可以设置 vim 的配置，包括：热键、配色、语法高亮、插件 等 Linux 中 vimrc 有两个位置，家目录下的配置文件优先级更高 12/etc/vim/vimrc~/.vimrc 常用的插件有： 代码补全 代码折叠 搜索 Git 集成 …… 网上有很多高手已经配置好的针对 python 开发的 vimrc 文件，可以下载过来直接使用，或者等大家多 Linux 比较熟悉后，再行学习！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xxren8218.github.io/categories/Linux/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://xxren8218.github.io/tags/vim/"}]}],"categories":[{"name":"机器学习基础实战","slug":"机器学习基础实战","permalink":"https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/"},{"name":"机器学习","slug":"机器学习","permalink":"https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"https://xxren8218.github.io/categories/python/"},{"name":"Linux","slug":"Linux","permalink":"https://xxren8218.github.io/categories/Linux/"}],"tags":[{"name":"机器学习基础实战","slug":"机器学习基础实战","permalink":"https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/"},{"name":"机器学习基础","slug":"机器学习基础","permalink":"https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"},{"name":"python基础","slug":"python基础","permalink":"https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"},{"name":"vim","slug":"vim","permalink":"https://xxren8218.github.io/tags/vim/"}]}