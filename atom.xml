<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-03-01T12:38:51.462Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://xxren8218.github.io/2021/03/01/hello-world/"/>
    <id>https://xxren8218.github.io/2021/03/01/hello-world/</id>
    <published>2021-03-01T12:38:51.462Z</published>
    <updated>2021-03-01T12:38:51.462Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>个人博客搭建教程</title>
    <link href="https://xxren8218.github.io/2021/03/01/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BC%98%E7%94%B1/"/>
    <id>https://xxren8218.github.io/2021/03/01/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BC%98%E7%94%B1/</id>
    <published>2021-02-28T17:07:56.037Z</published>
    <updated>2021-02-28T17:07:56.037Z</updated>
    
    
    
    
    <category term="杂谈" scheme="https://xxren8218.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="生活" scheme="https://xxren8218.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Linux下shell脚本编程学习</title>
    <link href="https://xxren8218.github.io/2020/11/27/learning-linux-shell-script/"/>
    <id>https://xxren8218.github.io/2020/11/27/learning-linux-shell-script/</id>
    <published>2020-11-27T06:19:03.000Z</published>
    <updated>2020-12-09T11:14:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：从11月27日到12月9日，大概花了一个星期的时间，终于啃完了621页的《Linux命令行与shell脚本编程大全》。<span id="more"></span></p><blockquote><p><font size=5><b>文章说明</b></font><br><strong>文章作者：</strong><a href="https://hwame.top">鴻塵</a><br><strong>文章说明：</strong>学习<code>shell</code>过程中的记录，参考书籍主要有《Linux命令行与shell脚本编程大全（第3版）》，《鸟哥的Linux私房菜（第三版）》系列和《快乐的 Linux 命令行》，参考资料主要有<a href="https://man.linuxde.net/">Linux命令大全</a>等。<br><strong>文章链接：</strong><a href="https://hwame.top/20201127/learning-linux-shell-script.html">https://hwame.top/20201127/learning-linux-shell-script.html</a></p></blockquote><h2 id="1-构建基本脚本"><a href="#1-构建基本脚本" class="headerlink" title="1.构建基本脚本"></a>1.构建基本脚本</h2><h3 id="1-1-创建shell脚本文件"><a href="#1-1-创建shell脚本文件" class="headerlink" title="1.1.创建shell脚本文件"></a>1.1.创建shell脚本文件</h3><p>创建shell脚本文件时，必须在文件的<strong>第一行</strong>指定要使用的shell。其格式为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br></pre></td></tr></table></figure></p><h2 id="4-处理用户输入"><a href="#4-处理用户输入" class="headerlink" title="4.处理用户输入"></a>4.处理用户输入</h2><h3 id="4-1-命令行参数"><a href="#4-1-命令行参数" class="headerlink" title="4.1.命令行参数"></a>4.1.命令行参数</h3><p><strong>注意：</strong>利用<code>$0</code>读取脚本名时存在一个潜在的问题，即<code>$0</code>参数会同时包含路径和连在一起的命令，如下表所示。解决这个问题只需要使用<code>basename</code>命令，他会返回不包含路径的脚本名：<code>basename $0</code>，例如<code>script=$(basename $0)</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">执行命令</th><th style="text-align:center"><code>$0</code>变量</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center"><code>bash mz.sh</code></td><td style="text-align:center"><code>mz.sh</code></td><td style="text-align:left">没有问题</td></tr><tr><td style="text-align:center"><code>./mz.sh</code></td><td style="text-align:center"><code>./mz.sh</code></td><td style="text-align:left">包含命令</td></tr><tr><td style="text-align:center"><code>bash /home/hwame/mz.sh</code></td><td style="text-align:center"><code>/home/hwame/mz.sh</code></td><td style="text-align:left">包含路径</td></tr></tbody></table></div><p>在shell脚本中使用命令行参数时要小心些。当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。<br>通俗的说，当脚本中使用了变量<code>$1</code>、<code>$2</code>、<code>$3</code>时，如果允许脚本时没有给出对应的命令行参数则会报错。</p><p>因此<strong>在使用参数前一定要检查其中是否存在数据</strong>，一种方法是使用<code>-n</code>测试来检查命令行参数<code>$1</code>中是否有数据：<code>if [ -n &quot;$1&quot;]; then</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Grabbing the last parameter</span></span><br><span class="line">params=<span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> The last parameter is <span class="variable">$params</span></span><br><span class="line"><span class="built_in">echo</span> The last parameter is <span class="variable">$&#123;!#&#125;</span></span><br></pre></td></tr></table></figure><p>上述示例中的两种方式都没问题。但要注意，当命令行上没有任何参数时，<code>$#</code>的值为<code>0</code>，<code>params</code>变量的值也一样，但<code>$&#123;!#&#125;</code>变量会返回命令行用到的脚本名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;$*&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;\$* Parameter #<span class="variable">$count</span> = <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;\$@ Parameter #<span class="variable">$count</span> = <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201抓取所有参数的两种方法.png" alt="抓取所有参数的两种方法"></p><h3 id="4-3-移动变量"><a href="#4-3-移动变量" class="headerlink" title="4.3.移动变量"></a>4.3.移动变量</h3><p>bash shell的<code>shift</code>命令能够用来操作命令行参数。顾名思义，他会根据它们的相对位置来移动命令行参数。<br>默认情况下它会将每个参数变量向左移动一个位置。所以，变量<code>$3</code>的值会移到<code>$2</code>中，变量<code>$2</code>的值会移到<code>$1</code>中，而变量<code>$1</code>的值则会被删除（注意，变量<code>$0</code>的值即程序名不会改变）。也可以一次性移动多个位置，只需要给<code>shift</code>命令提供一个参数指明要移动的位置数就行了：<code>shift n</code>。<br><strong>注意：</strong>如果某个参数被移出，它的值就被丢弃了，无法再恢复。</p><p>这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span> = <span class="variable">$1</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><br>运行结果如图所示：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201移动变量.png" alt="移动变量"></p><h3 id="4-4-处理选项"><a href="#4-4-处理选项" class="headerlink" title="4.4.处理选项"></a>4.4.处理选项</h3><p>「<code>选项</code>」是跟在单破折线后面的<strong>单个字母</strong>，它能改变命令的行为，此处介绍3种在脚本中处理选项的方法。</p><h4 id="1-查找选项"><a href="#1-查找选项" class="headerlink" title="(1)查找选项"></a>(1)查找选项</h4><p>表面上看，命令行选项也没什么特殊的。在命令行上，它们紧跟在脚本名之后，就跟命令行参数一样。实际上，如果愿意，你可以像处理命令行参数一样处理命令行选项。</p><ul><li><strong>①处理简单选项：</strong>可以用<code>shift</code>命令来处理脚本程序携带的命令行选项，用<code>case</code>语句来判断某个参数是否为选项。<code>case</code>语句会检查每个参数是不是有效选项，如果是就运行对应语句中的命令。不管选项按什么顺序出现在命令行上，这种方法都适用。示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># extracting command line options as parameters</span></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;;</span><br><span class="line">        -b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option&quot;</span> ;;</span><br><span class="line">        -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;;</span><br><span class="line">         *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span> ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><strong>②分离参数和选项：</strong>对于在shell脚本中同时使用<strong>选项</strong>和<strong>参数</strong>的情况，标准方式是用特殊字符（双破折线<code>--</code>）来将二者分开，该字符会告诉脚本<strong>何时选项结束</strong>以及<strong>普通参数何时开始</strong>。<br>shell会用双破折线来表明选项列表结束。在双破折线之后，脚本就可以放心地将剩下的命令行参数当作<strong>参数</strong>，而不是<strong>选项</strong>来处理了。要检查双破折线，只要在case语句中加一项就行了，如下例所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># extracting options and parameters</span></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;;</span><br><span class="line">        -b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option&quot;</span> ;;</span><br><span class="line">        -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;;</span><br><span class="line">        --) <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">break</span> ;;</span><br><span class="line">         *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span> ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>运行结果如图，可以看出，第一次未分离时脚本认为所有的命令行参数都是选项；第二次使用<code>--</code>分离后，当脚本遇到双破折线时，它会停止处理选项，并将剩下的参数都当作命令行参数。<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201分离参数和选项.png" alt="分离参数和选项"></li><li><strong>③处理带值的选项：</strong>有些选项会带上一个额外的参数值，例如：<code>./mz.sh -a test1 -b -c -d test2</code>。当命令行选项要求额外的参数时，脚本必须能检测到并正确处理，如下例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># extracting command line options and values</span></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span>;;</span><br><span class="line">        -b) param=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with parameter value <span class="variable">$param</span>&quot;</span></span><br><span class="line">            <span class="built_in">shift</span> ;;</span><br><span class="line">        -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span>;;</span><br><span class="line">        --) <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">break</span> ;;</span><br><span class="line">         *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>在这个例子中，<code>case</code>语句定义了三个它要处理的选项，其中<code>-b</code>选项还需要一个额外的参数值。由于要处理的参数是<code>$1</code>，额外的参数值就应该位于<code>$2</code>（因为所有的参数在处理完之后都会被移出）。只要将参数值从<code>$2</code>变量中提取出来就可以了。当然，因为这个选项占用了两个参数位，所以你还需要使用<code>shift</code>命令多移动一个位置。运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201201处理带值的选项.png" alt="处理带值的选项"></li></ul><p>该方法会将原始脚本的命令行参数传给<code>getopt</code>命令，之后再将<code>getopt</code>命令的输出传给<code>set</code>命令，用<code>getopt</code>格式化后的命令行参数来替换原始的命令行参数，格式看起来如下所示：<code>set -- $(getopt -q ab:cd &quot;$@&quot;)</code>。<br>现在原始的命令行参数变量的值会被<code>getopt</code>命令的输出替换，而<code>getopt</code>已经为我们格式化<br>好了命令行参数。利用该方法就可以写出能帮我们处理命令行参数的脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -- $(getopt -q ab:<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;;</span><br><span class="line">        -b) param=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with parameter value <span class="variable">$param</span>&quot;</span></span><br><span class="line">            <span class="built_in">shift</span> ;;</span><br><span class="line">        -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;;</span><br><span class="line">        --) <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">break</span> ;;</span><br><span class="line">         *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><br>注意到该例和上文<a href="#1-%E6%9F%A5%E6%89%BE%E9%80%89%E9%A1%B9">查找选项</a>中第三种情况「处理带值的选项」一样，唯一不同的是加入了<code>getopt</code>命令来帮助格式化命令行参数。并且可以运行带有复杂选项的脚本如合并的选项：<code>./mz.sh -ac</code>，同时之前的功能照样没有问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># simple demonstration of the getopts command</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :ab:c opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;;</span><br><span class="line">        b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with value <span class="variable">$OPTARG</span>&quot;</span>;;</span><br><span class="line">        c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;Unknown option: <span class="variable">$opt</span>&quot;</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><code>while</code>语句定义了<code>getopts</code>命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（<code>opt</code>）。注意到在本例中<code>case</code>语句的用法有些不同：<code>getopts</code>命令解析命令行选项时会移除开头的单破折线，所以在<code>case</code>定义中不用单破折线。<br><code>getopts</code>命令有几个好用的功能：①可以在参数值中包含空格；②可以将选项字母和参数值放在一起使用，而不用加空格，<code>getopts</code>命令能够从选项中正确解析出参数值；③可以将命令行上所有未定义的选项统一输出成问号，以问号形式发送给代码。<br>上述代码运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202getopts命令用法.png" alt="getopts命令用法"></p><p><code>getopts</code>命令知道何时停止处理选项，并将参数留给你处理。在<code>getopts</code>处理每个选项时，它会将<code>OPTIND</code>环境变量值增一。在<code>getopts</code>完成处理时，你可以使用<code>shift</code>命令和<code>OPTIND</code>值来移动参数。如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :ab:<span class="built_in">cd</span> opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;;</span><br><span class="line">        b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with value <span class="variable">$OPTARG</span>&quot;</span> ;;</span><br><span class="line">        c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;;</span><br><span class="line">        d) <span class="built_in">echo</span> <span class="string">&quot;Found the -d option&quot;</span> ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;Unknown option: <span class="variable">$opt</span>&quot;</span> ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span> $[ <span class="variable">$OPTIND</span> - 1 ]</span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Parameter <span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><br>运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202环境变量OPTIND.png" alt="环境变量OPTIND"></p><h3 id="4-5-将选项标准化"><a href="#4-5-将选项标准化" class="headerlink" title="4.5.将选项标准化"></a>4.5.将选项标准化</h3><p>所谓选项标准化，就是尽量遵循某些字母选项在Linux世界里已经拥有的某种程度的标准含义，而不是随意决定用哪些字母选项以及它们的用法，将选项标准化使得脚本看起来能更友好一些。常用的Linux命令选项如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">含义</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>-a</code></td><td style="text-align:center"><code>all</code></td><td style="text-align:left">显示所有对象</td></tr><tr><td style="text-align:center"><code>-c</code></td><td style="text-align:center"><code>count</code></td><td style="text-align:left">生成一个计数</td></tr><tr><td style="text-align:center"><code>-d</code></td><td style="text-align:center"><code>directory</code></td><td style="text-align:left">指定一个目录</td></tr><tr><td style="text-align:center"><code>-e</code></td><td style="text-align:center"><code>extend</code></td><td style="text-align:left">扩展一个对象</td></tr><tr><td style="text-align:center"><code>-f</code></td><td style="text-align:center"><code>file</code></td><td style="text-align:left">指定读入数据的文件</td></tr><tr><td style="text-align:center"><code>-h</code></td><td style="text-align:center"><code>help</code></td><td style="text-align:left">显示命令的帮助信息</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:center"><code>ignorecase</code></td><td style="text-align:left">忽略文本大小写</td></tr><tr><td style="text-align:center"><code>-l</code></td><td style="text-align:center"><code>long</code></td><td style="text-align:left">产生输出的长格式版本</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:center"><code>non-interactive</code></td><td style="text-align:left">使用非交互模式（批处理）</td></tr><tr><td style="text-align:center"><code>-o</code></td><td style="text-align:center"><code>output redirect</code></td><td style="text-align:left">将所有输出重定向到指定的输出文件</td></tr><tr><td style="text-align:center"><code>-q</code><br><code>-s</code></td><td style="text-align:center"><code>quiet</code><br><code>silent</code></td><td style="text-align:left">以安静模式运行</td></tr><tr><td style="text-align:center"><code>-r</code></td><td style="text-align:center"><code>recursive</code></td><td style="text-align:left">递归地处理目录和文件</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:center"><code>verbose</code></td><td style="text-align:left">生成详细输出</td></tr><tr><td style="text-align:center"><code>-x</code></td><td style="text-align:center"><code>exclude</code></td><td style="text-align:left">排除某个对象</td></tr><tr><td style="text-align:center"><code>-y</code></td><td style="text-align:center"><code>yes</code></td><td style="text-align:left">对所有问题回答yes</td></tr></tbody></table></div><h3 id="4-6-获得用户输入"><a href="#4-6-获得用户输入" class="headerlink" title="4.6.获得用户输入"></a>4.6.获得用户输入</h3><p>尽管命令行选项和参数是从脚本用户处获得输入的一种重要方式，但有时脚本的交互性还需要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本的人来回答。bash shell为此提供了<code>read</code>命令。</p><h4 id="1-基本的读取"><a href="#1-基本的读取" class="headerlink" title="(1)基本的读取"></a>(1)基本的读取</h4><p><code>read</code>命令从标准输入（键盘）或另一个文件描述符中接受输入，在收到输入后会将数据放进一个指定的变量。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Enter your name: &quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$name</span>, welcome to my program. &quot;</span></span><br></pre></td></tr></table></figure><br>注意，上例中生成提示的<code>echo</code>命令使用了<code>-n</code>选项。该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。这让脚本看起来更像表单。<br>实际上，<strong><code>read</code>命令包含了<code>-p</code>选项，允许你直接在<code>read</code>命令行指定提示符</strong>。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please enter your age: &quot;</span> age</span><br><span class="line">days=$[ <span class="variable">$age</span> * 365 ]</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;That makes you over <span class="variable">$days</span> days old! &quot;</span></span><br></pre></td></tr></table></figure><br><code>read</code>命令也允许指定多个变量，输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量。是不是和Python中的<code>*args</code>和<code>**kwargs</code>有点像呢？<br>也可以在<code>read</code>命令行中不指定变量，这样它收到的任何数据都会放进特殊环境变量<code>REPLY</code>中。<code>REPLY</code>环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用。</p><h4 id="2-超时"><a href="#2-超时" class="headerlink" title="(2)超时"></a>(2)超时</h4><p>如果不管是否有数据输入，脚本都必须继续执行，你可以用<code>-t</code>选项来指定一个计时器，他指定了<code>read</code>命令等待输入的秒数。当计时器过期后，<code>read</code>命令会返回一个非零退出状态码，可以使用<code>if-then</code>语句或<code>while</code>循环这种标准的结构化语句来理清所发生的具体情况。</p><p>也可以不对输入过程计时，而是让<code>read</code>命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。可以将<code>-n</code>选项和值<code>1</code>一起使用，告诉<code>read</code>命令在接受<strong>单个字符</strong>后退出。只要按下单个字符回答后，<code>read</code>命令就会接受输入并将它传给变量，无需按回车键。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -n1 -p <span class="string">&quot;Do you want to continue [Y/N]? &quot;</span> answer</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$answer</span> <span class="keyword">in</span></span><br><span class="line">    Y | y) <span class="built_in">echo</span></span><br><span class="line">           <span class="built_in">echo</span> <span class="string">&quot;fine, continue on…&quot;</span>;;</span><br><span class="line">    N | n) <span class="built_in">echo</span></span><br><span class="line">           <span class="built_in">echo</span> OK, goodbye</span><br><span class="line">           <span class="built_in">exit</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is the end of the script&quot;</span></span><br></pre></td></tr></table></figure><br>运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202read命令接受指定字符.png" alt="read命令接受指定字符"></p><h4 id="3-隐藏方式读取"><a href="#3-隐藏方式读取" class="headerlink" title="(3)隐藏方式读取"></a>(3)隐藏方式读取</h4><p>当需要输入类似密码这种需要从脚本用户处得到输入，但又在屏幕上显示输入信息时，可以使用<code>-s</code>选项不回显终端的输入（实际上数据会被显示，只是<code>read</code>命令会将文本颜色设成跟背景色一样）。输入提示符输入的数据不会出现在屏幕上，但会赋给变量，以便在脚本中使用。例如：<code>read -s -p &quot;Enter your password: &quot; password</code>。</p><h4 id="4-从文件中读取"><a href="#4-从文件中读取" class="headerlink" title="(4)从文件中读取"></a>(4)从文件中读取</h4><p>可以用<code>read</code>命令来读取文件里的数据，每次调用<code>read</code>命令都会从文件中读取一行文本。当文件中再没有内容时，<code>read</code>命令会退出并返回非零退出状态码。<br>如何将文件中的数据传给<code>read</code>命令呢？最常见的方法是对文件使用<code>cat</code>命令，将结果通过管道直接传给含有<code>read</code>命令的<code>while</code>命令。见下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">count=1</span><br><span class="line">cat textfile | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Line <span class="variable">$count</span>: <span class="variable">$line</span>&quot;</span></span><br><span class="line">    count=$[ <span class="variable">$count</span> + 1]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Finished processing the file&quot;</span></span><br></pre></td></tr></table></figure><br>文件<code>textfile</code>内容及运行结果如下：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201202从文件中读取数据.png" alt="从文件中读取数据"></p><h2 id="5-创建函数"><a href="#5-创建函数" class="headerlink" title="5.创建函数"></a>5.创建函数</h2><h3 id="5-1-基本脚本函数"><a href="#5-1-基本脚本函数" class="headerlink" title="5.1.基本脚本函数"></a>5.1.基本脚本函数</h3><p>函数是一个脚本代码块，你可以为其命名并在<strong>代码中任何位置</strong>重用，调用函数（在脚本中使用该代码块）时只要使用所起的函数名就行了。</p><p><strong>创建函数的第一种格式</strong>是采用关键字<code>function</code>，后跟分配给该代码块的函数名：<br><code>name</code>属性定义了赋予函数的唯一名称，脚本中定义的每个函数都必须有一个唯一的名称。<code>commands</code>是构成函数的一条或多条bash shell命令，在调用该函数时会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> name &#123;</span><br><span class="line">    commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>创建函数的第二种格式</strong>更接近于其他编程语言中定义函数的方式：<br>函数名后的空括号表明正在定义的是一个函数，这种格式的命名规则和之前定义shell脚本函数的格式一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">name</span></span>() &#123;</span><br><span class="line">    commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>至于使用函数，只需要像其他shell命令一样，在行中<strong>指定函数名</strong>就行了。</p><p><strong>注意①：</strong>函数定义不一定非得是shell脚本中首先要做的事，但必须在使用函数之前定义它，否则会收到一条<code>command not found</code>的错误消息。<br><strong>注意②：</strong>函数名必须是唯一的，如果你重定义了函数，新定义会覆盖原来函数的定义，这一切不会产生任何错误消息。</p><h3 id="5-2-返回值"><a href="#5-2-返回值" class="headerlink" title="5.2.返回值"></a>5.2.返回值</h3><p>bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码，生成退出状态码有以下3种不同的方法：</p><ul><li><strong>默认退出状态码：</strong>默认情况下，函数的退出状态码是<strong>函数中最后一条命令返回的退出状态码</strong>。在函数执行结束后，可以用标准变量<code>$?</code>来确定函数的退出状态码。<br><strong>注意</strong>：由于函数的默认退出状态码取决于函数体中最后一条命令的退出状态码，因此你无法知道函数中其他命令中是否成功运行，所以这种方法很危险。</li><li><strong>使用<code>return</code>命令：</strong>使用<code>return</code>命令来退出函数并返回特定的退出状态码，它允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。<br><strong>注意</strong>：①函数一结束就取返回值，否则可能会丢失返回值。②退出状态码的范围是0~255，超出则会取余。</li><li><strong>使用函数输出：</strong>正如可以将命令的输出保存到shell变量中一样，你也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中。见下例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> myfunc &#123;</span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;Enter a value: &quot;</span> value</span><br><span class="line">    <span class="built_in">echo</span> $[ <span class="variable">$value</span> * 2 ]</span><br><span class="line">&#125;</span><br><span class="line">result=$(myfunc)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The new value is <span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure><strong>注意①</strong>：该函数实际上输出了两条消息，<code>read</code>命令输出了一条简短的消息来向用户询问输入值，但bash shell并不将其作为<code>STDOUT</code>输出的一部分，并且忽略掉它。如果你用<code>echo</code>语句生成这条消息来向用户查询，那么它会与输出值一起被读进shell变量中。<br><strong>注意②</strong>：这种方法还可以返回浮点值和字符串值，这使它成为一种获取函数返回值的强大方法。上例运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209使用函数输出返回值.png" alt="使用函数输出返回值"></li></ul><h3 id="5-3-在函数中使用变量"><a href="#5-3-在函数中使用变量" class="headerlink" title="5.3.在函数中使用变量"></a>5.3.在函数中使用变量</h3><blockquote><p>在函数中使用变量时，你需要注意它们的定义方式以及处理方式——这是shell脚本中常见错误的根源。</p></blockquote><h4 id="向函数传递参数"><a href="#向函数传递参数" class="headerlink" title="向函数传递参数"></a>向函数传递参数</h4><p>bash shell会将函数当作小型脚本来对待，这意味着你可以像普通脚本那样向函数传递参数。</p><p>函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在<code>$0</code>变量中定义，函数命令行上的任何参数都会通过<code>$1</code>、<code>$2</code>等定义。也可以用特殊变量<code>$#</code>来判断传给函数的参数数目。<br><strong>注意①：</strong>在脚本中指定函数时，必须将参数和函数放在同一行，例如<code>func1 $value1 10</code>，<code>result=$(func1 $value1 10)</code>；<br><strong>注意②：</strong>由于函数使用特殊参数环境变量作为自己的参数值，因此它<strong>无法直接获取脚本在命令行中的参数值</strong>。尽管函数也使用了<code>$1</code>和<code>$2</code>变量，但它们和脚本主体中的<code>$1</code>和<code>$2</code>变量并不相同。要在函数中使用这些值，必须在调用函数时手动将它们传过去。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> myfunc &#123;</span><br><span class="line">    <span class="built_in">echo</span> $[ <span class="variable">$1</span> * <span class="variable">$2</span> ]</span><br><span class="line">&#125;</span><br><span class="line">value1=$(myfunc 10 20)</span><br><span class="line">value2=$(myfunc)</span><br><span class="line">value3=$(myfunc <span class="variable">$1</span> <span class="variable">$2</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The result is <span class="variable">$valuex</span>&quot;</span></span><br></pre></td></tr></table></figure><br>如上例，<code>value1</code>是正常的函数调用方式，将参数和函数放在同一行。如果想让<code>value2</code>以这种方式直接获取命令行参数值将报错：<code>syntax error: operand expected...</code>，原因见上，解决办法就是按<code>value3</code>的方式。尽管在函数的定义和调用时都使用了<code>$1</code>和<code>$2</code>变量，但他们的区别就如同形参和实参。</p><h4 id="在函数中处理变量"><a href="#在函数中处理变量" class="headerlink" title="在函数中处理变量"></a>在函数中处理变量</h4><p>变量的作用域也会经常带来麻烦，作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同，也就是说，对脚本的其他部分而言，它们是隐藏的。</p><p>函数使用两种类型的变量：<strong>全局变量</strong>和<strong>局部变量</strong>。</p><ul><li><strong>全局变量：</strong>在shell脚本中任何地方都有效的变量。如果你在脚本的主体部分定义了一个全局变量，那么可以在函数内读取它的值。<strong>类似地，如果你在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。</strong>默认情况下，在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问。<br><strong>注意：</strong>在使用全局变量时，如果变量被修改后新值将依然有效，这有时会产生难以预料的后果。它要求你清清楚楚地知道函数中具体使用了哪些变量，包括那些用来计算非返回值的变量。</li><li><strong>局部变量：</strong><code>local</code>关键字保证了变量只局限在该函数中，如果脚本中在该函数之外有同样名字的变量，那么shell将会保持这两个变量的值是分离的。<br>如果要将函数内部使用的任何变量都声明成局部变量，只需要在变量声明的前面加上<code>local</code>关键字：<code>local temp</code>。也可以在变量赋值语句中使用<code>local</code>关键字：<code>local temp=$[ $value + 5 ]</code>。</li></ul><h3 id="5-4-数组变量和函数"><a href="#5-4-数组变量和函数" class="headerlink" title="5.4.数组变量和函数"></a>5.4.数组变量和函数</h3><h4 id="向函数传递数组参数"><a href="#向函数传递数组参数" class="headerlink" title="向函数传递数组参数"></a>向函数传递数组参数</h4><p>向脚本函数传递数组变量的方法会有点不好理解。将数组变量当作单个参数传递的话，它不会起作用。见下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> testit &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The parameters are: <span class="variable">$@</span>&quot;</span></span><br><span class="line">    thisarray=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The received array is <span class="variable">$&#123;thisarray[*]&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">myarray=(1 2 3 4 5)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The original array is: <span class="variable">$&#123;myarray[*]&#125;</span>&quot;</span></span><br><span class="line">testit <span class="variable">$myarray</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果如下：</span></span><br><span class="line"><span class="comment"># The original array is: 1 2 3 4 5</span></span><br><span class="line"><span class="comment"># The parameters are: 1</span></span><br><span class="line"><span class="comment"># The received array is 1</span></span><br></pre></td></tr></table></figure><br>如你所见，如果将该数组变量作为函数参数，函数只会取数组变量的第一个值。要解决这个问题，必须将该数组变量的值分解成单个值，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量。<br>如下例所示，<code>$myarray</code>变量来保存所有的数组元素，然后将它们都放在函数的命令行上。该函数随后从命令行参数中重建数组变量。在函数内部，数组仍然可以像其他数组一样使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> testit &#123;</span><br><span class="line">    <span class="built_in">local</span> newarray</span><br><span class="line">    newarray=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>))</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The new array value is: <span class="variable">$&#123;newarray[*]&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">myarray=(1 2 3 4 5)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The original array is <span class="variable">$&#123;myarray[*]&#125;</span>&quot;</span></span><br><span class="line">testit <span class="variable">$&#123;myarray[*]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果如下：</span></span><br><span class="line"><span class="comment"># The original array is 1 2 3 4 5</span></span><br><span class="line"><span class="comment"># The new array value is: 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><br>下面是一个遍历数组并将所有元素累加的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> addarray &#123;</span><br><span class="line">    <span class="built_in">local</span> sum=0</span><br><span class="line">    <span class="built_in">local</span> newarray</span><br><span class="line">    newarray=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> <span class="variable">$&#123;newarray[*]&#125;</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        sum=$[ <span class="variable">$sum</span> + <span class="variable">$value</span> ]</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$sum</span></span><br><span class="line">&#125;</span><br><span class="line">myarray=(1 2 3 4 5)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The original array is: <span class="variable">$&#123;myarray[*]&#125;</span>&quot;</span></span><br><span class="line">arg1=$(<span class="built_in">echo</span> <span class="variable">$&#123;myarray[*]&#125;</span>)</span><br><span class="line">result=$(addarray <span class="variable">$arg1</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The result is <span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure><br>运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209遍历数组累加.png" alt="遍历数组累加"></p><h4 id="从函数返回数组"><a href="#从函数返回数组" class="headerlink" title="从函数返回数组"></a>从函数返回数组</h4><p>从函数里向shell脚本传回数组变量也用类似的方法：函数用<code>echo</code>语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。见下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> returnarray &#123;</span><br><span class="line">    <span class="built_in">local</span> oriarray</span><br><span class="line">    <span class="built_in">local</span> newarray</span><br><span class="line">    <span class="built_in">local</span> elements</span><br><span class="line">    <span class="built_in">local</span> i</span><br><span class="line">    oriarray=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>))</span><br><span class="line">    newarray=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>))</span><br><span class="line">    elements=$[ <span class="variable">$#</span> - 1 ]</span><br><span class="line">    <span class="keyword">for</span> (( i = 0; i &lt;= <span class="variable">$elements</span>; i++ ))</span><br><span class="line">    &#123;</span><br><span class="line">        newarray[<span class="variable">$i</span>]=$[ <span class="variable">$&#123;oriarray[$i]&#125;</span> * 2 ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;newarray[*]&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">myarray=(1 2 3 4 5)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The original array is: <span class="variable">$&#123;myarray[*]&#125;</span>&quot;</span></span><br><span class="line">arg1=$(<span class="built_in">echo</span> <span class="variable">$&#123;myarray[*]&#125;</span>)</span><br><span class="line">result=($(returnarray <span class="variable">$arg1</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The new array is: <span class="variable">$&#123;result[*]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><br>该脚本用<code>$arg1</code>变量将数组值传给<code>returnarray</code>函数，函数将该数组重组到新的数组变量中，生成该输出数组变量的一个副本。然后对数据元素进行遍历，将每个元素值翻倍，并将结果存入函数中该数组变量的副本。<br><code>returnarray</code>函数使用<code>echo</code>语句来输出每个数组元素的值。脚本用<code>returnarray</code>函数的输出来重新生成一个新的数组变量。运行结果如图：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209从函数返回数组.png" alt="从函数返回数组"></p><h3 id="5-5-函数递归"><a href="#5-5-函数递归" class="headerlink" title="5.5.函数递归"></a>5.5.函数递归</h3><p>局部函数变量的一个特性是<strong>自成体系</strong>，除了从脚本命令行处获得的变量，自成体系的函数不需要使用任何外部资源。这个特性使得函数可以递归地调用，也就是说，函数可以调用自己来得到结果。<br>通常递归函数都有一个最终可以迭代到的基准值。许多高级数学算法用递归对复杂的方程进行逐级规约，直到基准值定义的那级。递归算法的经典例子是计算阶乘：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> factorial &#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$1</span> -eq 1 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> 1</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">local</span> temp=$[ <span class="variable">$1</span> - 1 ]</span><br><span class="line">        <span class="built_in">local</span> result=$(factorial <span class="variable">$temp</span>)</span><br><span class="line">        <span class="built_in">echo</span> $[ <span class="variable">$result</span> * <span class="variable">$1</span> ]</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter value: &quot;</span> value</span><br><span class="line">result=$(factorial <span class="variable">$value</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The factorial of <span class="variable">$value</span> is: <span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure><br>运行结果如下：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209计算简单阶乘.png" alt="计算简单阶乘"></p><h3 id="5-6-创建库"><a href="#5-6-创建库" class="headerlink" title="5.6.创建库"></a>5.6.创建库</h3><p>bash shell允许创建函数<strong>库文件</strong>，然后在多个脚本中引用该库文件。<br>第一步需要创建一个包含脚本中所需函数的公用库文件，例如定义了3个简单的函数的库文件<code>myfuncs</code>。第二步就是在用到这些函数的脚本文件中包含该库文件，但是问题就来了。</p><blockquote><p>和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行<code>myfuncs</code>的shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。<br>这同样适用于脚本：如果你尝试像普通脚本文件那样运行库文件，函数并不会出现在脚本中。例如运行下例将报错<code>addem: command not found</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">./myfuncs</span><br><span class="line"><span class="comment"># 库文件中的函数addem将两数相加</span></span><br><span class="line">result=$(addem 10 15)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The result is <span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>使用函数库的关键在于<code>source</code>命令。 <code>source</code>命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用<code>source</code>命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。<br><code>source</code>命令有个快捷的别名<code>.</code>，称作点操作符（dot operator）。要在shell脚本中运行<code>myfuncs</code>库文件，只需添加：<code>. ./myfuncs</code>。如果库文件和shell脚本不是位于同一目录，则需要使用相应路径访问该库文件。</p><h3 id="5-7-在命令行上使用函数"><a href="#5-7-在命令行上使用函数" class="headerlink" title="5.7.在命令行上使用函数"></a>5.7.在命令行上使用函数</h3><p>和在shell脚本中将脚本函数当命令使用一样，在命令行界面的提示符下你也可以直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在<code>PATH</code>环境变量里。<br><strong>重点在于让shell能够识别这些函数</strong>，有以下两种方法：</p><ul><li>在命令行上创建函数；</li><li>在<code>.bashrc</code>文件中定义函数。</li></ul><p>对于简单的函数，可以在命令行上直接定义一个函数，因为shell会解释用户输入的命令。如果采用<strong>单行方式定义函数</strong>，必须在每个命令后面加个分号，这样shell就能知道在哪里是命令的起止了；如果采用<strong>多行方式定义函数</strong>，则不需要添加分号，只需要回车即可。如图所示：<br><img src="https://cdn.jsdelivr.net/gh/hwame/pics@main/shell/20201209命令行上使用函数.png" alt="命令行上使用函数"><br><strong>注意：</strong>在命令行上创建函数时，如果你给函数起了个跟内建命令或另一个命令相同的名字，函数将会覆盖原来的命令。</p><hr><p>在命令行上创建函数不仅输入不便，而且最主要的问题是退出shell时函数就消失了。最简单的解决办法就是将函数定义在<code>.bashrc</code>文件中，bash shell在每次启动时都会在主目录下查找这个文件，不管是交互式shell还是从现有shell中启动的新shell。</p><ul><li><strong>直接定义函数</strong>，可以直接在主目录下的<code>.bashrc</code>文件中定义函数。许多Linux发行版已经在<code>.bashrc</code>文件中定义了一些东西，所以注意不要误删了，把你写的函数放在文件末尾就行了。</li><li><strong>读取函数文件</strong>，只要是在shell脚本中，都可以用<code>source</code>命令（或者它的别名<code>.</code>操作符）将库文件中的函数添加到<code>.bashrc</code>脚本中。 shell还会将定义好的函数传给子shell进程，这样一来，这些函数就自动能够用于该shell会话中的任何shell脚本了。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：从11月27日到12月9日，大概花了一个星期的时间，终于啃完了621页的《Linux命令行与shell脚本编程大全》。</summary>
    
    
    
    <category term="Linux" scheme="https://xxren8218.github.io/categories/Linux/"/>
    
    
    <category term="shell" scheme="https://xxren8218.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置与uWSGI配置详解</title>
    <link href="https://xxren8218.github.io/2020/05/22/configuration-of-nginx-and-uwsgi/"/>
    <id>https://xxren8218.github.io/2020/05/22/configuration-of-nginx-and-uwsgi/</id>
    <published>2020-05-22T00:18:48.000Z</published>
    <updated>2020-07-02T09:29:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：文章介绍了<code>Nginx</code>与<code>uWSGI</code>的知识，并依具体的例子对<code>Web</code>应用进行详细配置。<span id="more"></span></p><blockquote><p><font size=5><b>文章说明</b></font><br><strong>文章作者：</strong><a href="https://hwame.top">鴻塵</a><br><strong>文章链接：</strong><a href="https://hwame.top/20200522/configuration-of-nginx-and-uwsgi.html">https://hwame.top/20200522/configuration-of-nginx-and-uwsgi.html</a></p></blockquote><h3 id="一、Nginx配置文件"><a href="#一、Nginx配置文件" class="headerlink" title="一、Nginx配置文件"></a>一、Nginx配置文件</h3><h4 id="1-指令"><a href="#1-指令" class="headerlink" title="1.指令"></a>1.指令</h4><p>Nginx配置文件包含指定指令控制的模块，指令分为 <strong><em>简单指令</em></strong> 和 <strong><em>块指令</em></strong> ，如果块指令大括号内有其他指令，就被称为一个 <strong><em>上下文</em></strong> ，比如<code>events, http, server, location</code>等。</p><blockquote><p><strong>简单指令</strong>：由名称和参数组成，以空格分隔，并以分号结尾；<br><strong>块指令</strong>：具有和简单指令相同的结构，以大括号包围的一堆附加指令结束。<br><strong>指令</strong>：</p><blockquote><p><code>nginx -t</code>不运行，仅测试配置文件；<br><code>nginx -c config_path</code>从指定路径加载配置文件；<br><code>nginx -t -c config_path</code>测试指定配置文件。</p></blockquote></blockquote><h4 id="2-控制命令"><a href="#2-控制命令" class="headerlink" title="2.控制命令"></a>2.控制命令</h4><p><strong>启动Nginx</strong>：<code>nginx [-c config_path]</code>，默认配置目录为<code>/etc/nginx/nginx.conf</code>。<br><strong>查看信息</strong>：<code>nginx -v</code>，查看版本信息；<code>nginx -V</code>，查看详细信息。<br><strong>查看进程</strong>：<code>ps -ef | grep nginx</code>，利用管道命令查看进程，ps命令用法参见：<a href="https://man.linuxde.net/ps">【Linux命令大全】</a><br><strong>控制Nginx</strong>：<code>nginx -s signal</code>，参数<code>signal</code>有<code>stop, quit, reload</code>，分别表示快速关闭、优雅关闭、重载配置<br><strong>系统管理</strong>：<code>systemctl option nginx</code>，参数<code>option</code>有<code>status, start, stop, enable, disable</code>，分别表示查看状态、启动服务、关闭服务、设置开机自启、禁止开机自启</p><h4 id="3-文件详情"><a href="#3-文件详情" class="headerlink" title="3.文件详情"></a>3.文件详情</h4><h5 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h5><p><strong>文件位置</strong>：默认位于<code>/etc/nginx/nginx.conf</code>，此乃默认配置文件，服务启动基于该文件。<br><strong>原文内容</strong>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">user nginx;</span><br><span class="line">worker_processes 1;</span><br><span class="line"></span><br><span class="line">error_log /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line">pid /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">worker-connections 1024 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">include /etc/nginx/mime.types;</span><br><span class="line">default_type appplication/octet-stream;</span><br><span class="line"></span><br><span class="line">log_format main <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line"><span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line">access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">sendfile on;</span><br><span class="line"><span class="comment">#tcp_nopush on;</span></span><br><span class="line"></span><br><span class="line">keepalive_timeout 65;</span><br><span class="line"></span><br><span class="line"><span class="comment">#gzip on;</span></span><br><span class="line"></span><br><span class="line">include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参数详解</strong>：</p><ul><li><strong><em><code>main</code></em></strong></li><li><ul><li><code>user</code>：worker进程运行的用户和组</li></ul></li><li><ul><li><code>worker_processes</code>：指定开启的子进程数，建议设置为与CPU数相等</li></ul></li><li><ul><li><code>error_log</code>：用来定义全局错误日志文件，如原文中路径为<code>/var/log/nginx/error.log</code>，级别<code>level</code>有<code>debug, info, notice, warn, error, crit</code></li></ul></li><li><ul><li><code>pid</code>：指定进程ID的存储文件位置</li></ul></li><li><strong><em><code>events</code></em></strong></li><li><ul><li><code>use</code>：指定Nginx工作模式，①<code>epoll=高效工作模式，Linux，默认</code>，②<code>kqueue=高效工作模式，BSD</code>，③<code>poll=标准模式</code>，④<code>epoll=标准模式</code></li></ul></li><li><ul><li><code>worker_connections</code>：每个进程的最大连接数，其中$正向代理=连接数×进程数$，$反向代理=\frac{1}{4}\times\text{连接数}\times\text{进程数}$<br>【Linux系统限制最多能同时打开$65535=2^{16}$个文件，亦即默认上限，能以<code>ulimit  -n 65535</code>解除】</li></ul></li><li><strong><em><code>http</code></em></strong>最核心的模块，主要负责http服务器相关配置，包含<code>server</code>和<code>upstream</code>子模块，见后文</li><li><ul><li><code>include</code>：第12行<code>include mime.types</code>设置文件的mime类型为<code>/etc/nginx/mime.types</code>所定义的类型，第27行<code>xxx.config</code>包含其他配置文件（分开规划解耦作用）的<code>server</code></li></ul></li><li><ul><li><code>default_type</code>：设置默认类型，当文件类型未知时将使用默认（注：<code>octet-stream=八进制字节流</code>）</li></ul></li><li><ul><li><code>log_format</code>：设置日志格式</li></ul></li><li><ul><li><code>access_log</code>：访问日志，中间为日志路径，最后<code>main</code>为日志格式<code>log_format</code>中的<code>main</code></li></ul></li><li><ul><li><code>sendfile</code>：设置高效文件传输模式</li></ul></li><li><ul><li><code>keepalive_timeout</code>：设置客户端连接活跃超时</li></ul></li><li><ul><li><code>gzip</code>：gzip压缩</li></ul></li></ul><p><strong>核心模块http</strong>：</p><ul><li><strong><em>upstream</em></strong>子模块，负载均衡，多服务器反向代理</li><li><ul><li><code>server ip:port weight=1</code>：指定反向代理服务器及分流权重</li></ul></li><li><strong><em>server</em></strong>子模块，用来指定虚拟主机</li><li><ul><li><code>listen 80;</code>：指定虚拟主机监听的端口，80端口表示http</li></ul></li><li><ul><li><code>server_name localhost;</code>：指定ip地址或域名，多个域名以空格分隔</li></ul></li><li><ul><li><code>charset utf-8</code>：指定网页的默认编码格式</li></ul></li><li><ul><li><code>error_page 500 502 /50x.html;</code>：指定错误页面，见<code>/etc/nginx/conf.d/*.conf</code>即<code>default.conf</code></li></ul></li><li><ul><li><code>access_log xxx main;</code>：指定虚拟主机的<strong>访问日志</strong>存放路径</li></ul></li><li><ul><li><code>error_log xxx main;</code>：指定虚拟主机的<strong>错误日志</strong>存放路径</li></ul></li><li><ul><li><code>root xxx;</code>：指定虚拟主机的根目录</li></ul></li><li><ul><li><code>index xxx;</code>：指定默认主页</li></ul></li><li><ul><li><code>location</code>：核心【server】中的核心【location】，后面主要就是配置这里，支持正则匹配和条件，其主要功能是定位和解析URL、实现动静分离。语法格式：<code>location [modifier] uri &#123;指令 xxx&#125;</code>，<strong>可选修饰符modifier</strong>表示定位URL的方式：①<code>=</code>，使用精确匹配并且终止搜索②<code>~</code>，区分大小写的正则③<code>~*</code>，不区分大小写的正则④<code>^~</code>，最佳匹配通常用来匹配目录（非正则匹配）；<strong>常用指令</strong>为<code>alias</code>，<code>alias</code>定义了<code>location</code>的别名（需要在文件系统中能够找到），如果<code>location</code>指定了正则表达式，<code>alias</code>将会应用正则表达式中的捕获，<code>alias</code>替代<code>location</code>中匹配的部分，没有匹配的部分将在文件系统中搜索</li></ul></li></ul><h5 id="default-conf"><a href="#default-conf" class="headerlink" title="default.conf"></a>default.conf</h5><p><strong>文件位置</strong>：位于<code>/etc/nginx/conf.d/nginx.conf</code>，只包含一个<code>server</code>模块。Nginx服务启动时由<code>nginx.conf</code>通过<code>include /etc/nginx/conf.d/*.conf;</code>引用其内容（即<code>server</code>），从而实现解耦。<br><strong>原文内容</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">    # concurs with nginx&#39;s one</span><br><span class="line">    #</span><br><span class="line">    #location ~ &#x2F;\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="二、uwsgi配置文件"><a href="#二、uwsgi配置文件" class="headerlink" title="二、uwsgi配置文件"></a>二、uwsgi配置文件</h3><h4 id="1-命令"><a href="#1-命令" class="headerlink" title="1.命令"></a>1.命令</h4><p>启动：<code>uwsgi --ini uwsgi.ini</code>，当前目录（项目目录）下新建ini文件<br>停止：<code>uwsgi --stop uwsgi.pid</code>，uWSGI服务器启动后在当前目录自动生成pid文件，无需新建</p><h4 id="2-文件详情"><a href="#2-文件详情" class="headerlink" title="2.文件详情"></a>2.文件详情</h4><p><strong>文件位置</strong>：位于<code>[Project_Dir]/uwsgi.ini</code>，此乃用户建立的配置文件，uwsgi服务启动基于该文件。<br><strong>文件内容</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"># 用于nginx与uwsgi对接时的uwsgi配置</span><br><span class="line"></span><br><span class="line"># (1)使用nginx连接时，使用socket</span><br><span class="line">socket &#x3D; ip:port</span><br><span class="line"></span><br><span class="line"># (2)直接作为web服务器使用(相当于测试，(1)(2)二选一)</span><br><span class="line">#http &#x3D; ip:port</span><br><span class="line"></span><br><span class="line"># (3)配置工程目录，wsgi-file为入口文件，此用于Flask</span><br><span class="line">chdir &#x3D; [Project_Absolute_dir]</span><br><span class="line">wsgi-file &#x3D; app.py</span><br><span class="line"># router</span><br><span class="line">callable &#x3D; app_flask_instance</span><br><span class="line"></span><br><span class="line"># (4)配置项目的wsgi目录，相对于工程目录(3)，此用于Django</span><br><span class="line">#chdir &#x3D; [Project_Absolute_dir]</span><br><span class="line">#wsgi-file &#x3D; Project_name&#x2F;wsgi.py</span><br><span class="line">#Note: unlike Flask, wsgi.py generated by Django automaticly</span><br><span class="line"></span><br><span class="line"># (5)配置进程和线程信息</span><br><span class="line">processes &#x3D; 4</span><br><span class="line">threads &#x3D; 10</span><br><span class="line">enable-threads &#x3D; True</span><br><span class="line">master &#x3D; True</span><br><span class="line">pidfile &#x3D; uwsgi.pid</span><br><span class="line">daemonize &#x3D; uwsgi.log</span><br></pre></td></tr></table></figure></p><h3 id="三、项目部署"><a href="#三、项目部署" class="headerlink" title="三、项目部署"></a>三、项目部署</h3><h4 id="1-项目描述"><a href="#1-项目描述" class="headerlink" title="1.项目描述"></a>1.项目描述</h4><p><strong>项目位置</strong>：位于<code>/usr/local/flask_covid/</code><br><strong>项目文件</strong>：主要包括<code>app.py</code>，<code>spider.py</code>，<code>static/css+js/</code>，<code>templates/main.html</code>，以及测试静态路由的文本文件<code>static/mmdd.md</code>。</p><h4 id="2-配置准备"><a href="#2-配置准备" class="headerlink" title="2.配置准备"></a>2.配置准备</h4><ol><li>将Nginx默认的配置文件<code>/etc/nginx/nginx.conf</code>和<code>/etc/nginx/conf.d/default.conf</code>复制到项目根目录下，<code>default.conf</code>用处不大（只需用到少量内容）</li><li>编辑配置文件<code>/usr/local/flask_covid/nginx.conf</code>【若因非root用户修改而出现权限问题，则需修改文件权限】，将<code>default.conf</code>内容去注释后复制到<code>nginx.conf</code>中的<code>include /etc/nginx/conf.d/*.conf;</code>处【由于将default配置转移过来了，所以不需要<code>include</code>语句来引用，删除之】，<code>nginx.conf</code>内容为：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">···omit text above···</span><br><span class="line"></span><br><span class="line">#include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">#Copy &quot;server &#123;...&#125;&quot; from file&#x3D;&quot;default.conf&quot;</span><br><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  localhost;</span><br><span class="line">#charset koi8-r;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   #Copy and replace over.</span><br></pre></td></tr></table></figure><ol><li>继续编辑配置文件<code>/usr/local/flask_covid/nginx.conf</code>，文件如上，修改如下：</li></ol><ul><li>(1)修改字符集：<code>charset utf-8;</code></li><li>(2)将<code>root</code>移动到上一级<code>server</code>下，并修改路径为项目的<strong>绝对路径</strong>：<code>root   /usr/local/flask_covid;</code></li><li>(3)修改URL静态路由的解析：首先将<code>location / &#123;···&#125;</code>修改为<code>location /static &#123;···&#125;</code>，以便于访问<code>./static</code>静态资源【注：ppt18，当client请求发出请求时，由Nginx直接提供静态资源，由uwsgi通过Nginx提供动态资源，后者才是真正意义上的代理】，然后为其内容设置别名<code>alias [Project_Absolute_dir]/static;</code></li><li>(4)由于默认用户为<code>user nginx;</code>时进程<code>master_process = root, worker_process = nginx</code>，为了避免请求静态资源时出现的因权限不够而请求失败的问题，故需修改用户：<code>user root;</code></li><li>此时在项目目录下执行<code>nginx -c /usr/local/flask_covid/nginx.conf</code>启动Nginx服务器，于是可以在浏览器中输入<a href="http://39.96.91.131/static/mmdd.md">http://ip/static/file_name（不加端口号）</a>访问到静态资源，就如同操作文件夹一样【实测成功，直接下载到了<code>./static/mmdd.md</code>文件，并且<code>./static</code>文件夹下的所有资源皆可访问到】。修改后<code>nginx.conf</code>内容为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">user root;</span><br><span class="line">worker_processes 1;</span><br><span class="line">error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span><br><span class="line">pid &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">worker-connections 1024 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">include &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">default_type appplication&#x2F;octet-stream;</span><br><span class="line">log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">&#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">&#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line">access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line">sendfile on;</span><br><span class="line">#tcp_nopush on;</span><br><span class="line">keepalive_timeout 65;</span><br><span class="line">#gzip on;</span><br><span class="line"></span><br><span class="line">#include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line"># ********** VERY IMPORTANT PARAGRAPH **********</span><br><span class="line">#Copy &quot;server &#123;...&#125;&quot; from file&#x3D;&quot;default.conf&quot;</span><br><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  localhost;</span><br><span class="line">charset utf-8;</span><br><span class="line">root   &#x2F;usr&#x2F;local&#x2F;flask_covid;</span><br><span class="line">location &#x2F;static &#123;</span><br><span class="line">alias &#x2F;usr&#x2F;local&#x2F;flask_covid&#x2F;static;</span><br><span class="line">&#125;</span><br><span class="line">error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    #Copy and replace over.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>至此测试成功</li></ol><h4 id="3-uWSGI配置"><a href="#3-uWSGI配置" class="headerlink" title="3.uWSGI配置"></a>3.uWSGI配置</h4><ol><li>安装uwsgi：<code>pip install uwsgi</code></li><li>工程目录下创建<code>uwsgi.ini</code>配置文件并添加配置信息，见2.2</li><li>个性化修改如下：</li></ol><ul><li>部署时用(1)，测试时用(2)，ip设置为<code>0.0.0.0</code>保证所有人可以访问，端口号与<code>app.py</code>相同；</li><li>Flask项目用(3)，Django项目用(4)，配置工程目录<code>chdir</code>为项目完整绝对路径，并与<code>nginx.conf</code>的<code>server → root</code>相同：<code>chdir = /usr/local/flask_covid</code>；<code>wsgi-file</code>为项目启动文件【注：Django项目会自动生成<code>./[Project_Name/wsgi.py]</code>】；</li><li>配置进程和线程，其中<code>enable-threads</code>表示线程可用</li></ul><ol><li>修改完成后<code>uwsgi.ini</code>内容为：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"># 用于nginx与uwsgi对接时的uwsgi配置</span><br><span class="line"></span><br><span class="line"># (1)使用nginx连接时，使用socket</span><br><span class="line">socket &#x3D; 0.0.0.0:5000</span><br><span class="line"># (2)直接作为web服务器使用(相当于测试，部署时与(1)二选一)</span><br><span class="line">#http &#x3D; 0.0.0.0:5000</span><br><span class="line"></span><br><span class="line"># (3)配置工程目录，wsgi-file为入口文件，callable为flask实例，此用于Flask</span><br><span class="line">chdir &#x3D; &#x2F;usr&#x2F;local&#x2F;flask_covid</span><br><span class="line">wsgi-file &#x3D; app.py</span><br><span class="line"># router</span><br><span class="line">callable &#x3D; app</span><br><span class="line"># (4)配置项目的wsgi目录，相对于工程目录(3)，此用于Django</span><br><span class="line">#chdir &#x3D; &#x2F;usr&#x2F;local&#x2F;flask_covid</span><br><span class="line">#wsgi-file &#x3D; flask_covid&#x2F;wsgi.py</span><br><span class="line">#Note: unlike flask, wsgi.py generated by Django automaticly</span><br><span class="line"></span><br><span class="line"># (5)配置进程和线程信息</span><br><span class="line">processes &#x3D; 2</span><br><span class="line">threads &#x3D; 4</span><br><span class="line">enable-threads &#x3D; True</span><br><span class="line">master &#x3D; True</span><br><span class="line">pidfile &#x3D; uwsgi.pid</span><br><span class="line">daemonize &#x3D; uwsgi.log</span><br></pre></td></tr></table></figure><ol><li>使用uWSGI服务器：</li></ol><ul><li>启动：<code>uwsgi --ini uwsgi.ini</code>，不能加<code>sudo</code></li><li>停止：<code>uwsgi --stop uwsgi.pid</code>，uWSGI服务器启动后在当前目录自动生成pid文件，无需新建</li></ul><ol><li>测试（打开(2)、关闭(1)）：启动 Nginx和uWSGI服务器，出现<code>[uWSGI] getting INI configuration from /usr/local/flask_covid/uwsgi.ini</code>的信息表明 uWSGI配置成功，此时可以在浏览器中输入<a href="http://39.96.91.131:5000">http://ip:port（加端口号）</a>访问</li><li>部署（打开(1)、关闭(2)）：见3.2</li></ol><h4 id="4-Nginx配置"><a href="#4-Nginx配置" class="headerlink" title="4.Nginx配置"></a>4.Nginx配置</h4><ol><li>首先停止3.3的测试：<code>uwsgi --stop /usr/local/flask_covid/uwsgi.pid</code>【注：如果无法停止并报错：<code>signal_pidfile()/kill(): No such process [core/uwsgi.c line 1693]</code>，首先利用<code>ps -ef | grep uwsgi</code>查询其进程号，然后将<code>uwsgi.pid</code>文件修改为相应进程号，最后执行停止命令】</li><li>部署时，uWSGI与 Nginx的对接依赖于<code>/etc/nginx/uwsgi_params</code>文件，该文件在安装uwsgi时自动生成，其定义了一系列的uwsgi参数</li><li>编辑配置文件<code>/usr/local/flask_covid/nginx.conf</code>，在原来配置好了的静态文件下配置首页目录，<code>location</code>定位和解析的URL<code>/</code>就表示首页，然后利用<code>include</code>去对接<code>uwsgi_params</code>文件，<code>uwsgi_pass</code>去关联<code>localhost</code>【因为uWSGI与 服务器同属一个地方】，端口号<code>port</code>必须与3.3<code>uwsgi.ini</code>的<code>socket</code>一致，如下所示：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;static &#123;</span><br><span class="line">alias xxx&#x2F;static&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">include &#x2F;etc&#x2F;nginx&#x2F;uwsgi_params;</span><br><span class="line">uwsgi_pass localhost:5000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>由于修改了Nginx配置，因此需要先关闭服务<code>nginx -s quit</code>，然后重新启动：<code>nginx -c /usr/local/flask_covid/nginx.conf</code></li><li>启动uWSGI服务器：<code>uwsgi --ini /usr/local/flask_covid/uwsgi.ini</code></li><li>此时nginx与uwsgi便对接成功，可以在浏览器中输入<a href="http://39.96.91.131">http://ip（不加端口号）</a>进行访问【由于<code>location /&#123;...&#125;</code>下面有<code>uwsgi_pass localhost:8000</code>进行转发代理，自动加上port，因此不能加端口号】</li></ol><h3 id="四、总结建议"><a href="#四、总结建议" class="headerlink" title="四、总结建议"></a>四、总结建议</h3><p>不建议改变Nginx默认的配置文件<code>/etc/nginx/nginx.conf</code>的位置，当部署大型项目时，或有多个服务需要同时运行，则将导致配置文件的混乱，且难以使用系统服务管理工具<code>systemctl</code>，建议的做法是针对具体的项目，在<code>/etc/nginx/conf.d/</code>目录下创建具有标识性的独用于本项目的配置文件<code>myproject.conf</code>，便于维护。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：文章介绍了&lt;code&gt;Nginx&lt;/code&gt;与&lt;code&gt;uWSGI&lt;/code&gt;的知识，并依具体的例子对&lt;code&gt;Web&lt;/code&gt;应用进行详细配置。</summary>
    
    
    
    <category term="Linux" scheme="https://xxren8218.github.io/categories/Linux/"/>
    
    
    <category term="Linux部署" scheme="https://xxren8218.github.io/tags/Linux%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
</feed>
