<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-09-12T11:48:55.172Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序与搜索算法</title>
    <link href="https://xxren8218.github.io/20210912/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html"/>
    <id>https://xxren8218.github.io/20210912/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html</id>
    <published>2021-09-12T11:44:44.000Z</published>
    <updated>2021-09-12T11:48:55.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-排序算法"><a href="#1-排序算法" class="headerlink" title="1.排序算法"></a>1.排序算法</h1><p>介绍以下几种排序算法：</p><h2 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h2><p><strong>冒泡排序</strong>（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>冒泡排序算法的运作如下：</p><ul><li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><h3 id="冒泡排序的分析"><a href="#冒泡排序的分析" class="headerlink" title="冒泡排序的分析"></a>冒泡排序的分析</h3><p>交换过程图示(第一次)：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194509.jpg" alt=""></p><p>那么我们需要进行n-1次冒泡过程，每次对应的比较次数如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194526.bmp" alt=""></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）</li><li>最坏时间复杂度：O(n^2)</li><li>稳定性：稳定</li></ul><h3 id="冒泡排序的演示"><a href="#冒泡排序的演示" class="headerlink" title="冒泡排序的演示"></a>冒泡排序的演示</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194540.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">alist</span>):</span>  <span class="comment"># 作用在链表上时候，交换两个链表的指针即可。</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):  <span class="comment"># 班长第几次走这个过程。</span></span><br><span class="line">        count = <span class="number">0</span>  <span class="comment"># 改进以后。最优为O(n).</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - <span class="number">1</span> - j):</span><br><span class="line">            <span class="comment"># 班长从头走到尾【0，n - 2】</span></span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i + <span class="number">1</span>]:</span><br><span class="line">                alist[i], alist[i + <span class="number">1</span>] = alist[i + <span class="number">1</span>], alist[i]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> == count:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># [1, 2,3 ,4 ,5, 6]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># i 0 ~ n-2   range(0, n-1) j=0</span></span><br><span class="line"><span class="comment"># i 0 ~ n-3   range(0, n-1-1) j=1</span></span><br><span class="line"><span class="comment"># i 0 ~ n-4   range(0, n-1-2) j=2</span></span><br><span class="line"><span class="comment"># j=n  i  range(0, n-1-j)</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    li = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">    print(li)</span><br><span class="line">    bubble_sort(li)</span><br><span class="line">    print(li)</span><br></pre></td></tr></table></figure><h2 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h2><p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h3 id="选择排序分析"><a href="#选择排序分析" class="headerlink" title="选择排序分析"></a>选择排序分析</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194559.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194611.gif" alt=""></p><p>红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alist = [17, 20,         93,54,77,31,44,55,226]</span></span><br><span class="line"><span class="comment">#          0   1         2   3  4  5  6  7  8</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># j=0</span></span><br><span class="line"><span class="comment"># min = 0  0+1</span></span><br><span class="line"><span class="comment"># alist[0], alist[3] = alist[3], alist[0]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># j=1</span></span><br><span class="line"><span class="comment"># min = 1  1+1</span></span><br><span class="line"><span class="comment"># alist[1], alist[8] = alist[8], alist[1]</span></span><br><span class="line"><span class="comment"># j=2</span></span><br><span class="line"><span class="comment"># min = 2  2+1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;选择排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>): <span class="comment"># j: 0 ~ n-2</span></span><br><span class="line">        min_index = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> alist[min_index] &gt; alist[i]:</span><br><span class="line">                min_index = i</span><br><span class="line">        alist[j], alist[min_index] = alist[min_index], alist[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    li = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">26</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]   <span class="comment"># 稳定性：不稳定（考虑升序每次选择最大的情况）</span></span><br><span class="line">    print(li)</span><br><span class="line">    select_sort(li)</span><br><span class="line">    print(li)</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最优时间复杂度：O(n2)</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定（考虑升序每次选择最大的情况）</li></ul><h3 id="选择排序演示"><a href="#选择排序演示" class="headerlink" title="选择排序演示"></a>选择排序演示</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194626.gif" alt=""></p><h2 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h2><p><strong>插入排序</strong>（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="插入排序分析"><a href="#插入排序分析" class="headerlink" title="插入排序分析"></a>插入排序分析</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194644.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194657.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alist = [91,      54, 77, 31, 44, 55, 226]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alist = [54,      91, 77, 31, 44, 55, 226]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alist = [54, 91,      77, 31, 44, 55, 226]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alist = [54, 77,      91, 31, 44, 55, 226]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alist = [54, 77, 91,      31, 44, 55, 226]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alist = [54, 77, 31,      91, 44, 55, 226]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alist = [54, 31, 77,      91, 44, 55, 226]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alist = [31, 54, 77,      91, 44, 55, 226]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alist = [31, 54, 77, 91,      44, 55, 226]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alist = [31, 54, 77, 44,      91, 55, 226]</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># alist = [31, 44, 54, 77,      91, 55, 226]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alist = [31, 44, 54, 77, 91,      55, 226]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;插入排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="comment"># 从右边的无序序列中取出多少个元素执行这样的过程</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># j = [1, 2, 3, n-1]</span></span><br><span class="line">        <span class="comment"># i 代表内层循环起始值</span></span><br><span class="line">        i = j</span><br><span class="line">        <span class="comment"># 执行从右边的无序序列中取出第一个元素，即i位置的元素，然后将其插入到前面的正确位置中</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> alist[i] &lt; alist[i-<span class="number">1</span>]:</span><br><span class="line">                alist[i], alist[i-<span class="number">1</span>] = alist[i-<span class="number">1</span>], alist[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 如果没有它，则前面有序的还会进行判断，直到 i = 0.时间复杂度始终为 O(n**2)</span></span><br><span class="line">                        <span class="comment"># 若是有序序列。则时间复杂度最优，为O(n)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    li = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">    print(li)</span><br><span class="line">    insert_sort(li)</span><br><span class="line">    print(li)</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：稳定</li></ul><h3 id="插入排序演示"><a href="#插入排序演示" class="headerlink" title="插入排序演示"></a>插入排序演示</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194711.gif" alt=""></p><h2 id="1-4-希尔排序"><a href="#1-4-希尔排序" class="headerlink" title="1.4 希尔排序"></a>1.4 希尔排序</h2><p><strong>希尔排序</strong>(Shell Sort)是<strong>插入排序的一种</strong>。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h3 id="希尔排序过程"><a href="#希尔排序过程" class="headerlink" title="希尔排序过程"></a>希尔排序过程</h3><p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p><p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样(竖着的元素是步长组成)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span> <span class="number">14</span> <span class="number">94</span> <span class="number">33</span> <span class="number">82</span></span><br><span class="line"><span class="number">25</span> <span class="number">59</span> <span class="number">94</span> <span class="number">65</span> <span class="number">23</span></span><br><span class="line"><span class="number">45</span> <span class="number">27</span> <span class="number">73</span> <span class="number">25</span> <span class="number">39</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>然后我们对每列进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">14</span> <span class="number">73</span> <span class="number">25</span> <span class="number">23</span></span><br><span class="line"><span class="number">13</span> <span class="number">27</span> <span class="number">94</span> <span class="number">33</span> <span class="number">39</span></span><br><span class="line"><span class="number">25</span> <span class="number">59</span> <span class="number">94</span> <span class="number">65</span> <span class="number">82</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">14</span> <span class="number">73</span></span><br><span class="line"><span class="number">25</span> <span class="number">23</span> <span class="number">13</span></span><br><span class="line"><span class="number">27</span> <span class="number">94</span> <span class="number">33</span></span><br><span class="line"><span class="number">39</span> <span class="number">25</span> <span class="number">59</span></span><br><span class="line"><span class="number">94</span> <span class="number">65</span> <span class="number">82</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure><p>排序之后变为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">14</span> <span class="number">13</span></span><br><span class="line"><span class="number">25</span> <span class="number">23</span> <span class="number">33</span></span><br><span class="line"><span class="number">27</span> <span class="number">25</span> <span class="number">59</span></span><br><span class="line"><span class="number">39</span> <span class="number">65</span> <span class="number">73</span></span><br><span class="line"><span class="number">45</span> <span class="number">94</span> <span class="number">82</span></span><br><span class="line"><span class="number">94</span></span><br></pre></td></tr></table></figure><p>最后以1步长进行排序（此时就是简单的插入排序了）</p><h3 id="希尔排序的分析"><a href="#希尔排序的分析" class="headerlink" title="希尔排序的分析"></a>希尔排序的分析</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194725.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;希尔排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># n=9</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="comment"># gap =4</span></span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># gap变化到0之前，插入算法执行的次数</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 插入算法，与普通的插入算法的区别就是gap步长</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            <span class="comment"># j = [gap, gap+1, gap+2, gap+3, ..., n-1]</span></span><br><span class="line">            i = j</span><br><span class="line">            <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> alist[i] &lt; alist[i-gap]:</span><br><span class="line">                    alist[i], alist[i-gap] = alist[i-gap], alist[i]</span><br><span class="line">                    i -= gap</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 缩短gap步长</span></span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    li = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">    print(li)</span><br><span class="line">    shell_sort(li)</span><br><span class="line">    print(li)</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最优时间复杂度：根据步长序列的不同而不同</li><li>最坏时间复杂度：O(n2)</li><li>稳定想：不稳定</li></ul><h3 id="希尔排序演示"><a href="#希尔排序演示" class="headerlink" title="希尔排序演示"></a>希尔排序演示</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194741.gif" alt=""></p><h2 id="1-5-快速排序"><a href="#1-5-快速排序" class="headerlink" title="1.5 快速排序"></a>1.5 快速排序</h2><p><strong>快速排序</strong>（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>步骤为：</p><ol><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><h3 id="快速排序的分析"><a href="#快速排序的分析" class="headerlink" title="快速排序的分析"></a>快速排序的分析</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194753.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">alist, first, last</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> first &gt;= last:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid_value = alist[first]</span><br><span class="line">    low = first</span><br><span class="line">    high = last</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="comment"># high 左移</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid_value:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        alist[low] = alist[high]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> low &lt;high <span class="keyword">and</span> alist[low] &lt; mid_value:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        alist[high] = alist[low]</span><br><span class="line">    <span class="comment"># 从循环退出时，low==high</span></span><br><span class="line">    alist[low] = mid_value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对low左边的列表执行快速排序</span></span><br><span class="line">    quick_sort(alist, first, low-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对low右边的列表排序</span></span><br><span class="line">    quick_sort(alist, low+<span class="number">1</span>, last)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    li = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">    print(li)</span><br><span class="line">    quick_sort(li, <span class="number">0</span>, <span class="built_in">len</span>(li)-<span class="number">1</span>)</span><br><span class="line">    print(li)</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最优时间复杂度：O(nlogn)</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定</li></ul><p>从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。</p><p>在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。</p><h3 id="快速排序演示"><a href="#快速排序演示" class="headerlink" title="快速排序演示"></a>快速排序演示</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194808.gif" alt=""></p><h2 id="1-6-归并排序"><a href="#1-6-归并排序" class="headerlink" title="1.6 归并排序"></a>1.6 归并排序</h2><p><strong>归并排序</strong>是采用分治法的一个非常典型的应用。归并排序的思想就是<strong>先递归分解数组，再合并数组</strong>。</p><p>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p><h3 id="归并排序的分析"><a href="#归并排序的分析" class="headerlink" title="归并排序的分析"></a>归并排序的分析</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194819.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;归并排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    mid = n//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># left 采用归并排序后形成的有序的新的列表</span></span><br><span class="line">    left_li = merge_sort(alist[:mid])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># right 采用归并排序后形成的有序的新的列表</span></span><br><span class="line">    right_li = merge_sort(alist[mid:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将两个有序的子序列合并为一个新的整体</span></span><br><span class="line">    <span class="comment"># merge(left, right)</span></span><br><span class="line">    left_pointer, right_pointer = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left_pointer &lt; <span class="built_in">len</span>(left_li) <span class="keyword">and</span> right_pointer &lt; <span class="built_in">len</span>(right_li):</span><br><span class="line">        <span class="keyword">if</span> left_li[left_pointer] &lt;=  right_li[right_pointer]: <span class="comment"># 保证稳定性，两边相等的话，先把左边的放进去，再把右边的放进去。</span></span><br><span class="line">            result.append(left_li[left_pointer])</span><br><span class="line">            left_pointer += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right_li[right_pointer])</span><br><span class="line">            right_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    result += left_li[left_pointer:]</span><br><span class="line">    result += right_li[right_pointer:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    li = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</span><br><span class="line">    print(li)</span><br><span class="line">    sorted_li = merge_sort(li)</span><br><span class="line">    print(li)</span><br><span class="line">    print(sorted_li)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># merge_sort   [54, 26, 93, 17, 77, 31, 44, 55, 20]</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># left_li = merge_sort [54, 26, 93, 17]</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     left_li = merge_sort [54, 26]</span></span><br><span class="line">    <span class="comment">#     left_li = [26, 54]</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#              left_li = [54]</span></span><br><span class="line">    <span class="comment">#              right_li = [26]</span></span><br><span class="line">    <span class="comment">#              result = [26, 54]</span></span><br><span class="line">    <span class="comment">#              return result</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     right_li = merge_sort([93, 17])</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#             left_li = merge_sort([93])</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#                         return [93]</span></span><br><span class="line">    <span class="comment">#             left_li =[93]</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#             right_li = merge_sort([17])</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#                         return [17]</span></span><br><span class="line">    <span class="comment">#             right_li = [17]</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#             result = [17, 93]</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#             return result</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     right_li = [17, 93]</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     result = [17, 26, 54, 93]</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     return result</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># left_li = [17, 26, 54, 93]</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># right_li = merge_sort([77, 31, 44, 55, 20])</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># result = []</span></span><br><span class="line">    <span class="comment"># return result</span></span><br></pre></td></tr></table></figure><h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最优时间复杂度：O(nlogn)</li><li>最坏时间复杂度：O(nlogn)</li><li>稳定性：稳定</li></ul><h2 id="1-7-堆排序"><a href="#1-7-堆排序" class="headerlink" title="1.7 堆排序"></a>1.7 堆排序</h2><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p>堆是一颗完全二叉树</p><blockquote><p>完全二叉树:<br>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p></blockquote><p>说白了就是这棵树除了最后面。</p><p>然后堆这颗二叉树有什么特点呢?<br>如果一颗完全二叉树里任意一个节点都比他的两个子节点要大,那么这棵树称为大根堆<br>反之,称为小根堆</p><h3 id="列表的堆化"><a href="#列表的堆化" class="headerlink" title="列表的堆化"></a>列表的堆化</h3><p>众所周知,一颗完全二叉树可以用一个列表直接表示,因为每一行基本是满的嘛<br>例如上图,用列表表示就是1 2 3 4 5 6 7 8 9 10<br>这样,他就会有一个神奇的性质:</p><blockquote><p>父结点索引：(i-1) // 2 # Python中需要整除<br>左孩子索引：2<em>i+1<br>右孩子索引：2</em>i+2<br>所以说,任何一个列表都可以看成是一个完全二叉树,而将完全二叉树树转化为堆的过程就被称为堆化。</p></blockquote><h3 id="堆化的过程"><a href="#堆化的过程" class="headerlink" title="堆化的过程"></a>堆化的过程</h3><p>这里只讲大根堆化,另一个反着想就可以了<br>堆化的思路是,先保证前<code>i</code>个元素是堆,再把<code>i+1</code>个元素插入进去<br>插入的时候,每次把他和他的父节点进行比较,如果他比父节点大,不成体统,那就把他们交换,然后再向爷爷去比较,直到替换完全</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">    <span class="comment">#print(&#x27;---&#x27;)</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> arr[(i-<span class="number">1</span>) // <span class="number">2</span>] &lt; arr[i]:</span><br><span class="line">        <span class="comment">#print(i)</span></span><br><span class="line">        arr[(i-<span class="number">1</span>) // <span class="number">2</span>],arr[i] = arr[i],arr[(i-<span class="number">1</span>) // <span class="number">2</span>]</span><br><span class="line">        i = (i-<span class="number">1</span>) // <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是指,将一个大根堆转换为一个从小到大排序的列表,那我们来看看怎么实现的:</p><p>我们知道,大根堆中,毫无疑问的,第一个元素就是整个列表中最大的那个.</p><ol><li>首先将堆中第一个元素与最后一个元素更换位置,并不再处理(可以直接理解为数组长度-1),<strong>现在我们找到了列表中最大的元素</strong></li><li>此时,这个列表除了第一个元素外,其余的部分依旧是一个堆。这个时候我们将它与它儿子中较大的那个进行更换,那么仅就这三个元素而言,又变回了一个堆,<br><strong>然后我们重复这个步骤,此时,整个列表再次变回了一个大根堆</strong></li><li>我们不断进行12过程,则列表中最大的数字一个个被提出,最终就完成排序了</li></ol><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">    arr[<span class="number">0</span>], arr[<span class="built_in">len</span>(arr)-i-<span class="number">1</span>] = arr[<span class="built_in">len</span>(arr)-i-<span class="number">1</span>], arr[<span class="number">0</span>] <span class="comment"># 交换首尾位置</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x, y = flag*<span class="number">2</span>+<span class="number">1</span>, flag*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        nums = &#123;arr[flag] : flag&#125;</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="built_in">len</span>(arr)-i-<span class="number">1</span>:</span><br><span class="line">            nums[arr[x]] = x</span><br><span class="line">        <span class="keyword">if</span> y &lt; <span class="built_in">len</span>(arr)-i-<span class="number">1</span>:</span><br><span class="line">            nums[arr[y]] = y</span><br><span class="line">        temp = <span class="built_in">max</span>(nums.keys())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> arr[flag] &lt; temp: <span class="comment">#与较大的那个交换位置,如果自己就是最大的,或者找到了尽头,则循环结束</span></span><br><span class="line">            arr[flag],arr[nums[temp]] = arr[nums[temp]],arr[flag]</span><br><span class="line">            flag = nums[temp]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>最后的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">34</span>,<span class="number">53</span>,<span class="number">22</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">29</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">    <span class="comment">#print(&#x27;---&#x27;)</span></span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> arr[(i-<span class="number">1</span>)//<span class="number">2</span>] &lt; arr[i]:</span><br><span class="line">        <span class="comment">#print(i)</span></span><br><span class="line">        arr[(i-<span class="number">1</span>)//<span class="number">2</span>],arr[i] = arr[i],arr[(i-<span class="number">1</span>)//<span class="number">2</span>]</span><br><span class="line">        i = (i-<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆排序</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">    arr[<span class="number">0</span>], arr[<span class="built_in">len</span>(arr)-i-<span class="number">1</span>] = arr[<span class="built_in">len</span>(arr)-i-<span class="number">1</span>], arr[<span class="number">0</span>] <span class="comment"># 交换首尾位置</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x,y = flag*<span class="number">2</span>+<span class="number">1</span>,flag*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        nums = &#123;arr[flag] : flag&#125;</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="built_in">len</span>(arr)-i-<span class="number">1</span>:</span><br><span class="line">            nums[arr[x]] = x</span><br><span class="line">        <span class="keyword">if</span> y &lt; <span class="built_in">len</span>(arr)-i-<span class="number">1</span>:</span><br><span class="line">            nums[arr[y]] = y</span><br><span class="line">        temp = <span class="built_in">max</span>(nums.keys())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> arr[flag] &lt; temp: <span class="comment"># 当前节点与较大的那个交换位置,如果自己就是最大的,或者找到了尽头,则循环结束</span></span><br><span class="line">            arr[flag],arr[nums[temp]] = arr[nums[temp]],arr[flag]</span><br><span class="line">            flag = nums[temp]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(arr) <span class="comment"># [1, 2, 2, 3, 3, 4, 4, 4, 5, 7, 22, 29, 33, 34, 53]</span></span><br></pre></td></tr></table></figure><h2 id="各个排序算法的对比"><a href="#各个排序算法的对比" class="headerlink" title="各个排序算法的对比"></a>各个排序算法的对比</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194842.PNG" alt=""></p><h2 id="2-搜索算法"><a href="#2-搜索算法" class="headerlink" title="2.搜索算法"></a>2.搜索算法</h2><h3 id="二分查找整体框架："><a href="#二分查找整体框架：" class="headerlink" title="二分查找整体框架："></a>二分查找整体框架：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    left, right = <span class="number">0</span>, ...</span><br><span class="line">    <span class="keyword">while</span> ...:</span><br><span class="line">        mid = (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; right:</span><br><span class="line">            left = ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; right:</span><br><span class="line">            right = ...</span><br><span class="line">    <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure><p><strong>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 elif 写清楚，这样可以清楚地展现所有细节</strong>。本文都会使用 elif，旨在讲清楚，读者理解后可自行简化。</p><h3 id="基本的二分查找："><a href="#基本的二分查找：" class="headerlink" title="基本的二分查找："></a>基本的二分查找：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (right - left) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h3 id="寻找左边界的二分查找"><a href="#寻找左边界的二分查找" class="headerlink" title="寻找左边界的二分查找"></a>寻找左边界的二分查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_bound</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span>, n <span class="comment"># 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt; right: <span class="comment"># 注意</span></span><br><span class="line">        mid = (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid <span class="comment"># 注意</span></span><br><span class="line">     </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    # target比所有数都大</span></span><br><span class="line"><span class="string">    if left == len(nums) return -1</span></span><br><span class="line"><span class="string">    # 类似之前算法的处理方式</span></span><br><span class="line"><span class="string">    return left if nums[left] == target else -1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="寻找右边界的二分查找"><a href="#寻找右边界的二分查找" class="headerlink" title="寻找右边界的二分查找"></a>寻找右边界的二分查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_bound</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span>, n </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt; right: </span><br><span class="line">        mid = (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line">            </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    if left == 0: return -1</span></span><br><span class="line"><span class="string">    return left - 1 if nums[left - 1] == target else -1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span> <span class="comment"># 注意</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-排序算法&quot;&gt;&lt;a href=&quot;#1-排序算法&quot; class=&quot;headerlink&quot; title=&quot;1.排序算法&quot;&gt;&lt;/a&gt;1.排序算法&lt;/h1&gt;&lt;p&gt;介绍以下几种排序算法：&lt;/p&gt;
&lt;h2 id=&quot;1-1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-1-冒泡排序&quot; </summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python高级-2</title>
    <link href="https://xxren8218.github.io/20210912/python%E9%AB%98%E7%BA%A7-2.html"/>
    <id>https://xxren8218.github.io/20210912/python%E9%AB%98%E7%BA%A7-2.html</id>
    <published>2021-09-12T11:37:46.000Z</published>
    <updated>2021-09-12T11:44:26.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-with与“上下文管理器”"><a href="#1-with与“上下文管理器”" class="headerlink" title="1.with与“上下文管理器”"></a>1.with与“上下文管理器”</h3><h4 id="普通版："><a href="#普通版：" class="headerlink" title="普通版："></a>普通版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m1</span>():</span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;python之禅&quot;</span>)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>这样写有一个潜在的问题，如果在调用 write 的过程中，出现了异常进而导致后续代码无法继续执行，close 方法无法被正常调用，因此资源就会一直被该程序占用者释放。那么该如何改进代码呢？</p><h4 id="进阶版："><a href="#进阶版：" class="headerlink" title="进阶版："></a>进阶版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m2</span>():</span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f.write(<span class="string">&quot;python之禅&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        print(<span class="string">&quot;oops error&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>改良版本的程序是对可能发生异常的代码处进行 try 捕获，使用 try/finally 语句，该语句表示如果在 try 代码块中程序出现了异常，后续代码就不再执行，而直接跳转到 except 代码块。而无论如何，finally 块的代码最终都会被执行。因此，只要把 close 放在 finally 代码中，文件就一定会关闭。</p><h4 id="高级版："><a href="#高级版：" class="headerlink" title="高级版："></a>高级版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m3</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;Python之禅&quot;</span>)</span><br></pre></td></tr></table></figure><p>一种更加简洁、优雅的方式就是用 with 关键字。open 方法的返回值赋值给变量 f，当离开 with 代码块的时候，系统会自动调用 f.close() 方法， with 的作用和使用 try/finally 语句是一样的。那么它的实现原理是什么？在讲 with 的原理前要涉及到另外一个概念，就是上下文管理器（Context Manager）。</p><h4 id="什么是上下文-context"><a href="#什么是上下文-context" class="headerlink" title="什么是上下文(context)?"></a>什么是上下文(context)?</h4><p>上下文在不同的地方表示不同的含义，要感性理解。context其实说白了，和文章的上下文是一个意思，在通俗一点，我觉得叫环境更好。….</p><p>林冲大叫一声“啊也！”….</p><p>问:这句话林冲的“啊也”表达了林冲怎样的心里？</p><p>答:啊你妈个头啊！</p><p>看，一篇文章，给你摘录一段，没前没后，你读不懂，因为有语境，就是语言环境存在，一段话说了什么，要通过上下文(文章的上下文)来推断。</p><p>app点击一个按钮进入一个新的界面，也要保存你是在哪个屏幕跳过来的等等信息，以便你点击返回的时候能正确跳回，如果不存肯定就无法正确跳回了。</p><p>看这些都是上下文的典型例子，理解成环境就可以，(而且上下文虽然叫上下文，但是程序里面一般都只有上文而已，只是叫的好听叫上下文。。进程中断在操作系统中是有上有下的，不过不这个高深的问题就不要深究了。。。</p><h4 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h4><p>任何实现了 __enter__() 和 __exit__() 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字。显然，文件（file）对象也实现了上下文管理器。</p><p>那么文件对象是如何实现这两个方法的呢？我们可以模拟实现一个自己的文件类，让该类实现 __enter__() 和 __exit__() 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filename, mode</span>):</span></span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;entering&quot;</span>)</span><br><span class="line">        self.f = <span class="built_in">open</span>(self.filename, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self.f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        print(<span class="string">&quot;will exit&quot;</span>)</span><br><span class="line">        self.f.close()</span><br></pre></td></tr></table></figure><p>__enter__() 方法返回资源对象，这里就是你将要打开的那个文件对象，__exit__() 方法处理一些清除工作。</p><p>因为 File 类实现了上下文管理器，现在就可以使用 with 语句了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> File(<span class="string">&#x27;out.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">&quot;writing&quot;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;hello, python&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这样，你就无需显示地调用 close 方法了，由系统自动去调用，哪怕中间遇到异常 close 方法也会被调用。</p><h3 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2.闭包"></a>2.闭包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问题：初中里学过函数，例如 y=kx+b, y=ax^2 + bx + c</span></span><br><span class="line"><span class="comment"># 以y=kx+b为例，请计算一条线上的过个点 即 给x值 计算出y值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第1种</span></span><br><span class="line">k = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">y = k*x + b</span><br><span class="line"><span class="comment"># 缺点：如果需要多次计算，那么就的写多次y = k*x+b这样的式子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2种</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">line_2</span>(<span class="params">k, b, x</span>):</span></span><br><span class="line">print(k*x + b)</span><br><span class="line"></span><br><span class="line">line_2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">line_2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">line_2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 缺点：如果想要计算多次这条线上的y值，那么每次都需要传递k，b的值，麻烦</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;-&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3种: 全局变量</span></span><br><span class="line">k = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">line_3</span>(<span class="params">x</span>):</span></span><br><span class="line">print(k*x + b)</span><br><span class="line"></span><br><span class="line">line_3(<span class="number">0</span>)</span><br><span class="line">line_3(<span class="number">1</span>)</span><br><span class="line">line_3(<span class="number">2</span>)</span><br><span class="line">k = <span class="number">11</span></span><br><span class="line">b = <span class="number">22</span></span><br><span class="line">line_3(<span class="number">0</span>)</span><br><span class="line">line_3(<span class="number">1</span>)</span><br><span class="line">line_3(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 缺点：如果要计算多条线上的y值，那么需要每次对全局变量进行修改，代码会增多，麻烦</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;-&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4种：缺省参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">line_4</span>(<span class="params">x, k=<span class="number">1</span>, b=<span class="number">2</span></span>):</span></span><br><span class="line">print(k*x + b)</span><br><span class="line"></span><br><span class="line">line_4(<span class="number">0</span>)</span><br><span class="line">line_4(<span class="number">1</span>)</span><br><span class="line">line_4(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">line_4(<span class="number">0</span>, k=<span class="number">11</span>, b=<span class="number">22</span>)</span><br><span class="line">line_4(<span class="number">1</span>, k=<span class="number">11</span>, b=<span class="number">22</span>)</span><br><span class="line">line_4(<span class="number">2</span>, k=<span class="number">11</span>, b=<span class="number">22</span>)</span><br><span class="line"><span class="comment"># 优点：比全局变量的方式好在：k, b是函数line_4的一部分 而不是全局变量，因为全局变量可以任意的被其他函数所修改</span></span><br><span class="line"><span class="comment"># 缺点：如果要计算多条线上的y值，那么需要在调用的时候进行传递参数，麻烦</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;-&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第5种：实例对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line5</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k, b</span>):</span></span><br><span class="line">self.k = k</span><br><span class="line">self.b = b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">print(self.k * x + self.b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line_5_1 = Line5(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 对象.方法()</span></span><br><span class="line"><span class="comment"># 对象()</span></span><br><span class="line">line_5_1(<span class="number">0</span>)</span><br><span class="line">line_5_1(<span class="number">1</span>)</span><br><span class="line">line_5_1(<span class="number">2</span>)</span><br><span class="line">line_5_2 = Line5(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">line_5_2(<span class="number">0</span>)</span><br><span class="line">line_5_2(<span class="number">1</span>)</span><br><span class="line">line_5_2(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 缺点：为了计算多条线上的y值，所以需要保存多个k, b的值，因此用了很多个实例对象， 浪费资源</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;-&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第6种：闭包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">line_6</span>(<span class="params">k, b</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_y</span>(<span class="params">x</span>):</span></span><br><span class="line">print(k*x + b)</span><br><span class="line"><span class="keyword">return</span> create_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line_6_1 = line_6(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">line_6_1(<span class="number">0</span>)</span><br><span class="line">line_6_1(<span class="number">1</span>)</span><br><span class="line">line_6_1(<span class="number">2</span>)</span><br><span class="line">line_6_2 = line_6(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">line_6_2(<span class="number">0</span>)</span><br><span class="line">line_6_2(<span class="number">1</span>)</span><br><span class="line">line_6_2(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思考：函数、匿名函数、闭包、对象 当做实参时 有什么区别？</span></span><br><span class="line"><span class="comment"># 1. 匿名函数能够完成基本的简单功能，，，传递是这个函数的引用 只有功能.</span></span><br><span class="line"><span class="comment"># 2. 普通函数能够完成较为复杂的功能，，，传递是这个函数的引用 只有功能.</span></span><br><span class="line"><span class="comment"># 3. 闭包能够将较为复杂的功能，，，传递是这个闭包中的函数以及数据，因此传递是功能+数据</span></span><br><span class="line"><span class="comment"># 4. 对象能够完成最为复杂的功能，，，传递是很多数据+很多功能，因此传递是功能+数据</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193818.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193831.jpg" alt=""></p><blockquote><h4 id="闭包通俗的理解：一个函数里面套着另外一个函数，我所要使用的是内部的函数，这样的函数叫闭包。一般来说内部的函数会用到外部函数的变量。将里面的函数和需要用到外层函数的变量这个整体叫做闭包。"><a href="#闭包通俗的理解：一个函数里面套着另外一个函数，我所要使用的是内部的函数，这样的函数叫闭包。一般来说内部的函数会用到外部函数的变量。将里面的函数和需要用到外层函数的变量这个整体叫做闭包。" class="headerlink" title="闭包通俗的理解：一个函数里面套着另外一个函数，我所要使用的是内部的函数，这样的函数叫闭包。一般来说内部的函数会用到外部函数的变量。将里面的函数和需要用到外层函数的变量这个整体叫做闭包。"></a>闭包通俗的理解：一个函数里面套着另外一个函数，我所要使用的是内部的函数，这样的函数叫闭包。一般来说内部的函数会用到外部函数的变量。将里面的函数和需要用到外层函数的变量这个整体叫做闭包。</h4></blockquote><p>闭包修改数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">300</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    x = <span class="number">200</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">        print(<span class="string">&quot;------1-----%d&quot;</span> % x)</span><br><span class="line">        <span class="comment"># x = 100 如果不注释，python解释器会认为 x 在上面打印的下面，没定义呢就打印，会出错。若注释了，会认为是外面的x，就不会出错。</span></span><br><span class="line">        print(<span class="string">&quot;------2-----%d&quot;</span> % x)</span><br><span class="line">    <span class="keyword">return</span> test2</span><br><span class="line"></span><br><span class="line">t1 = test1()</span><br><span class="line">t1()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;------<span class="number">1</span>-----<span class="number">200</span></span><br><span class="line">&gt;&gt;&gt;------<span class="number">2</span>-----<span class="number">200</span></span><br></pre></td></tr></table></figure><p>如果是这样的话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">300</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    x = <span class="number">200</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">        print(<span class="string">&quot;------1-----%d&quot;</span> % x)</span><br><span class="line">        x = <span class="number">100</span> <span class="comment"># 如果不注释，python解释器会认为 x 在上面打印的下面，没定义呢就打印，会出错。</span></span><br><span class="line">        print(<span class="string">&quot;------2-----%d&quot;</span> % x)</span><br><span class="line">    <span class="keyword">return</span> test2</span><br><span class="line"></span><br><span class="line">t1 = test1()</span><br><span class="line">t1()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;UnboundLocalError: local variable <span class="string">&#x27;x&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure><p>若要使它能用原来是在他前面加全局变量 <code>global x</code></p><p>现在是加个 <code>nonlocal x</code>即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">300</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    x = <span class="number">200</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        print(<span class="string">&quot;------1-----%d&quot;</span> % x)</span><br><span class="line">        x = <span class="number">100</span> </span><br><span class="line">        print(<span class="string">&quot;------2-----%d&quot;</span> % x)</span><br><span class="line">    <span class="keyword">return</span> test2</span><br><span class="line"></span><br><span class="line">t1 = test1()</span><br><span class="line">t1()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;------<span class="number">1</span>-----<span class="number">200</span></span><br><span class="line">&gt;&gt;&gt;------<span class="number">2</span>-----<span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="3-装饰器"><a href="#3-装饰器" class="headerlink" title="3.装饰器"></a>3.装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 第一波 ####</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foo  <span class="comment"># 表示是函数</span></span><br><span class="line">foo()  <span class="comment"># 表示执行foo函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 第二波 ####</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foo = <span class="keyword">lambda</span> x: x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">foo()  <span class="comment"># 执行lambda表达式，而不再是原来的foo函数，因为foo这个名字被重新指向了另外一个匿名函数</span></span><br></pre></td></tr></table></figure><p>函数名仅仅是个变量，只不过指向了定义的函数而已，所以才能通过 函数名()调用，如果 函数名=xxx被修改了，那么当在执行 函数名()时，调用的就不知之前的那个函数了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">w1</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="comment"># 验证1</span></span><br><span class="line">        <span class="comment"># 验证2</span></span><br><span class="line">        <span class="comment"># 验证3</span></span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;f1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Python解释器就会从上到下解释代码，步骤如下：</p><ol><li>def w1(func): ==&gt;将w1函数加载到内存</li><li>@w1</li></ol><p>没错， 从表面上看解释器仅仅会解释这两句代码，因为函数在 没有被调用之前其内部代码不会被执行。</p><p>从表面上看解释器着实会执行这两句，但是 @w1 这一句代码里却有大文章， @函数名 是python的一种语法糖。</p><p>装饰器：如果要修改函数的功能：</p><p>①在函数内部修改——<strong>违背了<code>开放封闭</code>原则</strong></p><p>②在函数外面写一个闭包，在函数外面写一个@函数名，即可实现。他会先执行@符号里面的函数，再执行原来的函数——<strong>装饰器</strong></p><blockquote><h3 id="注意：它解决的问题：要么在整体之前，要么在整体之后"><a href="#注意：它解决的问题：要么在整体之前，要么在整体之后" class="headerlink" title="注意：它解决的问题：要么在整体之前，要么在整体之后"></a>注意：它解决的问题：要么在整体之前，要么在整体之后</h3></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span>():</span></span><br><span class="line">print(<span class="string">&quot;---这是权限验证1----&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;---这是权限验证2----&quot;</span>)</span><br><span class="line">func()</span><br><span class="line"><span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">print(<span class="string">&quot;-----test1----&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><p>不加@符号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-----test1----</span><br></pre></td></tr></table></figure><p>加了@符号后:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---这是权限验证<span class="number">1</span>----</span><br><span class="line">---这是权限验证<span class="number">2</span>----</span><br></pre></td></tr></table></figure><p>装饰器执行的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span>():</span></span><br><span class="line">print(<span class="string">&quot;---这是权限验证1----&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;---这是权限验证2----&quot;</span>)</span><br><span class="line">func()</span><br><span class="line"><span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func  </span><span class="comment"># 等价于test1 = set_func(test1) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">print(<span class="string">&quot;-----test1----&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret = set_func(test1)</span></span><br><span class="line"><span class="comment"># ret()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test1 = set_func(test1) </span></span><br><span class="line">test1()</span><br><span class="line"></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193855.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193950.jpg" alt=""></p><blockquote><h2 id="装饰器：将函数的引用传递到闭包的外部函数中去，当调用函数时，内部函数调用这个函数即可。保证原函数功能不变时，对新功能的扩展。"><a href="#装饰器：将函数的引用传递到闭包的外部函数中去，当调用函数时，内部函数调用这个函数即可。保证原函数功能不变时，对新功能的扩展。" class="headerlink" title="装饰器：将函数的引用传递到闭包的外部函数中去，当调用函数时，内部函数调用这个函数即可。保证原函数功能不变时，对新功能的扩展。"></a>装饰器：将函数的引用传递到闭包的外部函数中去，当调用函数时，内部函数调用这个函数即可。保证原函数功能不变时，对新功能的扩展。</h2></blockquote><p>装饰器有以下作用，统计一个函数的运行时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span>():</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">func()</span><br><span class="line">stop_time = time.time()</span><br><span class="line">print(<span class="string">&quot;alltimeis %f&quot;</span> % (stop_time - start_time))</span><br><span class="line"><span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func  </span><span class="comment"># 等价于test1 = set_func(test1) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">print(<span class="string">&quot;-----test1----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret = set_func(test1)</span></span><br><span class="line"><span class="comment"># ret()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test1 = set_func(test1) </span></span><br><span class="line">test1()</span><br><span class="line"></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><h4 id="1-无参数无返回值的函数进行装饰"><a href="#1-无参数无返回值的函数进行装饰" class="headerlink" title="1.无参数无返回值的函数进行装饰"></a>1.无参数无返回值的函数进行装饰</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span>():</span></span><br><span class="line">print(<span class="string">&quot;---这是权限验证1----&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;---这是权限验证2----&quot;</span>)</span><br><span class="line">func()</span><br><span class="line"><span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func  </span><span class="comment"># 等价于test1 = set_func(test1) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">print(<span class="string">&quot;-----test1----&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret = set_func(test1)</span></span><br><span class="line"><span class="comment"># ret()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test1 = set_func(test1) </span></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><h4 id="2-对有参数无返回值的参数进行装饰-amp-同一个装饰器多个函数进行装饰（道理一样）"><a href="#2-对有参数无返回值的参数进行装饰-amp-同一个装饰器多个函数进行装饰（道理一样）" class="headerlink" title="2.对有参数无返回值的参数进行装饰 &amp; 同一个装饰器多个函数进行装饰（道理一样）"></a>2.对有参数无返回值的参数进行装饰 &amp; 同一个装饰器多个函数进行装饰（道理一样）</h4><ul><li>相当于创建了多个闭包。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span>(<span class="params">a</span>):</span>       <span class="comment"># 形参</span></span><br><span class="line">print(<span class="string">&quot;---这是权限验证1----&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;---这是权限验证2----&quot;</span>)</span><br><span class="line">func(a)             <span class="comment"># 实参</span></span><br><span class="line"><span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func  </span><span class="comment"># 相当于 test1 = set_func(test1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">num</span>):</span></span><br><span class="line">print(<span class="string">&quot;-----test1----%d&quot;</span> % num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1(<span class="number">100</span>)</span><br><span class="line">test1(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># xx = set_func(test1)</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194007.jpg" alt=""></p><blockquote><h4 id="装饰器在没有调用函数之前已经进行装饰了"><a href="#装饰器在没有调用函数之前已经进行装饰了" class="headerlink" title="装饰器在没有调用函数之前已经进行装饰了"></a>装饰器在没有调用函数之前已经进行装饰了</h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span>(<span class="params">func</span>):</span></span><br><span class="line">print(<span class="string">&quot;---开始进行装饰&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span>(<span class="params">a</span>):</span></span><br><span class="line">print(<span class="string">&quot;---这是权限验证1----&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;---这是权限验证2----&quot;</span>)</span><br><span class="line">func(a)</span><br><span class="line"><span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func  </span><span class="comment"># 相当于 test1 = set_func(test1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">num</span>):</span></span><br><span class="line">print(<span class="string">&quot;-----test1----%d&quot;</span> % num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func  </span><span class="comment"># 相当于 test2 = set_func(test2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>(<span class="params">num</span>):</span></span><br><span class="line">print(<span class="string">&quot;-----test2----%d&quot;</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器在调用函数之前，已经被python解释器执行了，所以要牢记 当调用函数之前 其实已经装饰好了，尽管调用就可以了</span></span><br><span class="line"><span class="comment"># test1(100)</span></span><br><span class="line"><span class="comment"># test2(200)</span></span><br></pre></td></tr></table></figure><h4 id="3-对不定长参数进行装饰"><a href="#3-对不定长参数进行装饰" class="headerlink" title="3.对不定长参数进行装饰"></a>3.对不定长参数进行装饰</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span>(<span class="params">func</span>):</span></span><br><span class="line">print(<span class="string">&quot;---开始进行装饰&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">print(<span class="string">&quot;---这是权限验证1----&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;---这是权限验证2----&quot;</span>)</span><br><span class="line"><span class="comment"># func(args, kwargs)  # 不行，相当于传递了2个参数 ：1个元组，1个字典</span></span><br><span class="line">func(*args, **kwargs)  <span class="comment"># 拆包  ############# 切记拆包的传！！！！##############</span></span><br><span class="line"><span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func  </span><span class="comment"># 相当于 test1 = set_func(test1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">num, *args, **kwargs</span>):</span></span><br><span class="line">print(<span class="string">&quot;-----test1----%d&quot;</span> % num)</span><br><span class="line">print(<span class="string">&quot;-----test1----&quot;</span> , args)</span><br><span class="line">print(<span class="string">&quot;-----test1----&quot;</span> , kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1(<span class="number">100</span>)</span><br><span class="line">test1(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">test1(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, mm=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="4-对带有返回值的函数进行装饰——通用装饰器"><a href="#4-对带有返回值的函数进行装饰——通用装饰器" class="headerlink" title="4.对带有返回值的函数进行装饰——通用装饰器"></a>4.对带有返回值的函数进行装饰——<code>通用装饰器</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span>(<span class="params">func</span>):</span></span><br><span class="line">print(<span class="string">&quot;---开始进行装饰&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">print(<span class="string">&quot;---这是权限验证1----&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;---这是权限验证2----&quot;</span>)</span><br><span class="line"><span class="comment"># func(args, kwargs)  # 不行，相当于传递了2个参数 ：1个元组，1个字典</span></span><br><span class="line"><span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 拆包</span></span><br><span class="line">    <span class="comment">#########################################</span></span><br><span class="line">        <span class="comment">## 写上 return 对于没有返回值的函数是没有影响的！</span></span><br><span class="line">        <span class="comment">#########################################</span></span><br><span class="line"><span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func  </span><span class="comment"># 相当于 test1 = set_func(test1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">num, *args, **kwargs</span>):</span></span><br><span class="line">print(<span class="string">&quot;-----test1----%d&quot;</span> % num)</span><br><span class="line">print(<span class="string">&quot;-----test1----&quot;</span> , args)</span><br><span class="line">print(<span class="string">&quot;-----test1----&quot;</span> , kwargs)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;ok&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">ret = test1(<span class="number">100</span>)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">ret = test2()</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194024.jpg" alt=""></p><h4 id="5-多个装饰器对同一个函数进行装饰"><a href="#5-多个装饰器对同一个函数进行装饰" class="headerlink" title="5.多个装饰器对同一个函数进行装饰"></a>5.多个装饰器对同一个函数进行装饰</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_qx</span>(<span class="params">func</span>):</span></span><br><span class="line">print(<span class="string">&quot;---开始进行装饰权限1的功能---&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">print(<span class="string">&quot;---这是权限验证1----&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_xx</span>(<span class="params">func</span>):</span></span><br><span class="line">print(<span class="string">&quot;---开始进行装饰xxx的功能---&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">print(<span class="string">&quot;---这是xxx的功能----&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@add_qx</span></span><br><span class="line"><span class="meta">@add_xx</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">print(<span class="string">&quot;------test1------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><blockquote><h4 id="装饰的流程：先装下面的。再装上面的，先执行上面的，再执行下面的。"><a href="#装饰的流程：先装下面的。再装上面的，先执行上面的，再执行下面的。" class="headerlink" title="装饰的流程：先装下面的。再装上面的，先执行上面的，再执行下面的。"></a>装饰的流程：先装下面的。再装上面的，先执行上面的，再执行下面的。</h4></blockquote><h3 id="4-log日志"><a href="#4-log日志" class="headerlink" title="4.log日志"></a>4.log日志</h3><p><strong>开发过程中出现bug是必不可免的，你会怎样debug？从第1行代码开始看么？还是有个文件里面记录着哪里错了更方便呢！！！log日志</strong></p><p><strong>Python中有个logging模块可以完成相关信息的记录，在debug时用它往往事半功倍</strong></p><h4 id="1-日志级别"><a href="#1-日志级别" class="headerlink" title="1. 日志级别"></a>1. 日志级别</h4><p>日志一共分成5个等级，从低到高分别是：</p><ol><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li></ol><p>说明:</p><ul><li>DEBUG：详细的信息,通常只出现在诊断问题上</li><li>INFO：确认一切按预期运行</li><li>WARNING：一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(例如。磁盘空间低”)。这个软件还能按预期工作。</li><li>ERROR：更严重的问题,软件没能执行一些功能</li><li>CRITICAL：一个严重的错误,这表明程序本身可能无法继续运行</li></ul><p>这5个等级，也分别对应5种打日志的方法： debug 、info 、warning 、error 、critical。默认的是WARNING，当在WARNING或之上时才被跟踪。</p><h4 id="2-日志输出"><a href="#2-日志输出" class="headerlink" title="2. 日志输出"></a>2. 日志输出</h4><p>有两种方式记录跟踪，一种输出控制台，另一种是记录到文件中，如日志文件。</p><h5 id="2-1、将日志输出到控制台"><a href="#2-1、将日志输出到控制台" class="headerlink" title="2.1、将日志输出到控制台"></a>2.1、将日志输出到控制台</h5><p>比如，log1.py 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.WARNING,  </span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始使用log功能</span></span><br><span class="line">logging.info(<span class="string">&#x27;这是 loggging info message&#x27;</span>)  </span><br><span class="line">logging.debug(<span class="string">&#x27;这是 loggging debug message&#x27;</span>)  </span><br><span class="line">logging.warning(<span class="string">&#x27;这是 loggging a warning message&#x27;</span>)  </span><br><span class="line">logging.error(<span class="string">&#x27;这是 an loggging error message&#x27;</span>)  </span><br><span class="line">logging.critical(<span class="string">&#x27;这是 loggging critical message&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:07:<span class="number">35</span>,<span class="number">725</span> - log1.py[line:<span class="number">9</span>] - WARNING: 这是 loggging a warning message</span><br><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:07:<span class="number">35</span>,<span class="number">725</span> - log1.py[line:<span class="number">10</span>] - ERROR: 这是 an loggging error message</span><br><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:07:<span class="number">35</span>,<span class="number">725</span> - log1.py[line:<span class="number">11</span>] - CRITICAL: 这是 loggging critical message</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><blockquote><p>通过logging.basicConfig函数对日志的输出格式及方式做相关配置，上面代码设置日志的输出等级是WARNING级别，意思是WARNING级别以上的日志才会输出。另外还制定了日志输出的格式。</p><p>注意，只要用过一次log功能再次设置格式时将失效，实际开发中格式肯定不会经常变化，所以刚开始时需要设定好格式</p></blockquote><h5 id="2-2、将日志输出到文件"><a href="#2-2、将日志输出到文件" class="headerlink" title="2.2、将日志输出到文件"></a>2.2、将日志输出到文件</h5><p>我们还可以将日志输出到文件，只需要在logging.basicConfig函数中设置好输出文件的文件名和写文件的模式。</p><p>log2.py 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.WARNING,  </span><br><span class="line">                    filename=<span class="string">&#x27;./log.txt&#x27;</span>,  </span><br><span class="line">                    filemode=<span class="string">&#x27;w&#x27;</span>,  </span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span>)  </span><br><span class="line"><span class="comment"># use logging  </span></span><br><span class="line">logging.info(<span class="string">&#x27;这是 loggging info message&#x27;</span>)  </span><br><span class="line">logging.debug(<span class="string">&#x27;这是 loggging debug message&#x27;</span>)  </span><br><span class="line">logging.warning(<span class="string">&#x27;这是 loggging a warning message&#x27;</span>)  </span><br><span class="line">logging.error(<span class="string">&#x27;这是 an loggging error message&#x27;</span>)  </span><br><span class="line">logging.critical(<span class="string">&#x27;这是 loggging critical message&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python@ubuntu: cat log.txt </span><br><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:<span class="number">10</span>:<span class="number">44</span>,<span class="number">549</span> - log2.py[line:<span class="number">10</span>] - WARNING: 这是 loggging a warning message</span><br><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:<span class="number">10</span>:<span class="number">44</span>,<span class="number">549</span> - log2.py[line:<span class="number">11</span>] - ERROR: 这是 an loggging error message</span><br><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:<span class="number">10</span>:<span class="number">44</span>,<span class="number">549</span> - log2.py[line:<span class="number">12</span>] - CRITICAL: 这是 loggging critical message</span><br></pre></td></tr></table></figure><h5 id="2-3、既要把日志输出到控制台，-还要写入日志文件"><a href="#2-3、既要把日志输出到控制台，-还要写入日志文件" class="headerlink" title="2.3、既要把日志输出到控制台， 还要写入日志文件"></a>2.3、既要把日志输出到控制台， 还要写入日志文件</h5><p>这就需要一个叫作Logger 的对象来帮忙，下面将对他进行详细介绍，现在这里先学习怎么实现把日志既要输出到控制台又要输出到文件的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步，创建一个logger  </span></span><br><span class="line">logger = logging.getLogger()  </span><br><span class="line">logger.setLevel(logging.INFO)  <span class="comment"># Log等级总开关  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步，创建一个handler，用于写入日志文件  </span></span><br><span class="line">logfile = <span class="string">&#x27;./log.txt&#x27;</span>  </span><br><span class="line">fh = logging.FileHandler(logfile, mode=<span class="string">&#x27;a&#x27;</span>)  <span class="comment"># open的打开模式这里可以进行参考</span></span><br><span class="line">fh.setLevel(logging.DEBUG)  <span class="comment"># 输出到file的log等级的开关  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步，再创建一个handler，用于输出到控制台  </span></span><br><span class="line">ch = logging.StreamHandler()  </span><br><span class="line">ch.setLevel(logging.WARNING)   <span class="comment"># 输出到console的log等级的开关  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步，定义handler的输出格式  </span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&quot;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&quot;</span>)  </span><br><span class="line">fh.setFormatter(formatter)  </span><br><span class="line">ch.setFormatter(formatter)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五步，将logger添加到handler里面  </span></span><br><span class="line">logger.addHandler(fh)  </span><br><span class="line">logger.addHandler(ch)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志  </span></span><br><span class="line">logger.debug(<span class="string">&#x27;这是 logger debug message&#x27;</span>)  </span><br><span class="line">logger.info(<span class="string">&#x27;这是 logger info message&#x27;</span>)  </span><br><span class="line">logger.warning(<span class="string">&#x27;这是 logger warning message&#x27;</span>)  </span><br><span class="line">logger.error(<span class="string">&#x27;这是 logger error message&#x27;</span>)  </span><br><span class="line">logger.critical(<span class="string">&#x27;这是 logger critical message&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行时终端的输出结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:<span class="number">14</span>:04,<span class="number">731</span> - log3.py[line:<span class="number">28</span>] - WARNING: 这是 logger warning message</span><br><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:<span class="number">14</span>:04,<span class="number">731</span> - log3.py[line:<span class="number">29</span>] - ERROR: 这是 logger error message</span><br><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:<span class="number">14</span>:04,<span class="number">731</span> - log3.py[line:<span class="number">30</span>] - CRITICAL: 这是 logger critical message</span><br></pre></td></tr></table></figure><p>在log.txt中，有如下数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:<span class="number">14</span>:04,<span class="number">731</span> - log3.py[line:<span class="number">27</span>] - INFO: 这是 logger info message</span><br><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:<span class="number">14</span>:04,<span class="number">731</span> - log3.py[line:<span class="number">28</span>] - WARNING: 这是 logger warning message</span><br><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:<span class="number">14</span>:04,<span class="number">731</span> - log3.py[line:<span class="number">29</span>] - ERROR: 这是 logger error message</span><br><span class="line"><span class="number">2017</span>-<span class="number">11</span>-06 <span class="number">23</span>:<span class="number">14</span>:04,<span class="number">731</span> - log3.py[line:<span class="number">30</span>] - CRITICAL: 这是 logger critical message</span><br></pre></td></tr></table></figure><h4 id="3、日志格式说明"><a href="#3、日志格式说明" class="headerlink" title="3、日志格式说明"></a>3、日志格式说明</h4><p>logging.basicConfig函数中，可以指定日志的输出格式format，这个参数可以输出很多有用的信息，如下:</p><ul><li>%(levelno)s: 打印日志级别的数值</li><li>%(levelname)s: 打印日志级别名称</li><li>%(pathname)s: 打印当前执行程序的路径，其实就是sys.argv[0]</li><li>%(filename)s: 打印当前执行程序名</li><li>%(funcName)s: 打印日志的当前函数</li><li>%(lineno)d: 打印日志的当前行号</li><li>%(asctime)s: 打印日志的时间</li><li>%(thread)d: 打印线程ID</li><li>%(threadName)s: 打印线程名称</li><li>%(process)d: 打印进程ID</li><li>%(message)s: 打印日志信息</li></ul><p>在工作中给的常用格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span></span><br></pre></td></tr></table></figure><p>这个格式可以输出日志的打印时间，是哪个模块输出的，输出的日志级别是什么，以及输入的日志内容。</p><h3 id="5-动态创建类"><a href="#5-动态创建类" class="headerlink" title="5.动态创建类"></a>5.动态创建类</h3><h4 id="1-类也是对象"><a href="#1-类也是对象" class="headerlink" title="1. 类也是对象"></a>1. 类也是对象</h4><p>在python中我们可以直接用 <code>input</code>、<code>print</code>这样的函数是因为解释器自动给我们导入了一些内嵌函数。<code>&#39;__builtin__&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBBBB</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">globals</span>()</span><br><span class="line">&gt;&gt;&gt;&#123;&#x27;__builtins__&#x27;: &lt;module &#x27;__builtin__&#x27; (built-in)&gt;, &#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;BBBBB&#x27;: &lt;class &#x27;__main__.BBBBB&#x27;&gt;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None&#125;</span><br><span class="line"><span class="comment"># 返回为字典。有什么决定了我们能使用什么</span></span><br></pre></td></tr></table></figure><p>在大多数编程语言中，<strong>类就是一组用来描述如何生成一个对象的代码段</strong>。在Python中这一点仍然成立：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…       <span class="keyword">pass</span></span><br><span class="line">…</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_object)</span><br><span class="line">&lt;__main__.ObjectCreator <span class="built_in">object</span> at <span class="number">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure><p>但是，Python中的类还远不止如此。<strong>类同样也是一种对象</strong>。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。</p><p>下面的代码段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…       <span class="keyword">pass</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类对象ObjectCreator）拥有创建对象（实例对象）的能力。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：</p><ol><li>你可以将它赋值给一个变量</li><li>你可以拷贝它</li><li>你可以为它增加属性</li><li>你可以将它作为函数参数进行传递</li></ol><blockquote><h3 id="元类——-gt-类——-gt-实例对象"><a href="#元类——-gt-类——-gt-实例对象" class="headerlink" title="元类——&gt;类——&gt;实例对象"></a>元类——&gt;类——&gt;实例对象</h3></blockquote><p><strong>列表、元素、集合…都是元类创建的。</strong></p><h4 id="2-动态的创建类"><a href="#2-动态的创建类" class="headerlink" title="2.动态的创建类"></a>2.动态的创建类</h4><p>因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span>(<span class="params">name</span>):</span></span><br><span class="line">…       <span class="keyword">if</span> name == <span class="string">&#x27;foo&#x27;</span>:</span><br><span class="line">…           <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…               <span class="keyword">pass</span></span><br><span class="line">…           <span class="keyword">return</span> Foo     <span class="comment"># 返回的是类，不是类的实例</span></span><br><span class="line">…       <span class="keyword">else</span>:</span><br><span class="line">…           <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…               <span class="keyword">pass</span></span><br><span class="line">…           <span class="keyword">return</span> Bar</span><br><span class="line">…</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass = choose_class(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyClass)  <span class="comment"># 函数返回的是类，不是类的实例</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>&#x27;.<span class="title">Foo</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">MyClass(<span class="params"></span>)</span>)  # 你可以通过这个类创建类实例，也就是对象</span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">Foo</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x89c6d4c</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。</p><p>当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。</p><p>还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">type</span>(<span class="number">1</span>))  <span class="comment"># 数值的类型</span></span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">type</span>(<span class="string">&quot;1&quot;</span>))  <span class="comment"># 字符串的类型</span></span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">type</span>(ObjectCreator()))  <span class="comment"># 实例对象的类型</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">ObjectCreator</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params"><span class="built_in">type</span>(<span class="params">ObjectCreator</span>)</span>)  # 类的类型</span></span><br><span class="line"><span class="class">&lt;<span class="title">type</span> &#x27;<span class="title">type</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>仔细观察上面的运行结果，发现使用type对ObjectCreator查看类型是，答案为type， 是不是有些惊讶。。。看下面</p><h4 id="3-使用type创建类"><a href="#3-使用type创建类" class="headerlink" title="3. 使用type创建类"></a>3. 使用type创建类</h4><p>type还有一种完全不同的功能，<strong>动态的创建类。</strong></p><p>type可以接受一个类的描述作为参数，然后返回一个类。（要知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）</p><p>type可以像这样工作：</p><blockquote><p>type(类名, 由父类名称组成的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</p></blockquote><p>比如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">2</span>]: <span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span> <span class="comment">#定义了一个Test类</span></span><br><span class="line">   ...:     <span class="keyword">pass</span></span><br><span class="line">   ...:</span><br><span class="line">In [<span class="number">3</span>]: Test() <span class="comment"># 创建了一个Test类的实例对象</span></span><br><span class="line">Out[<span class="number">3</span>]: &lt;__main__.Test at <span class="number">0x10d3f8438</span>&gt;</span><br></pre></td></tr></table></figure><p>可以手动像这样创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test2 = <span class="built_in">type</span>(<span class="string">&quot;Test2&quot;</span>, (), &#123;&#125;) <span class="comment"># 定了一个Test2类  # 前面的是变量名，后面的是class 变量名 中的变量名。</span></span><br><span class="line">In [<span class="number">5</span>]: Test2() <span class="comment"># 创建了一个Test2类的实例对象</span></span><br><span class="line">Out[<span class="number">5</span>]: &lt;__main__.Test2 at <span class="number">0x10d406b38</span>&gt;</span><br></pre></td></tr></table></figure><p>我们使用”Test2”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。即type函数中第1个实参，也可以叫做其他的名字，这个名字表示类的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">23</span>]: MyDogClass = <span class="built_in">type</span>(<span class="string">&#x27;MyDog&#x27;</span>, (), &#123;&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: print(MyDogClass)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">MyDog</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>使用help来测试这2个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="built_in">help</span>(Test) <span class="comment"># 用help查看Test类</span></span><br><span class="line"></span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="title">in</span> <span class="title">module</span> <span class="title">__main__</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">builtins.<span class="built_in">object</span></span>)</span></span><br><span class="line"><span class="class"> |  <span class="title">Data</span> <span class="title">descriptors</span> <span class="title">defined</span> <span class="title">here</span>:</span></span><br><span class="line"> |</span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line"> |</span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      <span class="built_in">list</span> of weak references to the <span class="built_in">object</span> (<span class="keyword">if</span> defined)</span><br><span class="line">In [<span class="number">8</span>]: <span class="built_in">help</span>(Test2) <span class="comment">#用help查看Test2类</span></span><br><span class="line"></span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="title">in</span> <span class="title">module</span> <span class="title">__main__</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span>(<span class="params">builtins.<span class="built_in">object</span></span>)</span></span><br><span class="line"><span class="class"> |  <span class="title">Data</span> <span class="title">descriptors</span> <span class="title">defined</span> <span class="title">here</span>:</span></span><br><span class="line"> |</span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line"> |</span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      <span class="built_in">list</span> of weak references to the <span class="built_in">object</span> (<span class="keyword">if</span> defined)</span><br></pre></td></tr></table></figure><h4 id="4-使用type创建带有属性的类"><a href="#4-使用type创建带有属性的类" class="headerlink" title="4. 使用type创建带有属性的类"></a>4. 使用type创建带有属性的类</h4><p>type 接受一个字典来为类定义属性，因此</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = <span class="built_in">type</span>(<span class="string">&#x27;Foo&#x27;</span>, (), &#123;<span class="string">&#x27;bar&#x27;</span>: <span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure><p>可以翻译为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">…       bar = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>并且可以将Foo当成一个普通的类一样使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Foo)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Foo</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">Foo.bar</span>)</span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line">&gt;&gt;&gt; f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f)</span><br><span class="line">&lt;__main__.Foo <span class="built_in">object</span> at <span class="number">0x8a9b84c</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.bar)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>当然，你可以继承这个类，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FooChild</span>(<span class="params">Foo</span>):</span></span><br><span class="line">…       <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>就可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = <span class="built_in">type</span>(<span class="string">&#x27;FooChild&#x27;</span>, (Foo,), &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(FooChild)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">FooChild</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">FooChild.bar</span>)  # <span class="title">bar</span>属性是由<span class="title">Foo</span>继承而来</span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>type的第2个参数，元组中是父类的名字，而不是字符串</li><li>添加的属性是类属性，并不是实例属性</li></ul><h4 id="5-使用type创建带有方法的类"><a href="#5-使用type创建带有方法的类" class="headerlink" title="5. 使用type创建带有方法的类"></a>5. 使用type创建带有方法的类</h4><p>最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。</p><h5 id="添加实例方法"><a href="#添加实例方法" class="headerlink" title="添加实例方法"></a>添加实例方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">46</span>]: <span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span>(<span class="params">self</span>):</span>  <span class="comment"># 定义了一个普通的函数</span></span><br><span class="line">    ...:     print(self.bar)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: FooChild = <span class="built_in">type</span>(<span class="string">&#x27;FooChild&#x27;</span>, (Foo,), &#123;<span class="string">&#x27;echo_bar&#x27;</span>: echo_bar&#125;)  <span class="comment"># 让FooChild类中的echo_bar属性，指向了上面定义的函数</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: <span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;echo_bar&#x27;</span>)  <span class="comment"># 判断Foo类中 是否有echo_bar这个属性</span></span><br><span class="line">Out[<span class="number">48</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]:</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: <span class="built_in">hasattr</span>(FooChild, <span class="string">&#x27;echo_bar&#x27;</span>)  <span class="comment"># 判断FooChild类中 是否有echo_bar这个属性</span></span><br><span class="line">Out[<span class="number">49</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: my_foo = FooChild()</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: my_foo.echo_bar()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h5 id="添加静态方法"><a href="#添加静态方法" class="headerlink" title="添加静态方法"></a>添加静态方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">36</span>]: @<span class="built_in">staticmethod</span></span><br><span class="line">    ...: <span class="function"><span class="keyword">def</span> <span class="title">test_static</span>():</span></span><br><span class="line">    ...:     print(<span class="string">&quot;static method ....&quot;</span>)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: Foochild = <span class="built_in">type</span>(<span class="string">&#x27;Foochild&#x27;</span>, (Foo,), &#123;<span class="string">&quot;echo_bar&quot;</span>: echo_bar, <span class="string">&quot;test_static&quot;</span>: test_static&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: fooclid = Foochild()</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: fooclid.test_static</span><br><span class="line">Out[<span class="number">39</span>]: &lt;function __main__.test_static&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: fooclid.test_static()</span><br><span class="line">static method ....</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: fooclid.echo_bar()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h5 id="添加类方法"><a href="#添加类方法" class="headerlink" title="添加类方法"></a>添加类方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">42</span>]: @<span class="built_in">classmethod</span></span><br><span class="line">    ...: <span class="function"><span class="keyword">def</span> <span class="title">test_class</span>(<span class="params">cls</span>):</span></span><br><span class="line">    ...:     print(cls.bar)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]:</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: Foochild = <span class="built_in">type</span>(<span class="string">&#x27;Foochild&#x27;</span>, (Foo,), &#123;<span class="string">&quot;echo_bar&quot;</span>:echo_bar, <span class="string">&quot;test_static&quot;</span>: test_static, <span class="string">&quot;test_class&quot;</span>: test_class&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]:</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: fooclid = Foochild()</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: fooclid.test_class()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。</p><p>较为完整的使用type创建类的方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_b</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(self.num)</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_static</span>():</span></span><br><span class="line">    print(<span class="string">&quot;----haha-----&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_class</span>(<span class="params">cls</span>):</span></span><br><span class="line">    print(cls.num)</span><br><span class="line"></span><br><span class="line">B = <span class="built_in">type</span>(<span class="string">&quot;B&quot;</span>, (A,), &#123;<span class="string">&quot;print_b&quot;</span>: print_b, <span class="string">&quot;print_static&quot;</span>: print_static, <span class="string">&quot;print_class&quot;</span>: print_class&#125;)</span><br><span class="line">b = B()</span><br><span class="line">b.print_b()</span><br><span class="line">b.print_static()</span><br><span class="line">b.print_class()</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 100</span></span><br><span class="line"><span class="comment"># ----haha-----</span></span><br><span class="line"><span class="comment"># 100</span></span><br></pre></td></tr></table></figure><h3 id="6-元类"><a href="#6-元类" class="headerlink" title="6.元类"></a>6.元类</h3><p>元类就是用来<strong>创建类</strong>的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。</p><p><strong>元类就是用来创建这些类（对象）的</strong>，元类就是<strong>类的类</strong>，你可以这样理解为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass = MetaClass() <span class="comment"># 使用元类创建出一个对象，这个对象称为“类”</span></span><br><span class="line">my_object = MyClass() <span class="comment"># 使用“类”来创建出实例对象</span></span><br></pre></td></tr></table></figure><p>你已经看到了type可以让你像这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass = <span class="built_in">type</span>(<span class="string">&#x27;MyClass&#x27;</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure><p>这是因为函数type实际上是一个元类。<strong>type就是Python在背后用来创建所有类的元类</strong>。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查<strong>class</strong>属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来，这个类就是type。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span> <span class="keyword">pass</span></span><br><span class="line">&gt;&gt;&gt;foo.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Bar</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>现在，对于任何一个__class__这个__class__属性又是什么呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>因此，元类就是创建类这种对象的东西。type就是Python的内建元类，当然了，你也可以创建自己的元类。</p><h5 id="究竟为什么要使用元类？"><a href="#究竟为什么要使用元类？" class="headerlink" title="究竟为什么要使用元类？"></a>究竟为什么要使用元类？</h5><p>现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：</p><p>“元类就是<strong>深度的魔法</strong>，<strong>99%的用户应该根本不必为此操心</strong>。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” —— Python界的领袖 Tim Peters</p><blockquote><h3 id="装饰器是对写好的函数进行修改的——添加功能"><a href="#装饰器是对写好的函数进行修改的——添加功能" class="headerlink" title="装饰器是对写好的函数进行修改的——添加功能"></a>装饰器是对写好的函数进行修改的——添加功能</h3><h3 id="元类是对写好的类进行修改的。——添加功能"><a href="#元类是对写好的类进行修改的。——添加功能" class="headerlink" title="元类是对写好的类进行修改的。——添加功能"></a>元类是对写好的类进行修改的。——添加功能</h3></blockquote><h3 id="元类的应用"><a href="#元类的应用" class="headerlink" title="元类的应用"></a>元类的应用</h3><blockquote><h3 id="ORM——对象关系映射"><a href="#ORM——对象关系映射" class="headerlink" title="ORM——对象关系映射"></a>ORM——对象关系映射</h3></blockquote><p>ORM 是 python编程语言后端web框架 Django的核心思想，“Object Relational Mapping”，即对象-关系映射，简称ORM。</p><p>一个句话理解就是：创建一个实例对象，用创建它的类名当做数据表名，用创建它的类属性对应数据表的字段，当对这个实例对象操作时，能够对应MySQL语句</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194101.PNG" alt=""></p><p>demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">父类省略</span>):</span></span><br><span class="line">    uid = (<span class="string">&#x27;uid&#x27;</span>, <span class="string">&quot;int unsigned&quot;</span>)</span><br><span class="line">    name = (<span class="string">&#x27;username&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    email = (<span class="string">&#x27;email&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    password = (<span class="string">&#x27;password&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    ...省略...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u = User(uid=<span class="number">12345</span>, name=<span class="string">&#x27;Michael&#x27;</span>, email=<span class="string">&#x27;test@orm.org&#x27;</span>, password=<span class="string">&#x27;my-pwd&#x27;</span>)</span><br><span class="line">u.save()</span><br><span class="line"><span class="comment"># 对应如下sql语句</span></span><br><span class="line"><span class="comment"># insert into User (username,email,password,uid)</span></span><br><span class="line"><span class="comment"># values (&#x27;Michael&#x27;,&#x27;test@orm.org&#x27;,&#x27;my-pwd&#x27;,12345)</span></span><br></pre></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ol><li>所谓的ORM就是让开发者在操作数据库的时候，能够像操作对象时通过<code>xxxx.属性=yyyy</code>一样简单，这是开发ORM的初衷</li><li>只不过ORM的实现较为复杂，Django中已经实现了 很复杂的操作，本节知识 主要通过完成一个 insert相类似的ORM，理解其中的道理就就可以了</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-with与“上下文管理器”&quot;&gt;&lt;a href=&quot;#1-with与“上下文管理器”&quot; class=&quot;headerlink&quot; title=&quot;1.with与“上下文管理器”&quot;&gt;&lt;/a&gt;1.with与“上下文管理器”&lt;/h3&gt;&lt;h4 id=&quot;普通版：&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python高级-1</title>
    <link href="https://xxren8218.github.io/20210912/python%E9%AB%98%E7%BA%A7-1.html"/>
    <id>https://xxren8218.github.io/20210912/python%E9%AB%98%E7%BA%A7-1.html</id>
    <published>2021-09-12T11:32:17.000Z</published>
    <updated>2021-09-12T11:43:49.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python高级"><a href="#Python高级" class="headerlink" title="Python高级"></a>Python高级</h2><h3 id="1-GIL"><a href="#1-GIL" class="headerlink" title="1.GIL"></a>1.GIL</h3><p>描述Python GIL的概念， 以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。</p><h4 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案:"></a>参考答案:</h4><blockquote><ol><li><strong>Python语言和GIL没有半毛钱关系</strong>。仅仅是由于历史原因在<strong>Cpython虚拟机(解释器)</strong>，难以移除GIL。</li><li>GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。</li><li>线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100</li><li>Python使用多进程是可以利用多核的CPU资源的。</li><li>多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁</li></ol></blockquote><p>python里面的多线程是假的，用的其实是一个线程的资源，为什么？</p><p>GIL——保证程序同一时刻只有一个线程在执行。</p><p><strong>计算密集型</strong>：进程好，（一直持续的计算）</p><p><strong>IO密集型</strong>：多线程好、协程。</p><p>两种解决方法：</p><ul><li>换python的解释器，换成JAVA等的</li><li>将线程的东西替换成其他语言的代码。</li></ul><h3 id="2-深拷贝与浅拷贝"><a href="#2-深拷贝与浅拷贝" class="headerlink" title="2.深拷贝与浅拷贝"></a>2.深拷贝与浅拷贝</h3><p><strong>简单理解：浅拷贝是拷贝了引用（id一样），深拷贝是拷贝了一份（id不一样）。</strong></p><p>a = b就是浅拷贝(指向)</p><p>c = copy.deepcopy(a)深拷贝</p><p>完成浅拷贝：copy.copy</p><p>完成深拷贝：copy.deepcopy</p><h4 id="copy-copy和copy-deepcopy"><a href="#copy-copy和copy-deepcopy" class="headerlink" title="copy.copy和copy.deepcopy"></a>copy.copy和copy.deepcopy</h4><p>copy.copy仅仅是拷贝最上层的东西，里面的东西不变（如果里面是引用的话，也拷贝引用，若引用一改则拷贝的内部的东西也变），——浅拷贝</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193239.PNG" alt=""></p><p>copy.deepcopy将所有的东西都拷贝一份。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193252.PNG" alt=""></p><p>看这样一个例子</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193315.PNG" alt=""></p><p>虽然d是浅拷贝，给c append一个列表，但是d看不到，因为d中没有那个引用，</p><blockquote><h3 id="注意-对于元组等不可变类型，copy-copy不会进行浅拷贝，只能指向。不可变类型不可修改，拷贝的时候拷贝不了，而仅仅是指向。copy-deepcopy也是。"><a href="#注意-对于元组等不可变类型，copy-copy不会进行浅拷贝，只能指向。不可变类型不可修改，拷贝的时候拷贝不了，而仅仅是指向。copy-deepcopy也是。" class="headerlink" title="注意:对于元组等不可变类型，copy.copy不会进行浅拷贝，只能指向。不可变类型不可修改，拷贝的时候拷贝不了，而仅仅是指向。copy.deepcopy也是。"></a>注意:对于元组等不可变类型，copy.copy不会进行浅拷贝，只能指向。不可变类型不可修改，拷贝的时候拷贝不了，而仅仅是指向。copy.deepcopy也是。</h3></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193325.PNG" alt=""></p><p>而下面的情况：copy.deepcopy的id值不一样。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193338.PNG" alt=""></p><blockquote><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><h3 id="如果用copy-copy、copy-deepcopy对一个全部都是不可变类型的数据进行拷贝，那么他们的结果相同，都是引用指向。"><a href="#如果用copy-copy、copy-deepcopy对一个全部都是不可变类型的数据进行拷贝，那么他们的结果相同，都是引用指向。" class="headerlink" title="如果用copy.copy、copy.deepcopy对一个全部都是不可变类型的数据进行拷贝，那么他们的结果相同，都是引用指向。"></a>如果用copy.copy、copy.deepcopy对一个全部都是不可变类型的数据进行拷贝，那么他们的结果相同，都是引用指向。</h3><h3 id="如果拷贝的是一个拥有可变类型的数据，即使元组是最顶层，那么copy-deepcopy依然是深拷贝，而copy-copy还是指向。"><a href="#如果拷贝的是一个拥有可变类型的数据，即使元组是最顶层，那么copy-deepcopy依然是深拷贝，而copy-copy还是指向。" class="headerlink" title="如果拷贝的是一个拥有可变类型的数据，即使元组是最顶层，那么copy.deepcopy依然是深拷贝，而copy.copy还是指向。"></a>如果拷贝的是一个拥有可变类型的数据，即使元组是最顶层，那么copy.deepcopy依然是深拷贝，而copy.copy还是指向。</h3></blockquote><h4 id="拷贝的其他方式："><a href="#拷贝的其他方式：" class="headerlink" title="拷贝的其他方式："></a>拷贝的其他方式：</h4><p><strong>列表</strong>的切片表达式可以复制一个序列。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193349.PNG" alt=""></p><p><strong>字典</strong>的拷贝：</p><p>字典的copy方法value是引用，而key是单独的一份，</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193404.PNG" alt=""></p><blockquote><h4 id="传递实参的时候-传递的都是引用。"><a href="#传递实参的时候-传递的都是引用。" class="headerlink" title="传递实参的时候,传递的都是引用。"></a>传递实参的时候,传递的都是引用。</h4></blockquote><h4 id="浅拷贝对不可变类型和可变类型的copy不同"><a href="#浅拷贝对不可变类型和可变类型的copy不同" class="headerlink" title="浅拷贝对不可变类型和可变类型的copy不同"></a>浅拷贝对不可变类型和可变类型的copy不同</h4><ol><li>copy.copy对于可变类型，会进行浅拷贝</li><li>copy.copy对于不可变类型，不会拷贝，仅仅是指向</li></ol><h3 id="3-私有化"><a href="#3-私有化" class="headerlink" title="3.私有化"></a>3.私有化</h3><ul><li>xx: 公有变量</li><li>_x: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问（一个模块有age，全局变量，完成一定功能，但是导入的程序里也有这个名字的全局变量，不允许它导入是用）</li><li>__xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)，子类继承不了</li><li>__xx__:双前后下划线,用户名字空间的魔法对象或属性。例如:<code>__init__</code> , __ 不要自己发明这样的名字,这个是继承的。</li><li>xx_:单后置下划线,用于避免与Python关键词的冲突</li></ul><p>通过name mangling（名字重整(目的就是以防子类意外重写基类的方法或者属性)如：_类名__方法名）机制就可以访问private了。</p><h3 id="4-import模块的导入"><a href="#4-import模块的导入" class="headerlink" title="4.import模块的导入"></a>4.import模块的导入</h3><h4 id="1-import搜索路径"><a href="#1-import搜索路径" class="headerlink" title="1.import搜索路径"></a>1.import搜索路径</h4><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193425.PNG" alt=""></p><h5 id="路径搜索"><a href="#路径搜索" class="headerlink" title="路径搜索"></a>路径搜索</h5><ul><li>从上面列出的目录里依次查找要导入的模块文件</li><li>‘’ 表示当前路径</li><li>列表中的路径的先后顺序代表了python解释器在搜索模块时的先后顺序</li></ul><h5 id="程序执行时添加新的模块路径"><a href="#程序执行时添加新的模块路径" class="headerlink" title="程序执行时添加新的模块路径"></a>程序执行时添加新的模块路径</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(<span class="string">&#x27;/home/it/xxx&#x27;</span>)</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">&#x27;/home/it/xxx&#x27;</span>)  <span class="comment"># 可以确保先搜索这个路径</span></span><br><span class="line">In [<span class="number">37</span>]: sys.path.insert(<span class="number">0</span>,<span class="string">&quot;/home/python/xxxx&quot;</span>)</span><br><span class="line">In [<span class="number">38</span>]: sys.path</span><br><span class="line">Out[<span class="number">38</span>]: </span><br><span class="line">[<span class="string">&#x27;/home/python/xxxx&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;/usr/bin&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;/usr/lib/python35.zip&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;/usr/lib/python3.5&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;/usr/lib/python3.5/plat-x86_64-linux-gnu&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;/usr/lib/python3.5/lib-dynload&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;/usr/local/lib/python3.5/dist-packages&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;/usr/lib/python3/dist-packages&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;/usr/lib/python3/dist-packages/IPython/extensions&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;/home/python/.ipython&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="2-重新导入模块"><a href="#2-重新导入模块" class="headerlink" title="2.重新导入模块"></a>2.重新导入模块</h4><p>模块被导入后，<code>import module</code>不能重新导入模块，重新导入需用<code>reload</code>，在imp模块中导入reload模块</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193439.PNG" alt=""></p><h3 id="5-多模块开发时的注意点"><a href="#5-多模块开发时的注意点" class="headerlink" title="5. 多模块开发时的注意点"></a>5. 多模块开发时的注意点</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193451.PNG" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xxx <span class="keyword">import</span> yyy</span><br><span class="line">相当于在本地新建了变量。</span><br><span class="line">若yyy是列表,append可以改。但是=新值就不会变。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193504.PNG" alt=""></p><h3 id="6-封装、继承、多态"><a href="#6-封装、继承、多态" class="headerlink" title="6.封装、继承、多态"></a>6.封装、继承、多态</h3><p>使用面向对象编程的优点：</p><p>每个由类创建的对象含有__class__属性，使得对象能找到类中的方法，实现不用拷贝多份代码，就能调用函数。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193517.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193533.PNG" alt=""></p><p>面向对象里面的self可以改，改为任何值。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193546.PNG" alt=""></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><blockquote><ol><li>能够提升代码的重用率，即开发一个类，可以在多个子功能中直接使用</li><li>继承能够有效的进行代码的管理，当某个类有问题只要修改这个类就行，而其继承这个类的子类往往不需要就修改</li></ol></blockquote><h3 id="7-多继承"><a href="#7-多继承" class="headerlink" title="7.多继承"></a>7.多继承</h3><p>多继承代表一个类继承了多个类。</p><p>重写“Python”：代表相同函数名的覆盖</p><p>重载”C++”：代表相同的函数的名字，不同的函数参数个数和类型调用不同的函数。</p><p>调用被覆盖的父类方法有三种方法：</p><p>①父类名.__方法__(self, name)</p><p>②super().__方法__(name)</p><p>③super(父类名,self).__方法__(name)</p><h4 id="1-单独调用父类的方法"><a href="#1-单独调用父类的方法" class="headerlink" title="1.单独调用父类的方法"></a>1.单独调用父类的方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;******多继承使用类名.__init__ 发生的状态******&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;parent的init开始被调用&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        print(<span class="string">&#x27;parent的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Son1的init开始被调用&#x27;</span>)</span><br><span class="line">        self.age = age</span><br><span class="line">        Parent.__init__(self, name)</span><br><span class="line">        print(<span class="string">&#x27;Son1的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, gender</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Son2的init开始被调用&#x27;</span>)</span><br><span class="line">        self.gender = gender</span><br><span class="line">        Parent.__init__(self, name)</span><br><span class="line">        print(<span class="string">&#x27;Son2的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandson</span>(<span class="params">Son1, Son2</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Grandson的init开始被调用&#x27;</span>)</span><br><span class="line">        Son1.__init__(self, name, age)  <span class="comment"># 单独调用父类的初始化方法</span></span><br><span class="line">        Son2.__init__(self, name, gender)</span><br><span class="line">        print(<span class="string">&#x27;Grandson的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gs = Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;姓名：&#x27;</span>, gs.name)</span><br><span class="line">print(<span class="string">&#x27;年龄：&#x27;</span>, gs.age)</span><br><span class="line">print(<span class="string">&#x27;性别：&#x27;</span>, gs.gender)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;******多继承使用类名.__init__ 发生的状态******\n\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">******多继承使用类名.__init__ 发生的状态******</span><br><span class="line">Grandson的init开始被调用</span><br><span class="line">Son1的init开始被调用</span><br><span class="line">parent的init开始被调用</span><br><span class="line">parent的init结束被调用</span><br><span class="line">Son1的init结束被调用</span><br><span class="line">Son2的init开始被调用</span><br><span class="line">parent的init开始被调用</span><br><span class="line">parent的init结束被调用</span><br><span class="line">Son2的init结束被调用</span><br><span class="line">Grandson的init结束被调用</span><br><span class="line">姓名： grandson</span><br><span class="line">年龄： <span class="number">12</span></span><br><span class="line">性别： 男</span><br><span class="line">******多继承使用类名.__init__ 发生的状态******</span><br></pre></td></tr></table></figure><h4 id="2-多继承中super调用有所父类的被重写的方法"><a href="#2-多继承中super调用有所父类的被重写的方法" class="headerlink" title="2.多继承中super调用有所父类的被重写的方法"></a>2.多继承中super调用有所父类的被重写的方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;******多继承使用super().__init__ 发生的状态******&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, *args, **kwargs</span>):</span>  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        print(<span class="string">&#x27;parent的init开始被调用&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        print(<span class="string">&#x27;parent的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, *args, **kwargs</span>):</span>  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        print(<span class="string">&#x27;Son1的init开始被调用&#x27;</span>)</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, *args, **kwargs)  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        print(<span class="string">&#x27;Son1的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, gender, *args, **kwargs</span>):</span>  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        print(<span class="string">&#x27;Son2的init开始被调用&#x27;</span>)</span><br><span class="line">        self.gender = gender</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, *args, **kwargs)  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        print(<span class="string">&#x27;Son2的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandson</span>(<span class="params">Son1, Son2</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Grandson的init开始被调用&#x27;</span>)</span><br><span class="line">        <span class="comment"># 多继承时，相对于使用类名.__init__方法，要把每个父类全部写一遍</span></span><br><span class="line">        <span class="comment"># 而super只用一句话，执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因</span></span><br><span class="line">        <span class="comment"># super(Grandson, self).__init__(name, age, gender)</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age, gender)</span><br><span class="line">        print(<span class="string">&#x27;Grandson的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(Grandson.__mro__)</span><br><span class="line"></span><br><span class="line">gs = Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;姓名：&#x27;</span>, gs.name)</span><br><span class="line">print(<span class="string">&#x27;年龄：&#x27;</span>, gs.age)</span><br><span class="line">print(<span class="string">&#x27;性别：&#x27;</span>, gs.gender)</span><br><span class="line">print(<span class="string">&quot;******多继承使用super().__init__ 发生的状态******\n\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">******多继承使用<span class="built_in">super</span>().__init__ 发生的状态******</span><br><span class="line">(&lt;class &#x27;__main__.Grandson&#x27;&gt;, &lt;class &#x27;__main__.Son1&#x27;&gt;, &lt;class &#x27;__main__.Son2&#x27;&gt;, &lt;class &#x27;__main__.Parent&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="line">Grandson的init开始被调用</span><br><span class="line">Son1的init开始被调用</span><br><span class="line">Son2的init开始被调用</span><br><span class="line">parent的init开始被调用</span><br><span class="line">parent的init结束被调用</span><br><span class="line">Son2的init结束被调用</span><br><span class="line">Son1的init结束被调用</span><br><span class="line">Grandson的init结束被调用</span><br><span class="line">姓名： grandson</span><br><span class="line">年龄： <span class="number">12</span></span><br><span class="line">性别： 男</span><br><span class="line">******多继承使用<span class="built_in">super</span>().__init__ 发生的状态*****</span><br></pre></td></tr></table></figure><p><strong>使用super()这种方法时，父类的调用方法是MRO这个方法决定的，Grandson.__mro__可以查看执行的顺序。基于一种C3算法，避免了使用父类名基类被执行多次。</strong></p><h4 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h4><blockquote><ol><li>以上2个代码执行的结果不同</li><li>如果2个子类中都继承了父类，当在子类中通过<strong>父类名调用时</strong>，parent被执行了<strong>2次</strong></li><li>如果2个子类中都继承了父类，当在子类中<strong>通过super调用时</strong>，parent被执行了<strong>1次</strong></li></ol></blockquote><h4 id="3-args-和-kwargs"><a href="#3-args-和-kwargs" class="headerlink" title="3.args 和 kwargs"></a>3.args 和 kwargs</h4><p><em>args和*</em>kwargs的形参和实参的区别：</p><p>形参表示传递的参数</p><p>实参表示拆包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>(<span class="params">a, b, *args, **kwargs</span>):</span></span><br><span class="line">    print(<span class="string">&quot;------&quot;</span>)</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">a, b, *args, **kwargs</span>):</span>  <span class="comment"># 此时表示接收参数(形参)</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># test2(a, b, args, kwargs)  # 相当于test2(11, 22, (33, 44, 55, 66), &#123;&quot;name&quot;:&quot;laowang&quot;, &quot;age&quot;:18&#125;)</span></span><br><span class="line">    <span class="comment"># test2(a, b, *args, kwargs)  # 相当于test2(11, 22, 33, 44, 55, 66, &#123;&quot;name&quot;:&quot;laowang&quot;, &quot;age&quot;:18&#125;)</span></span><br><span class="line">    test2(a, b, *args, **kwargs)  <span class="comment"># 相当于test2(11, 22, 33, 44, 55, 66, name=&quot;laowang&quot;, age=18) 此时表示拆包。(实参)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, name=<span class="string">&quot;laowang&quot;</span>, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure><h4 id="4-单继承中super"><a href="#4-单继承中super" class="headerlink" title="4.单继承中super"></a>4.单继承中super</h4><p>没有什么特殊了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;******单继承使用super().__init__ 发生的状态******&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;parent的init开始被调用&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        print(<span class="string">&#x27;parent的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Son1的init开始被调用&#x27;</span>)</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)  <span class="comment"># 单继承不能提供全部参数</span></span><br><span class="line">        print(<span class="string">&#x27;Son1的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandson</span>(<span class="params">Son1</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Grandson的init开始被调用&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)  <span class="comment"># 单继承不能提供全部参数</span></span><br><span class="line">        print(<span class="string">&#x27;Grandson的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gs = Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;姓名：&#x27;</span>, gs.name)</span><br><span class="line">print(<span class="string">&#x27;年龄：&#x27;</span>, gs.age)</span><br><span class="line"><span class="comment">#print(&#x27;性别：&#x27;, gs.gender)</span></span><br><span class="line">print(<span class="string">&quot;******单继承使用super().__init__ 发生的状态******\n\n&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>super().__init__相对于类名.__init__，在单继承上用法基本无差</li><li>但在多继承上有区别，super方法能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次，具体看前面的输出结果</li><li>多继承时，使用super方法，对父类的传参数，应该是由于python中super的算法导致的原因，必须把参数全部传递，否则会报错</li><li>单继承时，使用super方法，则不能全部传递，只能传父类方法所需的参数，否则会报错</li><li>多继承时，相对于使用类名.__init__方法，要把每个父类全部写一遍, 而使用super方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因</li></ol><p><strong>小测试：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lass Parent(<span class="built_in">object</span>):</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span>(<span class="params">Parent</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(Parent.x, Child1.x, Child2.x)</span><br><span class="line">Child1.x = <span class="number">2</span></span><br><span class="line">print(Parent.x, Child1.x, Child2.x)</span><br><span class="line">Parent.x = <span class="number">3</span></span><br><span class="line">print(Parent.x, Child1.x, Child2.x)</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>理解解释继承不是复制即可。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193608.jpg" alt=""></p><h3 id="8-类对象、实例对象、类方法、实例方法、类属性、实例属性、静态方法"><a href="#8-类对象、实例对象、类方法、实例方法、类属性、实例属性、静态方法" class="headerlink" title="8.类对象、实例对象、类方法、实例方法、类属性、实例属性、静态方法"></a>8.类对象、实例对象、类方法、实例方法、类属性、实例属性、静态方法</h3><h4 id="1-类属性、实例属性"><a href="#1-类属性、实例属性" class="headerlink" title="1. 类属性、实例属性"></a>1. 类属性、实例属性</h4><p>它们在定义和使用中有所区别，而最本质的区别是内存中保存的位置不同，</p><ul><li>实例属性属于对象</li><li>类属性属于类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Province</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    country = <span class="string">&#x27;中国&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="comment"># 实例属性</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个实例对象</span></span><br><span class="line">obj = Province(<span class="string">&#x27;山东省&#x27;</span>)</span><br><span class="line"><span class="comment"># 直接访问实例属性</span></span><br><span class="line">print(obj.name)</span><br><span class="line"><span class="comment"># 直接访问类属性</span></span><br><span class="line">Province.country</span><br></pre></td></tr></table></figure><p>由上述代码可以看出【实例属性需要通过对象来访问】【类属性通过类访问】，在使用上可以看出实例属性和类属性的归属是不同的。</p><p>其在内容的存储方式类似如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194318.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912194334.png" alt=""></p><p>由上图看出：</p><ul><li>类属性在内存中只保存一份</li><li>实例属性在每个对象中都要保存一份</li></ul><h5 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h5><ul><li>通过类创建实例对象时，如果每个对象需要具有相同名字的属性，那么就使用类属性，用一份既可</li></ul><p>通过实例属性修改类属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若是 实例.属性名 = xxx，相当于给实例属性赋值——不行</span><br><span class="line">可以  实例.__class__属性名 = xxx，这样可以改。</span><br></pre></td></tr></table></figure><h4 id="2-实例方法、静态方法和类方法"><a href="#2-实例方法、静态方法和类方法" class="headerlink" title="2.实例方法、静态方法和类方法"></a>2.实例方法、静态方法和类方法</h4><p>方法包括：实例方法、静态方法和类方法，三种方法在内存中都归属于类，区别在于调用方式不同。</p><ul><li>实例方法：由对象调用；至少一个self参数；执行实例方法时，自动将调用该方法的对象赋值给self；</li><li>类方法：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类赋值给cls；</li><li>静态方法：由类调用；无默认参数；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ord_func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 定义实例方法，至少有一个self参数 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># print(self.name)</span></span><br><span class="line">        print(<span class="string">&#x27;实例方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_func</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 定义类方法，至少有一个cls参数 &quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&#x27;类方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_func</span>():</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 定义静态方法 ，无默认参数&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&#x27;静态方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = Foo(<span class="string">&quot;中国&quot;</span>)</span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">f.ord_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用类方法</span></span><br><span class="line">Foo.class_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用静态方法</span></span><br><span class="line">Foo.static_func()</span><br></pre></td></tr></table></figure><p><strong>静态方法：和类方法没关、也和实例方法无关。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193704.PNG" alt=""></p><h3 id="7-property属性"><a href="#7-property属性" class="headerlink" title="7.property属性"></a>7.property属性</h3><h4 id="1-什么是property属性？"><a href="#1-什么是property属性？" class="headerlink" title="1.什么是property属性？"></a>1.什么是property属性？</h4><p>一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ############### 定义 ###############</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义property属性</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ############### 调用 ###############</span></span><br><span class="line">foo_obj = Foo()</span><br><span class="line">foo_obj.func()  <span class="comment"># 调用实例方法</span></span><br><span class="line">foo_obj.prop  <span class="comment"># 调用property属性,写方法名不用括号，它调用以后返回的是一个数。</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193717.PNG" alt=""></p><h5 id="property属性的定义和调用要注意一下几点："><a href="#property属性的定义和调用要注意一下几点：" class="headerlink" title="property属性的定义和调用要注意一下几点："></a>property属性的定义和调用要注意一下几点：</h5><ul><li><p>定义时，在实例方法的基础上添加 @property 装饰器；并且仅有一个self参数</p></li><li><p>调用时，无需括号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法：foo_obj.func()</span><br><span class="line"><span class="built_in">property</span>属性：foo_obj.prop</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-简单的实例"><a href="#2-简单的实例" class="headerlink" title="2. 简单的实例"></a>2. 简单的实例</h4><blockquote><p>对于京东商城中显示电脑主机的列表页面，每次请求不可能把数据库中的所有内容都显示到页面上，而是通过分页的功能局部显示，所以在向数据库中请求数据时就要显示的指定获取从第m条到第n条的所有数据 这个分页的功能包括：</p><ul><li>根据用户请求的当前页和总数据条数计算出 m 和 n</li><li>根据m 和 n 去数据库中请求数据</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ############### 定义 ###############</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pager</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, current_page</span>):</span></span><br><span class="line">        <span class="comment"># 用户当前请求的页码（第一页、第二页...）</span></span><br><span class="line">        self.current_page = current_page</span><br><span class="line">        <span class="comment"># 每页默认显示10条数据</span></span><br><span class="line">        self.per_items = <span class="number">10</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        val = (self.current_page - <span class="number">1</span>) * self.per_items</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end</span>(<span class="params">self</span>):</span></span><br><span class="line">        val = self.current_page * self.per_items</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"><span class="comment"># ############### 调用 ###############</span></span><br><span class="line">p = Pager(<span class="number">1</span>)</span><br><span class="line">p.start  <span class="comment"># 就是起始值，即：m</span></span><br><span class="line">p.end  <span class="comment"># 就是结束值，即：n</span></span><br></pre></td></tr></table></figure><p><strong>从上述可见</strong></p><ul><li>Python的property属性的功能是：property属性内部进行一系列的逻辑计算，最终将计算结果返回。</li></ul><h4 id="3-property属性的有两种方式"><a href="#3-property属性的有两种方式" class="headerlink" title="3. property属性的有两种方式"></a>3. property属性的有两种方式</h4><ul><li><p>装饰器 即：在方法上应用装饰器</p><ul><li>经典类中的属性只有一种访问方式，其对应被 @property 修饰的方法</li><li>新式类中的属性有三种访问方式，并分别对应了三个被@property、@方法名.setter、@方法名.deleter修饰的方法</li></ul></li><li><p>类属性 即：在类中定义值为property对象的类属性。</p><ul><li>当使用类属性的方式创建property属性时，<code>经典类</code>和<code>新式类</code>无区别</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_bar</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;laowang&#x27;</span></span><br><span class="line"></span><br><span class="line">    BAR = <span class="built_in">property</span>(get_bar)</span><br><span class="line"></span><br><span class="line">obj = Foo()</span><br><span class="line">reuslt = obj.BAR  <span class="comment"># 自动调用get_bar方法，并获取方法的返回值</span></span><br><span class="line">print(reuslt)</span><br></pre></td></tr></table></figure><p>property方法中有个四个参数</p><ul><li>第一个参数是方法名，调用 对象.属性 时自动触发执行方法</li><li>第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法</li><li>第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法</li><li>第四个参数是字符串，调用 对象.属性.__doc__ ，此参数是该属性的描述信息</li></ul></li></ul><h3 id="8-私有属性的访问"><a href="#8-私有属性的访问" class="headerlink" title="8.私有属性的访问"></a>8.私有属性的访问</h3><p>python并没有绝对的私有属性：——<strong>名字重整实现的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">a = Test(<span class="string">&quot;xiaoxiong&quot;</span>)</span><br><span class="line">a.__name</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>AttributeError: <span class="string">&#x27;Test&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__name&#x27;</span></span><br><span class="line">a.__dict__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;_Test__name&#x27;</span>: <span class="string">&#x27;xiaoxiong&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">a._Test__name</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;xiaoxiong&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若使用下面的是重新设置值</span></span><br><span class="line">a.__name = <span class="string">&quot;xxxx&quot;</span></span><br><span class="line"></span><br><span class="line">a.__dict___</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;__name&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;_Test__name&#x27;</span>: <span class="string">&#x27;xiaoxiong&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新设置的这个属性没有共有和私有之说。都可访问。</span></span><br></pre></td></tr></table></figure><p>_类名__私有属性名即可得到结果</p><h3 id="9-魔法属性"><a href="#9-魔法属性" class="headerlink" title="9.魔法属性"></a>9.魔法属性</h3><p>无论人或事物往往都有不按套路出牌的情况，Python的类属性也是如此，存在着一些具有特殊含义的属性，详情如下：</p><h4 id="1-doc"><a href="#1-doc" class="headerlink" title="1. __doc__"></a>1. __doc__</h4><ul><li>表示类的描述信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 描述类信息，这是用于看片的神奇 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(Foo.__doc__)</span><br><span class="line"><span class="comment"># 输出：类的描述信息</span></span><br></pre></td></tr></table></figure><h4 id="2-module-和-class"><a href="#2-module-和-class" class="headerlink" title="2. __module__ 和__class__"></a>2. __module__ 和__class__</h4><ul><li>__module__ 表示当前操作的对象在那个模块</li><li>__class__ 表示当前操作的对象的类是什么</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test.py</span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&#x27;laowang&#x27;</span></span><br><span class="line">main.py</span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> Person</span><br><span class="line"></span><br><span class="line">obj = Person()</span><br><span class="line">print(obj.__module__)  <span class="comment"># 输出 test 即：输出模块</span></span><br><span class="line">print(obj.__class__)  <span class="comment"># 输出 test.Person 即：输出类</span></span><br></pre></td></tr></table></figure><h4 id="3-init"><a href="#3-init" class="headerlink" title="3.__init__"></a>3.__init__</h4><ul><li>初始化方法，通过类创建对象时，自动触发执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Person(<span class="string">&#x27;laowang&#x27;</span>)  <span class="comment"># 自动执行类中的 __init__ 方法</span></span><br></pre></td></tr></table></figure><h4 id="4-del"><a href="#4-del" class="headerlink" title="4. __del__"></a>4. __del__</h4><ul><li>当对象在内存中被释放时，自动触发执行。</li></ul><p>注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，__del__的调用是由解释器在进行垃圾回收时自动触发执行的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="5-call"><a href="#5-call" class="headerlink" title="5. __call__"></a>5. __call__</h4><ul><li>对象后面加括号，触发执行。</li></ul><p>注：__init__方法的执行是由创建对象触发的，即：<code>对象 = 类名()</code> ；而对于 __call__ 方法的执行是由对象后加括号触发的，即：<code>对象()</code> 或者 <code>类()()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;__call__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Foo()  <span class="comment"># 执行 __init__</span></span><br><span class="line">obj()  <span class="comment"># 执行 __call__</span></span><br></pre></td></tr></table></figure><h4 id="6-dict"><a href="#6-dict" class="headerlink" title="6. __dict__"></a>6. __dict__</h4><ul><li>类或对象中的所有属性</li></ul><p>类的实例属性属于对象；类中的类属性和方法等属于类，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Province</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    country = <span class="string">&#x27;China&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, count</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.count = count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;func&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取类的属性，即：类属性、方法、</span></span><br><span class="line">print(Province.__dict__)</span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;Province&#x27; objects&gt;, &#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;country&#x27;: &#x27;China&#x27;, &#x27;__doc__&#x27;: None, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;Province&#x27; objects&gt;, &#x27;func&#x27;: &lt;function Province.func at 0x101897950&gt;, &#x27;__init__&#x27;: &lt;function Province.__init__ at 0x1018978c8&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">obj1 = Province(<span class="string">&#x27;山东&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line">print(obj1.__dict__)</span><br><span class="line"><span class="comment"># 获取 对象obj1 的属性</span></span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;count&#x27;: 10000, &#x27;name&#x27;: &#x27;山东&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">obj2 = Province(<span class="string">&#x27;山西&#x27;</span>, <span class="number">20000</span>)</span><br><span class="line">print(obj2.__dict__)</span><br><span class="line"><span class="comment"># 获取 对象obj1 的属性</span></span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;count&#x27;: 20000, &#x27;name&#x27;: &#x27;山西&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="7-str"><a href="#7-str" class="headerlink" title="7. __str__"></a>7. __str__</h4><ul><li>如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;laowang&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Foo()</span><br><span class="line">print(obj)</span><br><span class="line"><span class="comment"># 输出：laowang</span></span><br></pre></td></tr></table></figure><blockquote><h2 id="注意：列表的切片："><a href="#注意：列表的切片：" class="headerlink" title="注意：列表的切片："></a>注意：列表的切片：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nums = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">nums</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">nums[:<span class="number">3</span>] = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]</span><br><span class="line">nums</span><br><span class="line">[<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">nums[:<span class="number">3</span>] = [<span class="number">100</span>]</span><br><span class="line">nums</span><br><span class="line">[<span class="number">100</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">nums[:<span class="number">3</span>] = [<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,<span class="number">444</span>,<span class="number">555</span>]</span><br><span class="line">nums</span><br><span class="line">[<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,<span class="number">444</span>,<span class="number">555</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><h2 id="列表的删除"><a href="#列表的删除" class="headerlink" title="列表的删除"></a>列表的删除</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> nums[:<span class="number">3</span>]</span><br><span class="line">[<span class="number">444</span>,<span class="number">555</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Python高级&quot;&gt;&lt;a href=&quot;#Python高级&quot; class=&quot;headerlink&quot; title=&quot;Python高级&quot;&gt;&lt;/a&gt;Python高级&lt;/h2&gt;&lt;h3 id=&quot;1-GIL&quot;&gt;&lt;a href=&quot;#1-GIL&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>网络通信</title>
    <link href="https://xxren8218.github.io/20210912/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.html"/>
    <id>https://xxren8218.github.io/20210912/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.html</id>
    <published>2021-09-12T11:29:24.000Z</published>
    <updated>2021-09-12T11:31:56.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p><strong>TCP-IP协议指的不是TCP，也不是IP，而是指的是一类协议的总称，把数据稳定的传给对对方。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912192944.PNG" alt=""></p><p>UDP和TCP可以同时使用同一个端口，但是各自不能同时使用同一个。</p><p>比如传递一个HTTP的东西。浏览器写请求体，接下来到TCP，加入了原端口，目的端口，校验功能等，到达IP时，添加IP。再到网络接口层的时候添加MAC地址。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912192956.PNG" alt=""></p><p>MAC地址是网卡上的序列号，</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193011.PNG" alt=""></p><h3 id="1-两台电脑的连接"><a href="#1-两台电脑的连接" class="headerlink" title="1.两台电脑的连接"></a>1.两台电脑的连接</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193027.PNG" alt=""></p><p><strong>说明</strong></p><blockquote><ol><li>如果两台电脑之间通过网线连接是可以直接通信的，但是需要提前设置<strong>好ip地址</strong>以及<strong>网络掩码</strong></li><li>并且ip地址需要控制在同一网段内，例如 一台为<code>192.168.1.1</code>另一台为<code>192.168.1.2</code>则可以进行通信</li></ol></blockquote><p>子网掩码来确定网络号是什么？主机号是什么的？</p><p>对于IP采用二进制，与二进制的网络掩码如255.255.255.0的二进制进行与操作，再转换为二进制，得到的就是IP中的网络号。</p><h3 id="2-使用集线器组成一个网络"><a href="#2-使用集线器组成一个网络" class="headerlink" title="2.使用集线器组成一个网络"></a>2.使用集线器组成一个网络</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193045.PNG" alt=""></p><p><strong>说明</strong></p><blockquote><ol><li>当有多态电脑需要组成一个网时，那么可以通过集线器（Hub）将其链接在一起</li><li>一般情况下集线器的接口较少</li><li>集线器有个缺点，它<strong>以广播的方式进行发送任何数据</strong>，即如果集线器接收到来自A电脑的数据本来是想转发给B电脑，如果此时它还连接着另外两台电脑C、D，那么它会把这个数据给每个电脑都发送一份，因此会导致网络拥堵</li></ol></blockquote><h3 id="3-使用交换机组成一个网络"><a href="#3-使用交换机组成一个网络" class="headerlink" title="3. 使用交换机组成一个网络"></a>3. 使用交换机组成一个网络</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193113.PNG" alt=""></p><p><strong>说明</strong></p><blockquote><ol><li>克服了集线器以广播发送数据的缺点，当需要广播的时候发送广播，当需要单播的时候又能够以单播的方式进行发送</li><li>它已经替代了之前的集线器</li><li>企业中就是用交换机来完成多态电脑设备的链接成网络的</li></ol></blockquote><p><strong>ARP攻击：</strong>中间人攻击，</p><p>需要有MAC物理地址：每个网卡有个，是六位双数字。前三个代表厂家，后三个代表具体的网卡型号。</p><p>传输过去需要知道目的的MAC地址，如何知道？</p><p>先看ARP的缓存里面有没有，若没有。先通过ARP通信到交换机进行广播，用第二组MAC（共有的FF:FF:FF:FF:FF:FF）,广播后一看这个全为F的符合物理地址，就判断不是用的UDP或者TCP的协议而是ARP的协议。这样目的IP和端口会回送MAC地址（单包返回），存到ARP缓存里，其余的扔掉。这样就有目的的MAC地址了。</p><h3 id="4-使用路由器连接多个网络"><a href="#4-使用路由器连接多个网络" class="headerlink" title="4. 使用路由器连接多个网络"></a>4. 使用路由器连接多个网络</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193130.PNG" alt=""></p><p>路由器能将两个及以上不在同一网络内的设备连接起来。</p><p>其实路由器就是默认网关，左边这个网络的东西想要发到右边的网络，需要路由器进行发送，——默认网关</p><p>MAC地址在每一级网络里面都会变，但是IP地址不会变。</p><h3 id="5-通信过程（复杂）"><a href="#5-通信过程（复杂）" class="headerlink" title="5. 通信过程（复杂）"></a>5. 通信过程（复杂）</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912193142.PNG" alt=""></p><p><strong>DNS服务器是用来查找域名对应的IP的。</strong></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><blockquote><ol><li>在浏览器中输入一个网址时，需要将它先解析出ip地址来</li><li>当得到ip地址之后，浏览器以tcp的方式3次握手链接服务器</li><li>以tcp的方式发送http协议的请求数据 给 服务器</li><li>服务器tcp的方式回应http协议的应答数据 给浏览器</li></ol></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>MAC地址：在设备与设备之间数据通信时用来标记收发双方（网卡的序列号）</li><li>IP地址：在逻辑上标记一台电脑，用来指引数据包的收发方向（相当于电脑的序列号）</li><li>网络掩码：用来区分ip地址的网络号和主机号</li><li>默认网关：当需要发送的数据包的目的ip不在本网段内时，就会发送给默认的一台电脑，成为网关</li><li>集线器：已过时，用来连接多态电脑，缺点：每次收发数据都进行广播，网络会变的拥堵</li><li>交换机：集线器的升级版，有学习功能知道需要发送给哪台设备，根据需要进行单播、广播</li><li>路由器：连接多个不同的网段，让他们之间可以进行收发数据，每次收到数据后，ip不变，但是MAC地址会变化</li><li>DNS：用来解析出IP（类似电话簿）</li><li>http服务器：提供浏览器能够访问到的数据</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络通信&quot;&gt;&lt;a href=&quot;#网络通信&quot; class=&quot;headerlink&quot; title=&quot;网络通信&quot;&gt;&lt;/a&gt;网络通信&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;TCP-IP协议指的不是TCP，也不是IP，而是指的是一类协议的总称，把数据稳定的传给对对方。&lt;/stron</summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="https://xxren8218.github.io/20210912/http.html"/>
    <id>https://xxren8218.github.io/20210912/http.html</id>
    <published>2021-09-12T11:27:48.000Z</published>
    <updated>2021-09-12T11:29:06.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP是浏览器和服务器进行通信的一种协议。</p><p>浏览器向服务器请求一次。</p><p>服务器也向浏览器回应一次。<strong>第一部分叫header，第二部分叫body。——区分header和body（header的东西都是连续的，body出现前会出现一个空的换行。）</strong></p><ul><li>实现简单的http服务</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">service_client</span>(<span class="params">new_socket</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为这个客户端返回数据&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 接收浏览器发送过来的请求 ，即http请求  </span></span><br><span class="line">    <span class="comment"># GET / HTTP/1.1</span></span><br><span class="line">    <span class="comment"># .....</span></span><br><span class="line">    request = new_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    print(request)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 返回http格式的数据，给浏览器</span></span><br><span class="line">    <span class="comment"># 2.1 准备发送给浏览器的数据---header</span></span><br><span class="line">    response = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>       <span class="comment"># \r\n换行，windows显示换行，是\r\n表示。</span></span><br><span class="line">    response += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    <span class="comment"># 2.2 准备发送给浏览器的数据---boy</span></span><br><span class="line">    response += <span class="string">&quot;hahahhah&quot;</span></span><br><span class="line">    new_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    new_socket.close()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用来完成整体的控制&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定</span></span><br><span class="line">    tcp_server_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7890</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 变为监听套接字</span></span><br><span class="line">    tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4. 等待新客户端的链接</span></span><br><span class="line">        new_socket, client_addr = tcp_server_socket.accept()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 为这个客户端服务</span></span><br><span class="line">        service_client(new_socket)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭监听套接字</span></span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="1-TCP的3次捂手与4次挥手"><a href="#1-TCP的3次捂手与4次挥手" class="headerlink" title="1. TCP的3次捂手与4次挥手"></a>1. TCP的3次捂手与4次挥手</h3><p><strong>TCP是面向连接的。</strong></p><h4 id="1-TCP-3次握手—双方都在准备资源"><a href="#1-TCP-3次握手—双方都在准备资源" class="headerlink" title="1.TCP 3次握手—双方都在准备资源"></a>1.TCP 3次握手—双方都在准备资源</h4><p>客户端调用connet的时候，操作系统的底层自己发送数据包。过去，过来过去三次，叫三次握手。若成功了，才表示连接成功。</p><p>目的：保证收发双方在收数据和发收据的时候准备好资源。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912192839.PNG" alt=""></p><p>第一次握手：SYN J表示请求数据，ACK表示回答数据。</p><p>第二次握手：若成功将请求数据的状态码 J +1，表示服务器准备好资源了。服务器同时也给一个状态码SYN K，来请求客户端是否准备好资源。</p><p>第三次握手：客户端返回应答 ACK K + 1，表示客户端也准备好资源了。</p><p><strong>这是解阻塞。</strong></p><p>三次握手成功的标志：服务器调用accept()</p><h4 id="2-TCP-4次挥手—让双方准备的资源释放。"><a href="#2-TCP-4次挥手—让双方准备的资源释放。" class="headerlink" title="2.TCP 4次挥手—让双方准备的资源释放。"></a>2.TCP 4次挥手—让双方准备的资源释放。</h4><p>套接字是全双工的。关闭时需要将收发端口全关掉。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912192852.PNG" alt=""></p><p>第一次挥手：客户端调用close()时，客户端告诉服务器，不会再给服务器发送任何数据了。——是应用程序不发了，不是操作系统底层不发了。即告诉服务器不会再用send()了，此时关闭了send()的端口，而recv的端口还没关。</p><p>第二次挥手：服务器①告诉客户端数据收到了，②通知应用程序解阻塞。——关掉服务器new_socket的收。且可能调用服务器的close()。第二次挥手告诉客户端我接收到你第一次发来的数据了。</p><p>第三次挥手：服务器调用了close(),服务器告诉客户端我不会再给你发送数据了。此时客户端关闭收的通道。在第三次挥手之后，服务器会等段一段时间，比如4’’，若这个期间内，没有数据（第四次挥手的返回），那么会一直发送数据。（第三次挥手的数据）</p><p>第四次挥手：客户端告诉服务器不会收消息了。服务器关闭发送数据。</p><p><strong>为什么2、3没有合在一起？</strong></p><p>因为2是告诉客户端我接收到你发来的数据了，3是告诉客户端我调用了close(),可能服务器需要一段时间调用close()。若合在一起，若有阻塞等原因，导致客户端会一直等服务器调用了close()后才能收到数据。因此分成两次。</p><p><strong>为什么一般情况下客户端先调用close()，而不是服务器先调用close()呢？</strong></p><p>客户端是最后一个数据发送者，怎么保证数据到达，一个约定：谁先调close()，导致谁最后会等待2MSL（2倍的数据包的最长延迟时间），<strong>（因为可能没传送成功，就将资源释放了不适合。第三次挥手还可能一直发。）</strong>若服务器先调用，那么这两分钟会在这里等着，没有释放，端口不能再使用。而客户端不要绑定端口，这个端口不行了，操作系统会自动分配别的端口。</p><p>若要是用服务器先调用close()，则可以设置下面的代码来保证不会有端口被占用的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="2-写http的服务器"><a href="#2-写http的服务器" class="headerlink" title="2. 写http的服务器"></a>2. 写http的服务器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">service_client</span>(<span class="params">new_socket</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为这个客户端返回数据&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 接收浏览器发送过来的请求 ，即http请求  </span></span><br><span class="line">    <span class="comment"># GET / HTTP/1.1</span></span><br><span class="line">    <span class="comment"># .....</span></span><br><span class="line">    request = new_socket.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># print(&quot;&gt;&gt;&gt;&quot;*50)</span></span><br><span class="line">    <span class="comment"># print(request)</span></span><br><span class="line"></span><br><span class="line">    request_lines = request.splitlines()</span><br><span class="line">    print(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;&gt;&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    print(request_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># GET /index.html HTTP/1.1</span></span><br><span class="line">    <span class="comment"># get post put del</span></span><br><span class="line">    file_name = <span class="string">&quot;&quot;</span></span><br><span class="line">    ret = re.match(<span class="string">r&quot;[^/]+(/[^ ]*)&quot;</span>, request_lines[<span class="number">0</span>])  <span class="comment"># [^/]表示不以 / 开头</span></span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        file_name = ret.group(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(&quot;*&quot;*50, file_name)</span></span><br><span class="line">        <span class="keyword">if</span> file_name == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            file_name = <span class="string">&quot;/index.html&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 返回http格式的数据，给浏览器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&quot;./html&quot;</span> + file_name, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        response = <span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;------file not found-----&quot;</span></span><br><span class="line">        new_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        html_content = f.read()</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="comment"># 2.1 准备发送给浏览器的数据---header</span></span><br><span class="line">        response = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        <span class="comment"># 2.2 准备发送给浏览器的数据---boy</span></span><br><span class="line">        <span class="comment"># response += &quot;hahahhah&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将response header发送给浏览器</span></span><br><span class="line">        new_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        <span class="comment"># 将response body发送给浏览器</span></span><br><span class="line">        new_socket.send(html_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接</span></span><br><span class="line">    new_socket.close()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用来完成整体的控制&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定</span></span><br><span class="line">    tcp_server_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7890</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 变为监听套接字</span></span><br><span class="line">    tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4. 等待新客户端的链接</span></span><br><span class="line">        new_socket, client_addr = tcp_server_socket.accept()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 为这个客户端服务</span></span><br><span class="line">        service_client(new_socket)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭监听套接字</span></span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>response header是告诉浏览器，状态什么。用什么格式解码，什么的</p><p>response body 是告诉浏览器内容具体是什么的。</p><p>request 若是 GET 形式，没有body</p><p>request 若是 POST 形式，有body，告诉用户名这些。</p><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul><h3 id="3-多任务完成http"><a href="#3-多任务完成http" class="headerlink" title="3. 多任务完成http"></a>3. 多任务完成http</h3><p>目的：要是没有多任务的话，只为一个服务，那么服务器可能卡在三次握手的地方，别的浏览器不能浏览。用while True开启多个服务，为多个客户端服务。</p><h4 id="多任务完成http—多进程"><a href="#多任务完成http—多进程" class="headerlink" title="多任务完成http—多进程"></a>多任务完成http—多进程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">service_client</span>(<span class="params">new_socket</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为这个客户端返回数据&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 接收浏览器发送过来的请求 ，即http请求  </span></span><br><span class="line">    <span class="comment"># GET / HTTP/1.1</span></span><br><span class="line">    <span class="comment"># .....</span></span><br><span class="line">    request = new_socket.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># print(&quot;&gt;&gt;&gt;&quot;*50)</span></span><br><span class="line">    <span class="comment"># print(request)</span></span><br><span class="line"></span><br><span class="line">    request_lines = request.splitlines()</span><br><span class="line">    print(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;&gt;&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    print(request_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># GET /index.html HTTP/1.1</span></span><br><span class="line">    <span class="comment"># get post put del</span></span><br><span class="line">    file_name = <span class="string">&quot;&quot;</span></span><br><span class="line">    ret = re.match(<span class="string">r&quot;[^/]+(/[^ ]*)&quot;</span>, request_lines[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        file_name = ret.group(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(&quot;*&quot;*50, file_name)</span></span><br><span class="line">        <span class="keyword">if</span> file_name == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            file_name = <span class="string">&quot;/index.html&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 返回http格式的数据，给浏览器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&quot;./html&quot;</span> + file_name, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        response = <span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;------file not found-----&quot;</span></span><br><span class="line">        new_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        html_content = f.read()</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="comment"># 2.1 准备发送给浏览器的数据---header</span></span><br><span class="line">        response = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        <span class="comment"># 2.2 准备发送给浏览器的数据---boy</span></span><br><span class="line">        <span class="comment"># response += &quot;hahahhah&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将response header发送给浏览器</span></span><br><span class="line">        new_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        <span class="comment"># 将response body发送给浏览器</span></span><br><span class="line">        new_socket.send(html_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接</span></span><br><span class="line">    new_socket.close()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用来完成整体的控制&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定</span></span><br><span class="line">    tcp_server_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7890</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 变为监听套接字</span></span><br><span class="line">    tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4. 等待新客户端的链接</span></span><br><span class="line">        new_socket, client_addr = tcp_server_socket.accept()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 为这个客户端服务</span></span><br><span class="line">        <span class="comment">########################################################################</span></span><br><span class="line">        p = multiprocessing.Process(target=service_client, args=(new_socket,))</span><br><span class="line">        p.start()</span><br><span class="line">        <span class="comment">#########################################################################</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">####################################################################</span></span><br><span class="line">        new_socket.close()   <span class="comment"># 使用两次close()的原因，Linux一切皆文件，用进程时，相当于有两个文件指向它，删除一个后，引用计数器不为零，所以不删除。</span></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭监听套接字</span></span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="多任务完成http—多线程"><a href="#多任务完成http—多线程" class="headerlink" title="多任务完成http—多线程"></a>多任务完成http—多线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">service_client</span>(<span class="params">new_socket</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为这个客户端返回数据&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 接收浏览器发送过来的请求 ，即http请求  </span></span><br><span class="line">    <span class="comment"># GET / HTTP/1.1</span></span><br><span class="line">    <span class="comment"># .....</span></span><br><span class="line">    request = new_socket.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># print(&quot;&gt;&gt;&gt;&quot;*50)</span></span><br><span class="line">    <span class="comment"># print(request)</span></span><br><span class="line"></span><br><span class="line">    request_lines = request.splitlines()</span><br><span class="line">    print(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;&gt;&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    print(request_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># GET /index.html HTTP/1.1</span></span><br><span class="line">    <span class="comment"># get post put del</span></span><br><span class="line">    file_name = <span class="string">&quot;&quot;</span></span><br><span class="line">    ret = re.match(<span class="string">r&quot;[^/]+(/[^ ]*)&quot;</span>, request_lines[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        file_name = ret.group(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(&quot;*&quot;*50, file_name)</span></span><br><span class="line">        <span class="keyword">if</span> file_name == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            file_name = <span class="string">&quot;/index.html&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 返回http格式的数据，给浏览器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&quot;./html&quot;</span> + file_name, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        response = <span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;------file not found-----&quot;</span></span><br><span class="line">        new_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        html_content = f.read()</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="comment"># 2.1 准备发送给浏览器的数据---header</span></span><br><span class="line">        response = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        <span class="comment"># 2.2 准备发送给浏览器的数据---boy</span></span><br><span class="line">        <span class="comment"># response += &quot;hahahhah&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将response header发送给浏览器</span></span><br><span class="line">        new_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        <span class="comment"># 将response body发送给浏览器</span></span><br><span class="line">        new_socket.send(html_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接</span></span><br><span class="line">    new_socket.close()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用来完成整体的控制&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定</span></span><br><span class="line">    tcp_server_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7890</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 变为监听套接字</span></span><br><span class="line">    tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4. 等待新客户端的链接</span></span><br><span class="line">        new_socket, client_addr = tcp_server_socket.accept()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 为这个客户端服务</span></span><br><span class="line">        p = threading.Thread(target=service_client, args=(new_socket,))</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">        <span class="comment">##################################</span></span><br><span class="line">        <span class="comment"># new_socket.close()</span></span><br><span class="line">        <span class="comment">##################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭监听套接字</span></span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="多任务完成http—协程"><a href="#多任务完成http—协程" class="headerlink" title="多任务完成http—协程"></a>多任务完成http—协程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">service_client</span>(<span class="params">new_socket</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为这个客户端返回数据&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 接收浏览器发送过来的请求 ，即http请求  </span></span><br><span class="line">    <span class="comment"># GET / HTTP/1.1</span></span><br><span class="line">    <span class="comment"># .....</span></span><br><span class="line">    request = new_socket.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># print(&quot;&gt;&gt;&gt;&quot;*50)</span></span><br><span class="line">    <span class="comment"># print(request)</span></span><br><span class="line"></span><br><span class="line">    request_lines = request.splitlines()</span><br><span class="line">    print(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;&gt;&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    print(request_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># GET /index.html HTTP/1.1</span></span><br><span class="line">    <span class="comment"># get post put del</span></span><br><span class="line">    file_name = <span class="string">&quot;&quot;</span></span><br><span class="line">    ret = re.match(<span class="string">r&quot;[^/]+(/[^ ]*)&quot;</span>, request_lines[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        file_name = ret.group(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(&quot;*&quot;*50, file_name)</span></span><br><span class="line">        <span class="keyword">if</span> file_name == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            file_name = <span class="string">&quot;/index.html&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 返回http格式的数据，给浏览器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&quot;./html&quot;</span> + file_name, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        response = <span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;------file not found-----&quot;</span></span><br><span class="line">        new_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        html_content = f.read()</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="comment"># 2.1 准备发送给浏览器的数据---header</span></span><br><span class="line">        response = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        <span class="comment"># 2.2 准备发送给浏览器的数据---boy</span></span><br><span class="line">        <span class="comment"># response += &quot;hahahhah&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将response header发送给浏览器</span></span><br><span class="line">        new_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        <span class="comment"># 将response body发送给浏览器</span></span><br><span class="line">        new_socket.send(html_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接</span></span><br><span class="line">    new_socket.close()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用来完成整体的控制&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定</span></span><br><span class="line">    tcp_server_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7890</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 变为监听套接字</span></span><br><span class="line">    tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4. 等待新客户端的链接</span></span><br><span class="line">        new_socket, client_addr = tcp_server_socket.accept()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 为这个客户端服务</span></span><br><span class="line">        <span class="comment">#############################################</span></span><br><span class="line">        gevent.spawn(service_client, new_socket)</span><br><span class="line">        <span class="comment">#############################################</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># new_socket.close()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭监听套接字</span></span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="4-并发服务器"><a href="#4-并发服务器" class="headerlink" title="4. 并发服务器"></a>4. 并发服务器</h3><h4 id="单进程、单线程、非阻塞"><a href="#单进程、单线程、非阻塞" class="headerlink" title="单进程、单线程、非阻塞"></a>单进程、单线程、非阻塞</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">tcp_server_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">tcp_server_tcp.bind((<span class="string">&quot;&quot;</span>, <span class="number">7899</span>))</span><br><span class="line">tcp_server_tcp.listen(<span class="number">128</span>)</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line">tcp_server_tcp.setblocking(<span class="literal">False</span>)  <span class="comment"># 设置套接字为非堵塞的方式</span></span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"></span><br><span class="line">client_socket_list = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># time.sleep(0.5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        new_socket, new_addr = tcp_server_tcp.accept()</span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ret:</span><br><span class="line">        print(<span class="string">&quot;---没有新的客户端到来---&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;---只要没有产生异常，那么也就意味着 来了一个新的客户端----&quot;</span>)</span><br><span class="line">        <span class="comment">#####################################################</span></span><br><span class="line">        new_socket.setblocking(<span class="literal">False</span>)  <span class="comment"># 设置套接字为非堵塞的方式</span></span><br><span class="line">        client_socket_list.append(new_socket)</span><br><span class="line">        <span class="comment">#####################################################</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> client_socket <span class="keyword">in</span> client_socket_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            recv_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ret:</span><br><span class="line">            print(ret)</span><br><span class="line">            print(<span class="string">&quot;----这个客户端没有发送过来数据----&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;-----没有异常-----&quot;</span>)</span><br><span class="line">            print(recv_data)</span><br><span class="line">            <span class="keyword">if</span> recv_data:</span><br><span class="line">                <span class="comment"># 对方发送过来数据</span></span><br><span class="line">                print(<span class="string">&quot;----客户端发送过来了数据-----&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 对方调用close 导致了 recv返回</span></span><br><span class="line">                client_socket.close()</span><br><span class="line">                client_socket_list.remove(client_socket)</span><br><span class="line">                print(<span class="string">&quot;---客户端已经关闭----&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-长链接、短链接"><a href="#5-长链接、短链接" class="headerlink" title="5.长链接、短链接"></a>5.长链接、短链接</h3><p>HTTP的协议版本1.0为短链接、1.1为长链接。</p><p><strong>短链接：</strong>获取一次数据需要进行一次三次握手和四次挥手。</p><p><strong>长链接：</strong>获取多次数据只需要建立一次三次握手和四次挥手即可。</p><h5 id="TCP长-短连接的应用场景"><a href="#TCP长-短连接的应用场景" class="headerlink" title="TCP长/短连接的应用场景"></a>TCP长/短连接的应用场景</h5><ul><li><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。</p><p>每个TCP连接都需要三次握手，这需要时间，如果每个操作都是先连接，</p><p>再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，</p><p>再次处理时直接发送数据包就OK了，不用建立TCP连接。</p><p>例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，</p><p>而且频繁的socket 创建也是对资源的浪费。</p></li><li><p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，</p><p>而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，</p><p>如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，</p><p>那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">service_client</span>(<span class="params">new_socket, request</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为这个客户端返回数据&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 接收浏览器发送过来的请求 ，即http请求  </span></span><br><span class="line">    <span class="comment"># GET / HTTP/1.1</span></span><br><span class="line">    <span class="comment"># .....</span></span><br><span class="line">    <span class="comment"># request = new_socket.recv(1024).decode(&quot;utf-8&quot;)</span></span><br><span class="line">    <span class="comment"># print(&quot;&gt;&gt;&gt;&quot;*50)</span></span><br><span class="line">    <span class="comment"># print(request)</span></span><br><span class="line"></span><br><span class="line">    request_lines = request.splitlines()</span><br><span class="line">    print(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;&gt;&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    print(request_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># GET /index.html HTTP/1.1</span></span><br><span class="line">    <span class="comment"># get post put del</span></span><br><span class="line">    file_name = <span class="string">&quot;&quot;</span></span><br><span class="line">    ret = re.match(<span class="string">r&quot;[^/]+(/[^ ]*)&quot;</span>, request_lines[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        file_name = ret.group(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(&quot;*&quot;*50, file_name)</span></span><br><span class="line">        <span class="keyword">if</span> file_name == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            file_name = <span class="string">&quot;/index.html&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 返回http格式的数据，给浏览器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&quot;./html&quot;</span> + file_name, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        response = <span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;------file not found-----&quot;</span></span><br><span class="line">        new_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        html_content = f.read()</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        response_body = html_content</span><br><span class="line"></span><br><span class="line">        response_header = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">        response_header += <span class="string">&quot;Content-Length:%d\r\n&quot;</span> % <span class="built_in">len</span>(response_body)</span><br><span class="line">        response_header += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line"></span><br><span class="line">        response = response_header.encode(<span class="string">&quot;utf-8&quot;</span>) + response_body</span><br><span class="line"></span><br><span class="line">        new_socket.send(response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用来完成整体的控制&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定</span></span><br><span class="line">    tcp_server_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7890</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 变为监听套接字</span></span><br><span class="line">    tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line">    tcp_server_socket.setblocking(<span class="literal">False</span>)  <span class="comment"># 将套接字变为非堵塞</span></span><br><span class="line"></span><br><span class="line">    client_socket_list = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4. 等待新客户端的链接</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            new_socket, client_addr = tcp_server_socket.accept()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ret:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_socket.setblocking(<span class="literal">False</span>)</span><br><span class="line">            client_socket_list.append(new_socket)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> client_socket <span class="keyword">in</span> client_socket_list:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                recv_data = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> ret:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> recv_data:</span><br><span class="line">                    service_client(client_socket, recv_data)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    client_socket.close()</span><br><span class="line">                    client_socket_list.remove(client_socket)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭监听套接字</span></span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>改为长链接有个问题。去掉了new_socket.close()这行代码。但是程序如何知道传递完了呢？</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response_header += <span class="string">&quot;Content-Length:%d\r\n&quot;</span> % <span class="built_in">len</span>(response_body) <span class="comment"># 在内容主体里面告诉浏览器body到底有多长，加这个就可以了保证确实加载完了。</span></span><br></pre></td></tr></table></figure><h3 id="6-epoll"><a href="#6-epoll" class="headerlink" title="6. epoll"></a>6. epoll</h3><p><strong>Linux</strong>采用的多任务形式。不用多进程、多线程、多协程的方式。</p><p><strong>gevent</strong>的底层就是按照<strong>epoll</strong>实现的。</p><p><strong>epoll的机制</strong>：操作系统和应用程序都有自己的空间，原先写的多任务，都是在应用程序里面进行操作套接字列表的，应用程序把套接字给操作系统，操作系统会在自己的空间内重新复制一份，然后执行看套接字里是否有数据，这样浪费时间，</p><p>①而epoll采用了应用程序和操作系统公用的空间，使得它们公用这个空间，这样就能提升性能。减少了复制过程。——内存映射机制（mmap）</p><p>②不用<strong>遍历套接字（轮询）</strong>的方式，而是以<strong>事件通知</strong>的方式进行。——基于事件的就绪通知方式。</p><p>从而保证epoll的效率很高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">service_client</span>(<span class="params">new_socket, request</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为这个客户端返回数据&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 接收浏览器发送过来的请求 ，即http请求  </span></span><br><span class="line">    <span class="comment"># GET / HTTP/1.1</span></span><br><span class="line">    <span class="comment"># .....</span></span><br><span class="line">    <span class="comment"># request = new_socket.recv(1024).decode(&quot;utf-8&quot;)</span></span><br><span class="line">    <span class="comment"># print(&quot;&gt;&gt;&gt;&quot;*50)</span></span><br><span class="line">    <span class="comment"># print(request)</span></span><br><span class="line"></span><br><span class="line">    request_lines = request.splitlines()</span><br><span class="line">    print(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;&gt;&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    print(request_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># GET /index.html HTTP/1.1</span></span><br><span class="line">    <span class="comment"># get post put del</span></span><br><span class="line">    file_name = <span class="string">&quot;&quot;</span></span><br><span class="line">    ret = re.match(<span class="string">r&quot;[^/]+(/[^ ]*)&quot;</span>, request_lines[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        file_name = ret.group(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(&quot;*&quot;*50, file_name)</span></span><br><span class="line">        <span class="keyword">if</span> file_name == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            file_name = <span class="string">&quot;/index.html&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 返回http格式的数据，给浏览器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&quot;./html&quot;</span> + file_name, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        response = <span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        response += <span class="string">&quot;------file not found-----&quot;</span></span><br><span class="line">        new_socket.send(response.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        html_content = f.read()</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        response_body = html_content</span><br><span class="line"></span><br><span class="line">        response_header = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">        response_header += <span class="string">&quot;Content-Length:%d\r\n&quot;</span> % <span class="built_in">len</span>(response_body)</span><br><span class="line">        response_header += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line"></span><br><span class="line">        response = response_header.encode(<span class="string">&quot;utf-8&quot;</span>) + response_body</span><br><span class="line"></span><br><span class="line">        new_socket.send(response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用来完成整体的控制&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定</span></span><br><span class="line">    tcp_server_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7890</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 变为监听套接字</span></span><br><span class="line">    tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line">    tcp_server_socket.setblocking(<span class="literal">False</span>)  <span class="comment"># 将套接字变为非堵塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个epoll对象</span></span><br><span class="line">    epl = select.epoll()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#########################################################</span></span><br><span class="line">    <span class="comment"># 将监听套接字对应的fd注册到epoll中(fd文件描述符)</span></span><br><span class="line">    epl.register(tcp_server_socket.fileno(), select.EPOLLIN)</span><br><span class="line"><span class="comment">#########################################################</span></span><br><span class="line">    </span><br><span class="line">    fd_event_dict = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        </span><br><span class="line"><span class="comment">###############################################################################################</span></span><br><span class="line">        fd_event_list = epl.poll()  <span class="comment"># 默认会堵塞，直到 os监测到数据到来 通过事件通知方式 告诉这个程序，此时才会解堵塞</span></span><br><span class="line">        <span class="comment"># [(fd, event), (套接字对应的文件描述符, 这个文件描述符到底是什么事件 例如 可以调用recv接收等)]</span></span><br><span class="line"><span class="comment">###############################################################################################</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> fd, event <span class="keyword">in</span> fd_event_list:</span><br><span class="line">            <span class="comment"># 等待新客户端的链接</span></span><br><span class="line">            <span class="keyword">if</span> fd == tcp_server_socket.fileno():</span><br><span class="line">                new_socket, client_addr = tcp_server_socket.accept()</span><br><span class="line">                epl.register(new_socket.fileno(), select.EPOLLIN)</span><br><span class="line">                fd_event_dict[new_socket.fileno()] = new_socket</span><br><span class="line">            <span class="keyword">elif</span> event==select.EPOLLIN:</span><br><span class="line">                <span class="comment"># 判断已经链接的客户端是否有数据发送过来</span></span><br><span class="line">                recv_data = fd_event_dict[fd].recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> recv_data:</span><br><span class="line">                    service_client(fd_event_dict[fd], recv_data)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    fd_event_dict[fd].close()</span><br><span class="line">                    epl.unregister(fd)</span><br><span class="line">                    <span class="keyword">del</span> fd_event_dict[fd]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭监听套接字</span></span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h2&gt;&lt;p&gt;HTTP是浏览器和服务器进行通信的一种协议。&lt;/p&gt;
&lt;p&gt;浏览器向服务器请求一次。&lt;/p&gt;
&lt;p&gt;服务器也向浏览器回应一次</summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://xxren8218.github.io/20210912/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
    <id>https://xxren8218.github.io/20210912/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</id>
    <published>2021-09-12T11:27:13.000Z</published>
    <updated>2021-09-12T11:27:39.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>比如判断邮箱、电话是否合法的时候用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">result = re.match(<span class="string">&quot;xxren8218&quot;</span>, <span class="string">&quot;xxren8218.cn&quot;</span>)</span><br><span class="line"></span><br><span class="line">result.group()</span><br></pre></td></tr></table></figure><ul><li>re.match() 能够匹配出以xxx开头的字符串</li></ul><h3 id="1-匹配单个字符"><a href="#1-匹配单个字符" class="headerlink" title="1.匹配单个字符"></a>1.匹配单个字符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">匹配任意1个字符（除了\n）</td></tr><tr><td style="text-align:center">[ ]</td><td style="text-align:left">匹配[ ]中列举的字符</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:left">匹配数字，即0-9</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:left">匹配非数字，即不是数字</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:left">匹配空白，即 空格，tab键</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:left">匹配非空白</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:left">匹配单词字符，即a-z、A-Z、0-9、_、中文也可以</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:left">匹配非单词字符</td></tr></tbody></table></div><h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1： ."></a>示例1： .</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;M&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;t.o&quot;</span>,<span class="string">&quot;too&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;t.o&quot;</span>,<span class="string">&quot;two&quot;</span>)</span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M</span><br><span class="line">too</span><br><span class="line">two</span><br></pre></td></tr></table></figure><h4 id="示例2："><a href="#示例2：" class="headerlink" title="示例2：[ ]"></a>示例2：[ ]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果hello的首字符小写，那么正则表达式需要小写的h</span></span><br><span class="line">ret = re.match(<span class="string">&quot;h&quot;</span>,<span class="string">&quot;hello Python&quot;</span>) </span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果hello的首字符大写，那么正则表达式需要大写的H</span></span><br><span class="line">ret = re.match(<span class="string">&quot;H&quot;</span>,<span class="string">&quot;Hello Python&quot;</span>) </span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大小写h都可以的情况</span></span><br><span class="line">ret = re.match(<span class="string">&quot;[hH]&quot;</span>,<span class="string">&quot;hello Python&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line">ret = re.match(<span class="string">&quot;[hH]&quot;</span>,<span class="string">&quot;Hello Python&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line">ret = re.match(<span class="string">&quot;[hH]ello Python&quot;</span>,<span class="string">&quot;Hello Python&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配0到9第一种写法</span></span><br><span class="line">ret = re.match(<span class="string">&quot;[0123456789]Hello Python&quot;</span>,<span class="string">&quot;7Hello Python&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配0到9第二种写法</span></span><br><span class="line">ret = re.match(<span class="string">&quot;[0-9]Hello Python&quot;</span>,<span class="string">&quot;7Hello Python&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;[0-35-9]Hello Python&quot;</span>,<span class="string">&quot;7Hello Python&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这个正则不能够匹配到数字4，因此ret为None</span></span><br><span class="line">ret = re.match(<span class="string">&quot;[0-35-9]Hello Python&quot;</span>,<span class="string">&quot;4Hello Python&quot;</span>)  <span class="comment">##这是0-3 5-9</span></span><br><span class="line"><span class="comment"># print(ret.group())</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h</span><br><span class="line">H</span><br><span class="line">h</span><br><span class="line">H</span><br><span class="line">Hello Python</span><br><span class="line">7Hello Python</span><br><span class="line">7Hello Python</span><br><span class="line">7Hello Python</span><br></pre></td></tr></table></figure><h3 id="2-匹配多个字符"><a href="#2-匹配多个字符" class="headerlink" title="2.匹配多个字符"></a>2.匹配多个字符</h3><p>匹配多个字符的相关格式</p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:left">匹配<strong>前一个字符</strong>出现0次或者无限次，即可有可无</td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">匹配<strong>前一个字符</strong>出现1次或者无限次，即至少有1次</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">匹配<strong>前一个字符</strong>出现1次或者0次，即要么有1次，要么没有</td></tr><tr><td style="text-align:center">{m}</td><td style="text-align:left">匹配<strong>前一个字符</strong>出现m次</td></tr><tr><td style="text-align:center">{m,n}</td><td style="text-align:left">匹配<strong>前一个字符</strong>出现从m到n次</td></tr></tbody></table></div><h4 id="示例1：-1"><a href="#示例1：-1" class="headerlink" title="示例1：*"></a>示例1：*</h4><p>需求：匹配出，一个字符串第一个字母为大小字符，后面都是小写字母并且这些小写字母可有可无</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;[A-Z][a-z]*&quot;</span>,<span class="string">&quot;M&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;[A-Z][a-z]*&quot;</span>,<span class="string">&quot;MnnM&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;[A-Z][a-z]*&quot;</span>,<span class="string">&quot;Aabcdef&quot;</span>)</span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M</span><br><span class="line">Mnn</span><br><span class="line">Aabcdef</span><br></pre></td></tr></table></figure><h4 id="示例2：-1"><a href="#示例2：-1" class="headerlink" title="示例2：+"></a>示例2：+</h4><p>需求：匹配出，变量名是否有效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;2_name&quot;</span>, <span class="string">&quot;__name__&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    ret = re.match(<span class="string">&quot;[a-zA-Z_]+[a-zA-Z0-9]*&quot;</span>,name)  <span class="comment"># 这个不行比如age#，这个不合法，但是判断为合法，因为match只能判断以什么开头。</span></span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        print(<span class="string">&quot;变量名 %s 符合要求&quot;</span> % ret.group())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;变量名 %s 非法&quot;</span> % name)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量名 name1 符合要求</span><br><span class="line">变量名 _name 符合要求</span><br><span class="line">变量名 2_name 非法</span><br><span class="line">变量名 __name__ 符合要求</span><br></pre></td></tr></table></figure><h4 id="示例3："><a href="#示例3：" class="headerlink" title="示例3：?"></a>示例3：?</h4><p>需求：匹配出，0到99之间的数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;[1-9]?[0-9]&quot;</span>,<span class="string">&quot;7&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;[1-9]?\d&quot;</span>,<span class="string">&quot;33&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;[1-9]?\d&quot;</span>,<span class="string">&quot;09&quot;</span>)</span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">0</span> <span class="comment"># 这个结果并不是想要的，利用$才能解决</span></span><br></pre></td></tr></table></figure><h4 id="示例4：-m"><a href="#示例4：-m" class="headerlink" title="示例4：{m}"></a>示例4：{m}</h4><p>需求：匹配出，8到20位的密码，可以是大小写英文字母、数字、下划线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;[a-zA-Z0-9_]&#123;6&#125;&quot;</span>,<span class="string">&quot;12a3g45678&quot;</span>)</span><br><span class="line">print(ret.group())</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">&quot;[a-zA-Z0-9_]&#123;8,20&#125;&quot;</span>,<span class="string">&quot;1ad12f23s34455ff66&quot;</span>)</span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12a3g4</span><br><span class="line">1ad12f23s34455ff66</span><br></pre></td></tr></table></figure><ul><li>判断电话号码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(<span class="string">r&quot;\d&#123;3,4&#125;-?\d&#123;7,8&#125;&quot;</span>, <span class="string">&quot;021-12345678&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-匹配开头结尾"><a href="#3-匹配开头结尾" class="headerlink" title="3.匹配开头结尾"></a>3.匹配开头结尾</h3><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">^</td><td style="text-align:left">匹配字符串开头</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">匹配字符串结尾</td></tr></tbody></table></div><ul><li>变量命名是否合法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(<span class="string">&quot;^[a-zA-Z_]+[a-zA-Z0-9]*$&quot;</span>,name)</span><br></pre></td></tr></table></figure><ul><li>判断163地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(<span class="string">r&quot;^[a-zA-Z0-9_]&#123;4,20&#125;@163\.com$&quot;</span>, email) <span class="comment"># 这里的.是通用的需要转义</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="如果在正则表达式中需要用到了某些普通的字符，比如-？等，仅仅需要在他们前面添加一个-进行转义"><a href="#如果在正则表达式中需要用到了某些普通的字符，比如-？等，仅仅需要在他们前面添加一个-进行转义" class="headerlink" title="如果在正则表达式中需要用到了某些普通的字符，比如 . ？等，仅仅需要在他们前面添加一个 / 进行转义"></a>如果在正则表达式中需要用到了某些普通的字符，比如 . ？等，仅仅需要在他们前面添加一个 / 进行转义</h4></blockquote><h3 id="4-匹配分组"><a href="#4-匹配分组" class="headerlink" title="4.匹配分组"></a>4.匹配分组</h3><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td style="text-align:left"></td><td>匹配左右任意一个表达式</td></tr><tr><td style="text-align:center">(ab)</td><td style="text-align:left">将括号中字符作为一个分组</td></tr><tr><td style="text-align:center"><code>\num</code></td><td style="text-align:left">引用分组num匹配到的字符串</td></tr><tr><td style="text-align:center"><code>(?P&lt;name&gt;)</code></td><td style="text-align:left">分组起别名</td></tr><tr><td style="text-align:center">(?P=name)</td><td style="text-align:left">引用别名为name分组匹配到的字符串</td></tr></tbody></table></div><h4 id="示例1：-——分组"><a href="#示例1：-——分组" class="headerlink" title="示例1：()——分组"></a>示例1：()——分组</h4><ul><li>判断163或者126地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">re.match(<span class="string">r&quot;^[a-zA-Z0-9_]&#123;4,20&#125;@(163|126)\.com$&quot;</span>, <span class="string">&quot;xxren8218@163.com&quot;</span>).group()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xxren8218@<span class="number">163.</span>com</span><br><span class="line"></span><br><span class="line">re.match(<span class="string">r&quot;^[a-zA-Z0-9_]&#123;4,20&#125;@(126|163)\.com$&quot;</span>, <span class="string">&quot;xxren8218@163.com&quot;</span>).group(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="number">163</span></span><br><span class="line"></span><br><span class="line">re.match(<span class="string">r&quot;^([a-zA-Z0-9_]&#123;4,20&#125;)@(163|126)\.com$&quot;</span>, <span class="string">&quot;xxren8218@163.com&quot;</span>).group(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;xxren8218</span><br></pre></td></tr></table></figure><p>判断标签是否合法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">re.match(<span class="string">r&quot;&lt;\w*&gt;.*&lt;/\w*&gt;&quot;</span>, <span class="string">&quot;&lt;h1&gt;haha&lt;/h2&gt;&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>合法，但实际不合法——利用分组()</span><br><span class="line">re.match(<span class="string">r&quot;&lt;(\w*)&gt;.*&lt;/\1&gt;&quot;</span>, <span class="string">&quot;&lt;h1&gt;haha&lt;/h1&gt;&quot;</span>)   <span class="comment"># \1 第一分组里的值。</span></span><br><span class="line">&gt;&gt;&gt;不合法</span><br><span class="line"></span><br><span class="line">re.match(<span class="string">r&quot;&lt;(\w*)&gt;&lt;(\w*)&gt;.*&lt;/\2&gt;&lt;/\1&gt;&quot;</span>, <span class="string">&quot;&lt;body&gt;&lt;h1&gt;haha&lt;/h1&gt;&lt;/body&gt;&quot;</span>) </span><br></pre></td></tr></table></figure><h4 id="示例2：-P-lt-name-gt-P-name"><a href="#示例2：-P-lt-name-gt-P-name" class="headerlink" title="示例2：(?P&lt;name&gt;) (?P=name)"></a>示例2：<code>(?P&lt;name&gt;)</code> <code>(?P=name)</code></h4><p>需求：匹配出<code>&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">r&quot;&lt;(?P&lt;name1&gt;\w*)&gt;&lt;(?P&lt;name2&gt;\w*)&gt;.*&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;&quot;</span>, <span class="string">&quot;&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;&quot;</span>)</span><br><span class="line">ret.group()</span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">r&quot;&lt;(?P&lt;name1&gt;\w*)&gt;&lt;(?P&lt;name2&gt;\w*)&gt;.*&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;&quot;</span>, <span class="string">&quot;&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h2&gt;&lt;/html&gt;&quot;</span>)</span><br><span class="line">ret.group()</span><br></pre></td></tr></table></figure><h3 id="5-Python中re模块的高级用法"><a href="#5-Python中re模块的高级用法" class="headerlink" title="5.Python中re模块的高级用法"></a>5.Python中re模块的高级用法</h3><ul><li>search</li><li>findall</li><li>sub</li><li>split</li></ul><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>需求：匹配出文章阅读的次数</p><p><strong>match是从头开始匹配，而search并不是，只要满足要求就可以。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.search(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;阅读次数为 9999&quot;</span>)</span><br><span class="line">ret.group()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;9999&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="findall—不用group"><a href="#findall—不用group" class="headerlink" title="findall—不用group()"></a>findall—不用group()</h4><p>需求：统计出python、c、c++相应文章阅读的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.findall(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;python = 9999, c = 7890, c++ = 12345&quot;</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;9999&#x27;</span>, <span class="string">&#x27;7890&#x27;</span>, <span class="string">&#x27;12345&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="sub-将匹配到的数据进行替换"><a href="#sub-将匹配到的数据进行替换" class="headerlink" title="sub 将匹配到的数据进行替换"></a>sub 将匹配到的数据进行替换</h4><ul><li>先找值，然后进行替换。</li></ul><p><strong>需求：将匹配到的阅读次数加1</strong></p><p><strong>方法1：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.sub(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&#x27;998&#x27;</span>, <span class="string">&quot;python = 997&quot;</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python = <span class="number">998</span></span><br></pre></td></tr></table></figure><p><strong>方法2：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">temp</span>):</span></span><br><span class="line">    strNum = temp.group()</span><br><span class="line">    num = <span class="built_in">int</span>(strNum) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(num)</span><br><span class="line"></span><br><span class="line">ret = re.sub(<span class="string">r&quot;\d+&quot;</span>, add, <span class="string">&quot;python = 997&quot;</span>)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">ret = re.sub(<span class="string">r&quot;\d+&quot;</span>, add, <span class="string">&quot;python = 99&quot;</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python = <span class="number">998</span></span><br><span class="line">python = <span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="split-根据匹配进行切割字符串，并返回一个列表"><a href="#split-根据匹配进行切割字符串，并返回一个列表" class="headerlink" title="split 根据匹配进行切割字符串，并返回一个列表"></a>split 根据匹配进行切割字符串，并返回一个列表</h4><p>需求：切割字符串“info:xiaoxiong 25 shanxi</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.split(<span class="string">r&quot;:| &quot;</span>,<span class="string">&quot;info:xiaoxiong 25 shanxi&quot;</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;xiaoxiong&#x27;</span>, <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;shanxi&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>Python中字符串前面加上 r 表示原生字符串</code>，</p><p>与大多数编程语言相同，<code>正则表达式里使用&quot;\&quot;作为转义字符</code>，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\”：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。</p><p>Python里的原生字符串很好地解决了这个问题，有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = re.match(<span class="string">r&quot;c:\\a&quot;</span>,mm).group()  <span class="string">&quot;c:\\\\a&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ret)</span><br><span class="line">c:\a</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h2&gt;&lt;p&gt;比如判断邮箱、电话是否合法的时候用&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多任务-协程</title>
    <link href="https://xxren8218.github.io/20210912/%E5%A4%9A%E4%BB%BB%E5%8A%A1-%E5%8D%8F%E7%A8%8B.html"/>
    <id>https://xxren8218.github.io/20210912/%E5%A4%9A%E4%BB%BB%E5%8A%A1-%E5%8D%8F%E7%A8%8B.html</id>
    <published>2021-09-12T11:26:16.000Z</published>
    <updated>2021-09-12T11:26:53.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多任务—协程"><a href="#多任务—协程" class="headerlink" title="多任务—协程"></a>多任务—协程</h2><h3 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h3><blockquote><p>迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classmate</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.names = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;如果想要一个对象称为一个　可以迭代的对象，即可以使用for，那么必须实现__iter__方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> ClassIterator()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassIterator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classmate = Classmate()</span><br><span class="line">classmate.add(<span class="string">&quot;老王&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;王二&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;判断classmate是否是可以迭代的对象:&quot;, isinstance(classmate, Iterable))</span></span><br><span class="line"><span class="comment"># classmate_iterator = iter(classmate)</span></span><br><span class="line"><span class="comment"># print(&quot;判断classmate_iterator是否是迭代器:&quot;, isinstance(classmate_iterator, Iterator))</span></span><br><span class="line"><span class="comment"># print(next(classmate_iterator))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> classmate:</span><br><span class="line">    print(name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>想要用for循环：</strong></p><ul><li>先判断for后面的是否是可以迭代对象（含有<strong>iter</strong>方法）</li><li>该方法是否返回含有iter和next方法的引用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> xxx_obj:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ol><li>判断xxx_obj是否是可以迭代对象</li><li>在1成立的前提下，调用iter函数得到xxx_obj对象的iter方法的返回值</li><li>iter方法的返回值是一个迭代器。for循环就会调用它的next方法。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classmate</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.names = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;如果想要一个对象称为一个　可以迭代的对象，即可以使用for，那么必须实现__iter__方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> ClassIterator(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassIterator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        self.obj = obj</span><br><span class="line">self.current_num = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment">##########################</span></span><br><span class="line">        <span class="comment">#return self.obj.names[0]#</span></span><br><span class="line">        <span class="comment">##########################</span></span><br><span class="line">    ret = self.obj.names[self.current_num]</span><br><span class="line">        self.current_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classmate = Classmate()</span><br><span class="line">classmate.add(<span class="string">&quot;老王&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;王二&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;判断classmate是否是可以迭代的对象:&quot;, isinstance(classmate, Iterable))</span></span><br><span class="line"><span class="comment"># classmate_iterator = iter(classmate)</span></span><br><span class="line"><span class="comment"># print(&quot;判断classmate_iterator是否是迭代器:&quot;, isinstance(classmate_iterator, Iterator))</span></span><br><span class="line"><span class="comment"># print(next(classmate_iterator))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> classmate:</span><br><span class="line">    print(name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classmate</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.names = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;如果想要一个对象称为一个　可以迭代的对象，即可以使用for，那么必须实现__iter__方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> ClassIterator(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassIterator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        self.obj = obj</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; <span class="built_in">len</span>(self.obj.names):</span><br><span class="line">            ret = self.obj.names[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classmate = Classmate()</span><br><span class="line">classmate.add(<span class="string">&quot;老王&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;王二&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;判断classmate是否是可以迭代的对象:&quot;, isinstance(classmate, Iterable))</span></span><br><span class="line"><span class="comment"># classmate_iterator = iter(classmate)</span></span><br><span class="line"><span class="comment"># print(&quot;判断classmate_iterator是否是迭代器:&quot;, isinstance(classmate_iterator, Iterator))</span></span><br><span class="line"><span class="comment"># print(next(classmate_iterator))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> classmate:</span><br><span class="line">    print(name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>只需要一个对象实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classmate</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.names = <span class="built_in">list</span>()</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;如果想要一个对象称为一个　可以迭代的对象，即可以使用for，那么必须实现__iter__方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 调用iter(xxobj)的时候 只要__iter__方法返回一个 迭代器即可，至于是自己 还是 别的对象都可以的, 但是要保证是一个迭代器(即实现了 __iter__  __next__方法)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; <span class="built_in">len</span>(self.names):</span><br><span class="line">            ret = self.names[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classmate = Classmate()</span><br><span class="line">classmate.add(<span class="string">&quot;老王&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;王二&quot;</span>)</span><br><span class="line">classmate.add(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;判断classmate是否是可以迭代的对象:&quot;, isinstance(classmate, Iterable))</span></span><br><span class="line"><span class="comment"># classmate_iterator = iter(classmate)</span></span><br><span class="line"><span class="comment"># print(&quot;判断classmate_iterator是否是迭代器:&quot;, isinstance(classmate_iterator, Iterator))</span></span><br><span class="line"><span class="comment"># print(next(classmate_iterator))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> classmate:</span><br><span class="line">    print(name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><h4 id="一个对象是迭代器，一定是可迭代对象，但是，若一个对象是可迭代对象，他不一定是迭代器。"><a href="#一个对象是迭代器，一定是可迭代对象，但是，若一个对象是可迭代对象，他不一定是迭代器。" class="headerlink" title="一个对象是迭代器，一定是可迭代对象，但是，若一个对象是可迭代对象，他不一定是迭代器。"></a>一个对象是迭代器，一定是可迭代对象，但是，若一个对象是可迭代对象，他不一定是迭代器。</h4></blockquote><p>迭代器存储的是生成数据的方式，而不是存储的是生成数据的结果。</p><ul><li>python2</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">1000000000000000</span>)</span><br><span class="line"><span class="comment"># 生成很多数。——占用空间很大（Python2中，立马生成）</span></span><br><span class="line"></span><br><span class="line">xrange(<span class="number">100000000000000</span>)</span><br><span class="line"><span class="comment"># 存放生成数据的方式，是可迭代对象，什么时候取，什么时候调、</span></span><br></pre></td></tr></table></figure><ul><li>python3</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>) <span class="comment"># 返回迭代器。</span></span><br></pre></td></tr></table></figure><h4 id="并不是只有for循环能接收可迭代对象"><a href="#并不是只有for循环能接收可迭代对象" class="headerlink" title="并不是只有for循环能接收可迭代对象"></a>并不是只有for循环能接收可迭代对象</h4><p>除了for循环能接收可迭代对象，list、tuple等也能接收。（类型转转。先创建空的列表、字典、元祖等，然后塞数据）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = <span class="built_in">list</span>(FibIterator(<span class="number">15</span>))</span><br><span class="line">print(li)</span><br><span class="line">tp = <span class="built_in">tuple</span>(FibIterator(<span class="number">6</span>))</span><br><span class="line">print(tp)</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><ul><li><strong>保证函数执行一部分以后，然后返回。</strong></li></ul><h4 id="yield和return的区别："><a href="#yield和return的区别：" class="headerlink" title="yield和return的区别："></a>yield和return的区别：</h4><p>yield调用后，函数不会停止，只是暂停。而调用return后，函数终止。</p><p>利用迭代器，我们可以在每次迭代获取数据（通过next()方法）时按照特定的规律进行生成。但是我们在实现一个迭代器时，<strong>关于当前迭代到的状态需要我们自己记录，</strong>进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合next()函数进行迭代使用，我们可以采用更简便的语法，即<strong>生成器(generator)。生成器是一类特殊的迭代器</strong>。</p><h4 id="创建生成器1"><a href="#创建生成器1" class="headerlink" title="创建生成器1"></a>创建生成器1</h4><p>要创建一个生成器，有很多种方法。第一种方法很简单，只要把一个列表生成式的 [ ] 改成 ( )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: L = [ x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: L</span><br><span class="line">Out[<span class="number">16</span>]: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: G = ( x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))  <span class="comment"># 迭代器：节省空间。</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: G</span><br><span class="line">Out[<span class="number">18</span>]: &lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7f626c132db0</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="创建生成器2"><a href="#创建生成器2" class="headerlink" title="创建生成器2"></a>创建生成器2</h4><ul><li>将函数里面加yield</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_num</span>(<span class="params">all_num</span>):</span></span><br><span class="line">    print(<span class="string">&quot;----1---&quot;</span>)</span><br><span class="line">    <span class="comment"># a = 0</span></span><br><span class="line">    <span class="comment"># b = 1</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current_num &lt; all_num:</span><br><span class="line">        print(<span class="string">&quot;----2---&quot;</span>)</span><br><span class="line">        <span class="comment"># print(a)</span></span><br><span class="line">        <span class="keyword">yield</span> a  <span class="comment"># 如果一个函数中有yield语句，那么这个就不在是函数，而是一个生成器的模板</span></span><br><span class="line">        print(<span class="string">&quot;----3---&quot;</span>)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line">        print(<span class="string">&quot;----4---&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在调用create_num的时候，发现这个函数中有yield那么此时，不是调用函数，而是创建一个生成器对象</span></span><br><span class="line">obj = create_num(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">next</span>(obj)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">next</span>(obj)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">obj2 = create_num(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">next</span>(obj2)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for num in obj:</span></span><br><span class="line"><span class="comment">#    print(num)</span></span><br></pre></td></tr></table></figure><p>yield的使得函数停留在这个地方，若是for循环，yieid后面东西返回给num。下次进行时，会从yield后面接着运行。</p><p>原来的调函数，现在为调用生成器对象。</p><blockquote><h4 id="生成器的执行是调用next，而不是调用函数。"><a href="#生成器的执行是调用next，而不是调用函数。" class="headerlink" title="生成器的执行是调用next，而不是调用函数。"></a>生成器的执行是调用next，而不是调用函数。</h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_num</span>(<span class="params">all_num</span>):</span></span><br><span class="line">    <span class="comment"># a = 0</span></span><br><span class="line">    <span class="comment"># b = 1</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current_num &lt; all_num:</span><br><span class="line">        <span class="comment"># print(a)</span></span><br><span class="line">        <span class="keyword">yield</span> a  <span class="comment"># 如果一个函数中有yield语句，那么这个就不在是函数，而是一个生成器的模板</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok....&quot;</span></span><br><span class="line"></span><br><span class="line">obj2 = create_num(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret = <span class="built_in">next</span>(obj2)</span><br><span class="line">        print(ret)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ret:</span><br><span class="line">        print(ret.value)  <span class="comment"># 若要捕获生成器中的return的返回值，需要进行返回异常中的value来进行获取。</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>若要捕获生成器中的return的返回值，需要进行返回异常中的value来进行获取。</p><blockquote><h4 id="生成器的执行也可以用send唤醒。"><a href="#生成器的执行也可以用send唤醒。" class="headerlink" title="生成器的执行也可以用send唤醒。"></a>生成器的执行也可以用send唤醒。</h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.send(<span class="string">&#x27;haha&#x27;</span>) <span class="comment"># 生成器对象.send</span></span><br><span class="line"><span class="built_in">next</span>(f)        <span class="comment"># next(生成器对象)  </span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_num</span>(<span class="params">all_num</span>):</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current_num &lt; all_num:</span><br><span class="line">        ret = <span class="keyword">yield</span> a  <span class="comment"># 第一次调用 next 将 a 给下面的ret，第二次调用 send 将 &quot;haha&quot; 传给这里的 ret</span></span><br><span class="line">        print(<span class="string">&quot;&gt;&gt;&gt;ret&gt;&gt;&gt;&gt;&quot;</span>, ret)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">obj = create_num(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># obj.send(None)  # send一般不会放到第一次启动生成器，如果非要这样做 那么传递None</span></span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">next</span>(obj)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># send里面的数据会 传递给第5行，当做yield a的结果，然后ret保存这个结果,,, </span></span><br><span class="line"><span class="comment"># send的结果是下一次调用yield时 yield后面的值</span></span><br><span class="line">ret = obj.send(<span class="string">&quot;hahahha&quot;</span>)  </span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><ul><li>send可以传参数，next不可以传参数。</li></ul><blockquote><h4 id="注意：send带值的话一般是不放在第一次调用的，没人接收它的值。"><a href="#注意：send带值的话一般是不放在第一次调用的，没人接收它的值。" class="headerlink" title="注意：send带值的话一般是不放在第一次调用的，没人接收它的值。"></a>注意：send带值的话一般是不放在第一次调用的，没人接收它的值。</h4><h4 id="生成器和迭代器都是保存生成数据的代码"><a href="#生成器和迭代器都是保存生成数据的代码" class="headerlink" title="生成器和迭代器都是保存生成数据的代码"></a>生成器和迭代器都是保存生成数据的代码</h4></blockquote><h3 id="使用生成器完成多任务——协程"><a href="#使用生成器完成多任务——协程" class="headerlink" title="使用生成器完成多任务——协程"></a>使用生成器完成多任务——协程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_1</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&quot;---1----&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_2</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&quot;---2----&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    t1 = task_1()</span><br><span class="line">    t2 = task_2()</span><br><span class="line">    <span class="comment"># 先让t1运行一会，当t1中遇到yield的时候，再返回到24行，然后</span></span><br><span class="line">    <span class="comment"># 执行t2，当它遇到yield的时候，再次切换到t1中</span></span><br><span class="line">    <span class="comment"># 这样t1/t2/t1/t2的交替运行，最终实现了多任务....协程</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">next</span>(t1)</span><br><span class="line">        <span class="built_in">next</span>(t2)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><ul><li>并发</li></ul><blockquote><h3 id="进程之间切换任务占用资源，相当大。创建和释放进程需要浪费大量的时间。"><a href="#进程之间切换任务占用资源，相当大。创建和释放进程需要浪费大量的时间。" class="headerlink" title="进程之间切换任务占用资源，相当大。创建和释放进程需要浪费大量的时间。"></a>进程之间切换任务占用资源，相当大。创建和释放进程需要浪费大量的时间。</h3><h3 id="进程效率没有线程高。"><a href="#进程效率没有线程高。" class="headerlink" title="进程效率没有线程高。"></a>进程效率没有线程高。</h3><h3 id="协程调用一个多任务，就像调用一个函数一样，切换资源最少。"><a href="#协程调用一个多任务，就像调用一个函数一样，切换资源最少。" class="headerlink" title="协程调用一个多任务，就像调用一个函数一样，切换资源最少。"></a>协程调用一个多任务，就像调用一个函数一样，切换资源最少。</h3></blockquote><h4 id="协程和线程差异"><a href="#协程和线程差异" class="headerlink" title="协程和线程差异"></a>协程和线程差异</h4><p>在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。</p><h4 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h4><p>为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;---A--&quot;</span></span><br><span class="line">        gr2.switch()</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;---B--&quot;</span></span><br><span class="line">        gr1.switch()</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">gr1 = greenlet(test1)</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换到gr1中运行</span></span><br><span class="line">gr1.switch()</span><br></pre></td></tr></table></figure><h4 id="gevent（使用较多）"><a href="#gevent（使用较多）" class="headerlink" title="gevent（使用较多）"></a>gevent（使用较多）</h4><p>greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块<code>gevent</code></p><blockquote><h4 id="gevent遇到延时就切换，没有延时，就不切换。——需要gevent的延时，不是time-sleep的延时。"><a href="#gevent遇到延时就切换，没有延时，就不切换。——需要gevent的延时，不是time-sleep的延时。" class="headerlink" title="gevent遇到延时就切换，没有延时，就不切换。——需要gevent的延时，不是time.sleep的延时。"></a>gevent遇到延时就切换，没有延时，就不切换。——需要gevent的延时，不是time.sleep的延时。</h4><h4 id="利用了延时时间，利用起来——协程的最主要作用。"><a href="#利用了延时时间，利用起来——协程的最主要作用。" class="headerlink" title="利用了延时时间，利用起来——协程的最主要作用。"></a>利用了延时时间，利用起来——协程的最主要作用。</h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()  <span class="comment"># 打补丁，可以使time.sleep对于gevent也是适用的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        print(gevent.getcurrent(), i)</span><br><span class="line">        <span class="comment"># time.sleep(0.5)</span></span><br><span class="line">        gevent.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        print(gevent.getcurrent(), i)</span><br><span class="line">        <span class="comment"># time.sleep(0.5)</span></span><br><span class="line">gevent.sleep(<span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        print(gevent.getcurrent(), i)</span><br><span class="line">        <span class="comment"># time.sleep(0.5)</span></span><br><span class="line">        gevent.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;----1---&quot;</span>)</span><br><span class="line">g1 = gevent.spawn(f1, <span class="number">5</span>)</span><br><span class="line">print(<span class="string">&quot;----2---&quot;</span>)</span><br><span class="line">g2 = gevent.spawn(f2, <span class="number">5</span>)</span><br><span class="line">print(<span class="string">&quot;----3---&quot;</span>)</span><br><span class="line">g3 = gevent.spawn(f3, <span class="number">5</span>)</span><br><span class="line">print(<span class="string">&quot;----4---&quot;</span>)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有耗时操作时需要</span></span><br><span class="line">monkey.patch_all()  <span class="comment"># 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine_work</span>(<span class="params">coroutine_name</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        print(coroutine_name, i)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">        gevent.spawn(coroutine_work, <span class="string">&quot;work1&quot;</span>),</span><br><span class="line">        gevent.spawn(coroutine_work, <span class="string">&quot;work2&quot;</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><ol><li>进程是资源分配的单位</li><li>线程是操作系统调度的单位</li><li>进程切换需要的资源很最大，效率很低</li><li>线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）</li><li>协程切换任务资源很小，效率高（在考虑网络有很多阻塞时。）</li><li>多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多任务—协程&quot;&gt;&lt;a href=&quot;#多任务—协程&quot; class=&quot;headerlink&quot; title=&quot;多任务—协程&quot;&gt;&lt;/a&gt;多任务—协程&lt;/h2&gt;&lt;h3 id=&quot;1-迭代器&quot;&gt;&lt;a href=&quot;#1-迭代器&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多任务-进程</title>
    <link href="https://xxren8218.github.io/20210912/%E5%A4%9A%E4%BB%BB%E5%8A%A1-%E8%BF%9B%E7%A8%8B.html"/>
    <id>https://xxren8218.github.io/20210912/%E5%A4%9A%E4%BB%BB%E5%8A%A1-%E8%BF%9B%E7%A8%8B.html</id>
    <published>2021-09-12T11:25:38.000Z</published>
    <updated>2021-09-12T11:25:56.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多任务—进程"><a href="#多任务—进程" class="headerlink" title="多任务—进程"></a>多任务—进程</h2><p><strong>程序</strong>：例如xxx.py这是程序，是一个<strong>静态</strong>的</p><p><strong>进程：</strong>一个程序运行起来后，<strong>代码+用到的资源</strong> 称之为进程，它是<strong>操作系统分配资源的基本单元</strong>。</p><p><strong>进程的状态：新建—就绪—运行—等待—死亡</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&quot;1--------&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&quot;2--------&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"> <span class="comment">#    t1 = threading.Thread(target=test1)</span></span><br><span class="line"> <span class="comment">#    t2 = threading.Thread(target=test2)</span></span><br><span class="line"> <span class="comment">#    t1.start()</span></span><br><span class="line"> <span class="comment">#    t2.start()</span></span><br><span class="line"></span><br><span class="line">    p1 = multiprocessing.Process(target=test1)</span><br><span class="line">    p2 = multiprocessing.Process(target=test2)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux # 查看所有进程 PID唯一</span><br></pre></td></tr></table></figure><p>代码 + 资源 = 进程</p><p>创建一个进程后，还是 代码 + 资源 = 进程——进程耗费资源很大。</p><h3 id="进程、线程对比"><a href="#进程、线程对比" class="headerlink" title="进程、线程对比"></a>进程、线程对比</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ</li><li>线程，能够完成多任务，比如 一个QQ中的多个聊天窗口</li></ul><h4 id="定义的不同"><a href="#定义的不同" class="headerlink" title="定义的不同"></a>定义的不同</h4><ul><li><strong>进程</strong>是系统进行<strong>资源分配和调度</strong>的一个独立单位.</li><li><strong>线程</strong>是进程的一个实体,是<strong>CPU调度和分派的基本单位</strong>,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</li><li>线程不能够独立执行，必须依存在进程中</li><li>可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人</li><li><strong>线程之间共享全局变量，进程之间不共享全局变量</strong></li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h3 id="进程间数据共享"><a href="#进程间数据共享" class="headerlink" title="进程间数据共享"></a>进程间数据共享</h3><p>采用队列Queue进行，相当于写入一块内存，进程间相互用。</p><ul><li>还有一个作用：解耦、进程A下载数据，扔进进程，进程B处理数据。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">一个进程向Queue中写入数据，另外一个进程从Queue中获取数据，</span></span><br><span class="line"><span class="string">通过Queue完成了 多个需要配合的进程间的数据共享，从而能够 起到 解耦的作用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_from_web</span>(<span class="params">q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 模拟从网上下载的数据</span></span><br><span class="line">    data = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向队列中写入数据</span></span><br><span class="line">    <span class="keyword">for</span> temp <span class="keyword">in</span> data:</span><br><span class="line">        q.put(temp)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;---下载器已经下载完了数据并且存入到队列中----&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis_data</span>(<span class="params">q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;数据处理&quot;&quot;&quot;</span></span><br><span class="line">    waitting_analysis_data = <span class="built_in">list</span>()</span><br><span class="line">    <span class="comment"># 从队列中获取数据</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = q.get()</span><br><span class="line">        waitting_analysis_data.append(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> q.empty():</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟数据处理</span></span><br><span class="line">    print(waitting_analysis_data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 1. 创建一个队列</span></span><br><span class="line">    q = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 创建多个进程，将队列的引用当做实参进行传递到里面</span></span><br><span class="line">    p1 = multiprocessing.Process(target=download_from_web, args=(q,))</span><br><span class="line">    p2 = multiprocessing.Process(target=analysis_data, args=(q,))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="进程池Pool"><a href="#进程池Pool" class="headerlink" title="进程池Pool"></a>进程池Pool</h4><ul><li>若使用文件下载，不需要，两个进程即可，一个收，一个写。</li></ul><p>缓存缓冲——重复利用进程池中的进程。（划船例子。买船，需要进行测试）减少进程的创建和销毁的次数</p><p>当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是<strong>上百甚至上千个目标</strong>，手动的去创建进程的工作量巨大，此时就可以用到<strong>multiprocessing模块</strong>提供的<strong>Pool</strong>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">msg</span>):</span></span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(<span class="string">&quot;%s开始执行,进程号为%d&quot;</span> % (msg,os.getpid()))</span><br><span class="line">    <span class="comment"># random.random()随机生成0~1之间的浮点数</span></span><br><span class="line">    time.sleep(random.random()*<span class="number">2</span>) </span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(msg,<span class="string">&quot;执行完毕，耗时%0.2f&quot;</span> % (t_stop-t_start))</span><br><span class="line">    </span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line">po = Pool(<span class="number">3</span>)  <span class="comment"># 定义一个进程池，最大进程数3</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="comment"># Pool().apply_async(要调用的目标,(传递给目标的参数元祖,))</span></span><br><span class="line">    <span class="comment"># 每次循环将会用空闲出来的子进程去调用目标</span></span><br><span class="line">    po.apply_async(worker,(i,))</span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;----start----&quot;</span>)</span><br><span class="line">po.close()  <span class="comment"># 关闭进程池，关闭后po不再接收新的请求</span></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line">po.join()  <span class="comment"># 等待po中所有子进程执行完成，必须放在close语句之后——主进程不会等待子进程（进程池）</span></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line">print(<span class="string">&quot;-----end-----&quot;</span>)</span><br></pre></td></tr></table></figure><p>multiprocessing.Pool常用函数解析：</p><ul><li>apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwargs为传递给func的关键字参数列表；</li><li>close()：关闭Pool，使其不再接受新的任务；</li><li>terminate()：不管任务是否完成，立即终止；</li><li>join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；</li></ul><blockquote><h4 id="进程池之间的通信"><a href="#进程池之间的通信" class="headerlink" title="进程池之间的通信"></a>进程池之间的通信</h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q = Manager().Queue()  <span class="comment"># 使用Manager中的Queue</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多任务—进程&quot;&gt;&lt;a href=&quot;#多任务—进程&quot; class=&quot;headerlink&quot; title=&quot;多任务—进程&quot;&gt;&lt;/a&gt;多任务—进程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;：例如xxx.py这是程序，是一个&lt;strong&gt;静态&lt;/strong</summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多任务-线程</title>
    <link href="https://xxren8218.github.io/20210912/%E5%A4%9A%E4%BB%BB%E5%8A%A1-%E7%BA%BF%E7%A8%8B.html"/>
    <id>https://xxren8218.github.io/20210912/%E5%A4%9A%E4%BB%BB%E5%8A%A1-%E7%BA%BF%E7%A8%8B.html</id>
    <published>2021-09-12T11:23:28.000Z</published>
    <updated>2021-09-12T11:25:02.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多任务—线程（轻量级）"><a href="#多任务—线程（轻量级）" class="headerlink" title="多任务—线程（轻量级）"></a>多任务—线程（轻量级）</h2><ul><li><strong>并发：</strong>指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</li><li><strong>并行</strong>：指的是任务数小于等于cpu核数，即任务真的是一起执行的<ul><li>时间片轮转</li><li>优先级调度</li></ul></li></ul><h4 id="1-线程："><a href="#1-线程：" class="headerlink" title="1. 线程："></a>1. 线程：</h4><p>一个程序执行起来之后，一定有一个执行代码的东西，这个东西我们称之为  线程。</p><p>threading里面有个Thread(target=saySorry)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saySorry</span>():</span></span><br><span class="line">    print(<span class="string">&quot;亲爱的，我错了，我能吃饭了吗？&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="comment">######################################</span></span><br><span class="line">        t = threading.Thread(target=saySorry)</span><br><span class="line">        <span class="comment">######################################</span></span><br><span class="line">        t.start() <span class="comment"># 启动线程，即让线程开始执行</span></span><br></pre></td></tr></table></figure><h4 id="2-主线程会等待所有的子线程结束后才结束"><a href="#2-主线程会等待所有的子线程结束后才结束" class="headerlink" title="2. 主线程会等待所有的子线程结束后才结束"></a>2. 主线程会等待所有的子线程结束后才结束</h4><p>主线程帮子线程收拾，处理垃圾。</p><p><strong>线程的执行是调用t.start()时执行，一个线程的结束是函数的结束。</strong></p><p>当调用Thread的时候不会创建 线程</p><p>当<strong>调用Thread创建出来的实例对象的start方法时候才会创建线程，以及让线程开始运行。</strong></p><h4 id="3-查看线程数量"><a href="#3-查看线程数量" class="headerlink" title="3. 查看线程数量"></a>3. 查看线程数量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep,ctime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sing</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">&quot;正在唱歌...%d&quot;</span>%i)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dance</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">&quot;正在跳舞...%d&quot;</span>%i)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&#x27;---开始---:%s&#x27;</span>%ctime())</span><br><span class="line"></span><br><span class="line">    t1 = threading.Thread(target=sing)</span><br><span class="line">    t2 = threading.Thread(target=dance)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">####################################</span></span><br><span class="line">        length = <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>())</span><br><span class="line">        print(<span class="string">&#x27;当前运行的线程数为：%d&#x27;</span>%length)</span><br><span class="line">        <span class="comment">####################################</span></span><br><span class="line">        <span class="keyword">if</span> length&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><blockquote><h4 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h4></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912192024.PNG" alt=""></p><blockquote><h3 id="注意：线程的执行的顺序不确定。——可以通过延迟来决定谁先执行。time-sleep-1"><a href="#注意：线程的执行的顺序不确定。——可以通过延迟来决定谁先执行。time-sleep-1" class="headerlink" title="注意：线程的执行的顺序不确定。——可以通过延迟来决定谁先执行。time.sleep(1)"></a>注意：线程的执行的顺序不确定。——可以通过延迟来决定谁先执行。time.sleep(1)</h3></blockquote><p><strong>线程使用两种方法：</strong></p><ul><li>Thread(target = 函数名)</li><li>封装成类，必须写run方法，run方法写啥，start()执行什么。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            msg = <span class="string">&quot;I&#x27;m &quot;</span>+self.name+<span class="string">&#x27; @ &#x27;</span>+<span class="built_in">str</span>(i) <span class="comment">#name属性中保存的是当前线程的名字</span></span><br><span class="line">            print(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h3 id="多线程-共享全局变量"><a href="#多线程-共享全局变量" class="headerlink" title="多线程-共享全局变量"></a>多线程-共享全局变量</h3><p><strong>函数里面修改全局变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">100</span></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line"></span><br><span class="line">    num += <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    nums.append(<span class="number">33</span>)  <span class="comment"># 可行</span></span><br><span class="line">nums += [<span class="number">33</span>, <span class="number">44</span>] <span class="comment"># 不行</span></span><br><span class="line">    <span class="comment">######################</span></span><br><span class="line">    <span class="comment"># 在一个函数中，对全局变量进行修改时，到底是否需要使用global进行说明，要看是否对全局变量的指向进行修改。，若修改了指向，那么必须使用global。若只是改了数据不需要。</span></span><br><span class="line">    <span class="comment"># 不可变：数字 字符串 元祖</span></span><br><span class="line">    <span class="comment">######################</span></span><br><span class="line"></span><br><span class="line">print(num)</span><br><span class="line">print(nums)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">test2()</span><br><span class="line"></span><br><span class="line">print(num)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure><p><strong>列表当做实参传递到线程中</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">temp</span>):</span></span><br><span class="line">    temp.append(<span class="number">33</span>)</span><br><span class="line">    print(<span class="string">&quot;-----in test1 temp=%s----&quot;</span> % <span class="built_in">str</span>(temp))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>(<span class="params">temp</span>):</span></span><br><span class="line">    print(<span class="string">&quot;-----in test2 temp=%s----&quot;</span> % <span class="built_in">str</span>(temp))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_nums = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment">########################################</span></span><br><span class="line">    <span class="comment"># target指定将来 这个线程去哪个函数执行代码</span></span><br><span class="line">    <span class="comment"># args指定将来调用 函数的时候 传递什么数据过去</span></span><br><span class="line">    <span class="comment">########################################</span></span><br><span class="line">    t1 = threading.Thread(target=test1, args=(g_nums,))</span><br><span class="line">    t2 = threading.Thread(target=test2, args=(g_nums,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    t2.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;-----in main Thread g_nums = %s---&quot;</span> % <span class="built_in">str</span>(g_nums))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>线程之间共享全局变量的优点：</strong></p><p>一个抓取数据，一个处理数据，一个返回数据。</p><h3 id="共享全局变量的问题：——资源竞争。"><a href="#共享全局变量的问题：——资源竞争。" class="headerlink" title="共享全局变量的问题：——资源竞争。"></a>共享全局变量的问题：——资源竞争。</h3><p>假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加10次，g_num的最终的结果应该为20。</p><p><strong>存在资源竞争：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个全局变量</span></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">&quot;-----in test1 g_num=%d----&quot;</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">&quot;-----in test2 g_num=%d=----&quot;</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    t1 = threading.Thread(target=test1, args=(<span class="number">1000000</span>,))</span><br><span class="line">    t2 = threading.Thread(target=test2, args=(<span class="number">1000000</span>,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待上面的2个线程执行完毕....</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;-----in main Thread g_num = %d---&quot;</span> % g_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>输出结果不是200000.小于200000</p><p>问题在于 g_num += 1是分3步执行。</p><ul><li>读取g_num</li><li>g_num的值加1</li><li>将值赋值给g_num。</li></ul><p>有可能两个线程都进行了第二步，那么分别赋值都是1了，不是2了。</p><h4 id="解决：同步（协同完成）—互斥锁"><a href="#解决：同步（协同完成）—互斥锁" class="headerlink" title="解决：同步（协同完成）—互斥锁"></a>解决：同步（协同完成）—互斥锁</h4><ul><li><p>上厕所的例子</p></li><li><p>hreading模块中定义了Lock类，可以方便的处理锁定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定</span></span><br><span class="line">mutex.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure></li></ul><p><strong>若只创建一个锁，你用了，别人阻塞。</strong>避免了资源竞争。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个全局变量</span></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        mutex.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        mutex.release()  <span class="comment"># 解锁</span></span><br><span class="line">    print(<span class="string">&quot;-----in test1 g_num=%d----&quot;</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        mutex.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        mutex.release()  <span class="comment"># 解锁</span></span><br><span class="line">    print(<span class="string">&quot;-----in test2 g_num=%d=----&quot;</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个互斥锁，默认是没有上锁的</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    t1 = threading.Thread(target=test1, args=(<span class="number">1000000</span>,))</span><br><span class="line">    t2 = threading.Thread(target=test2, args=(<span class="number">1000000</span>,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待上面的2个线程执行完毕....</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;-----in main Thread g_num = %d---&quot;</span> % g_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个资源相互竞争，上了两把锁相互竞争。由互斥锁导致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 对mutexA上锁</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># mutexA上锁后，延时1秒，等待另外那个线程 把mutexB上锁</span></span><br><span class="line">        print(self.name+<span class="string">&#x27;----do1---up----&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时会堵塞，因为这个mutexB已经被另外的线程抢先上锁了</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(self.name+<span class="string">&#x27;----do1---down----&#x27;</span>)</span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对mutexA解锁</span></span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 对mutexB上锁</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># mutexB上锁后，延时1秒，等待另外那个线程 把mutexA上锁</span></span><br><span class="line">        print(self.name+<span class="string">&#x27;----do2---up----&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时会堵塞，因为这个mutexA已经被另外的线程抢先上锁了</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(self.name+<span class="string">&#x27;----do2---down----&#x27;</span>)</span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对mutexB解锁</span></span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = MyThread1()</span><br><span class="line">    t2 = MyThread2()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure><h4 id="避免死锁："><a href="#避免死锁：" class="headerlink" title="避免死锁："></a>避免死锁：</h4><ul><li>程序设计时要尽量避免（银行家算法）</li><li>添加超时时间等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912192452.PNG" alt=""></p><h3 id="多线程UDP聊天器"><a href="#多线程UDP聊天器" class="headerlink" title="多线程UDP聊天器"></a>多线程UDP聊天器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_msg</span>(<span class="params">udp_socket</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收数据并显示&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收数据</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recv_data = udp_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        print(recv_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span>(<span class="params">udp_socket, dest_ip, dest_port</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;发送数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        send_data = <span class="built_in">input</span>(<span class="string">&quot;输入要发送的数据:&quot;</span>)</span><br><span class="line">        udp_socket.sendto(send_data.encode(<span class="string">&quot;utf-8&quot;</span>), (dest_ip, dest_port))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;完成udp聊天器的整体控制&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定本地信息</span></span><br><span class="line">    udp_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7890</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 获取对方的ip</span></span><br><span class="line">    dest_ip = <span class="built_in">input</span>(<span class="string">&quot;请输入对方的ip:&quot;</span>)</span><br><span class="line">    dest_port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入对方的port:&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 创建2个线程，去执行相应的功能</span></span><br><span class="line">    t_recv = threading.Thread(target=recv_msg, args=(udp_socket,))</span><br><span class="line">    t_send = threading.Thread(target=send_msg, args=(udp_socket, dest_ip, dest_port))</span><br><span class="line"></span><br><span class="line">    t_recv.start()</span><br><span class="line">    t_send.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多任务—线程（轻量级）&quot;&gt;&lt;a href=&quot;#多任务—线程（轻量级）&quot; class=&quot;headerlink&quot; title=&quot;多任务—线程（轻量级）&quot;&gt;&lt;/a&gt;多任务—线程（轻量级）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;并发：&lt;/strong&gt;指的是任务数多余</summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="https://xxren8218.github.io/20210912/%E7%BD%91%E7%BB%9C.html"/>
    <id>https://xxren8218.github.io/20210912/%E7%BD%91%E7%BB%9C.html</id>
    <published>2021-09-12T11:22:48.000Z</published>
    <updated>2021-09-12T11:23:13.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="1-ip"><a href="#1-ip" class="headerlink" title="1 ip"></a>1 ip</h3><p>ip地址：用来在网络中标记一台电脑，比如192.168.1.1；在本地局域网上是唯一的。</p><p>ifconfig ens40 down</p><h3 id="2-Ipv4-amp-Ipv6"><a href="#2-Ipv4-amp-Ipv6" class="headerlink" title="2 Ipv4 &amp; Ipv6"></a>2 Ipv4 &amp; Ipv6</h3><p>ipv4共有<strong>256^4</strong>个地址。127.168.19.211</p><p>ipv4根据主机数不同进行划分。A B C D E ，D进行多播，E进行保留</p><p>A能存在254个主机。0 和 255不能。</p><h3 id="3-端口："><a href="#3-端口：" class="headerlink" title="3 端口："></a>3 端口：</h3><p>地址知道了，发送的数据给哪个程序呢？通过端口来实现。</p><p>在linux系统中，端口可以有65536（<strong>2的16次方</strong>）个之多！</p><p>既然有这么多，操作系统为了统一管理，所以进行了编号，这就是<code>端口号</code></p><p><strong>进程是运行起来的程序。</strong></p><h4 id="3-1-知名端口（Well-Known-Ports）"><a href="#3-1-知名端口（Well-Known-Ports）" class="headerlink" title="3.1 知名端口（Well Known Ports）"></a>3.1 知名端口（Well Known Ports）</h4><p>知名端口是众所周知的端口号，<strong>范围从0到1023</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">80端口分配给HTTP服务</span><br><span class="line">21端口分配给FTP服务</span><br></pre></td></tr></table></figure><p>一般情况下，如果一个程序需要使用知名端口的需要有root权限。</p><h4 id="3-2-动态端口（Dynamic-Ports）"><a href="#3-2-动态端口（Dynamic-Ports）" class="headerlink" title="3.2 动态端口（Dynamic Ports）"></a>3.2 动态端口（Dynamic Ports）</h4><p>动态端口的范围是从1024到65535</p><p>之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配。</p><p>动态分配是指当一个系统程序或应用程序程序需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。</p><p>当这个程序关闭时，同时也就释放了所占用的端口号</p><h3 id="4-socket"><a href="#4-socket" class="headerlink" title="4 socket"></a>4 socket</h3><h4 id="4-1-UDP——写信（面向无连接的通信）"><a href="#4-1-UDP——写信（面向无连接的通信）" class="headerlink" title="4.1 UDP——写信（面向无连接的通信）"></a>4.1 UDP——写信（面向无连接的通信）</h4><ul><li><strong>User Datagram Protocol</strong> 用户传输报协议</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 创建一个udp套接字             ipv4              udp</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取对方的ip/port</span></span><br><span class="line">    dest_ip = <span class="built_in">input</span>(<span class="string">&quot;请输入对方的ip:&quot;</span>)</span><br><span class="line">    dest_port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入对方的port:&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从键盘获取数据</span></span><br><span class="line">    send_data = <span class="built_in">input</span>(<span class="string">&quot;请输入要发送的数据：&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以使用套接字收发数据</span></span><br><span class="line">    <span class="comment"># udp_socket.sendto(&quot;hahahah&quot;, 对方的ip以及port)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># udp_socket.sendto(b&quot;hahahah------1----&quot;, (&quot;192.168.33.53&quot;, 8080))</span></span><br><span class="line">    <span class="comment"># udp_socket.sendto(send_data.encode(&quot;utf-8&quot;), (&quot;192.168.33.53&quot;, 8080))</span></span><br><span class="line">    udp_socket.sendto(send_data.encode(<span class="string">&quot;utf-8&quot;</span>), (dest_ip, dest_port))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收回送过来的数据</span></span><br><span class="line">    recv_data = udp_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 套接字是一个可以同时 收发数据</span></span><br><span class="line">    print(recv_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    udp_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>操作系统会随机分配端口。——（若没有绑定端口）</p><p>桥接网络能ping通。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dhclient</span><br></pre></td></tr></table></figure><p>发数据可以，但是接收数据需要绑定端口，这样别人才能给你一直发数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建套接字</span></span><br><span class="line">udp_socket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 绑定本地的相关信息，如果一个网络程序不绑定，则系统会随机分配</span></span><br><span class="line">local_addr = (<span class="string">&#x27;&#x27;</span>, <span class="number">7788</span>) <span class="comment">#  ip地址和端口号，ip一般不用写，表示本机的任何一个ip</span></span><br><span class="line">udp_socket.bind(local_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 等待接收对方发送的数据</span></span><br><span class="line">recv_data = udp_socket.recvfrom(<span class="number">1024</span>) <span class="comment">#  1024表示本次接收的最大字节数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 显示接收到的数据</span></span><br><span class="line">print(recv_data[<span class="number">0</span>].decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 关闭套接字</span></span><br><span class="line">udp_socket.close()</span><br></pre></td></tr></table></figure><p><strong>套接字可以同时收发数据。</strong></p><ul><li>单工：收音机（只能收或发）</li><li>半双工：对讲机（发的时候收不了）</li><li>全双工：打电话（同一时刻，收发都可）</li></ul><p><strong>socket套接字是全双工。</strong></p><p>recvfrom在没有数据到来的时候会阻塞。</p><blockquote><h4 id="udp聊天器"><a href="#udp聊天器" class="headerlink" title="udp聊天器"></a>udp聊天器</h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span>(<span class="params">udp_socket</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;发送消息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取要发送的内容</span></span><br><span class="line">    dest_ip = <span class="built_in">input</span>(<span class="string">&quot;请输入对方的ip:&quot;</span>)</span><br><span class="line">    dest_port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入对方的port:&quot;</span>))</span><br><span class="line">    send_data = <span class="built_in">input</span>(<span class="string">&quot;请输入要发送的消息：&quot;</span>)</span><br><span class="line">    udp_socket.sendto(send_data.encode(<span class="string">&quot;utf-8&quot;</span>), (dest_ip, dest_port))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_msg</span>(<span class="params">udp_socket</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收数据&quot;&quot;&quot;</span></span><br><span class="line">    recv_data = udp_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">&quot;%s:%s&quot;</span> % (<span class="built_in">str</span>(recv_data[<span class="number">1</span>]), recv_data[<span class="number">0</span>].decode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line">    <span class="comment"># print(&quot;%s:%s&quot; % (str(recv_data[1]), recv_data[0].decode(&quot;gbk&quot;)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绑定信息</span></span><br><span class="line">    udp_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7788</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环循环来进行处理事情</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 发送</span></span><br><span class="line">        send_msg(udp_socket)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收并显示</span></span><br><span class="line">        recv_msg(udp_socket)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>udp接收东西的时候会先将数据存在操作系统中，调用了recvfrom以后才会加载。——要防止内存泄漏。</p><p>udp：写信模型，不稳定。比较简单。每封信都要写收发人姓名。不安全。——数据可能丢。</p><p>tcp：打电话模型。稳定，但是比较复杂、通讯之前必须先建立链接。</p><ul><li>TCP通信需要经过<strong>创建连接、数据传送、终止连接</strong>三个步骤。</li></ul><h4 id="TCP——打电话（面向连接的通信）"><a href="#TCP——打电话（面向连接的通信）" class="headerlink" title="TCP——打电话（面向连接的通信）"></a>TCP——打电话（面向连接的通信）</h4><ul><li><strong>Transmission Control Protocol</strong>传输控制协议</li></ul><blockquote><h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4></blockquote><p>1）<strong>TCP采用发送应答机制</strong></p><p>TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功</p><p>2）<strong>超时重传</strong></p><p>发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。</p><p>TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。</p><p>3）<strong>错误校验</strong></p><p>TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</p><p>4) <strong>流量控制和阻塞管理</strong></p><p>流量控制用来避免主机发送得过快而使接收方来不及完全收下。</p><ul><li><strong>tcp严格区分客户端和服务端。</strong></li></ul><p>客户端一般不绑定端口，先创建链接，然后发送和接收数据。</p><p>服务器必须得绑定端口。</p><p>客户端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 1. 创建tcp的套接字</span></span><br><span class="line">    tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 链接服务器</span></span><br><span class="line">    <span class="comment"># tcp_socket.connect((&quot;192.168.33.11&quot;, 7890))</span></span><br><span class="line">    server_ip = <span class="built_in">input</span>(<span class="string">&quot;请输入要链接的服务器的ip:&quot;</span>)</span><br><span class="line">    server_port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入要链接的服务器的port:&quot;</span>))</span><br><span class="line">    server_addr = (server_ip, server_port)</span><br><span class="line">    tcp_socket.connect(server_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 发送数据/接收数据</span></span><br><span class="line">    send_data = <span class="built_in">input</span>(<span class="string">&quot;请输入要发送的数据:&quot;</span>)</span><br><span class="line">    tcp_socket.send(send_data.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 关闭套接字</span></span><br><span class="line">    tcp_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 1. 买个手机(创建套接字 socket)</span></span><br><span class="line">    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 插入手机卡(绑定本地信息 bind)</span></span><br><span class="line">    tcp_server_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7890</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 将手机设置为正常的 响铃模式(让默认的套接字由主动变为被动 listen)</span></span><br><span class="line">    tcp_server_socket.listen(<span class="number">128</span>)   <span class="comment"># 决定同一时刻客户端的多与少。</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;-----1----&quot;</span>)</span><br><span class="line">    <span class="comment"># 4. 等待别人的电话到来(等待客户端的链接 accept)</span></span><br><span class="line">    <span class="comment">####################################</span></span><br><span class="line">    <span class="comment"># 默认阻塞，只要有一个客户端连接你，解阻塞 #</span></span><br><span class="line">    <span class="comment">####################################</span></span><br><span class="line">    new_client_socket, client_addr = tcp_server_socket.accept()</span><br><span class="line">    <span class="comment">#       客服        客户端地址</span></span><br><span class="line">    print(<span class="string">&quot;-----2----&quot;</span>)</span><br><span class="line"></span><br><span class="line">    print(client_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收客户端发送过来的请求</span></span><br><span class="line">    <span class="comment">#########################</span></span><br><span class="line">    <span class="comment"># 默认阻塞，接收数据，解阻塞 #</span></span><br><span class="line">    <span class="comment">#########################</span></span><br><span class="line">    recv_data = new_client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    print(recv_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回送一部分数据给客户端</span></span><br><span class="line">    new_client_socket.send(<span class="string">&quot;hahahghai-----ok-----&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    new_client_socket.close()</span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>多客户端多服务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 1. 买个手机(创建套接字 socket)</span></span><br><span class="line">    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 插入手机卡(绑定本地信息 bind)</span></span><br><span class="line">    tcp_server_socket.bind((<span class="string">&quot;&quot;</span>, <span class="number">7890</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 将手机设置为正常的 响铃模式(让默认的套接字由主动变为被动 listen)</span></span><br><span class="line">    tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环目的：调用多次accept,从而为多个客户端服务</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&quot;等待一个新的客户端的到来...&quot;</span>)</span><br><span class="line">        <span class="comment"># 4. 等待别人的电话到来(等待客户端的链接 accept)</span></span><br><span class="line">        new_client_socket, client_addr = tcp_server_socket.accept()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;一个新的客户端已经到来%s&quot;</span> % <span class="built_in">str</span>(client_addr))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环目的: 为同一个客户端 服务多次</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 接收客户端发送过来的请求</span></span><br><span class="line">            recv_data = new_client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            print(<span class="string">&quot;客户端福送过来的请求是:%s&quot;</span> % recv_data.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果recv解堵塞，那么有2种方式：</span></span><br><span class="line">            <span class="comment">###################################################</span></span><br><span class="line">            <span class="comment"># 1. 客户端发送过来数据</span></span><br><span class="line">            <span class="comment">###################################################</span></span><br><span class="line">            <span class="comment"># 2. 客户端调用close导致而了 这里 recv解堵塞，这里recv为空</span></span><br><span class="line">            <span class="comment">###################################################</span></span><br><span class="line">            <span class="keyword">if</span> recv_data:</span><br><span class="line">                <span class="comment"># 回送一部分数据给客户端</span></span><br><span class="line">                new_client_socket.send(<span class="string">&quot;hahahghai-----ok-----&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭套接字</span></span><br><span class="line">        <span class="comment"># 关闭accept返回的套接字 意味着 不会在为这个客户端服务</span></span><br><span class="line">        new_client_socket.close()</span><br><span class="line">        print(<span class="string">&quot;已经为这个客户端服务完毕。。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果将监听套接字 关闭了，那么会导致 不能再次等待新客户端的到来，即xxxx.accept就会失败</span></span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>注意：break破坏的是最里面的while True循环。</strong></p><h4 id="tcp注意点"><a href="#tcp注意点" class="headerlink" title="tcp注意点"></a>tcp注意点</h4><ol><li>tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器</li><li>tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机</li><li>tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的</li><li>当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信</li><li>当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务</li><li>listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的</li><li>关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。</li><li>关闭accept返回的套接字意味着这个客户端已经服务完毕</li><li>当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线</li></ol><p>with open的使用注意事项：</p><ul><li><p>能打开前提下才能with open：</p></li><li><p>如果使用操作是<code>wb</code>，则用with打开没问题</p></li><li><p>要是<code>rb</code>的方式，不一定能打开。需要</p><ul><li><pre><code class="lang-python"> try:     f = open(file_name, &quot;rb&quot;)     file_content = f.read()     f.close() except Exception as ret:     print(&quot;没有要下载的文件(%s)&quot; % file_name)</code></pre></li></ul></li></ul><h3 id="QQ是不绑定端口的：服务器来实现转发功能。"><a href="#QQ是不绑定端口的：服务器来实现转发功能。" class="headerlink" title="QQ是不绑定端口的：服务器来实现转发功能。"></a>QQ是不绑定端口的：服务器来实现转发功能。</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h2&gt;&lt;h3 id=&quot;1-ip&quot;&gt;&lt;a href=&quot;#1-ip&quot; class=&quot;headerlink&quot; title=&quot;1 ip&quot;&gt;&lt;/a&gt;1 ip&lt;/h</summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>事务的隔离级别</title>
    <link href="https://xxren8218.github.io/20210912/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html"/>
    <id>https://xxren8218.github.io/20210912/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html</id>
    <published>2021-09-12T11:21:58.000Z</published>
    <updated>2021-09-12T11:22:30.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h3><p>事务只是一个改变，是<strong>一些操作的集合</strong>，用专业的术语讲，他就是一个程序的执行单元，<strong>事务本身其实并不包含四个特性</strong>，我们需要通过某些手段，尽可能的让这个执行单元满足这四个特性，那么，我们就可以称它为一个事务，或者说是一个正确的事务。</p><h3 id="2-四个特性"><a href="#2-四个特性" class="headerlink" title="2.四个特性"></a>2.四个特性</h3><ul><li>原子性：满足原子操作单元，要么全部执行，要么全部失败。</li><li>一致性：事务开始和完成，数据必须保证一致。</li><li>隔离性：事务之间是相互独立的，中间状态对外不可见。</li><li>持久性：数据的修改是永久的。</li></ul><h3 id="3-隔离级别"><a href="#3-隔离级别" class="headerlink" title="3.隔离级别"></a>3.隔离级别</h3><h4 id="3-1并发情况下事务引发的问题"><a href="#3-1并发情况下事务引发的问题" class="headerlink" title="3.1并发情况下事务引发的问题"></a>3.1并发情况下事务引发的问题</h4><blockquote><p>一般情况下，多个单元操作并发执行，会出现这么几个问题</p></blockquote><ul><li>脏读：A事务还未提交，B事务就读到了A事务的结果。（破坏了隔离性）</li><li>不可重复读：A事务在本次事务中，对自己未操作过的数据，进行了多次读取，结果出现了不一致或者记录不存在的情况。（破坏了一致性，update 和 delate）</li><li>幻读：A事务在本次事务中，对自己未操作过的数据，进行了多次读取，第一次读取时，记录不存在，第二次读取时，记录出现了。（破坏了一致性。insert）</li></ul><h4 id="3-2-解决（制定标准）"><a href="#3-2-解决（制定标准）" class="headerlink" title="3.2 解决（制定标准）"></a>3.2 解决（制定标准）</h4><p>为了权衡【隔离】和【并发】的矛盾。ISO定义了四个事务的隔离级别。每个级别的隔离程度不同，允许出现的副作用也不同。</p><ul><li>未提交读（read-uncommited）:最低级别，只能保证持久性。</li><li>已提交读（read-commited）：语句级别的</li><li><p>可重复读（repeatable-read）：事务级别的——MySQL默认的隔离级别。</p></li><li><p>串行化（seriallizable）：最高级别的、事务与事务完全串行执行，毫无并发可言，性能极低。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210912192212.PNG" alt=""></p><blockquote><p><strong>注意：这四个级别只是一个标准，各个数据库厂商，并不是完全按照这个标准来做的。</strong></p></blockquote><h4 id="3-3-实现（innoDB）"><a href="#3-3-实现（innoDB）" class="headerlink" title="3.3 实现（innoDB）"></a>3.3 实现（innoDB）</h4><ul><li><p>锁机制：阻止其他事务对数据进行操作，各个隔离级别主要体现在读取数据时加的锁和释放时机</p><ul><li>RU：事务读取的时候，不加锁</li><li>RC：事务读取的时候加行级共享锁（读到才加锁），一旦读完，立刻释放（并不是事务结束）。</li><li>RR：事务读取时加行级共享锁，直到事务结束时才会释放。</li><li>SE：事务读取时加表级共享锁。直到事务结束时，才会释放。</li></ul><blockquote><p>其他还有些不同，主要就是这些，</p></blockquote></li><li><p>MVCC机制：生成一个数据快照，并用这个快照来提供一定级别的一致性读取，也成为了多版本数据控制。</p><ul><li>实际就是【CAS版本控制】和【读写分离】的思想</li><li>重要作用RC和RR级别</li></ul></li></ul><h3 id="并发的锁机制"><a href="#并发的锁机制" class="headerlink" title="并发的锁机制"></a>并发的锁机制</h3><ul><li>悲观锁<ul><li>进程间加锁，只有拿到锁，事务解决完，释放锁以后，才能继续向下执行。查询的时候加一个  <code>for update.</code></li></ul></li><li>乐观锁<ul><li>在查询数据的时候不加锁。在修改时进行判断。判断更新时的库存和之前查出来的库存是否一致。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库的隔离级别&quot;&gt;&lt;a href=&quot;#数据库的隔离级别&quot; class=&quot;headerlink&quot; title=&quot;数据库的隔离级别&quot;&gt;&lt;/a&gt;数据库的隔离级别&lt;/h2&gt;&lt;h3 id=&quot;1-事务&quot;&gt;&lt;a href=&quot;#1-事务&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>索引原理</title>
    <link href="https://xxren8218.github.io/20210912/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.html"/>
    <id>https://xxren8218.github.io/20210912/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.html</id>
    <published>2021-09-12T11:21:05.000Z</published>
    <updated>2021-09-12T11:21:25.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><p>磁盘读写：IO</p><ul><li>顺序读写（快，需要了解局部性原理）</li><li>随机读写（慢，目前是随机读写）<ul><li>磁盘预读——按页进行（4K的数据）</li></ul></li></ul><p>索引是什么？</p><ul><li>帮助MySQL高效获取数据的数据结构</li><li>索引存储在文件系统中</li><li>索引的文件存储形式与存储引擎有关<ul><li>innoDB</li><li>MyISAM</li></ul></li><li><p>索引文件的结构</p><ul><li><p>hash</p><ul><li>利用哈希存储的话需要将所有的数据文件追加到内存，比较耗费内存空间</li><li>如果所有的查询都是等值查询，那么hash表很快，但在企业中或实际中范围查询的数据多（想象中离的很近的值，在hash表中离的很远），而不是等值查询，因此hash就不太合适了。（范围查询不适合）</li></ul></li><li><p>二叉树</p><ul><li><p>二分查找——无论是二叉树还是红黑树，都会因为树的深度过深而造成IO次数过多，影响数据的读取。</p></li><li><p>红黑树为什么不能用于MySQL的索引呢？</p><p>答：对于服务器而言，需要从以下几个方向调优：</p><p>​        ①内存: 千万级别的数据需要加载到硬盘，不能在内存。  </p><p>​        ②CPU </p><p>​        ③磁盘IO：磁盘读写机制：一次 拿一页（4K）红黑树一个点只有一个数据，深度高的话，磁盘的IO比较大。——引入B树和B+树，存放多个数据。</p><ul><li>减少IO次数（多）</li><li>减少IO数据量（4K固定）</li></ul></li></ul></li><li><p>B树（就是B-树，没人叫B-树）</p><ul><li><p>多路查找树，让每个结点存多个数据，减少磁盘IO。</p></li><li><p>关键字（存数据），m颗子树是指针。（数组实现）</p></li><li><p>除根节点和叶结点，其他结点至少有(m/2)个子树，向上取整。</p></li><li><p>B树有一个非常重要的操作，分裂。（红黑树是左旋和右旋）</p></li><li><p>为什么B树不能做MySQL的索引？</p><ul><li>每个结点（磁盘块为4K）若一个Data为1.9K，则只能存两个数据，这样会造成树深度变深。</li></ul></li><li><p>MySQL的索引为什么不用B树，而是B+树呢？</p><p>B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。<br><strong>B+ 树的优点在于：</strong></p><ul><li><strong>IO次数更少</strong>：由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。</li><li><strong>遍历更加方便</strong>：B+树的叶子结点都是相链的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li></ul></li></ul></li><li><p>B+树（MySQL所使用的的）</p><ul><li>多路查找树。</li><li>每个磁盘块只存索引，不存放数据，使得每个磁盘块存放的指针很多，百万量级的由来，</li><li>所有的叶子结点链表连接，是链式环。</li></ul></li></ul></li></ul><h3 id="InnoDB引擎：（一个文件）"><a href="#InnoDB引擎：（一个文件）" class="headerlink" title="InnoDB引擎：（一个文件）"></a>InnoDB引擎：（一个文件）</h3><p>给主键（唯一键）创建索引遍历一次B+树即可，根据主键（唯一建）能找到数据。</p><p>若给非主键（id,name.age），给name建立索引，那么我们如何根据name来找到数据呢？</p><ul><li>给name建立索引，会先进行一个遍历B+树，不过叶子结点存的主键（id），然后再根据id进行一次遍历。相当于走了两次B+树，比主键的B+树慢。但是有限。一次读4K、很少。</li></ul><p>聚簇索引</p><h3 id="MyISAM引擎：（两个文件）"><a href="#MyISAM引擎：（两个文件）" class="headerlink" title="MyISAM引擎：（两个文件）"></a>MyISAM引擎：（两个文件）</h3><p>采用B+树时，叶子结点不存放具体的数据了、而是存放数据的地址，根据地址去读表里的相应记录数据。</p><p>索引的分类：</p><ul><li>主键索引：每个表只有一个主键,必须指定PRIMARY KEY</li><li>唯一索引：唯一且值可以为空。</li><li>普通索引：基本类型，值可以为空，没有唯一性限制。</li><li>全文索引：对于一篇文章建立索引，FULLTEXT  ES（很少用）</li><li>组合索引：多列值组成一个索引，专门用于组合搜索</li></ul><p>非聚簇索引</p><h4 id="索引的技术名词"><a href="#索引的技术名词" class="headerlink" title="索引的技术名词"></a>索引的技术名词</h4><ul><li><p>回表：</p><ul><li>InnoDB、MyISAM索引使用的都是B+树。Memory使用的是哈希。</li><li>主键索引是直接查找，而普通列的索引叶子结点存的是主键的值，再根据主键的值进行一次查找，——回表。</li></ul></li><li><p>覆盖索引：</p><ul><li>```sql<br>select * from table1 where name=”张三”;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;sq</span><br><span class="line">  select id from table1 where name&#x3D;&quot;张三&quot;;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;索引原理&quot;&gt;&lt;a href=&quot;#索引原理&quot; class=&quot;headerlink&quot; title=&quot;索引原理&quot;&gt;&lt;/a&gt;索引原理&lt;/h2&gt;&lt;p&gt;磁盘读写：IO&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序读写（快，需要了解局部性原理）&lt;/li&gt;
&lt;li&gt;随机读写（慢，目前是随机读写</summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python的垃圾回收机制</title>
    <link href="https://xxren8218.github.io/20210912/python%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html"/>
    <id>https://xxren8218.github.io/20210912/python%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html</id>
    <published>2021-09-12T11:18:44.000Z</published>
    <updated>2021-09-12T11:25:25.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python的垃圾回收机制"><a href="#Python的垃圾回收机制" class="headerlink" title="Python的垃圾回收机制"></a>Python的垃圾回收机制</h2><ul><li>引用计数器为主，标记清除和分代回收为辅 + 缓存机制</li></ul><ul><li>引用计数器</li><li>标记清除</li><li>分代回收</li><li>缓存机制</li><li>Python的源码</li></ul><h3 id="1-引用计数器"><a href="#1-引用计数器" class="headerlink" title="1.引用计数器"></a>1.引用计数器</h3><h4 id="1-1-环状的双向链表-refchain"><a href="#1-1-环状的双向链表-refchain" class="headerlink" title="1.1 环状的双向链表 refchain"></a>1.1 环状的双向链表 refchain</h4><p>在python程序中创建的任何对象都会在refchain链表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;任晓雄&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">hobby = [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;美女&quot;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内部会创建结构体【上一个指针(对象)，下一个指针(对象)、类型、引用个数】</span><br><span class="line">name = <span class="string">&quot;任晓雄&quot;</span> </span><br><span class="line">new = name</span><br><span class="line"></span><br><span class="line">内部会创建结构体【上一个指针(对象)，下一个指针(对象)、类型、引用个数、value=<span class="number">18</span>】</span><br><span class="line">age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">内部会创建结构体【上一个指针(对象)，下一个指针(对象)、类型、引用个数、items=元素、元素的个数】</span><br><span class="line">hobby = [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;美女&quot;</span>]</span><br></pre></td></tr></table></figure><p>在C源码中如何体现每个对象都有的相同的值 PyObject 结构体（4个值）</p><p>由多个元素组成的对象，PyObject结构体（4个数）+  ob_size 。</p><h4 id="1-2-类型封装结构体"><a href="#1-2-类型封装结构体" class="headerlink" title="1.2 类型封装结构体"></a>1.2 类型封装结构体</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line">内部创建：</span><br><span class="line">_ob_next = refchain中的上一对象</span><br><span class="line">    _ob_prev = refchain中的下一对象</span><br><span class="line">    ob_refcnt = <span class="number">1</span></span><br><span class="line">    ob_type = <span class="built_in">float</span></span><br><span class="line">    ob_fval = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><h4 id="1-3-引用计数器"><a href="#1-3-引用计数器" class="headerlink" title="1.3 引用计数器"></a>1.3 引用计数器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1 = <span class="number">3.14</span></span><br><span class="line">v2 = <span class="number">999</span></span><br><span class="line">v3 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>当python程序运行时，会根据数据类型的不同找到其对应的结构体，根据结构体中的字段来进行创建相关的数据，然后将对象添加到refchain双向链表中。</p><p>在源码中有两个关键的结构体：PyObject结构体（单个元素时）、PyVarObject结构体（多个元素组成时）。</p><p>每一个对象中都有 ob_refcnt就是引用计数器、默认为1，当有其他变量引用这个对象时，引用计数器就会发生变化。</p><ul><li><p>引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">9999</span></span><br><span class="line">b = a</span><br></pre></td></tr></table></figure></li><li><p>去除引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">9999</span></span><br><span class="line">b = a</span><br><span class="line"><span class="keyword">del</span> b <span class="comment"># b 变量删除，b对应对象引用计数器 -1</span></span><br><span class="line"><span class="keyword">del</span> a <span class="comment"># a 变量删除，a对应对象引用计数器 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当引用计数器为0时，意味着没有人再使用这个对象了。就需要进行垃圾回收</span></span><br><span class="line"><span class="comment"># 回收两件事：</span></span><br><span class="line">  <span class="comment"># 1.对象从refchain链表中移除</span></span><br><span class="line">  <span class="comment"># 2.将对象销毁、内存归还。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-引用计数器的BUG—循环引用"><a href="#1-4-引用计数器的BUG—循环引用" class="headerlink" title="1.4 引用计数器的BUG—循环引用"></a>1.4 引用计数器的BUG—循环引用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v1 = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]  <span class="comment"># refchain中创建一个列表对象，由于v1=对象，所以列表引用对象计数器为1</span></span><br><span class="line">v2 = [<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>]  <span class="comment"># refchain再创建一个列表对象，由于v2=对象，所以列表引用对象计数器为1</span></span><br><span class="line">v1.append(v2)    <span class="comment"># 把v2追加到v1中，则v2对应的[44,55,66]对象的引用计数器加1，最终为2</span></span><br><span class="line">v2.append(v1)    <span class="comment"># 把v1追加到v2中，则v1对应的[11,22,33]对象的引用计数器加1，最终为2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> v1           <span class="comment"># 引用计数器-1</span></span><br><span class="line"><span class="keyword">del</span> v2           <span class="comment"># 引用计数器-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按理来说删掉就不存在了，但是引用数还都是1，则，没有删除，还在内存中，会造成内存泄漏。</span></span><br></pre></td></tr></table></figure><h3 id="2-标记清除"><a href="#2-标记清除" class="headerlink" title="2.标记清除"></a>2.标记清除</h3><p>目的：是为了解决引用计数器循环引用的不足。</p><p>实现：在python的底层  再 去维护一个链表，链表中专门放那些可能存在循环引用的对象（列表、字典、元祖、集合）。</p><p>则会存在两个链表：</p><ul><li><p>refchain：存储所有对象</p></li><li><p>另一个链表：存储可能存在循环引用的链表</p></li></ul><p>在python内部，某种情况下触发，会去扫描可能存在循环引用的链表的每个元素，检查是否有循环引用，如果有，则让双方的引用计数器各自减一：如果是0，垃圾回收，如果不是0，不动他。</p><p>问题：</p><ul><li>多久扫描、什么时候扫描？</li><li>可能存在循环引用的链表扫描的代价比较大、每次扫描耗时久。</li></ul><h3 id="3-分代回收——分三级"><a href="#3-分代回收——分三级" class="headerlink" title="3.分代回收——分三级"></a>3.分代回收——分三级</h3><p>将可能存在循环引用的对象维护成3个链表：</p><ul><li>0代：0代中对象个数达到700个扫描一次。</li><li>1代：0代如果扫描10次，则1代扫描1次。</li><li>2代：1代如果扫描10次，则2代扫描1次。</li></ul><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><p>在python中维护了一个refchain的双向环状链表，这个链表中存储程序创建的所有对象，每种类型的对象中，都有一个叫ob_refcnt引用计数器的值，维护着引用的个数，引用个数 + 1、- 1。最后引用计数器变为0时，进行垃圾回收（对象销毁，refchain中移除）</p><p>但是，在python中对于那些可以有由个元素组成的对象可能会存在循环引用的问题，为了解决这个问题，为了解决这个问题python又引入了标记清除和分代回收。在其内部维护4个链表</p><ul><li>refchain</li><li>2代  10次</li><li>1代  10次</li><li>0代  700个</li></ul><p>在源码的内部当达到各自的阈值时，就会触发扫描链表进行标记清除的动作，若有循环， 各自减一。</p><p>But，源码内部在上述的流程中提出了优化机制——缓存。</p><h3 id="5-Python缓存"><a href="#5-Python缓存" class="headerlink" title="5.Python缓存"></a>5.Python缓存</h3><h4 id="5-1-池（int、字符串）"><a href="#5-1-池（int、字符串）" class="headerlink" title="5.1 池（int、字符串）"></a>5.1 池（int、字符串）</h4><p><strong>为了避免重复的创建和销毁一些常见对象，维护一个池。</strong></p><ul><li><p>int类型，不是基于free_list，而是维护一个small_ints链表保存常见数据（小数据池），小数据池范围：<code>-5 &lt;= value &lt; 257</code>。即：重复使用这个范围的整数时，不会重新开辟内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v1 = <span class="number">38</span>    <span class="comment"># 去小数据池small_ints中获取38整数对象，将对象添加到refchain并让引用计数器+1。  </span></span><br><span class="line">print( <span class="built_in">id</span>(v1))  <span class="comment"># 内存地址：4514343712  </span></span><br><span class="line">v2 = <span class="number">38</span> <span class="comment"># 去小数据池small_ints中获取38整数对象，将refchain中的对象的引用计数器+1。  </span></span><br><span class="line">print( <span class="built_in">id</span>(v2) ) <span class="comment"># 内存地址：4514343712  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：在解释器启动时候-5~256就已经被加入到small_ints链表中且引用计数器初始化为1，代码中使用的值时直接去small_ints中拿来用并将引用计数器+1即可。另外，small_ints中的数据引用计数器永远不会为0（初始化时就设置为1了），所以也不会被销毁。</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>字符串有个驻留机制：若只含有数字、字母、下划线时，删除再创建、id一致，若含有别的如（汉字），则不一样。</p><ul><li>str类型，维护<code>unicode_latin1[256]</code>链表，内部将所有的<code>ascii字符</code>缓存起来，以后使用时就不再反复创建。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v1 = <span class="string">&quot;A&quot;</span>  </span><br><span class="line">print( <span class="built_in">id</span>(v1) ) <span class="comment"># 输出：4517720496  </span></span><br><span class="line"><span class="keyword">del</span> v1  </span><br><span class="line">v2 = <span class="string">&quot;A&quot;</span>  </span><br><span class="line">print( <span class="built_in">id</span>(v1) ) <span class="comment"># 输出：4517720496  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 除此之外，Python内部还对字符串做了驻留机制，针对那么只含有字母、数字、下划线的字符串（见源码Objects/codeobject.c），如果内存中已存在则不会重新在创建而是使用原来的地址里（不会像free_list那样一直在内存存活，只有内存中有才能被重复利用）。  </span></span><br><span class="line"></span><br><span class="line">v1 = <span class="string">&quot;wupeiqi&quot;</span>  </span><br><span class="line">v2 = <span class="string">&quot;wupeiqi&quot;</span>  </span><br><span class="line">print(<span class="built_in">id</span>(v1) == <span class="built_in">id</span>(v2)) <span class="comment"># 输出：True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-2-free-list机制（float-list-tuple-dict）"><a href="#5-2-free-list机制（float-list-tuple-dict）" class="headerlink" title="5.2 free_list机制（float/list/tuple/dict）"></a>5.2 free_list机制（float/list/tuple/dict）</h4><p>当一个对象的引用计数器为0时，按理应该对其进行回收，内部不会对其进行回收，而是将对象添加到free_list链表中当成缓存，以后再创建对象时，就不会重新开辟内存了，而是直接使用free_list。</p><ul><li><p>float类型，维护的free_list链表最多可缓存100个float对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v1 = <span class="number">3.14</span>    <span class="comment"># 开辟内存来存储float对象，并将对象添加到refchain链表。  </span></span><br><span class="line">print( <span class="built_in">id</span>(v1) ) <span class="comment"># 内存地址：4436033488  </span></span><br><span class="line"><span class="keyword">del</span> v1    <span class="comment"># 引用计数器-1，如果为0则在rechain链表中移除，不销毁对象，而是将对象添加到float的free_list.  </span></span><br><span class="line">v2 = <span class="number">9.999</span>    <span class="comment"># 优先去free_list中获取对象，并重置为9.999，如果free_list为空才重新开辟内存。  </span></span><br><span class="line">print( <span class="built_in">id</span>(v2) ) <span class="comment"># 内存地址：4436033488  # 注意：引用计数器为0时，会先判断free_list中缓存个数是否满了，未满则将对象缓存，已满则直接将对象销毁。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v1 = <span class="number">3.14</span> <span class="comment"># 开辟内存，内存存储结构体中定义的那几个值，存储到refchain中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> v1    <span class="comment"># 从refchain中移除，将对象添加到free_list中（最多如 80 个）。缓冲池满了才进行销毁。</span></span><br><span class="line"></span><br><span class="line">v9 = <span class="number">999.99</span> <span class="comment"># 不会重新开辟内存了，而是直接去free_list中获取对象，对象内部数据进行初始化，再放到refchain中。</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>ist类型，维护的free_list数组最多可缓存80个list对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v1 = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]  </span><br><span class="line">print( <span class="built_in">id</span>(v1) ) <span class="comment"># 输出：4517628816  </span></span><br><span class="line"><span class="keyword">del</span> v1  </span><br><span class="line">v2 = [<span class="string">&quot;任&quot;</span>,<span class="string">&quot;晓雄&quot;</span>]  </span><br><span class="line">print( <span class="built_in">id</span>(v2) ) <span class="comment"># 输出：4517628816</span></span><br></pre></td></tr></table></figure></li><li><p>tuple类型，维护一个free_list数组且数组容量20，数组中元素可以是链表且每个链表最多可以容纳2000个元组对象。元组的free_list数组在存储数据时，是按照元组可以容纳的个数为索引找到free_list数组中对应的链表，并添加到链表中。</p><ul><li>元祖有些特殊：索引机制<ul><li>free_list = [0,     1,      2,     …     19]</li><li>​               （(空元祖)，(一个元素的元祖)，(2个元素的元祖)，，，（19个元素的元祖）），每个里面都可以存2000个</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v1 = (<span class="number">1</span>,<span class="number">2</span>)  </span><br><span class="line">print( <span class="built_in">id</span>(v1) )  </span><br><span class="line"><span class="keyword">del</span> v1  <span class="comment"># 因元组的数量为2，所以会把这个对象缓存到free_list[2]的链表中。  </span></span><br><span class="line">v2 = (<span class="string">&quot;任晓雄&quot;</span>,<span class="string">&quot;Alex&quot;</span>)  <span class="comment"># 不会重新开辟内存，而是去free_list[2]对应的链表中拿到一个对象来使用。  </span></span><br><span class="line">print( <span class="built_in">id</span>(v2) )</span><br></pre></td></tr></table></figure></li><li><p>dict类型，维护的free_list数组最多可缓存80个dict对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v1 = &#123;<span class="string">&quot;k1&quot;</span>:<span class="number">123</span>&#125;  </span><br><span class="line">print( <span class="built_in">id</span>(v1) )  <span class="comment"># 输出：4515998128  </span></span><br><span class="line"><span class="keyword">del</span> v1  </span><br><span class="line">v2 = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;任晓雄&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;  </span><br><span class="line">print( <span class="built_in">id</span>(v1) )  <span class="comment"># 输出：4515998128</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Python的垃圾回收机制&quot;&gt;&lt;a href=&quot;#Python的垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;Python的垃圾回收机制&quot;&gt;&lt;/a&gt;Python的垃圾回收机制&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;引用计数器为主，标记清除和分代回收为辅 </summary>
      
    
    
    
    <category term="python" scheme="https://xxren8218.github.io/categories/python/"/>
    
    
    <category term="python基础" scheme="https://xxren8218.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>初识5G</title>
    <link href="https://xxren8218.github.io/20210827/%E5%88%9D%E8%AF%86.html"/>
    <id>https://xxren8218.github.io/20210827/%E5%88%9D%E8%AF%86.html</id>
    <published>2021-08-26T16:34:02.000Z</published>
    <updated>2021-08-26T16:40:55.187Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了一下5G的知识，总结了所了解的一些框架，希望以后能帮助到刚学习的同学。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210827004032.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天看了一下5G的知识，总结了所了解的一些框架，希望以后能帮助到刚学习的同学。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210827004032.png&quot; alt=&quot;&quot;&gt;</summary>
      
    
    
    
    <category term="科技杂谈" scheme="https://xxren8218.github.io/categories/%E7%A7%91%E6%8A%80%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>06-两数之和</title>
    <link href="https://xxren8218.github.io/20210817/06-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html"/>
    <id>https://xxren8218.github.io/20210817/06-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</id>
    <published>2021-08-16T16:25:43.000Z</published>
    <updated>2021-08-16T16:26:23.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210817002609.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。</p><p>本题呢，则要使用map，那么来看一下使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下表位置，因为要返回x 和 y的下表。所以set 也不能用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            hashmap[num] = ind</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            j = hashmap.get(target - num)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">and</span> i != j:</span><br><span class="line">                <span class="keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>05-快乐数</title>
    <link href="https://xxren8218.github.io/20210817/05-%E5%BF%AB%E4%B9%90%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210817/05-%E5%BF%AB%E4%B9%90%E6%95%B0.html</id>
    <published>2021-08-16T16:24:44.000Z</published>
    <updated>2021-08-16T16:25:30.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210817002500.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目看上去貌似一道数学问题，其实并不是！</p><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        set_ = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            sum_ = self.getSum(n)</span><br><span class="line">            <span class="keyword">if</span> sum_ == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false</span></span><br><span class="line">            <span class="keyword">if</span> sum_ <span class="keyword">in</span> set_:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                set_.add(sum_)</span><br><span class="line">            n = sum_</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 取数值各个位上的单数之和</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            sum_ += (n % <span class="number">10</span>) * (n % <span class="number">10</span>)</span><br><span class="line">            n //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> sum_</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快乐数&quot;&gt;&lt;a href=&quot;#快乐数&quot; class=&quot;headerlink&quot; title=&quot;快乐数&quot;&gt;&lt;/a&gt;快乐数&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>04-两个数组的交集</title>
    <link href="https://xxren8218.github.io/20210817/04-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html"/>
    <id>https://xxren8218.github.io/20210817/04-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html</id>
    <published>2021-08-16T16:23:40.000Z</published>
    <updated>2021-08-16T16:24:28.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210817002412.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。</p><p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序</strong></p><p>这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。</p><p><strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        result_set = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        set1 = <span class="built_in">set</span>(nums1)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> set1:</span><br><span class="line">                result_set.add(num) <span class="comment"># set1里出现的nums2元素 存放到结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(result_set)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两个数组的交集&quot;&gt;&lt;a href=&quot;#两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;两个数组的交集&quot;&gt;&lt;/a&gt;两个数组的交集&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>03-查找常用字符</title>
    <link href="https://xxren8218.github.io/20210817/03-%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6.html"/>
    <id>https://xxren8218.github.io/20210817/03-%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6.html</id>
    <published>2021-08-16T16:22:06.000Z</published>
    <updated>2021-08-16T16:23:27.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查找常用字符"><a href="#查找常用字符" class="headerlink" title="查找常用字符"></a>查找常用字符</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210817002247.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题意一起就有点绕，不是那么容易懂，其实就是26个小写字符中有字符 在所有字符串里都出现的话，就输出，重复的也算。</p><p>例如：</p><p>输入：[“ll”,”ll”,”ll”] 输出：[“l”,”l”]</p><p>这道题目一眼看上去，就是用哈希法，<strong>“小写字符”，“出现频率”， 这些关键字都是为哈希法量身定做的啊</strong></p><p>首先可以想到的是暴力解法，一个字符串一个字符串去搜，时间复杂度是O(n^m)，n是字符串长度，m是有几个字符串。</p><p>可以看出这是指数级别的时间复杂度，非常高，而且代码实现也不容易，因为要统计 重复的字符，还要适当的替换或者去重。</p><p>了解了哈希法，理解了数组在哈希法中的应用之后，可以来看解题思路了。</p><p>整体思路就是统计出搜索字符串里26个字符的出现的频率，然后取每个字符频率最小值，最后转成输出格式就可以了。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210817002306.png" alt=""></p><p>先统计第一个字符串所有字符出现的次数，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span> = [<span class="number">0</span>] * <span class="number">26</span> <span class="comment"># 用来统计所有字符串里字符出现的最小频率</span></span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(words[<span class="number">0</span>]):  <span class="comment"># 用第一个字符串给hash初始化</span></span><br><span class="line"><span class="built_in">hash</span>[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>接下来，把其他字符串里字符的出现次数也统计出来一次放在hashOtherStr中。</p><p>然后hash 和 hashOtherStr 取最小值，这是本题关键所在，此时取最小值，就是 一个字符在所有字符串里出现的最小次数了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计除第一个字符串外字符的出现频率</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(words)):</span><br><span class="line">    hashOtherStr = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words[<span class="number">0</span>])):</span><br><span class="line">        hashOtherStr[<span class="built_in">ord</span>(words[i][j]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">        <span class="built_in">hash</span>[k] = <span class="built_in">min</span>(<span class="built_in">hash</span>[k], hashOtherStr[k])</span><br></pre></td></tr></table></figure><p>此时hash里统计着字符在所有字符串里出现的最小次数，那么把hash转成题目要求的输出格式就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将hash统计的字符次数，转成输出形式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">hash</span>[i] != <span class="number">0</span>: <span class="comment"># 注意这里是while，多个重复的字符</span></span><br><span class="line">    result.extend(<span class="built_in">chr</span>(i + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">        <span class="built_in">hash</span>[i] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commonChars</span>(<span class="params">self, words: List[<span class="built_in">str</span>]</span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words: <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="built_in">hash</span> = [<span class="number">0</span>] * <span class="number">26</span> <span class="comment"># 用来统计所有字符串里字符出现的最小频率</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(words[<span class="number">0</span>]):  <span class="comment"># 用第一个字符串给hash初始化</span></span><br><span class="line">            <span class="built_in">hash</span>[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 统计除第一个字符串外字符的出现频率</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(words)):</span><br><span class="line">            hashOtherStr = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words[<span class="number">0</span>])):</span><br><span class="line">                hashOtherStr[<span class="built_in">ord</span>(words[i][j]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                <span class="built_in">hash</span>[k] = <span class="built_in">min</span>(<span class="built_in">hash</span>[k], hashOtherStr[k])</span><br><span class="line">        <span class="comment"># 将hash统计的字符次数，转成输出形式</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">hash</span>[i] != <span class="number">0</span>: <span class="comment"># 注意这里是while，多个重复的字符</span></span><br><span class="line">                result.extend(<span class="built_in">chr</span>(i + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">                <span class="built_in">hash</span>[i] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;查找常用字符&quot;&gt;&lt;a href=&quot;#查找常用字符&quot; class=&quot;headerlink&quot; title=&quot;查找常用字符&quot;&gt;&lt;/a&gt;查找常用字符&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>02-有效字母异位词</title>
    <link href="https://xxren8218.github.io/20210811/02-%E6%9C%89%E6%95%88%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html"/>
    <id>https://xxren8218.github.io/20210811/02-%E6%9C%89%E6%95%88%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html</id>
    <published>2021-08-11T15:27:19.000Z</published>
    <updated>2021-08-11T15:28:12.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有效字母异位词"><a href="#有效字母异位词" class="headerlink" title="有效字母异位词"></a>有效字母异位词</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232757.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>创建Hash表，键为字符，值为出现次数。default默认可以同时给字典增加键和值</p></li><li><p>不用这个高级函数的话，还可以用数组实现，数组的索引为字母，值为出现个数，对于s值加，对于t，值减。</p></li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">        s_dict = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        t_dict = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            s_dict[x] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> t:</span><br><span class="line">            t_dict[x] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s_dict == t_dict </span><br></pre></td></tr></table></figure><p>方法二的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        record = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">            record[<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">            record[<span class="built_in">ord</span>(t[i]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> record[i] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有效字母异位词&quot;&gt;&lt;a href=&quot;#有效字母异位词&quot; class=&quot;headerlink&quot; title=&quot;有效字母异位词&quot;&gt;&lt;/a&gt;有效字母异位词&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>01-哈希表基础</title>
    <link href="https://xxren8218.github.io/20210811/01-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E7%A1%80.html"/>
    <id>https://xxren8218.github.io/20210811/01-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-08-11T15:24:15.000Z</published>
    <updated>2021-08-11T15:27:05.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希表基础"><a href="#哈希表基础" class="headerlink" title="哈希表基础"></a>哈希表基础</h2><p>首先什么是 哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>这么这官方的解释可能有点懵，其实直白来讲其实数组就是一张哈希表。</p><p>哈希表中关键码就是数组的索引下表，然后通过下表直接访问数组中的元素，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232505.png" alt=""></p><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>例如要查询一个名字是否在这所学校里。</p><p>要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1) 就可以做到。</p><p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p><p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下表快速知道这位同学是否在这所学校里了。</p><p>哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232505.png" alt=""></p><p>如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？</p><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p><p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。</p><p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下表的位置。</p><p>接下来<strong>哈希碰撞</strong>登场</p><h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>如图所示，小李和小王都映射到了索引下表 1的位置，<strong>这一现象叫做哈希碰撞</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232505.png" alt=""></p><p>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232635.png" alt=""></p><p>（数据规模是dataSize， 哈希表的大小为tableSize）</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210811232650.png" alt=""></p><h3 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h3><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;哈希表基础&quot;&gt;&lt;a href=&quot;#哈希表基础&quot; class=&quot;headerlink&quot; title=&quot;哈希表基础&quot;&gt;&lt;/a&gt;哈希表基础&lt;/h2&gt;&lt;p&gt;首先什么是 哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道</summary>
      
    
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/categories/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
  </entry>
  
</feed>
