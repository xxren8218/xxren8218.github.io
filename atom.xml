<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-07-25T13:37:44.924Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>03-摆动序列</title>
    <link href="https://xxren8218.github.io/20210725/03-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210725/03-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html</id>
    <published>2021-07-25T13:36:43.000Z</published>
    <updated>2021-07-25T13:37:44.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210725213704.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>相信这么一说吓退不少同学，这要求最大摆动序列又可以修改数组，这得如何修改呢？</p><p>来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？</p><p>用示例二来举例，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210725213719.png" alt=""></p><p><strong>「局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值」</strong>。</p><p><strong>「整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列」</strong>。</p><p>局部最优推出全局最优，并举不出反例，那么试试贪心！</p><p>（为方便表述，以下说的峰值都是指局部峰值）</p><p><strong>「实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）」</strong></p><p><strong>「这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点」</strong>。</p><p>本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。</p><p>例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</p><p>所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210725213731.png" alt=""></p><p>针对以上情形，result初始为1（默认最右面有一个峰值），此时curDiff &gt; 0 and preDiff &lt;= 0，那么result += 1（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        curDiff = <span class="number">0</span>            <span class="comment"># 当前一对差值</span></span><br><span class="line">        preDiff = <span class="number">0</span>            <span class="comment"># 前一对差值</span></span><br><span class="line">        result = <span class="number">1</span>             <span class="comment"># 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            curDiff = nums[i] - nums[i - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 有峰值的地方进行记录</span></span><br><span class="line">            <span class="keyword">if</span> curDiff &gt; <span class="number">0</span> <span class="keyword">and</span> preDiff &lt;= <span class="number">0</span> <span class="keyword">or</span> curDiff &lt; <span class="number">0</span> <span class="keyword">and</span> preDiff &gt;= <span class="number">0</span>:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                preDiff = curDiff</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>「贪心的题目说简单有的时候就是常识，说难就难在都不知道该怎么用贪心」</strong>。</p><p>本题大家如果要去模拟删除元素达到最长摆动子序列的过程，那指定绕里面去了，一时半会拔不出来。</p><p>而这道题目有什么技巧说一下子能想到贪心么？</p><p>其实也没有，类似的题目做过了就会想到。</p><p>此时大家就应该了解了：<strong>保持区间波动，只需要把单调区间上的元素移除就可以了。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摆动序列&quot;&gt;&lt;a href=&quot;#摆动序列&quot; class=&quot;headerlink&quot; title=&quot;摆动序列&quot;&gt;&lt;/a&gt;摆动序列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>02-分发饼干</title>
    <link href="https://xxren8218.github.io/20210725/02-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html"/>
    <id>https://xxren8218.github.io/20210725/02-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html</id>
    <published>2021-07-25T13:35:32.000Z</published>
    <updated>2021-07-25T13:36:24.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210725213559.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了了满足更多的小孩，就不要造成饼干尺寸的浪费。</p><p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p><p><strong>「这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩」</strong>。</p><p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p><p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210725213613.jpg" alt=""></p><p>这个例子可以看出饼干9只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type g: List[int]</span></span><br><span class="line"><span class="string">        :type s: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 分别排序孩子和饼干的列表</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 饼干的索引</span></span><br><span class="line">        index = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历孩子列表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(g) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 若饼干能满足孩子的胃口，结果加一。</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= <span class="number">0</span> <span class="keyword">and</span> s[index] &gt;= g[i]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment">######################</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">######################</span></span><br></pre></td></tr></table></figure><p>从代码中可以看出我用了一个index来控制饼干数组的遍历，遍历饼干并没有再起一个for循环，而是采用自减的方式，这也是常用的技巧。</p><p>有的同学看到要遍历两个数组，就想到用两个for循环，那样逻辑其实就复杂了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题是贪心很好的一道入门题目，思路还是比较容易想到的。</p><p>文中详细介绍了思考的过程，<strong>「想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，并想不出反例，那么就试一试贪心」</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分发饼干&quot;&gt;&lt;a href=&quot;#分发饼干&quot; class=&quot;headerlink&quot; title=&quot;分发饼干&quot;&gt;&lt;/a&gt;分发饼干&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>01-认识贪心算法</title>
    <link href="https://xxren8218.github.io/20210725/01-%E8%AE%A4%E8%AF%86%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html"/>
    <id>https://xxren8218.github.io/20210725/01-%E8%AE%A4%E8%AF%86%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</id>
    <published>2021-07-25T13:34:46.000Z</published>
    <updated>2021-07-25T13:35:20.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识贪心算法"><a href="#认识贪心算法" class="headerlink" title="认识贪心算法"></a>认识贪心算法</h2><h3 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="什么是贪心"></a>什么是贪心</h3><p><strong>「贪心的本质是选择每一阶段的局部最优，从而达到全局最优」</strong>。</p><p>这么说有点抽象，来举一个例子：</p><p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p><p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p><p>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p><p>再举一个例子如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。</p><h3 id="贪心的套路（什么时候用贪心）"><a href="#贪心的套路（什么时候用贪心）" class="headerlink" title="贪心的套路（什么时候用贪心）"></a>贪心的套路（什么时候用贪心）</h3><p>很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看就看出来是贪心。</p><p><strong>「说实话贪心算法并没有固定的套路」</strong>。</p><p>所以唯一的难点就是如何通过局部最优，推出整体最优。</p><p>那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？</p><p><strong>「不好意思，也没有！」</strong> 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。</p><p>有同学问了如何验证可不可以用贪心算法呢？</p><p><strong>「最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧」</strong>。</p><p>可有有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。</p><p>一般数学证明有如下两种方法：</p><ul><li>数学归纳法</li><li>反证法</li></ul><p>看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。</p><p><strong>「面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了」</strong>。</p><p>举一个不太恰当的例子：我要用一下1+1 = 2，但我要先证明1+1 为什么等于2。严谨是严谨了，但没必要。</p><p>虽然这个例子很极端，但可以表达这么个意思：<strong>「刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心」</strong>。</p><p><strong>「例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！」</strong></p><p>所以这也是为什么很多同学通过（accept）了贪心的题目，但都不知道自己用了贪心算法，<strong>「因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！」</strong></p><h3 id="贪心一般解题步骤"><a href="#贪心一般解题步骤" class="headerlink" title="贪心一般解题步骤"></a>贪心一般解题步骤</h3><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><p>其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪心的题目往往还和其他方面的知识混在一起。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇给出了什么是贪心以及大家关心的贪心算法固定套路。</p><p><strong>不好意思了，贪心没有套路，说白了就是常识性推导加上举反例。</strong></p><p>最后给出贪心的一般解题步骤，大家可以发现这个解题步骤也是比较抽象的，不像是二叉树，回溯算法，给出了那么具体的解题套路和模板。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;认识贪心算法&quot;&gt;&lt;a href=&quot;#认识贪心算法&quot; class=&quot;headerlink&quot; title=&quot;认识贪心算法&quot;&gt;&lt;/a&gt;认识贪心算法&lt;/h2&gt;&lt;h3 id=&quot;什么是贪心&quot;&gt;&lt;a href=&quot;#什么是贪心&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="贪心算法" scheme="https://xxren8218.github.io/categories/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>17-解数独</title>
    <link href="https://xxren8218.github.io/20210723/17-%E8%A7%A3%E6%95%B0%E7%8B%AC.html"/>
    <id>https://xxren8218.github.io/20210723/17-%E8%A7%A3%E6%95%B0%E7%8B%AC.html</id>
    <published>2021-07-23T10:57:04.000Z</published>
    <updated>2021-07-23T10:58:34.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185733.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185747.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>棋盘搜索问题可以使用回溯法暴力搜索，只不过这次我们要做的是<strong>「二维递归\</strong>」*<em>*</em>。</p><p>怎么做<strong>二维递归</strong>呢？</p><p>大家已经跟着「代码随想录」刷过了如下回溯法题目，例如【组合】【分割】【子集】【排列】其实这些题目都是<strong>一维递归</strong>。</p><p>【N皇后问题】是因为每一行每一列只放一个皇后，只需要一层for循环遍历一行，递归来来遍历列，然后一行一列确定皇后的唯一位置。</p><p>本题就不一样了，<strong>「本题中棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更宽更深」</strong>。</p><p>因为这个树形结构太大了，我抽取一部分，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185801.png" alt=""></p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数以及参数</li></ul><p><strong>「递归函数的返回值需要是bool类型，为什么呢？」</strong></p><p>因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值，这一点在【N皇后】中已经介绍过了，一样的道理。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">board</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。</p><p><strong>「不用终止条件会不会死循环？」</strong></p><p>递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！</p><p><strong>「那么有没有永远填不满的情况呢？」</strong></p><p>这个问题我在递归单层搜索逻辑里在来讲！</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185801.png" alt=""></p><p>在树形图中可以看出我们需要的是一个<strong>二维递归</strong>（也就是两个for循环嵌套着递归）</p><p><strong>「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」</strong></p><p>代码如下：（<strong>「详细看注释」</strong>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">board</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):                <span class="comment"># 遍历行</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):         <span class="comment"># 遍历列</span></span><br><span class="line">        <span class="keyword">if</span> board[i][j] != <span class="string">&quot;.&quot;</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):              <span class="comment"># (i, j) 这个位置放k是否合适</span></span><br><span class="line">            <span class="keyword">if</span> isValid(i, j, k, board):</span><br><span class="line">                    board[i][j] = <span class="built_in">str</span>(k)       <span class="comment"># 放置k</span></span><br><span class="line">                    <span class="keyword">if</span> backtrack(board): <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 如果找到合适一组立刻返回</span></span><br><span class="line">                    board[i][j] = <span class="string">&quot;.&quot;</span>          <span class="comment"># 回溯，撤销k</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>                       <span class="comment"># 9个数都试完了，都不行，那么就返回False</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span>                            <span class="comment"># 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br></pre></td></tr></table></figure><p><strong>「注意这里return False的地方，这里放return False 是有讲究的」</strong>。</p><p>因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！</p><p>那么会直接返回， <strong>「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」</strong></p><h3 id="判断棋盘是否合法"><a href="#判断棋盘是否合法" class="headerlink" title="判断棋盘是否合法"></a>判断棋盘是否合法</h3><p>判断棋盘是否合法有如下三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>9宫格里是否重复</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">row, col, val, board</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):                       <span class="comment"># 判断行里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> board[row][i] == <span class="built_in">str</span>(val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):                       <span class="comment"># 判断列里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> board[j][col] == <span class="built_in">str</span>(val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    startRow = (row // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    startcol = (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startRow,startRow + <span class="number">3</span>):   <span class="comment"># 判断9方格里是否重复</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(startcol,startcol + <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="built_in">str</span>(val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>最后整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span>(<span class="params">self, board</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">board</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):                  <span class="comment"># 遍历行</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):           <span class="comment"># 遍历列</span></span><br><span class="line">                    <span class="keyword">if</span> board[i][j] != <span class="string">&quot;.&quot;</span>: <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):                <span class="comment"># (i, j) 这个位置放k是否合适</span></span><br><span class="line">                        <span class="keyword">if</span> isValid(i, j, k, board):</span><br><span class="line">                            board[i][j] = <span class="built_in">str</span>(k)         <span class="comment"># 放置k</span></span><br><span class="line">                            <span class="keyword">if</span> backtrack(board): <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 如果找到合适一组立刻返回</span></span><br><span class="line">                            board[i][j] = <span class="string">&quot;.&quot;</span>            <span class="comment"># 回溯，撤销k</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span>                         <span class="comment"># 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>                                  <span class="comment"># 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">row, col, val, board</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):                           <span class="comment"># 判断行里是否重复</span></span><br><span class="line">                <span class="keyword">if</span> board[row][i] == <span class="built_in">str</span>(val):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):                           <span class="comment"># 判断列里是否重复</span></span><br><span class="line">                <span class="keyword">if</span> board[j][col] == <span class="built_in">str</span>(val):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            startRow = (row // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">            startcol = (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startRow,startRow + <span class="number">3</span>):       <span class="comment"># 判断9方格里是否重复</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(startcol,startcol + <span class="number">3</span>):</span><br><span class="line">                    <span class="keyword">if</span> board[i][j] == <span class="built_in">str</span>(val):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        backtrack(board)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解数独可以说是非常难的题目了，如果还一直停留在单层递归的逻辑中，这道题目可以让大家瞬间崩溃。</p><p>所以我在开篇就提到了<strong>【二维递归】</strong>。</p><p><strong>「这样，解数独这么难的问题，也被我们攻克了」</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;解数独&quot;&gt;&lt;a href=&quot;#解数独&quot; class=&quot;headerlink&quot; title=&quot;解数独&quot;&gt;&lt;/a&gt;解数独&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>16-N皇后</title>
    <link href="https://xxren8218.github.io/20210723/16-N%E7%9A%87%E5%90%8E.html"/>
    <id>https://xxren8218.github.io/20210723/16-N%E7%9A%87%E5%90%8E.html</id>
    <published>2021-07-23T10:55:46.000Z</published>
    <updated>2021-07-23T10:56:48.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185615.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>都知道n皇后问题是回溯算法解决的经典问题，但是用回溯解决多了组合、切割、子集、排列问题之后，遇到这种二维矩阵还会有点不知所措。</p><p>首先来看一下皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p><p>下面我用一个3 * 3 的棋牌，将搜索过程抽象为一颗树，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185629.jpg" alt=""></p><p>从图中，可以看出，二维矩阵中矩阵的高就是这颗树的高度，矩阵的宽就是树型结构中每一个节点的宽度。</p><p>那么我们用皇后们的约束条件，来回溯搜索这颗树，<strong>「只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了」</strong>。</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><p>按照我总结的如下回溯模板，我们来依次分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">参数</span>)：</span></span><br><span class="line"><span class="function">    <span class="title">if</span> 终止条件:</span></span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）:</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表)  <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure><ul><li>递归函数参数</li></ul><p>我依然是定义全局变量二维数组result来记录最终结果。</p><p>参数n是棋牌的大小，然后用row来记录当前遍历到棋盘的第几层了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">chessboard = [[<span class="string">&quot;.&quot;</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">n, row, chessboard</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>在如下树形结构中：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185629.jpg" alt=""></p><p>可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果走到最后一行，说明已经找到一个解</span></span><br><span class="line"><span class="keyword">if</span> row == n:</span><br><span class="line">    <span class="comment"># 注意不能直接加进去，注意格式，需要再处理一下</span></span><br><span class="line">    <span class="comment"># result.append(chessboard)</span></span><br><span class="line">    <span class="keyword">if</span> row == n:</span><br><span class="line">        temp_res = []</span><br><span class="line">       <span class="keyword">for</span> temp <span class="keyword">in</span> chessboard:</span><br><span class="line">            temp_str = <span class="string">&quot;&quot;</span>.join(temp)</span><br><span class="line">            temp_res.append(temp_str)</span><br><span class="line">            </span><br><span class="line">        result.append(temp_res)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>单层搜索的逻辑</li></ul><p><strong>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</strong></p><p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">    <span class="keyword">if</span> isValid(row, col, chessboard, n):      <span class="comment"># 验证合法就可以放</span></span><br><span class="line">        chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>            <span class="comment"># 放置皇后</span></span><br><span class="line">        backtracking(n, row + <span class="number">1</span>, chessboard)</span><br><span class="line">        chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>            <span class="comment"># 回溯，撤销皇后</span></span><br></pre></td></tr></table></figure><ul><li>验证棋牌是否合法</li></ul><p>按照如下标准去重：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线 （45度和135度角）</li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, row, col, chessboard</span>):</span></span><br><span class="line">    <span class="comment"># 判断同一列是否冲突</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">        <span class="keyword">if</span> chessboard[i][col] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断45度是否冲突</span></span><br><span class="line">    i = row - <span class="number">1</span></span><br><span class="line">    j = col - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> chessboard[i][j] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 判断135度是否冲突</span></span><br><span class="line">    i = row - <span class="number">1</span></span><br><span class="line">    j = col + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(chessboard):</span><br><span class="line">        <span class="keyword">if</span> chessboard[i][j] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>在这份代码中，细心的同学可以发现为什么没有在同行进行检查呢？</p><p>因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p><p>那么按照这个模板不难写出如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n: <span class="keyword">return</span> []</span><br><span class="line">        chessboard = [[<span class="string">&quot;.&quot;</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        self.backtracking(n, <span class="number">0</span>, chessboard)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, n, row, chessboard</span>):</span></span><br><span class="line">        <span class="keyword">if</span> row == n:</span><br><span class="line">            temp_res = []</span><br><span class="line">            <span class="keyword">for</span> temp <span class="keyword">in</span> chessboard:</span><br><span class="line">                temp_str = <span class="string">&quot;&quot;</span>.join(temp)</span><br><span class="line">                temp_res.append(temp_str)</span><br><span class="line">            </span><br><span class="line">            self.result.append(temp_res)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> self.isValid(row, col, chessboard):</span><br><span class="line">                chessboard[row][col] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">                self.backtracking(n, row + <span class="number">1</span>, chessboard)</span><br><span class="line">                chessboard[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, row, col, chessboard</span>):</span></span><br><span class="line">        <span class="comment"># 判断同一列是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">if</span> chessboard[i][col] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断45度是否冲突</span></span><br><span class="line">        i = row - <span class="number">1</span></span><br><span class="line">        j = col - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> chessboard[i][j] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断135度是否冲突</span></span><br><span class="line">        i = row - <span class="number">1</span></span><br><span class="line">        j = col + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(chessboard):</span><br><span class="line">            <span class="keyword">if</span> chessboard[i][j] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是我们解决棋盘问题的第一道题目。</p><p>如果从来没有接触过N皇后问题的同学看着这样的题会感觉无从下手，可能知道要用回溯法，但也不知道该怎么去搜。</p><p><strong>「这里我明确给出了棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度，这样就可以套进回溯法的模板里了」</strong>。</p><p>大家可以在仔细体会体会！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;N皇后&quot;&gt;&lt;a href=&quot;#N皇后&quot; class=&quot;headerlink&quot; title=&quot;N皇后&quot;&gt;&lt;/a&gt;N皇后&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>15-重新安排行程</title>
    <link href="https://xxren8218.github.io/20210723/15-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html"/>
    <id>https://xxren8218.github.io/20210723/15-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html</id>
    <published>2021-07-23T10:53:43.000Z</published>
    <updated>2021-07-23T10:55:30.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185421.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185434.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目还是很难的，之前我们用回溯法解决了如下问题：【组合】【分割】【子集】【排列】问题。</p><p>直觉上来看 这道题和回溯法没有什么关系，更像是图论中的深度优先搜索。</p><p>实际上确实是深搜，但这是深搜中使用了回溯的例子，在查找路径的时候，如果不回溯，怎么能查到目标路径呢。</p><p>所以我倾向于说本题应该使用回溯法，那么我也用回溯法的思路来讲解本题，其实深搜一般都使用了回溯法的思路。</p><p><strong>「这里就是先给大家拓展一下，原来回溯法还可以这么玩！」</strong></p><p><strong>「这道题目有几个难点：」</strong></p><ol><li>一个行程中，如果航班处理不好容易变成一个圈，成为死循环</li><li>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</li><li>使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？</li><li>搜索的过程中，如何遍历一个机场所对应的所有机场。</li></ol><p>针对以上问题我来逐一解答！</p><h3 id="如何理解死循环"><a href="#如何理解死循环" class="headerlink" title="如何理解死循环"></a>如何理解死循环</h3><p>对于死循环，我来举一个有重复机场的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185449.jpg" alt=""></p><p>为什么要举这个例子呢，就是告诉大家，出发机场和到达机场也会重复的，<strong>「如果在解题的过程中没有对集合元素处理好，就会死循环。」</strong></p><h3 id="该记录映射关系"><a href="#该记录映射关系" class="headerlink" title="该记录映射关系"></a>该记录映射关系</h3><p>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</p><p>一个机场映射多个机场，机场之间要靠字母序排列，一个机场映射多个机场，可以使用 {‘JFK’: [‘SFO’, ‘ATL’], ‘SFO’: [‘ATL’], ‘ATL’: [‘JFK’, ‘SFO’]})</p><p><strong>「再说一下为什么一定要增删元素呢，正如开篇我给出的图中所示，出发机场和到达机场是会重复的，搜索的过程没及时删除目的机场就会死循环。」</strong></p><p>使用tickets_dict = defaultdict(list)来方便为不存在key的字典赋值为列表。</p><p>from collections import defaultdict</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>这道题目我使用回溯法，那么下面按照我总结的回溯模板来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">参数</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）:</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表) <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure><p>本题以输入：[[“JFK”, “KUL”], [“JFK”, “NRT”], [“NRT”, “JFK”]为例，抽象为树形结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185501.png" alt=""></p><p>开始回溯三部曲讲解：</p><ul><li>递归函数参数</li></ul><p>在讲解映射关系的时候，已经讲过了，用tickets_dict记录各个航班&lt;出发航班，[到达航班1，到达航班2…]&gt;信息，对其进行变量的传递。</p><p>代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;“出发航班”：[到达航班1，到达航班2...]&#125;</span></span><br><span class="line"></span><br><span class="line">tickets_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> tickets:</span><br><span class="line">    tickets_dict[item[<span class="number">0</span>]].append(item[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">def backtracking(tickets,start_point, tickets_dic): -&gt; 返回bool类型数据</span><br></pre></td></tr></table></figure><p><strong>「注意函数返回值是bool！」</strong></p><p>我们之前讲解回溯算法的时候，一般函数返回值都是None，这次为什么是bool呢？</p><p>因为我们只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185517.png" alt=""></p><p>所以找到了这个叶子节点了直接返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> tickets_dict:</span><br><span class="line">    <span class="comment"># 必须及时删除，避免出现死循环</span></span><br><span class="line">    end_point = tickets_dict[start_point].pop(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    path.append(end_point)</span><br><span class="line">    <span class="comment"># 只要找到一个就可以返回了</span></span><br><span class="line">    <span class="keyword">if</span> backtracking(tickets, end_point, tickets_dict):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    path.pop()</span><br><span class="line">    tickets_dict[start_point].append(end_point)</span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>拿题目中的示例为例，输入: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]] ，这是有4个航班，那么只要找出一种行程，行程里的机场个数是5就可以了。</p><p>所以终止条件是：我们回溯遍历的过程中，遇到的机场个数，如果达到了（航班数量+1），那么我们就找到了一个行程，把所有航班串在一起了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(result) == <span class="built_in">len</span>(tickets) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>已经看习惯回溯法代码的同学，到叶子节点了习惯性的想要收集结果，但发现并不需要，本题的path就是记录路径的（就一条），在如下单层搜索的逻辑中result就添加元素了。</p><ul><li>单层搜索的逻辑</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必须及时删除，避免出现死循环</span></span><br><span class="line">end_point = tickets_dict[start_point].pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">path.append(end_point)</span><br><span class="line"><span class="comment"># 只要找到一个就可以返回了</span></span><br><span class="line"><span class="keyword">if</span> backtracking(tickets, end_point, tickets_dict):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">path.pop()</span><br><span class="line">tickets_dict[start_point].append(end_point)</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path = [<span class="string">&quot;JFK&quot;</span>] </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span>(<span class="params">self, tickets</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type tickets: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        tickets_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="comment">#############################</span></span><br><span class="line">        <span class="comment"># 它的其他功能与dict相同，但会为一个不存在的键提供默认值，</span></span><br><span class="line">        <span class="comment">#############################</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> tickets:</span><br><span class="line">            tickets_dict[item[<span class="number">0</span>]].append(item[<span class="number">1</span>])</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        tickets_dict里面的内容是这样的</span></span><br><span class="line"><span class="string">         &#123;&#x27;JFK&#x27;: [&#x27;SFO&#x27;, &#x27;ATL&#x27;], &#x27;SFO&#x27;: [&#x27;ATL&#x27;], &#x27;ATL&#x27;: [&#x27;JFK&#x27;, &#x27;SFO&#x27;]&#125;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        self.backtracking(tickets, <span class="string">&quot;JFK&quot;</span>, tickets_dict)</span><br><span class="line">        <span class="keyword">return</span> self.path</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, tickets, start_point, tickets_dict</span>):</span></span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == <span class="built_in">len</span>(tickets) + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        tickets_dict[start_point].sort()</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> tickets_dict[start_point]:</span><br><span class="line">            <span class="comment"># 必须及时删除，避免出现死循环</span></span><br><span class="line">            end_point = tickets_dict[start_point].pop(<span class="number">0</span>)</span><br><span class="line">            self.path.append(end_point)</span><br><span class="line">            <span class="comment"># 只要找到一个就可以返回了</span></span><br><span class="line">            <span class="keyword">if</span> self.backtracking(tickets, end_point, tickets_dict):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            self.path.pop()</span><br><span class="line">            tickets_dict[start_point].append(end_point)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题其实可以算是一道hard的题目了，关于本题的难点我在文中已经列出了。</p><p><strong>「如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上」</strong>。</p><p>本题其实是一道深度优先搜索的题目，但是我完全使用回溯法的思路来讲解这道题题目，<strong>「算是给大家拓展一下思维方式，其实深搜和回溯也是分不开的，毕竟最终都是用递归」</strong>。</p><p>如果最终代码，发现照着回溯法模板画的话好像也能画出来，但难就难如何知道可以使用回溯，以及如何套进去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重新安排行程&quot;&gt;&lt;a href=&quot;#重新安排行程&quot; class=&quot;headerlink&quot; title=&quot;重新安排行程&quot;&gt;&lt;/a&gt;重新安排行程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>14-全排列二</title>
    <link href="https://xxren8218.github.io/20210723/14-%E5%85%A8%E6%8E%92%E5%88%97%E4%BA%8C.html"/>
    <id>https://xxren8218.github.io/20210723/14-%E5%85%A8%E6%8E%92%E5%88%97%E4%BA%8C.html</id>
    <published>2021-07-23T10:51:37.000Z</published>
    <updated>2021-07-23T10:53:23.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全排列二"><a href="#全排列二" class="headerlink" title="全排列二"></a>全排列二</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185221.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目和【排列问题】<strong>「给定一个可包含重复数字的序列」</strong>，要返回<strong>「所有不重复的全排列」</strong>。</p><p>这里又涉及到去重了。</p><p>在【求组合总和（三）】 、【求子集问题（二）】我们分别详细讲解了组合问题和子集问题如何去重。</p><p>那么排列问题其实也是一样的套路。</p><p><strong>「还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了」</strong>。</p><p>我以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185235.png" alt=""></p><p>图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。</p><p><strong>「一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果」</strong>。</p><p>在【排列问题】已经详解讲解了排列问题的写法，【求组合总和（三）】 、【求子集问题（二）】详细讲解的去重的写法，所以这次我就不用回溯三部曲分析了，直接给出代码，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path = []</span><br><span class="line">        self.result = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        self.backtracking(nums, used)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, nums, used</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            self.result.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> used[i] == <span class="literal">False</span>:</span><br><span class="line">                self.path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                self.backtracking(nums, used)</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line">                self.path.pop()</span><br></pre></td></tr></table></figure><p>大家发现，去重最为关键的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>: </span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p><strong>「如果改成 <code>used[i - 1] == true</code>， 也是正确的!」</strong>，去重代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">True</span> </span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用<code>used[i - 1] == False</code>，如果要对树枝前一位去重用<code>used[i - 1] == True</code>。</p><p><strong>「对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！」</strong></p><p>这么说是不是有点抽象？</p><p>来来来，我就用输入: [1,1,1] 来举一个例子。</p><p>树层上去重(used[i - 1] == False)，的树形结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185252.png" alt=""></p><p>树枝上去重（used[i - 1] == True）的树型结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210723185308.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题其实还是用了我们之前讲过的去重思路，但有意思的是，去重的代码中，这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>: </span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>和这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">True</span>: </span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>都是可以的，这也是很多同学做这道题目困惑的地方，知道<code>used[i - 1] == False</code>也行而<code>used[i - 1] == True</code>也行，但是就想不明白为啥。</p><p>所以我通过举[1,1,1]的例子，把这两个去重的逻辑分别抽象成树形结构，大家可以一目了然：为什么两种写法都可以以及哪一种效率更高！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;全排列二&quot;&gt;&lt;a href=&quot;#全排列二&quot; class=&quot;headerlink&quot; title=&quot;全排列二&quot;&gt;&lt;/a&gt;全排列二&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>13-全排列</title>
    <link href="https://xxren8218.github.io/20210722/13-%E5%85%A8%E6%8E%92%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210722/13-%E5%85%A8%E6%8E%92%E5%88%97.html</id>
    <published>2021-07-22T10:59:03.000Z</published>
    <updated>2021-07-22T11:00:00.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185925.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>此时我们已经学习了【组合问题】【切割问题】和【子集问题】，接下来看一看排列问题。</p><p>相信这个排列问题就算是让你用for循环暴力把结果搜索出来，这个暴力也不是很好写。</p><p>为什么回溯法是暴力搜索，效率这么低，还要用它？这就是原因。</p><p><strong>「因为一些问题能暴力搜出来就已经很不错了！」</strong></p><p>我以[1,2,3]为例，抽象成树形结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185941.png" alt=""></p><h2 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h2><ul><li>递归函数参数</li></ul><p><strong>「首先排列是有序的，也就是说[1,2] 和[2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方」</strong>。</p><p>可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。</p><p>但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185941.png" alt=""></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">path = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span> (<span class="params">nums, used</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185941.png" alt=""></p><p>可以看出叶子节点，就是收割结果的地方。</p><p>那么什么时候，算是到达叶子节点呢？</p><p>当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时说明找到了一组</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">    result.append(path)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>单层搜索的逻辑</li></ul><p>这里和【组合问题】【切割问题】和【子集问题】最大的不同就是for循环里不用startIndex了。</p><p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p><p><strong>「而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次」</strong>。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">if</span> used[i] == <span class="literal">True</span>: </span><br><span class="line">        <span class="keyword">continue</span>               <span class="comment"># path里已经收录的元素，直接跳过</span></span><br><span class="line">    used[i] = <span class="literal">True</span></span><br><span class="line">    path.append(nums[i])</span><br><span class="line">    backtracking(nums, used)</span><br><span class="line">    path.pop()</span><br><span class="line">    used[i] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path = []</span><br><span class="line">        self.result = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        self.backtracking(nums, used)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, nums, used</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            self.result.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> used[i] == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            self.backtracking(nums, used)</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>大家此时可以感受出排列问题的不同：</p><ul><li>每层都是从0开始搜索而不是startIndex</li><li>需要used数组记录path里都放了哪些元素了</li></ul><p>排列问题是回溯算法解决的经典题目，大家可以好好体会体会。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;全排列&quot;&gt;&lt;a href=&quot;#全排列&quot; class=&quot;headerlink&quot; title=&quot;全排列&quot;&gt;&lt;/a&gt;全排列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/202</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>12-递增子序列</title>
    <link href="https://xxren8218.github.io/20210722/12-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210722/12-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2021-07-22T10:57:46.000Z</published>
    <updated>2021-07-22T10:58:47.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自增子序列"><a href="#自增子序列" class="headerlink" title="自增子序列"></a>自增子序列</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185813.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个递增子序列比较像是取有序的子集。而且本题也要求不能有相同的递增子序列。</p><p>这又是子集，又是去重，是不是不由自主的想起了刚刚讲过的【子集问题二】</p><p>就是因为太像了，更要注意差别所在，要不就掉坑里了！</p><p>在【子集问题二】我们是通过排序，再加一个标记数组来达到去重的目的。</p><p>而本题求自增子序列，是不能对原数组进行排序的，排完序的数组都是自增子序列了。</p><p><strong>「所以不能使用之前的去重逻辑！」</strong></p><p>本题给出的示例，还是一个有序数组 [4, 6, 7, 7]，这更容易误导大家按照排序的思路去做了。</p><p>为了有鲜明的对比，我用[4, 7, 6, 7]这个数组来举例，抽象为树形结构如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185831.png" alt=""></p><h2 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h2><ul><li>递归函数参数</li></ul><p>本题求子序列，很明显一个元素不能重复使用，所以需要startIndex，调整下一层递归的起始位置。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">path = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums, startIndex</span>) </span></span><br></pre></td></tr></table></figure><ul><li>终止条件</li></ul><p>本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以【求子集问题】一样，可以不加终止条件，startIndex每次都会加1，并不会无限递归。</p><p>但本题收集结果有所不同，题目要求递增子序列大小至少为2，所以代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="number">1</span>:</span><br><span class="line">    result.append(path[:])</span><br><span class="line">    <span class="comment"># 注意这里不要加return，因为要取树上的所有节点</span></span><br></pre></td></tr></table></figure><ul><li>单层搜索逻辑</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185831.png" alt=""></p><p>在图中可以看出，同层上使用过的元素就不能在使用了，<strong>「注意这里和【求子集问题】中去重的区别」</strong>。</p><p><strong>「本题只要同层重复使用元素，递增子序列就会重复」</strong>，【求子集问题】是排序之后看相邻元素是否重复使用。</p><p>还有一种情况就是如果选取的元素小于子序列最后一个元素，那么就不能是递增的，所以也要pass掉。</p><p>那么去重的逻辑代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> path <span class="keyword">and</span> nums[i] &lt; path[-<span class="number">1</span>] <span class="keyword">or</span> path[i] <span class="keyword">in</span> repeat:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>判断<code>nums[i] &lt; path[-1]</code>之前一定要判断path是否为空，所以是<code>path and nums[i] &lt; path[-1]</code>。</p><p><code>uset.find(nums[i]) != uset.end()</code>判断nums[i]在本层是否使用过。</p><p>那么单层搜索代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uset = []   <span class="comment"># 使用set来对本层元素进行去重</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, lne(nums)):</span><br><span class="line">    <span class="keyword">if</span> path <span class="keyword">and</span> nums[i] &lt; path[-<span class="number">1</span>] <span class="keyword">or</span> path[i] <span class="keyword">in</span> repeat:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">    repeat.append(nums[i])    <span class="comment"># 记录这个元素在本层用过了，本层后面不能再用了</span></span><br><span class="line">    path.append(nums[i])</span><br><span class="line">    backtracking(nums, i + <span class="number">1</span>)</span><br><span class="line">    path.pop()</span><br></pre></td></tr></table></figure><p><strong>「对于已经习惯写回溯的同学，看到递归函数上面的<code>repeat.append(nums[i])</code>，下面却没有对应的pop之类的操作，应该很不习惯吧，哈哈」</strong></p><p><strong>「这也是需要注意的点，<code>repeat.append(nums[i]</code> 是记录本层元素是否重复使用，新的一层repeat都会重新定义（清空），所以要知道repeat只负责本层！」</strong></p><p>最后代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubsequences</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        self.backtracking(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, nums, startIndex</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) &gt; <span class="number">1</span>:</span><br><span class="line">            self.result.append(self.path[:])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 用来标记本层用过的数。</span></span><br><span class="line">        repeat = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> self.path <span class="keyword">and</span> nums[i] &lt; self.path[-<span class="number">1</span>] <span class="keyword">or</span> nums[i] <span class="keyword">in</span> repeat:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            repeat.append(nums[i])</span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            self.backtracking(nums, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop() </span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题题解清一色都说是深度优先搜索，但我更倾向于说它用回溯法，而且本题我也是完全使用回溯法的逻辑来分析的。</p><p>相信大家在本题中处处都能看到是【子集问题二】身影，但处处又都是陷阱。</p><p><strong>「对于养成思维定式或者套模板套嗨了的同学，这道题起到了很好的警醒作用。更重要的是拓展了大家的思路！」</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自增子序列&quot;&gt;&lt;a href=&quot;#自增子序列&quot; class=&quot;headerlink&quot; title=&quot;自增子序列&quot;&gt;&lt;/a&gt;自增子序列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>24-搜索树转累加树</title>
    <link href="https://xxren8218.github.io/20210722/24-%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E7%B4%AF%E5%8A%A0%E6%A0%91.html"/>
    <id>https://xxren8218.github.io/20210722/24-%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E7%B4%AF%E5%8A%A0%E6%A0%91.html</id>
    <published>2021-07-22T10:56:16.000Z</published>
    <updated>2021-07-22T10:57:22.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜素树转累加树"><a href="#搜素树转累加树" class="headerlink" title="搜素树转累加树"></a>搜素树转累加树</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185640.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185653.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一看到累加树，相信很多小伙伴都会疑惑：如何累加？遇到一个节点，然后在遍历其他节点累加？怎么一想这么麻烦呢。</p><p>然后再发现这是一颗二叉搜索树，二叉搜索树啊，这是有序的啊。</p><p>那么有序的元素如果求累加呢？</p><p><strong>「其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]，是不是感觉这就简单了。」</strong></p><p>为什么变成数组就是感觉简单了呢？</p><p>因为数组大家都知道怎么遍历啊，从后向前，挨个累加就完事了，这换成了二叉搜索树，看起来就别扭了一些是不是。</p><p>那么知道如何遍历这个二叉树，也就迎刃而解了，<strong>「从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了」</strong>。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>遍历顺序如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185707.png" alt=""></p><p>本题依然需要一个pre指针记录当前遍历节点cur的前一个节点，这样才方便做累加。</p><p>pre指针的使用技巧，我们在【搜索树的最小绝对差】和【二叉树的众数】都提到了，这是常用的操作手段。</p><ul><li>递归函数参数以及返回值</li></ul><p>这里很明确了，不需要递归函数的返回值做什么操作了，要遍历整棵树。</p><p>同时需要定义一个全局变量pre，用来保存cur节点的前一个节点的数值，定义为int型就可以了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pre = <span class="number">0</span> <span class="comment"># 记录前一个节点的数值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">cur</span>):</span> </span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>遇空就终止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>确定单层递归的逻辑</li></ul><p>注意<strong>「要右中左来遍历二叉树」</strong>， 中节点的处理逻辑就是让cur的数值加上前一个节点的数值。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">traversal(cur.right)  <span class="comment"># 右</span></span><br><span class="line">cur.val += pre        <span class="comment"># 中</span></span><br><span class="line">pre = cur.val</span><br><span class="line">traversal(cur.left)   <span class="comment"># 左</span></span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pre = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.travsersal(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travsersal</span>(<span class="params">self, cur</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">        self.travsersal(cur.right)</span><br><span class="line">        cur.val += self.pre</span><br><span class="line">        self.pre = cur.val</span><br><span class="line">        self.travsersal(cur.left)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二叉树就练习到这里了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;搜素树转累加树&quot;&gt;&lt;a href=&quot;#搜素树转累加树&quot; class=&quot;headerlink&quot; title=&quot;搜素树转累加树&quot;&gt;&lt;/a&gt;搜素树转累加树&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>23-构造搜索树</title>
    <link href="https://xxren8218.github.io/20210722/23-%E6%9E%84%E9%80%A0%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>https://xxren8218.github.io/20210722/23-%E6%9E%84%E9%80%A0%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2021-07-22T10:49:36.000Z</published>
    <updated>2021-07-22T10:55:59.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造搜索树"><a href="#构造搜索树" class="headerlink" title="构造搜索树"></a>构造搜索树</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185513.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185527.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目中说要转换为一棵高度平衡二叉搜索树。这和转换为一棵普通二叉搜索树有什么差别呢？</p><p>其实这里不用强调平衡二叉搜索树，数组构造二叉树，构成平衡树是自然而然的事情，因为大家默认都是从数组中间位置取值作为节点元素，一般不会随机取，<strong>「所以想构成不平衡的二叉树是自找麻烦」</strong>。</p><p>在【构造二叉树】和【构造一棵最大的二叉树】其实已经讲过了，如何根据数组构造一颗二叉树。</p><p><strong>「本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间」</strong>。</p><p>本题比前面的简单一些，因为有序数组构造二叉搜索树，寻找分割点就比较容易了。</p><p>分割点就是数组中间位置的节点。</p><p>那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个？</p><p>取哪一个都可以，只不过构成了不同的平衡二叉搜索树。</p><p>例如：输入：[-10,-3,0,5,9]</p><p>如下两棵树，都是这个数组的平衡二叉搜索树：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210722185541.png" alt=""></p><p>如果要分割的数组长度为偶数的时候，中间元素为两个，是取左边元素  就是树1，取右边元素就是树2。</p><p><strong>「这也是题目中强调答案不是唯一的原因。理解这一点，这道题目算是理解到位了」</strong>。</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归三部曲：</p><ul><li>确定递归函数返回值及其参数</li></ul><p>删除二叉树节点，增加二叉树节点，都是用递归函数的返回值来完成，这样是比较方便的。</p><p>相信大家如果仔细看了【搜索树中的插入操作】和【搜索树中的删除操作】，一定会对递归函数返回值的作用深有感触。</p><p>那么本题要构造二叉树，依然用递归函数的返回值来构造中节点的左右孩子。</p><p>再来看参数，首先是传入数组，然后就是左下表left和右下表right，我们在【构造二叉树】中提过，在构造二叉树的时候尽量不要重新定义左右区间数组，而是用下表来操作原数组。</p><p>所以代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左闭右闭区间[left, right]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">nums, left, right</span>):</span> </span><br></pre></td></tr></table></figure><p>这里注意，<strong>「我这里定义的是左闭右闭区间，在不断分割的过程中，也会坚持左闭右闭的区间，这又涉及到我们讲过的循环不变量」</strong>。</p><p>在【构造二叉树】讲过循环不变量。</p><ul><li>确定递归终止条件</li></ul><p>这里定义的是左闭右闭的区间，所以当区间 left &gt; right的时候，就是空节点了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> left &gt; right: <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><ul><li>确定单层递归的逻辑</li></ul><p>首先取数组中间元素的位置，不难写出<code>mid = (left + right) / 2</code>，<strong>「这么写其实有一个问题，就是数值越界，例如left和right都是最大int，这么操作就越界了，在[二分法中尤其需要注意！」</strong></p><p>所以可以这么写：<code>mid = left + ((right - left) / 2)</code></p><p>但本题leetcode的测试数据并不会越界，所以怎么写都可以。但需要有这个意识！</p><p>取了中间位置，就开始以中间位置的元素构造节点，代码：<code>root = TreeNode(nums[mid])</code>。</p><p>接着划分区间，root的左孩子接住下一层左区间的构造节点，右孩子接住下一层右区间构造的节点。</p><p>最后返回root节点，单层递归整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mid = left + ((right - left) / <span class="number">2</span>)</span><br><span class="line">root = TreeNode(nums[mid])</span><br><span class="line">root.left = traversal(nums, left, mid - <span class="number">1</span>)</span><br><span class="line">root.right = traversal(nums, mid + <span class="number">1</span>, right)</span><br><span class="line"><span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>这里<code>mid = left + ((right - left) / 2)</code>的写法相当于是如果数组长度为偶数，中间位置有两个元素，取靠左边的。</p><p>最后的整体代码如下图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.traversal(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, nums, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = left + ((right - left) / <span class="number">2</span>)</span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = self.traversal(nums, left, mid - <span class="number">1</span>)</span><br><span class="line">        root.right = self.traversal(nums, mid + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>「注意：在调用traversal的时候为什么传入的left和right为什么是0和len(nums)- 1，因为定义的区间为左闭右闭」</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>【构造二叉树】 和 【构造一棵最大的二叉树】之后，我们顺理成章的应该构造一下二叉搜索树了，一不小心还是一棵平衡二叉搜索树」</strong>。</p><p>其实思路也是一样的，不断中间分割，然后递归处理左区间，右区间，也可以说是分治。</p><p>此时相信大家应该对通过递归函数的返回值来增删二叉树很熟悉了，这也是常规操作。</p><p>在定义区间的过程中我们又一次强调了循环不变量的重要性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;构造搜索树&quot;&gt;&lt;a href=&quot;#构造搜索树&quot; class=&quot;headerlink&quot; title=&quot;构造搜索树&quot;&gt;&lt;/a&gt;构造搜索树&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>11-子集问题二</title>
    <link href="https://xxren8218.github.io/20210721/11-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E4%BA%8C.html"/>
    <id>https://xxren8218.github.io/20210721/11-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E4%BA%8C.html</id>
    <published>2021-07-21T09:07:10.000Z</published>
    <updated>2021-07-21T09:08:04.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子集问题二"><a href="#子集问题二" class="headerlink" title="子集问题二"></a>子集问题二</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170739.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目【子集问题】区别就是集合里有重复元素了，而且求取的子集要去重。</p><p>那么关于回溯算法中的去重问题，<strong>「在【组合总和II】中已经详细讲解过了，和本题是一个套路」</strong>。</p><p><strong>「剧透一下，后期要讲解的排列问题里去重也是这个套路，所以理解“树层去重”和“树枝去重”非常重要」</strong>。</p><p>用示例中的[1, 2, 2] 来举例，如图所示：（<strong>「注意去重需要先对集合排序」</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170753.jpg" alt=""></p><p>从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！</p><p>本题就是其实就是【子集问题】基础上加上了去重，去重我们在【组合总和三】也讲过了，所以我就直接给出代码了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        used = [<span class="literal">False</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        self.backtracking(nums, <span class="number">0</span>, used)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, nums, startIndex, used</span>):</span></span><br><span class="line">        self.res.append(self.path[:])</span><br><span class="line">        <span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            self.backtracking(nums, i + <span class="number">1</span>, used)</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这道题目的知识点，我们之前都讲过了，如果之前讲过的子集问题和去重问题都掌握的好，这道题目应该分分钟AC。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;子集问题二&quot;&gt;&lt;a href=&quot;#子集问题二&quot; class=&quot;headerlink&quot; title=&quot;子集问题二&quot;&gt;&lt;/a&gt;子集问题二&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>10-求子集问题</title>
    <link href="https://xxren8218.github.io/20210721/10-%E6%B1%82%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210721/10-%E6%B1%82%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98.html</id>
    <published>2021-07-21T09:05:30.000Z</published>
    <updated>2021-07-21T09:06:37.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="求子集问题"><a href="#求子集问题" class="headerlink" title="求子集问题"></a>求子集问题</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170559.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求子集问题和【求组合】和【分割问题】又不一样了。</p><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>「那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！」</strong></p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p><p><strong>「那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！」</strong></p><p>有同学问了，什么时候for可以从0开始呢？</p><p>求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续会讲到的。</p><p>以示例中nums = [1,2,3]为例把求子集抽象为树型结构，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170615.png" alt=""></p><p>从图中红线部分，可以看出<strong>「遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合」</strong>。</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数参数</li></ul><p>全局变量数组path为子集收集元素，二维数组result存放子集组合。（也可以放到递归函数参数里）</p><p>递归函数参数在上面讲到了，需要startIndex。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">path = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums, startIndex</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>从图中可以看出：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170615.png" alt=""></p><p>剩余集合为空的时候，就是叶子节点。</p><p>那么什么时候剩余集合为空呢？</p><p>就是startIndex已经大于数组的长度了，就终止了，因为没有元素可取了，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(nums):</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>「其实可以不需要加终止条件，因为startIndex &gt;= nums.size()，本层for循环本来也结束了」</strong>。</p><ul><li>单层搜索逻辑</li></ul><p><strong>「求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树」</strong>。</p><p>那么单层递归逻辑代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">    path.append(nums[i])        <span class="comment"># 子集收集元素</span></span><br><span class="line">    backtracking(nums, i + <span class="number">1</span>)   <span class="comment"># 注意从i+1开始，元素不重复取</span></span><br><span class="line">    path.pop()                  <span class="comment"># 回溯</span></span><br></pre></td></tr></table></figure><p>整体代码如下：</p><p>回溯算法模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">参数</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">       存放结果</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择：本层集合中元素（树中节点孩子的数量就是集合的大小）:</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表) <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.backtracking(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, nums, startIndex</span>):</span></span><br><span class="line">        <span class="comment"># 注意处理节点在这里</span></span><br><span class="line">        self.result.append(self.path[:])</span><br><span class="line">        <span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            self.backtracking(nums, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在注释中，可以发现可以不写终止条件，因为本来我们就要遍历整颗树。</p><p>有的同学可能担心不写终止条件会不会无限递归？</p><p>并不会，因为每次递归的下一层就是从i+1开始的。</p><p><strong>子集问题有点简单了，其实这就是一道标准的模板题。</strong></p><p>但是要清楚子集问题和组合问题、分割问题的的区别，<strong>「子集是收集树形结构中树的所有节点的结果」</strong>。</p><p><strong>「而组合问题、分割问题是收集树形结构中叶子节点的结果」</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;求子集问题&quot;&gt;&lt;a href=&quot;#求子集问题&quot; class=&quot;headerlink&quot; title=&quot;求子集问题&quot;&gt;&lt;/a&gt;求子集问题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>22-修剪一颗搜索树</title>
    <link href="https://xxren8218.github.io/20210721/22-%E4%BF%AE%E5%89%AA%E4%B8%80%E9%A2%97%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>https://xxren8218.github.io/20210721/22-%E4%BF%AE%E5%89%AA%E4%B8%80%E9%A2%97%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2021-07-21T09:03:15.000Z</published>
    <updated>2021-07-21T09:05:06.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修剪一颗搜索树"><a href="#修剪一颗搜索树" class="headerlink" title="修剪一颗搜索树"></a>修剪一颗搜索树</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170351.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170407.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个题真的不简单！</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>直接想法就是：递归处理，然后遇到 <code>root.val &lt; low or root.val &gt; high</code> 的时候直接return None，一波修改，干净利落。</p><p>不难写出如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">root, low, high</span>):</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val &lt; low <span class="keyword">or</span> root.val &gt; high: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root.left = trimBST(root.left, low, high)</span><br><span class="line">    root.right = trimBST(root.right, low, high)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>「然而[1, 3]区间在二叉搜索树的中可不是单纯的节点3和左孩子节点0就决定的，还要考虑节点0的右子树」</strong>。</p><p>我们在重新关注一下第二个示例，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170429.png" alt=""></p><p><strong>「所以以上的代码是不可行的！」</strong></p><p>从图中可以看出需要重构二叉树，想想是不是本题就有点复杂了。</p><p>其实不用重构那么复杂。</p><p>在上图中我们发现节点0并不符合区间要求，那么将节点0的右孩子 节点2 直接赋给 节点3的左孩子就可以了（就是把节点0从二叉树中移除），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170447.jpg" alt=""></p><p>理解了最关键部分了我们在递归三部曲：</p><ul><li>确定递归函数的参数以及返回值</li></ul><p>这里我们为什么需要返回值呢？</p><p>因为是要遍历整棵树，做修改，其实不需要返回值也可以，我们也可以完成修剪（其实就是从二叉树中移除节点）的操作。</p><p>但是有返回值，更方便，可以通过递归函数的返回值来移除节点。</p><p>这样的做法【搜索树中的插入操作】和【搜索树中的删除操作】中大家已经了解过了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">root, low, high</span>):</span></span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><ul><li>确定单层递归的逻辑</li></ul><p>如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">right = trimBST(root.right, low, high) <span class="comment"># 寻找符合区间[low, high]的节点</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><p>如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &gt; high:</span><br><span class="line">    left = trimBST(root.left, low, high) <span class="comment"># 寻找符合区间[low, high]的节点</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>接下来要将下一层处理完左子树的结果赋给root.left，处理完右子树的结果赋给root.right。</p><p>最后返回root节点，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root.left = trimBST(root.left, low, high) <span class="comment"># root.left接入符合条件的左孩子</span></span><br><span class="line">root.right = trimBST(root.right, low, high) <span class="comment"># root.right接入符合条件的右孩子</span></span><br><span class="line"><span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>此时大家是不是还没发现这多余的节点究竟是如何从二叉树中移除的呢？</p><p>在回顾一下上面的代码，针对下图中二叉树的情况</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210721170447.jpg" alt=""></p><p>如下代码相当于把节点0的右孩子（节点2）返回给上一层，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">right = trimBST(root.right, low, high) <span class="comment"># 寻找符合区间[low, high]的节点</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><p>然后如下代码相当于用节点3的左孩子 把下一层返回的 节点0的右孩子（节点2） 接住。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.left = trimBST(root.left, low, high)</span><br></pre></td></tr></table></figure><p>此时节点3的右孩子就变成了节点2，将节点0从二叉树中移除了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">self, root, low, high</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type low: int</span></span><br><span class="line"><span class="string">        :type high: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">            right = self.trimBST(root.right, low, high)</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; high:</span><br><span class="line">            left = self.trimBST(root.left, low, high)</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        root.left = self.trimBST(root.left, low, high)</span><br><span class="line">        root.right = self.trimBST(root.right, low, high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>因为二叉搜索树的有序性，不需要使用栈模拟递归的过程。</p><p>在剪枝的时候，可以分为三步：</p><ul><li>将root移动到[L, R] 范围内，注意是左闭右闭区间</li><li>剪枝左子树</li><li>剪枝右子树</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">self, root, low, high</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type low: int</span></span><br><span class="line"><span class="string">        :type high: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">and</span> (root.val &lt; low <span class="keyword">or</span> root.val &gt; high):</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; low: root = root.right <span class="comment"># 小于L往右走</span></span><br><span class="line">            <span class="keyword">else</span>: root = root.left               <span class="comment"># 大于R往右走</span></span><br><span class="line"></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="comment"># 此时root已经在[L, R] 范围内，处理左孩子元素小于L的情况</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur.left <span class="keyword">and</span> cur.left.val &lt; low:</span><br><span class="line">                cur.left = cur.left.right</span><br><span class="line">            </span><br><span class="line">            cur = cur.left</span><br><span class="line"></span><br><span class="line">        cur = root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时root已经在[L, R] 范围内，处理右孩子大于R的情况</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur.right <span class="keyword">and</span> cur.right.val &gt; high:</span><br><span class="line">                cur.right = cur.right.left</span><br><span class="line"></span><br><span class="line">            cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>修剪二叉搜索树其实并不难，但在递归法中大家可看出我费了很大的功夫来讲解如何删除节点的，这个思路其实是比较绕的。</p><p>最终的代码倒是很简洁。</p><p><strong>「如果不对递归有深刻的理解，这道题目还是有难度的！」</strong></p><p>本题我依然给出递归法和迭代法，初学者掌握递归就可以了，如果想进一步学习，就把迭代法也写一写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;修剪一颗搜索树&quot;&gt;&lt;a href=&quot;#修剪一颗搜索树&quot; class=&quot;headerlink&quot; title=&quot;修剪一颗搜索树&quot;&gt;&lt;/a&gt;修剪一颗搜索树&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/bl</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>09-复原ip地址</title>
    <link href="https://xxren8218.github.io/20210720/09-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80.html"/>
    <id>https://xxren8218.github.io/20210720/09-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80.html</id>
    <published>2021-07-20T09:29:08.000Z</published>
    <updated>2021-07-20T09:30:42.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复原ip地址"><a href="#复原ip地址" class="headerlink" title="复原ip地址"></a>复原ip地址</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210720172946.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>做这道题目之前，最好先把【分割回文串】这个做了。</p><p>这道题目相信大家刚看的时候，应该会一脸茫然。</p><p>其实只要意识到这是切割问题，<strong>「切割问题就可以使用回溯搜索法把所有可能性搜出来」</strong>，和刚做过的【分割回文串】十分类似了。</p><p>切割问题可以抽象为树型结构，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210720173000.png" alt=""></p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归参数</li></ul><p>在【分割回文串】中我们就提到切割问题类似组合问题。</p><p>startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。</p><p>本题我们还需要一个变量pointNum，记录添加逗点的数量。</p><p>所以代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []  <span class="comment"># 记录结果</span></span><br><span class="line"><span class="comment"># startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">s, startIndex, pointNum</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>终止条件和【分割回文串】情况就不同了，本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是<strong>分割的段数作为终止条件。</strong></p><p>pointNum表示逗点数量，pointNum为3说明字符串分成了4段了。</p><p>然后验证一下第四段是否合法，如果合法就加入到结果集里</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pointNum == <span class="number">3</span>:  <span class="comment"># 逗点数量为3时，分隔结束</span></span><br><span class="line">    <span class="comment"># 判断第四段子字符串是否合法，如果合法就放进result中</span></span><br><span class="line">    <span class="keyword">if</span> isValid(s, startIndex, <span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">        result.append(s)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>单层搜索的逻辑</li></ul><p>在【分割回文串】中已经讲过在循环遍历中如何截取子串。</p><p>在<code>for i in range(startIndex, len(s)):</code>循环中 [startIndex, i]这个区间就是截取的子串，需要判断这个子串是否合法。</p><p>如果合法就在字符串后面加上符号<code>.</code>表示已经分割。</p><p>如果不合法就结束本层循环，如图中剪掉的分支：</p><p><img src="C:\Users\Administrator\Desktop\剑指\04_回溯法\09\2.png" alt=""></p><p>然后就是递归和回溯的过程：</p><p>递归调用时，下一层递归的startIndex要从i+2开始（因为需要在字符串中加入了分隔符<code>.</code>），同时记录分割符的数量pointNum 要 +1。</p><p>回溯的时候，就将刚刚加入的分隔符<code>.</code> 删掉就可以了，pointNum也要-1。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">if</span> isValid(s, startIndex, i):            <span class="comment"># 判断 [startIndex,i] 这个区间的子串是否合法</span></span><br><span class="line">            </span><br><span class="line">        tmp = <span class="built_in">list</span>(s)                        <span class="comment"># 在i的后面插入一个逗点</span></span><br><span class="line">        tmp.insert(i + <span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span>.join(tmp)</span><br><span class="line">        pointNum += <span class="number">1</span></span><br><span class="line">        backtracking(s, i + <span class="number">2</span>, pointNum)     <span class="comment"># 插入逗点之后下一个子串的起始位置为i+2</span></span><br><span class="line">        pointNum -= <span class="number">1</span>                        <span class="comment"># 回溯</span></span><br><span class="line">        tmp = <span class="built_in">list</span>(s)</span><br><span class="line">        tmp.pop(i + <span class="number">1</span>)</span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span>.join(tmp)                     <span class="comment"># 回溯删掉逗点</span></span><br><span class="line">                   </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span>                                <span class="comment"># 不合法，直接结束本层循环</span></span><br></pre></td></tr></table></figure><h3 id="判断子串是否合法"><a href="#判断子串是否合法" class="headerlink" title="判断子串是否合法"></a>判断子串是否合法</h3><p>最后就是在写一个判断段位是否是有效段位了。</p><p>主要考虑到如下三点：</p><ul><li>以0为开头的数字不合法</li><li>含有非整数的字符不合法</li><li>大于255不合法</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">s, start, end</span>):</span></span><br><span class="line">    <span class="keyword">if</span> start &gt; end:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> s[start] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> start != end:  <span class="comment">#  0开头的数字不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i] &gt; <span class="string">&#x27;9&#x27;</span> <span class="keyword">or</span> s[i] &lt; <span class="string">&#x27;0&#x27;</span>:      <span class="comment"># 遇到非数字字符不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        num = num * <span class="number">10</span> + (<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> num &gt; <span class="number">255</span>:                     <span class="comment"># 如果大于255了不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据回溯算法的模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">参数</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">       存放结果</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择：本层集合中元素（树中节点孩子的数量就是集合的大小）:</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表)  <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.backtracking(s, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, s, startIndex, pointNum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pointNum == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> self.isValid(s, startIndex, <span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">                self.result.append(s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> self.isValid(s, startIndex, i):</span><br><span class="line">                tmp = <span class="built_in">list</span>(s)                        <span class="comment"># 在i的后面插入一个逗点</span></span><br><span class="line">                tmp.insert(i + <span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                s = <span class="string">&#x27;&#x27;</span>.join(tmp)</span><br><span class="line">                pointNum += <span class="number">1</span></span><br><span class="line">                self.backtracking(s, i + <span class="number">2</span>, pointNum)     <span class="comment"># 插入逗点之后下一个子串的起始位置为i+2</span></span><br><span class="line">                pointNum -= <span class="number">1</span>                        <span class="comment"># 回溯</span></span><br><span class="line">                tmp = <span class="built_in">list</span>(s)</span><br><span class="line">                tmp.pop(i + <span class="number">1</span>)</span><br><span class="line">                s = <span class="string">&#x27;&#x27;</span>.join(tmp)                     <span class="comment"># 回溯删掉逗点</span></span><br><span class="line">                   </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s, start, end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> s[start] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> start != end:  <span class="comment">#  0开头的数字不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] &gt; <span class="string">&#x27;9&#x27;</span> <span class="keyword">or</span> s[i] &lt; <span class="string">&#x27;0&#x27;</span>:       <span class="comment"># 遇到非数字字符不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            num = num * <span class="number">10</span> + (<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">255</span>:                     <span class="comment"># 如果大于255了不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在【分割回文串】列举的分割字符串的难点，本题都覆盖了。</p><p>而且本题还需要操作字符串添加逗号作为分隔符，并验证区间的合法性。</p><p>可以说是【分割回文串】的加强版。</p><p>在本文的树形结构图中，我已经把详细的分析思路都画了出来，相信大家看了之后一定会思路清晰不少！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;复原ip地址&quot;&gt;&lt;a href=&quot;#复原ip地址&quot; class=&quot;headerlink&quot; title=&quot;复原ip地址&quot;&gt;&lt;/a&gt;复原ip地址&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>21-搜索树中的删除操作</title>
    <link href="https://xxren8218.github.io/20210720/21-%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html"/>
    <id>https://xxren8218.github.io/20210720/21-%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html</id>
    <published>2021-07-20T09:27:18.000Z</published>
    <updated>2021-07-20T09:28:42.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜索树中的删除操作"><a href="#搜索树中的删除操作" class="headerlink" title="搜索树中的删除操作"></a>搜索树中的删除操作</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210720172757.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210720172811.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>递归三部曲：</p><ul><li>确定递归函数参数以及返回值</li></ul><p>说道递归函数的返回值，在【搜索树中的插入操作】中通过递归返回值来加入新节点， 这里也可以通过递归返回值删除节点。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">root, key</span>) </span></span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>遇到空返回，其实这也说明没找到删除的节点，遍历到空节点直接返回了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><ul><li>确定单层递归的逻辑</li></ul><p>这里就把平衡二叉树中删除节点遇到的情况都搞清楚。</p><p>有以下五种情况：</p><ul><li><p>第一种情况：没找到删除的节点，遍历到空节点直接返回了</p></li><li><p>找到删除的节点</p></li><li><ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210720172825.gif" alt=""></p><p>动画中颗二叉搜索树中，删除元素7， 那么删除节点（元素7）的左孩子就是5，删除节点（元素7）的右子树的最左面节点是元素8。</p><p>将删除节点（元素7）的左孩子放到删除节点（元素7）的右子树的最左面节点（元素8）的左孩子上，就是把5为根节点的子树移到了8的左孩子的位置。</p><p>要删除的节点（元素7）的右孩子（元素9）为新的根节点。.</p><p>这样就完成删除元素7的逻辑，最好动手画一个图，尝试删除一个节点试试。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val == key:</span><br><span class="line">    <span class="comment"># 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">    <span class="comment"># 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left: <span class="keyword">return</span> root.right </span><br><span class="line">    <span class="comment"># 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> root.left </span><br><span class="line">    <span class="comment"># 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">    <span class="comment"># 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        cur = root.right <span class="comment"># 找右子树最左面的节点</span></span><br><span class="line">        <span class="keyword">while</span> cur.left: </span><br><span class="line">            cur = cur.left</span><br><span class="line"></span><br><span class="line">        cur.left = root.left    <span class="comment"># 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class="line">        tmp = root              <span class="comment"># 把root节点保存一下，下面来删除</span></span><br><span class="line">        root = root.right       <span class="comment"># 返回旧root的右孩子作为新root</span></span><br><span class="line">        <span class="keyword">del</span> tmp                 <span class="comment"># 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>这里相当于把新的节点返回给上一层，上一层就要用 root.left 或者 root.right接住，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &gt; key: root.left = deleteNode(root.left, key)</span><br><span class="line"><span class="keyword">if</span> root.val &lt; key: root.right = deleteNode(root.right, key)</span><br><span class="line"><span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>「整体代码如下：（注释中：情况1，2，3，4，5和上面分析严格对应）」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.val == key:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left: <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = root.right</span><br><span class="line">                <span class="keyword">while</span> cur.left:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                </span><br><span class="line">                cur.left = root.left</span><br><span class="line">                tmp = root</span><br><span class="line">                root = root.right </span><br><span class="line">                <span class="keyword">del</span> tmp</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key: root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key: root.left = self.deleteNode(root.left, key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>读完本篇，大家会发现二叉搜索树删除节点比增加节点复杂的多。</p><p><strong>「因为二叉搜索树添加节点只需要在叶子上添加就可以的，不涉及到结构的调整，而删除节点操作涉及到结构的调整」</strong>。</p><p>这里我们依然使用递归函数的返回值来完成把节点从二叉树中移除的操作。</p><p><strong>「这里最关键的逻辑就是第五种情况（删除一个左右孩子都不为空的节点），这种情况一定要想清楚」</strong>。</p><p>而且就算想清楚了，对应的代码也未必可以写出来，所以<strong>「这道题目即考察思维逻辑，也考察代码能力」</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;搜索树中的删除操作&quot;&gt;&lt;a href=&quot;#搜索树中的删除操作&quot; class=&quot;headerlink&quot; title=&quot;搜索树中的删除操作&quot;&gt;&lt;/a&gt;搜索树中的删除操作&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxre</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>08-分割回文串</title>
    <link href="https://xxren8218.github.io/20210719/08-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html"/>
    <id>https://xxren8218.github.io/20210719/08-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html</id>
    <published>2021-07-19T09:36:53.000Z</published>
    <updated>2021-07-19T09:38:12.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173728.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题涉及到两个关键问题：</p><ol><li>切割问题，有不同的切割方式</li><li>判断回文</li></ol><p>相信这里不同的切割方式可以搞懵很多同学了。</p><p>这种题目，想用for循环暴力解法，可能都不那么容易写出来，所以要换一种暴力的方式，就是回溯。</p><p>一些同学可能想不清楚 回溯究竟是如果切割字符串呢？</p><p>我们来分析一下切割，<strong>「其实切割问题类似组合问题」</strong>。</p><p>例如对于字符串abcdef：</p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选取第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li></ul><p>感受出来了不？</p><p>所以切割问题，也可以抽象为一颗树形结构，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173742.png" alt=""></p><p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p><p>此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数参数</li></ul><p>全局变量数组path存放切割后回文的子串，数组result存放结果集。（这两个参数可以放到函数参数里）</p><p>本题递归函数参数还需要startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。</p><p>在【求组合总和二】中我们深入探讨了组合问题什么时候需要startIndex，什么时候不需要startIndex。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">path = [] <span class="comment"># 放已经回文的子串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span> (<span class="params">s, startIndex</span>):</span></span><br></pre></td></tr></table></figure><ul><li>递归函数终止条件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173742.png" alt=""></p><p>从树形结构的图中可以看出：切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止终止条件。</p><p><strong>「那么在代码里什么是切割线呢？」</strong></p><p>在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。</p><p>所以终止条件代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span> (<span class="params">s, startIndex</span>):</span></span><br><span class="line">    <span class="comment"># 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span></span><br><span class="line">    <span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(s):</span><br><span class="line">        result.append(path)</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>单层搜索的逻辑</li></ul><p><strong>「来看看在递归循环，中如何截取子串呢？」</strong></p><p>在<code>for i in range(startIndex, len(s)):</code>循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。</p><p>首先判断这个子串是不是回文，如果是回文，就加入在<code>path</code>中，path用来记录切割过的回文子串。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="comment"># 是回文子串</span></span><br><span class="line">    <span class="keyword">if</span> isPalindrome(s, startIndex, i): </span><br><span class="line">        <span class="comment"># 获取[startIndex,i]在s中的子串</span></span><br><span class="line">        Str = s[startIndex, i - startIndex + <span class="number">1</span>]</span><br><span class="line">        path.append(Str)</span><br><span class="line">    <span class="keyword">else</span>:                <span class="comment"># 如果不是则直接跳过</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">   </span><br><span class="line">    backtracking(s, i + <span class="number">1</span>) <span class="comment"># 寻找i+1为起始位置的子串</span></span><br><span class="line">    path.pop()        <span class="comment"># 回溯过程，弹出本次已经填在的子串</span></span><br></pre></td></tr></table></figure><p><strong>「注意切割过的位置，不能重复切割，所以，backtracking(s, i + 1); 传入下一层的起始位置为i + 1」</strong>。</p><h3 id="判断回文子串"><a href="#判断回文子串" class="headerlink" title="判断回文子串"></a>判断回文子串</h3><p>最后我们看一下回文子串要如何判断了，判断一个字符串是否是回文。</p><p>可以使用双指针法，一个指针从前向后，一个指针从后先前，如果前后指针所指向的元素是相等的，就是回文字符串了。</p><p>那么判断回文的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">s, start, end</span>):</span></span><br><span class="line">    i, j = start, end</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[j]):</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>此时关键代码已经讲解完毕.</p><p>根据回溯算法模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def backtracking(参数) &#123;</span><br><span class="line">    <span class="keyword">if</span> 终止条件:</span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择：本层集合中元素（树中节点孩子的数量就是集合的大小）:</span><br><span class="line">        处理节点</span><br><span class="line">        backtracking(路径，选择列表) <span class="comment"># 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br></pre></td></tr></table></figure><p>不难写出如下代码：</p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.backtracking(s, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, s, startIndex</span>):</span></span><br><span class="line">        <span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(s):</span><br><span class="line">            self.result.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> self.isPalandrome(s, startIndex, i):</span><br><span class="line">                Str = s[startIndex: i + <span class="number">1</span>]</span><br><span class="line">                self.path.append(Str)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            self.backtracking(s, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalandrome</span>(<span class="params">self, s, start, end</span>):</span></span><br><span class="line">        i, j = start, end</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题目在leetcode上是中等，但可以说是hard的题目了，但是代码其实就是按照模板的样子来的。</p><p>那么难究竟难在什么地方呢？</p><p><strong>「我列出如下几个难点：」</strong></p><ul><li>切割问题可以抽象为组合问题</li><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><p><strong>「我们平时在做难题的时候，总结出来难究竟难在哪里也是一种需要锻炼的能力」</strong>。</p><p>一些同学可能遇到题目比较难，但是不知道题目难在哪里，反正就是很难。其实这样还是思维不够清晰，这种总结的能力需要多接触多锻炼。</p><p><strong>「本题我相信很多同学主要卡在了第一个难点上：就是不知道如何切割，甚至知道要用回溯法，也不知道如何用。也就是没有体会到按照求组合问题的套路就可以解决切割」</strong>。</p><p>如果意识到这一点，算是重大突破了。接下来就可以对着模板照葫芦画瓢。</p><p><strong>「但接下来如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了」</strong>。</p><p>除了这些难点，<strong>「本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1」</strong>。</p><p>所以本题应该是一个道hard题目了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分割回文串&quot;&gt;&lt;a href=&quot;#分割回文串&quot; class=&quot;headerlink&quot; title=&quot;分割回文串&quot;&gt;&lt;/a&gt;分割回文串&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogimages</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>20-搜索树中的插入操作</title>
    <link href="https://xxren8218.github.io/20210719/20-%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html"/>
    <id>https://xxren8218.github.io/20210719/20-%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html</id>
    <published>2021-07-19T09:35:24.000Z</published>
    <updated>2021-07-19T09:36:34.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜索树中的插入操作"><a href="#搜索树中的插入操作" class="headerlink" title="搜索树中的插入操作"></a>搜索树中的插入操作</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173551.PNG" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173604.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实这道题目其实是一道简单题目，<strong>「但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人」</strong>，瞬间感觉题目复杂了很多。</p><p>其实<strong>「可以不考虑题目中提示所说的改变树的结构的插入方式。」</strong></p><p>如下演示视频中可以看出：只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173621.gif" alt=""></p><p>例如插入元素10 ，需要找到末尾节点插入便可，一样的道理来插入元素15，插入元素0，插入元素6，<strong>「需要调整二叉树的结构么？并不需要。」</strong>。</p><p>只要遍历二叉搜索树，找到空节点 插入元素就可以了，那么这道题其实就简单了。</p><p>接下来就是遍历二叉搜索树的过程了。</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归三部曲：</p><ul><li>确定递归函数参数以及返回值</li></ul><p>参数就是根节点指针，以及要插入元素，这里递归函数要不要有返回值呢？</p><p>可以有，也可以没有，但递归函数如果没有返回值的话，实现是比较麻烦的，下面也会给出其具体实现代码。</p><p><strong>「有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作」</strong>。（下面会进一步解释）</p><p>递归函数的返回类型为节点类型 。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">root, val</span>) </span></span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>终止条件就是找到遍历的节点为None的时候，就是要插入节点的位置了，并把插入的节点返回。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">    node = TreeNode(val)</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p>这里把添加的节点返回给上一层，就完成了父子节点的赋值操作了，详细再往下看。</p><ul><li>确定单层递归的逻辑</li></ul><p>此时要明确，需要遍历整棵树么？</p><p>别忘了这是搜索树，遍历整颗搜索树简直是对搜索树的侮辱，哈哈。</p><p>搜索树是有方向了，可以根据插入元素的数值，决定递归方向。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root.val &gt; val: </span><br><span class="line">    root.left = insertIntoBST(root.left, val)</span><br><span class="line">if root-&gt;val &lt; val: </span><br><span class="line">    root.right = insertIntoBST(root.right, val)</span><br><span class="line"><span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>「到这里，大家应该能感受到，如何通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root.left或者root.right将其接住」</strong>。</p><p>整体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            node = TreeNode(val)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            root.left = self.insertIntoBST(root.left, val)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            root.right = self.insertIntoBST(root.right, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>再来看看迭代法，对二叉搜索树迭代写法不熟悉，可以看：【二叉搜索树】</p><p>在迭代法遍历的过程中，需要记录一下当前遍历的节点的父节点，这样才能做插入节点的操作。</p><p>在【搜索树的最小绝对差】和【二叉树的众数】中，都是用了记录pre和cur两个指针的技巧，本题也是一样的。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            node = TreeNode(val)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        parent = root</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            parent = cur</span><br><span class="line">            <span class="keyword">if</span> cur.val &gt; val: </span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">        node = TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> val &lt; parent.val:</span><br><span class="line">            parent.left = node</span><br><span class="line">        <span class="keyword">if</span> val &gt; parent.val:</span><br><span class="line">            parent.right = node </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先在二叉搜索树中的插入操作，大家不用恐惧其重构搜索树，其实根本不用重构。</p><p>然后在递归中，我们重点讲了如果通过递归函数的返回值完成新加入节点和其父节点的赋值操作，并强调了搜索树的有序性。</p><p>最后依然给出了迭代的方法，迭代的方法就需要记录当前遍历节点的父节点了，这个和没有返回值的递归函数实现的代码逻辑是一样的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;搜索树中的插入操作&quot;&gt;&lt;a href=&quot;#搜索树中的插入操作&quot; class=&quot;headerlink&quot; title=&quot;搜索树中的插入操作&quot;&gt;&lt;/a&gt;搜索树中的插入操作&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxre</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>19-搜索树的公共祖先问题</title>
    <link href="https://xxren8218.github.io/20210719/19-%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210719/19-%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98.html</id>
    <published>2021-07-19T09:33:30.000Z</published>
    <updated>2021-07-19T09:35:07.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜索树的公共祖先问题"><a href="#搜索树的公共祖先问题" class="headerlink" title="搜索树的公共祖先问题"></a>搜索树的公共祖先问题</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173438.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>做过【公共祖先问题】题目的同学应该知道，利用回溯从底向上搜索，遇到一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。</p><p>那么本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。</p><p>在有序树里，如果判断一个节点的左子树里有p，右子树里有q呢？</p><p>其实只要从上到下遍历的时候，cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了。</p><p>理解这一点，本题就很好解了。</p><p>和【公共祖先问题】不同，普通二叉树求最近公共祖先需要使用回溯，从底向上来查找，二叉搜索树就不用了，因为搜索树有序（相当于自带方向），那么只要从上向下遍历就可以了。</p><p>那么我们可以采用前序遍历（其实这里没有中节点的处理逻辑，遍历顺序无所谓了）。</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210719173452.png" alt=""></p><p>可以看出直接按照指定的方向，就可以找到节点4，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！</p><p>递归三部曲如下：</p><ul><li>确定递归函数返回值以及参数</li></ul><p>参数就是 当前节点，以及两个结点 p、q。</p><p>返回值是要返回最近公共祖先，所以是  。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">cur, p, q</span>) </span></span><br></pre></td></tr></table></figure><ul><li>确定终止条件</li></ul><p>遇到空返回就可以了，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>其实都不需要这个终止条件，因为题目中说了p、q 为不同节点且均存在于给定的二叉搜索树中。也就是说一定会找到公共祖先的，所以并不存在遇到空的情况。</p><ul><li>确定单层递归的逻辑</li></ul><p>在遍历二叉搜索树的时候就是寻找区间[p.val, q.val]（注意这里是左闭右闭）</p><p>那么如果 cur.val 大于 p.val，同时 cur.val 大于q.val，那么就应该向左遍历（说明目标区间在左子树上）。</p><p><strong>「需要注意的是此时不知道p和q谁大，所以两个都要判断」</strong></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cur.val &gt; p.val <span class="keyword">and</span> cur.val &gt; q.val:</span><br><span class="line">    left = traversal(cur.left, p, q)</span><br><span class="line">    <span class="keyword">if</span> left:</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>「细心的同学会发现，在这里调用递归函数的地方，把递归函数的返回值left，直接return」</strong>。</p><p>在【公共祖先问题】中，如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树。</p><p>搜索一条边的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 递归函数(root.left)： <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 递归函数(root.right)： <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>搜索整个树写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root.left)</span><br><span class="line">right = 递归函数(root.right)</span><br><span class="line">left与right的逻辑处理</span><br></pre></td></tr></table></figure><p>本题就是标准的搜索一条边的写法，遇到递归函数的返回值，如果不为空，立刻返回。</p><p>如果 cur.val 小于 p.val，同时 cur.val 小于 q.val，那么就应该向右遍历（目标区间在右子树）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cur.val &lt; p.val <span class="keyword">and</span> cur.val &lt; q.val:</span><br><span class="line">    right = traversal(cur.right, p, q)</span><br><span class="line">    <span class="keyword">if</span> right:</span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><p>剩下的情况，就是cur节点在区间（p.val &lt;=  cur.val and cur.val &lt;= q.val）或者 （q.val &lt;=  cur.val and cur.val &lt;= p.val）中，那么cur就是最近公共祖先了，直接返回cur。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><p>那么整体递归代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.traversal(root, p, q)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, cur, p, q</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; p.val <span class="keyword">and</span> cur.val &lt; q.val:</span><br><span class="line">            right = self.traversal(cur.right, p, q)</span><br><span class="line">            <span class="keyword">if</span> right: <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">elif</span> cur.val &gt; p.val <span class="keyword">and</span> cur.val &gt; q.val:</span><br><span class="line">            left = self.traversal(cur.left, p, q)</span><br><span class="line">            <span class="keyword">if</span> left: <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>对于二叉搜索树的迭代法，大家应该在【二叉搜索树】就了解了。</p><p>利用其有序性，迭代的方式还是比较简单的，解题思路在递归中已经分析了。</p><p>迭代代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">elif</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>灵魂拷问：是不是又被简单的迭代法感动到痛哭流涕？</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于二叉搜索树的最近祖先问题，其实要比【普通二叉树公共祖先问题】简单的多。</p><p>不用使用回溯了，二叉搜索树自带方向性，可以方便的从上向下查找目标区间，遇到目标区间内的节点，直接返回。</p><p>最后给出了对应的迭代法，二叉搜索树的迭代法甚至比递归更容易理解，也是因为其有序性（自带方向性），按照目标区间找就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;搜索树的公共祖先问题&quot;&gt;&lt;a href=&quot;#搜索树的公共祖先问题&quot; class=&quot;headerlink&quot; title=&quot;搜索树的公共祖先问题&quot;&gt;&lt;/a&gt;搜索树的公共祖先问题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/</summary>
      
    
    
    
    <category term="二叉树" scheme="https://xxren8218.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>07-求组和总和三</title>
    <link href="https://xxren8218.github.io/20210716/07-%E6%B1%82%E7%BB%84%E5%92%8C%E6%80%BB%E5%92%8C%E4%B8%89.html"/>
    <id>https://xxren8218.github.io/20210716/07-%E6%B1%82%E7%BB%84%E5%92%8C%E6%80%BB%E5%92%8C%E4%B8%89.html</id>
    <published>2021-07-16T14:26:03.000Z</published>
    <updated>2021-07-16T14:27:16.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="求组合总和三"><a href="#求组合总和三" class="headerlink" title="求组合总和三"></a>求组合总和三</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222634.PNG" alt=""></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目和【组合总和】如下区别：</p><ol><li>本题candidates 中的每个数字在每个组合中只能使用一次。</li><li>本题数组candidates的元素是有重复的，而【组合总和】是无重复元素的数组candidates</li></ol><p>最后本题和【组合总和】要求一样，解集不能包含重复的组合。</p><p><strong>「本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合」</strong>。</p><p>一些同学可能想了：我把所有组合求出来，再用set或者map去重，这么做很容易超时！</p><p>所以要在搜索的过程中就去掉重复组合。</p><p>很多同学在去重的问题上想不明白，其实很多题解也没有讲清楚，反正代码是能过的，感觉是那么回事，稀里糊涂的先把题目过了。</p><p>这个去重为什么很难理解呢，<strong>「所谓去重，其实就是使用过的元素不能重复选取。」</strong>这么一说好像很简单！</p><p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<strong>「没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。」</strong></p><p>那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？</p><p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>「所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重」</strong>。</p><p>为了理解去重我们来举一个例子，candidates = [1, 1, 2], target = 3，（方便起见candidates已经排序了）</p><p>选择过程树形结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222650.png" alt=""></p><p>可以看到图中，每个节点相对于 【组合总和】我多加了used数组，这个used数组下面会重点介绍。</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li><strong>「递归函数参数」</strong></li></ul><p>与【组合总和】套路相同，此题还需要加一个bool型数组used，用来记录同一树枝上的元素是否使用过。</p><p>这个集合去重的重任就是used来完成的。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []                 <span class="comment"># 存放组合集合</span></span><br><span class="line">path = []                   <span class="comment"># 符合条件的组合</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">candidates, target, Sum, startIndex, used</span>):</span></span><br></pre></td></tr></table></figure><ul><li><strong>「递归终止条件」</strong></li></ul><p>与【组合总和】套路相同，终止条件为 <code>sum &gt; target</code> 和 <code>sum == target</code>。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> Sum &gt; target:     <span class="comment"># 这个条件其实可以省略 </span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Sum == target: </span><br><span class="line">    result.append(path)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>Sum &gt; target</code> 这个条件其实可以省略，因为和在递归单层遍历的时候，会有剪枝的操作，下面会介绍到。</p><ul><li><strong>「单层搜索的逻辑」</strong></li></ul><p>这里与【组合总和】最大的不同就是要去重了。</p><p>前面我们提到：要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。</p><p><strong>「如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == False</code>，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]」</strong>。</p><p>此时for循环里就应该做continue的操作。</p><p>这块比较抽象，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210716222705.png" alt=""></p><p>我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：</p><ul><li>used[i - 1] == True，说明同一树支candidates[i - 1]使用过</li><li>used[i - 1] == False，说明同一树层candidates[i - 1]使用过</li></ul><p><strong>「这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！」</strong></p><p>那么单层搜索的逻辑代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">    <span class="keyword">if</span> Sum + candidates[i] &lt;= target:</span><br><span class="line">    <span class="comment"># used[i - 1] == True，说明同一树支candidates[i - 1]使用过</span></span><br><span class="line">    <span class="comment"># used[i - 1] == False，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">    <span class="comment"># 要对同一树层使用过的元素进行跳过</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        Sum += candidates[i]</span><br><span class="line">        path.append(candidates[i])</span><br><span class="line">        used[i] = <span class="literal">True</span></span><br><span class="line">        backtracking(candidates, target, Sum, i + <span class="number">1</span>, used) <span class="comment"># 和组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次</span></span><br><span class="line">        used[i] = <span class="literal">False</span></span><br><span class="line">        Sum -= candidates[i]</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure><p><strong>「注意sum + candidates[i] &lt;= target为剪枝操作，在【组合总和】有讲解过！」</strong></p><p>整体代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates: <span class="keyword">return</span> []</span><br><span class="line">        used = [<span class="literal">False</span>]*<span class="built_in">len</span>(candidates)</span><br><span class="line">        <span class="comment"># 首先把给candidates排序，让其相同的元素都挨在一起。</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>, used)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">self, candidates, target, Sum, startIndex, used</span>):</span></span><br><span class="line">        <span class="keyword">if</span> Sum == target: self.result.append(self.path[:])</span><br><span class="line">        <span class="keyword">if</span> Sum &gt; target: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>] <span class="keyword">and</span> used[i - <span class="number">1</span>] == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.path.append(candidates[i])</span><br><span class="line">            Sum += candidates[i]</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            self.backtracking(candidates, target, Sum, i + <span class="number">1</span>, used)</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line">            Sum -= candidates[i]</span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题同样是求组合总和，但就是因为其数组candidates有重复元素，而要求不能有重复的组合，所以相对于【组合求和】难度提升了不少。</p><p><strong>「关键是去重的逻辑，代码很简单，网上一搜一大把，但几乎没有能把这块代码含义讲明白的，基本都是给出代码，然后说这就是去重了，究竟怎么个去重法也是模棱两可」</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;求组合总和三&quot;&gt;&lt;a href=&quot;#求组合总和三&quot; class=&quot;headerlink&quot; title=&quot;求组合总和三&quot;&gt;&lt;/a&gt;求组合总和三&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xxren8218/blogim</summary>
      
    
    
    
    <category term="回溯法" scheme="https://xxren8218.github.io/categories/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
