<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-06-10T09:41:33.976Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>08-算法实现：Item-Based CF 预测评分</title>
    <link href="https://xxren8218.github.io/20210610/08-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9AItem-Based-CF-%E9%A2%84%E6%B5%8B%E8%AF%84%E5%88%86.html"/>
    <id>https://xxren8218.github.io/20210610/08-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9AItem-Based-CF-%E9%A2%84%E6%B5%8B%E8%AF%84%E5%88%86.html</id>
    <published>2021-06-10T09:40:42.000Z</published>
    <updated>2021-06-10T09:41:33.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="案例—算法实现：Item-Based-CF-预测评分"><a href="#案例—算法实现：Item-Based-CF-预测评分" class="headerlink" title="案例—算法实现：Item-Based CF 预测评分"></a>案例—算法实现：Item-Based CF 预测评分</h2><p><strong>评分预测公式：</strong></p><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{j\in I_{rated}}sim(i,j)*r_{uj}}{\sum_{j\in I_{rated}}sim(i,j)}</script><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><ul><li><p>实现评分预测方法：<code>predict</code></p><ul><li><p>方法说明：</p><p>利用原始评分矩阵、以及物品间两两相似度，预测指定用户对指定物品的评分。</p><p>如果无法预测，则抛出异常</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">uid, iid, ratings_matrix, item_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测给定用户对给定物品的评分值</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param iid: 物品ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :param item_similar: 物品两两相似度矩阵</span></span><br><span class="line"><span class="string">    :return: 预测的评分值</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&quot;开始预测用户&lt;%d&gt;对电影&lt;%d&gt;的评分...&quot;</span>%(uid, iid))</span><br><span class="line">    <span class="comment"># 1. 找出iid物品的相似物品</span></span><br><span class="line">    similar_items = item_similar[iid].drop([iid]).dropna()</span><br><span class="line">    <span class="comment"># 相似物品筛选规则：正相关的物品</span></span><br><span class="line">    similar_items = similar_items.where(similar_items&gt;<span class="number">0</span>).dropna()</span><br><span class="line">    <span class="keyword">if</span> similar_items.empty <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;物品&lt;%d&gt;没有相似的物品&quot;</span> %<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 从iid物品的近邻相似物品中筛选出uid用户评分过的物品</span></span><br><span class="line">    ids = <span class="built_in">set</span>(ratings_matrix.ix[uid].dropna().index)&amp;<span class="built_in">set</span>(similar_items.index)</span><br><span class="line">    finally_similar_items = similar_items.ix[<span class="built_in">list</span>(ids)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 结合iid物品与其相似物品的相似度和uid用户对其相似物品的评分，预测uid对iid的评分</span></span><br><span class="line">    sum_up = <span class="number">0</span>    <span class="comment"># 评分预测公式的分子部分的值</span></span><br><span class="line">    sum_down = <span class="number">0</span>    <span class="comment"># 评分预测公式的分母部分的值</span></span><br><span class="line">    <span class="keyword">for</span> sim_iid, similarity <span class="keyword">in</span> finally_similar_items.iteritems():</span><br><span class="line">        <span class="comment"># 近邻物品的评分数据</span></span><br><span class="line">        sim_item_rated_movies = ratings_matrix[sim_iid].dropna()</span><br><span class="line">        <span class="comment"># uid用户对相似物品物品的评分</span></span><br><span class="line">        sim_item_rating_from_user = sim_item_rated_movies[uid]</span><br><span class="line">        <span class="comment"># 计算分子的值</span></span><br><span class="line">        sum_up += similarity * sim_item_rating_from_user</span><br><span class="line">        <span class="comment"># 计算分母的值</span></span><br><span class="line">        sum_down += similarity</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算预测的评分值并返回</span></span><br><span class="line">    predict_rating = sum_up/sum_down</span><br><span class="line">    print(<span class="string">&quot;预测出用户&lt;%d&gt;对电影&lt;%d&gt;的评分：%0.2f&quot;</span> % (uid, iid, predict_rating))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">round</span>(predict_rating, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;item&quot;</span>)</span><br><span class="line">    <span class="comment"># 预测用户1对物品1的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">1</span>, ratings_matrix, item_similar)</span><br><span class="line">    <span class="comment"># 预测用户1对物品2的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">2</span>, ratings_matrix, item_similar)</span><br></pre></td></tr></table></figure></li><li><p>实现预测全部评分方法：<code>predict_all</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span>(<span class="params">uid, ratings_matrix, item_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param item_similar: 物品两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 准备要预测的物品的id列表</span></span><br><span class="line">    item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, item_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;item&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, item_similar):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>添加过滤规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_predict_all</span>(<span class="params">uid, item_ids,ratings_matrix, item_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param item_ids: 要预测物品id列表</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param item_similar: 物品两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, item_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span>(<span class="params">uid, ratings_matrix, item_similar, filter_rule=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分，并可根据条件进行前置过滤</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param item_similar: 物品两两间的相似度</span></span><br><span class="line"><span class="string">    :param filter_rule: 过滤规则，只能是四选一，否则将抛异常：&quot;unhot&quot;,&quot;rated&quot;,[&quot;unhot&quot;,&quot;rated&quot;],None</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> filter_rule:</span><br><span class="line">        item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">str</span>) <span class="keyword">and</span> filter_rule == <span class="string">&quot;unhot&quot;</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤非热门电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 统计每部电影的评分数</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        <span class="comment"># 过滤出评分数高于10的电影，作为热门电影</span></span><br><span class="line">        item_ids = count.where(count&gt;<span class="number">10</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">str</span>) <span class="keyword">and</span> filter_rule == <span class="string">&quot;rated&quot;</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤用户评分过的电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 获取用户对所有电影的评分记录</span></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        <span class="comment"># 评分范围是1-5，小于6的都是评分过的，除此以外的都是没有评分的</span></span><br><span class="line">        _ = user_ratings&lt;<span class="number">6</span></span><br><span class="line">        item_ids = _.where(_==<span class="literal">False</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">set</span>(filter_rule) == <span class="built_in">set</span>([<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>]):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤非热门和用户已经评分过的电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        ids1 = count.where(count &gt; <span class="number">10</span>).dropna().index</span><br><span class="line"></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        _ = user_ratings &lt; <span class="number">6</span></span><br><span class="line">        ids2 = _.where(_ == <span class="literal">False</span>).dropna().index</span><br><span class="line">        <span class="comment"># 取二者交集</span></span><br><span class="line">        item_ids = <span class="built_in">set</span>(ids1)&amp;<span class="built_in">set</span>(ids2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;无效的过滤参数&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> _predict_all(uid, item_ids, ratings_matrix, item_similar)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;item&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, item_similar, filter_rule=[<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>]):</span><br><span class="line">        print(result)</span><br></pre></td></tr></table></figure></li><li><p>为指定用户推荐TOP-N结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_k_rs_result</span>(<span class="params">k</span>):</span></span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;item&quot;</span>)</span><br><span class="line">    results = predict_all(<span class="number">1</span>, ratings_matrix, item_similar, filter_rule=[<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(results, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>], reverse=<span class="literal">True</span>)[:k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">    result = top_k_rs_result(<span class="number">20</span>)</span><br><span class="line">    pprint(result)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;案例—算法实现：Item-Based-CF-预测评分&quot;&gt;&lt;a href=&quot;#案例—算法实现：Item-Based-CF-预测评分&quot; class=&quot;headerlink&quot; title=&quot;案例—算法实现：Item-Based CF 预测评分&quot;&gt;&lt;/a&gt;案例—算法实现：</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>07-算法实现：User-Based CF 预测评分</title>
    <link href="https://xxren8218.github.io/20210610/07-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9AUser-Based-CF-%E9%A2%84%E6%B5%8B%E8%AF%84%E5%88%86.html"/>
    <id>https://xxren8218.github.io/20210610/07-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9AUser-Based-CF-%E9%A2%84%E6%B5%8B%E8%AF%84%E5%88%86.html</id>
    <published>2021-06-10T09:39:12.000Z</published>
    <updated>2021-06-10T09:40:19.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="案例—算法实现：User-Based-CF-预测评分"><a href="#案例—算法实现：User-Based-CF-预测评分" class="headerlink" title="案例—算法实现：User-Based CF 预测评分"></a>案例—算法实现：User-Based CF 预测评分</h2><p><strong>评分预测公式：</strong></p><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}</script><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><ul><li><p>实现评分预测方法：<code>predict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">uid, iid, ratings_matrix, user_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测给定用户对给定物品的评分值</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param iid: 物品ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两相似度矩阵</span></span><br><span class="line"><span class="string">    :return: 预测的评分值</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&quot;开始预测用户&lt;%d&gt;对电影&lt;%d&gt;的评分...&quot;</span>%(uid, iid))</span><br><span class="line">    <span class="comment"># 1. 找出uid用户的相似用户</span></span><br><span class="line">    similar_users = user_similar[uid].drop([uid]).dropna()</span><br><span class="line">    <span class="comment"># 相似用户筛选规则：正相关的用户</span></span><br><span class="line">    similar_users = similar_users.where(similar_users&gt;<span class="number">0</span>).dropna()</span><br><span class="line">    <span class="keyword">if</span> similar_users.empty <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;用户&lt;%d&gt;没有相似的用户&quot;</span> % uid)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 从uid用户的近邻相似用户中筛选出对iid物品有评分记录的近邻用户</span></span><br><span class="line">    ids = <span class="built_in">set</span>(ratings_matrix[iid].dropna().index)&amp;<span class="built_in">set</span>(similar_users.index)</span><br><span class="line">    finally_similar_users = similar_users.ix[<span class="built_in">list</span>(ids)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 结合uid用户与其近邻用户的相似度预测uid用户对iid物品的评分</span></span><br><span class="line">    sum_up = <span class="number">0</span>    <span class="comment"># 评分预测公式的分子部分的值</span></span><br><span class="line">    sum_down = <span class="number">0</span>    <span class="comment"># 评分预测公式的分母部分的值</span></span><br><span class="line">    <span class="keyword">for</span> sim_uid, similarity <span class="keyword">in</span> finally_similar_users.iteritems():</span><br><span class="line">        <span class="comment"># 近邻用户的评分数据</span></span><br><span class="line">        sim_user_rated_movies = ratings_matrix.ix[sim_uid].dropna()</span><br><span class="line">        <span class="comment"># 近邻用户对iid物品的评分</span></span><br><span class="line">        sim_user_rating_for_item = sim_user_rated_movies[iid]</span><br><span class="line">        <span class="comment"># 计算分子的值</span></span><br><span class="line">        sum_up += similarity * sim_user_rating_for_item</span><br><span class="line">        <span class="comment"># 计算分母的值</span></span><br><span class="line">        sum_down += similarity</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算预测的评分值并返回</span></span><br><span class="line">    predict_rating = sum_up/sum_down</span><br><span class="line">    print(<span class="string">&quot;预测出用户&lt;%d&gt;对电影&lt;%d&gt;的评分：%0.2f&quot;</span> % (uid, iid, predict_rating))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">round</span>(predict_rating, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    <span class="comment"># 预测用户1对物品1的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">1</span>, ratings_matrix, user_similar)</span><br><span class="line">    <span class="comment"># 预测用户1对物品2的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">2</span>, ratings_matrix, user_similar)</span><br></pre></td></tr></table></figure></li><li><p>实现预测全部评分方法：<code>predict_all</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span>(<span class="params">uid, ratings_matrix, user_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 准备要预测的物品的id列表</span></span><br><span class="line">    item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, user_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, user_similar):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>添加过滤规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_predict_all</span>(<span class="params">uid, item_ids, ratings_matrix, user_similar</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分</span></span><br><span class="line"><span class="string">    :param uid: 用户id</span></span><br><span class="line"><span class="string">    :param item_ids: 要预测的物品id列表</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 逐个预测</span></span><br><span class="line">    <span class="keyword">for</span> iid <span class="keyword">in</span> item_ids:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rating = predict(uid, iid, ratings_matrix, user_similar)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> uid, iid, rating</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_all</span>(<span class="params">uid, ratings_matrix, user_similar, filter_rule=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    预测全部评分，并可根据条件进行前置过滤</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品打分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两间的相似度</span></span><br><span class="line"><span class="string">    :param filter_rule: 过滤规则，只能是四选一，否则将抛异常：&quot;unhot&quot;,&quot;rated&quot;,[&quot;unhot&quot;,&quot;rated&quot;],None</span></span><br><span class="line"><span class="string">    :return: 生成器，逐个返回预测评分</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> filter_rule:</span><br><span class="line">        item_ids = ratings_matrix.columns</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">str</span>) <span class="keyword">and</span> filter_rule == <span class="string">&quot;unhot&quot;</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤非热门电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 统计每部电影的评分数</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        <span class="comment"># 过滤出评分数高于10的电影，作为热门电影</span></span><br><span class="line">        item_ids = count.where(count&gt;<span class="number">10</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">str</span>) <span class="keyword">and</span> filter_rule == <span class="string">&quot;rated&quot;</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤用户评分过的电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 获取用户对所有电影的评分记录</span></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        <span class="comment"># 评分范围是1-5，小于6的都是评分过的，除此以外的都是没有评分的</span></span><br><span class="line">        _ = user_ratings&lt;<span class="number">6</span></span><br><span class="line">        item_ids = _.where(_==<span class="literal">False</span>).dropna().index</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(filter_rule, <span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">set</span>(filter_rule) == <span class="built_in">set</span>([<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>]):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;过滤非热门和用户已经评分过的电影&#x27;&#x27;&#x27;</span></span><br><span class="line">        count = ratings_matrix.count()</span><br><span class="line">        ids1 = count.where(count &gt; <span class="number">10</span>).dropna().index</span><br><span class="line"></span><br><span class="line">        user_ratings = ratings_matrix.ix[uid]</span><br><span class="line">        _ = user_ratings &lt; <span class="number">6</span></span><br><span class="line">        ids2 = _.where(_ == <span class="literal">False</span>).dropna().index</span><br><span class="line">        <span class="comment"># 取二者交集</span></span><br><span class="line">        item_ids = <span class="built_in">set</span>(ids1)&amp;<span class="built_in">set</span>(ids2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;无效的过滤参数&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> _predict_all(uid, item_ids, ratings_matrix, user_similar)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> predict_all(<span class="number">1</span>, ratings_matrix, user_similar, filter_rule=[<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>]):</span><br><span class="line">        print(result)</span><br></pre></td></tr></table></figure></li><li><p>根据预测评分为指定用户进行TOP-N推荐：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_k_rs_result</span>(<span class="params">k</span>):</span></span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    results = predict_all(<span class="number">1</span>, ratings_matrix, user_similar, filter_rule=[<span class="string">&quot;unhot&quot;</span>, <span class="string">&quot;rated&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(results, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>], reverse=<span class="literal">True</span>)[:k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">    result = top_k_rs_result(<span class="number">20</span>)</span><br><span class="line">    pprint(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;案例—算法实现：User-Based-CF-预测评分&quot;&gt;&lt;a href=&quot;#案例—算法实现：User-Based-CF-预测评分&quot; class=&quot;headerlink&quot; title=&quot;案例—算法实现：User-Based CF 预测评分&quot;&gt;&lt;/a&gt;案例—算法实现：</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>06-案例--基于协同过滤的电影推荐</title>
    <link href="https://xxren8218.github.io/20210610/06-%E6%A1%88%E4%BE%8B-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%9A%84%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90.html"/>
    <id>https://xxren8218.github.io/20210610/06-%E6%A1%88%E4%BE%8B-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%9A%84%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90.html</id>
    <published>2021-06-10T09:37:29.000Z</published>
    <updated>2021-06-10T09:38:38.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="案例—基于协同过滤的电影推荐"><a href="#案例—基于协同过滤的电影推荐" class="headerlink" title="案例—基于协同过滤的电影推荐"></a>案例—基于协同过滤的电影推荐</h2><p>前面我们已经基本掌握了协同过滤推荐算法，以及其中两种最基本的实现方案：User-Based CF和Item-Based CF，下面我们将利用真是的数据来进行实战演练。</p><p>案例需求 演示效果</p><p>分析案例</p><h4 id="数据集下载"><a href="#数据集下载" class="headerlink" title="数据集下载"></a>数据集下载</h4><p><a href="https://grouplens.org/datasets/movielens/latest/">MovieLens Latest Datasets Small</a></p><p>建议下载<a href="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip">ml-latest-small.zip</a>，数据量小，便于我们单机使用和运行</p><p>目标：根据<code>ml-latest-small/ratings.csv</code>（用户-电影评分数据），分别实现User-Based CF和Item-Based CF，并进行电影评分的预测，然后为用户实现电影推荐</p><h4 id="数据集加载"><a href="#数据集加载" class="headerlink" title="数据集加载"></a>数据集加载</h4><ul><li><p>加载ratings.csv，并转换为用户-电影评分矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">DATA_PATH = <span class="string">&quot;./datasets/ml-latest-small/ratings.csv&quot;</span></span><br><span class="line">CACHE_DIR = <span class="string">&quot;./datasets/cache/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>(<span class="params">data_path</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    加载数据</span></span><br><span class="line"><span class="string">    :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">    :param cache_path: 数据集缓存路径</span></span><br><span class="line"><span class="string">    :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 数据集缓存地址</span></span><br><span class="line">    cache_path = os.path.join(CACHE_DIR, <span class="string">&quot;ratings_matrix.cache&quot;</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;开始加载数据集...&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(cache_path):    <span class="comment"># 判断是否存在缓存文件</span></span><br><span class="line">        print(<span class="string">&quot;加载缓存中...&quot;</span>)</span><br><span class="line">        ratings_matrix = pd.read_pickle(cache_path)</span><br><span class="line">        print(<span class="string">&quot;从缓存加载数据集完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;加载新数据中...&quot;</span>)</span><br><span class="line">        <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">        dtype = &#123;<span class="string">&quot;userId&quot;</span>: np.int32, <span class="string">&quot;movieId&quot;</span>: np.int32, <span class="string">&quot;rating&quot;</span>: np.float32&#125;</span><br><span class="line">        <span class="comment"># 加载数据，我们只用前三列数据，分别是用户ID，电影ID，已经用户对电影的对应评分</span></span><br><span class="line">        ratings = pd.read_csv(data_path, dtype=dtype, usecols=<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">        <span class="comment"># 透视表，将电影ID转换为列名称，转换成为一个User-Movie的评分矩阵</span></span><br><span class="line">        ratings_matrix = ratings.pivot_table(index=[<span class="string">&quot;userId&quot;</span>], columns=[<span class="string">&quot;movieId&quot;</span>], values=<span class="string">&quot;rating&quot;</span>)</span><br><span class="line">        <span class="comment"># 存入缓存文件</span></span><br><span class="line">        ratings_matrix.to_pickle(cache_path)</span><br><span class="line">        print(<span class="string">&quot;数据集加载完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span>  ratings_matrix</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line">    print(ratings_matrix)</span><br></pre></td></tr></table></figure></li></ul><h4 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h4><ul><li><p>计算用户或物品两两相似度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_pearson_similarity</span>(<span class="params">ratings_matrix, based=<span class="string">&quot;user&quot;</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    计算皮尔逊相关系数</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :param based: &quot;user&quot; or &quot;item&quot;</span></span><br><span class="line"><span class="string">    :return: 相似度矩阵</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    user_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">&quot;user_similarity.cache&quot;</span>)</span><br><span class="line">    item_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">&quot;item_similarity.cache&quot;</span>)</span><br><span class="line">    <span class="comment"># 基于皮尔逊相关系数计算相似度</span></span><br><span class="line">    <span class="comment"># 用户相似度</span></span><br><span class="line">    <span class="keyword">if</span> based == <span class="string">&quot;user&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(user_similarity_cache_path):</span><br><span class="line">            print(<span class="string">&quot;正从缓存加载用户相似度矩阵&quot;</span>)</span><br><span class="line">            similarity = pd.read_pickle(user_similarity_cache_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;开始计算用户相似度矩阵&quot;</span>)</span><br><span class="line">            similarity = ratings_matrix.T.corr()</span><br><span class="line">            similarity.to_pickle(user_similarity_cache_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> based == <span class="string">&quot;item&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(item_similarity_cache_path):</span><br><span class="line">            print(<span class="string">&quot;正从缓存加载物品相似度矩阵&quot;</span>)</span><br><span class="line">            similarity = pd.read_pickle(item_similarity_cache_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;开始计算物品相似度矩阵&quot;</span>)</span><br><span class="line">            similarity = ratings_matrix.corr()</span><br><span class="line">            similarity.to_pickle(item_similarity_cache_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Unhandled &#x27;based&#x27; Value: %s&quot;</span>%based)</span><br><span class="line">    print(<span class="string">&quot;相似度矩阵计算/加载完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> similarity</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line"></span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    print(user_similar)</span><br><span class="line">    item_similar = compute_pearson_similarity(ratings_matrix, based=<span class="string">&quot;item&quot;</span>)</span><br><span class="line">    print(item_similar)</span><br></pre></td></tr></table></figure></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>以上实现，仅用于实验阶段，因为工业上、或生产环境中，数据量是远超过我们本例中使用的数据量的，而pandas是无法支撑起大批量数据的运算的，因此工业上通常会使用spark、mapReduce等分布式计算框架来实现，我们后面的课程中也是建立在此基础上进行实践的。</p><p>但是正如前面所说，推荐算法的思想和理念都是统一的，不论使用什么平台工具、有多大的数据体量，其背后的实现原理都是不变的。</p><p>所以在本节，大家要深刻去学习的是推荐算法的业务流程，以及在具体的业务场景中，如本例的电影推荐，如何实现出推荐算法，并产生推荐结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;案例—基于协同过滤的电影推荐&quot;&gt;&lt;a href=&quot;#案例—基于协同过滤的电影推荐&quot; class=&quot;headerlink&quot; title=&quot;案例—基于协同过滤的电影推荐&quot;&gt;&lt;/a&gt;案例—基于协同过滤的电影推荐&lt;/h2&gt;&lt;p&gt;前面我们已经基本掌握了协同过滤推荐算法，以及</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>05-推荐系统冷启动问题</title>
    <link href="https://xxren8218.github.io/20210610/05-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%86%B7%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98.html"/>
    <id>https://xxren8218.github.io/20210610/05-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%86%B7%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98.html</id>
    <published>2021-06-10T09:33:03.000Z</published>
    <updated>2021-06-10T09:46:03.192Z</updated>
    
    <content type="html"><![CDATA[<h3 id="推荐系统的冷启动问题"><a href="#推荐系统的冷启动问题" class="headerlink" title="推荐系统的冷启动问题"></a>推荐系统的冷启动问题</h3><ul><li><p>推荐系统冷启动概念</p><ul><li>⽤户冷启动：如何为新⽤户做个性化推荐</li><li>物品冷启动：如何将新物品推荐给⽤户（协同过滤）</li><li>系统冷启动：⽤户冷启动+物品冷启动</li><li>本质是推荐系统依赖历史数据，没有历史数据⽆法预测⽤户偏好</li></ul></li><li><p>用户冷启动</p><ul><li><p>1.收集⽤户特征</p><ul><li><p>⽤户注册信息：性别、年龄、地域</p></li><li><p>设备信息：定位、⼿机型号、app列表</p></li><li><p>社交信息、推⼴素材、安装来源</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173438.png" alt=""></p></li></ul></li><li><p>2 引导用户填写兴趣</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173458.png" alt=""></p></li><li><p>3 使用其它站点的行为数据, 例如腾讯视频&amp;QQ音乐 今日头条&amp;抖音</p></li><li><p>4 新老用户推荐策略的差异</p><ul><li>新⽤户在冷启动阶段更倾向于热门排⾏榜，⽼⽤户会更加需要长尾推荐</li><li>Explore Exploit⼒度</li><li>使⽤单独的特征和模型预估</li></ul></li><li><p>举例 性别与电视剧的关系</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173540.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173600.png" alt=""></p></li><li><p>物品冷启动</p><ul><li>给物品打标签</li><li>利用物品的内容信息，将新物品先投放给曾经喜欢过和它内容相似的其他物品的用户。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173622.png" alt=""></p></li><li><p>系统冷启动</p><ul><li>基于内容的推荐 系统早期</li><li>基于内容的推荐逐渐过渡到协同过滤</li><li>基于内容的推荐和协同过滤的推荐结果都计算出来 加权求和得到最终推荐结果</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;推荐系统的冷启动问题&quot;&gt;&lt;a href=&quot;#推荐系统的冷启动问题&quot; class=&quot;headerlink&quot; title=&quot;推荐系统的冷启动问题&quot;&gt;&lt;/a&gt;推荐系统的冷启动问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;推荐系统冷启动概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⽤户冷启动：</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>04-推荐系统评估</title>
    <link href="https://xxren8218.github.io/20210610/04-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BC%B0.html"/>
    <id>https://xxren8218.github.io/20210610/04-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BC%B0.html</id>
    <published>2021-06-10T09:30:03.000Z</published>
    <updated>2021-06-10T09:32:24.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二-推荐系统评估"><a href="#二-推荐系统评估" class="headerlink" title="二 推荐系统评估"></a>二 推荐系统评估</h2><ul><li>好的推荐系统可以实现用户, 服务提供方, 内容提供方的共赢</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173145.png" alt=""></p><ul><li><p>显示反馈和隐式反馈</p><table style="overflow: scroll;">  <tr>    <th></th>    <th>显式反馈</th>    <th>隐式反馈</th>  </tr>  <tr> <td> 例子 </td> <td> 电影/书籍评分  是否喜欢这个推荐 </td> <td> 播放/点击 评论 下载 购买 </td>  </tr>  <tr>    <td> 准确性 </td>    <td> 高 </td>    <td> 低 </td>  </tr>  <tr>    <td> 数量 </td>    <td> 少 </td>    <td> 多 </td>  </tr>  <tr>    <td> 获取成本 </td>    <td> 高 </td>    <td> 低 </td>  </tr></table></li><li><p>常用评估指标</p><p>• 准确性  • 信任度<br>• 满意度  • 实时性<br>• 覆盖率  • 鲁棒性<br>• 多样性  • 可扩展性<br>• 新颖性  • 商业⽬标<br>• 惊喜度  • ⽤户留存</p><ul><li>准确性 (理论角度) Netflix 美国录像带租赁<ul><li>评分预测<ul><li>RMSE   MAE</li></ul></li><li>topN推荐<ul><li>召回率 精准率</li></ul></li></ul></li><li>准确性 (业务角度)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210610173209.png" alt=""></p><ul><li>覆盖度<ul><li>信息熵 对于推荐越大越好</li><li>覆盖率</li></ul></li><li>多样性&amp;新颖性&amp;惊喜性<ul><li>多样性：推荐列表中两两物品的不相似性。（相似性如何度量？</li><li>新颖性：未曾关注的类别、作者；推荐结果的平均流⾏度</li><li>惊喜性：历史不相似（惊）但很满意（喜）</li><li>往往需要牺牲准确性</li><li>使⽤历史⾏为预测⽤户对某个物品的喜爱程度</li><li>系统过度强调实时性</li></ul></li><li>Exploitation &amp; Exploration 探索与利用问题<ul><li>Exploitation(开发 利用)：选择现在可能最佳的⽅案</li><li>Exploration(探测 搜索)：选择现在不确定的⼀些⽅案，但未来可能会有⾼收益的⽅案</li><li>在做两类决策的过程中，不断更新对所有决策的不确定性的认知，优化<br>长期的⽬标</li></ul></li><li>EE问题实践<ul><li>兴趣扩展: 相似话题, 搭配推荐</li><li>人群算法: userCF 用户聚类</li><li>平衡个性化推荐和热门推荐比例</li><li>随机丢弃用户行为历史</li><li>随机扰动模型参数</li></ul></li><li>EE可能带来的问题<ul><li>探索伤害用户体验, 可能导致用户流失</li><li>探索带来的长期收益(留存率)评估周期长, KPI压力大</li><li>如何平衡实时兴趣和长期兴趣</li><li>如何平衡短期产品体验和长期系统生态</li><li>如何平衡大众口味和小众需求</li></ul></li><li>评估方法<ul><li>问卷调查: 成本高</li><li>离线评估:<ul><li>只能在用户看到过的候选集上做评估, 且跟线上真实效果存在偏差</li><li>只能评估少数指标</li><li>速度快, 不损害用户体验</li></ul></li><li>在线评估: 灰度发布 &amp; A/B测试 50% 全量上线</li><li>实践: 离线评估和在线评估结合, 定期做问卷调查</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二-推荐系统评估&quot;&gt;&lt;a href=&quot;#二-推荐系统评估&quot; class=&quot;headerlink&quot; title=&quot;二 推荐系统评估&quot;&gt;&lt;/a&gt;二 推荐系统评估&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;好的推荐系统可以实现用户, 服务提供方, 内容提供方的共赢&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>03-推荐算法</title>
    <link href="https://xxren8218.github.io/20210602/03-%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95.html"/>
    <id>https://xxren8218.github.io/20210602/03-%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95.html</id>
    <published>2021-06-01T16:22:39.000Z</published>
    <updated>2021-06-07T15:37:54.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><ul><li>推荐模型构建流程</li><li>推荐算法概述</li><li>基于协同过滤的推荐算法</li><li>协同过滤实现</li></ul><h3 id="一-推荐模型构建流程"><a href="#一-推荐模型构建流程" class="headerlink" title="一 推荐模型构建流程"></a>一 推荐模型构建流程</h3><p>Data(数据)-&gt;Features(特征)-&gt;ML Algorithm(机器学习算法)-&gt;Prediction Output(预测输出)</p><ul><li>数据清洗/数据处理</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002426.png" alt=""></p><ul><li>数据来源<ul><li>显性数据<ul><li>Rating 打分</li><li>Comments 评论/评价</li></ul></li><li>隐形数据<ul><li> Order history 历史订单</li><li> Cart events    加购物车</li><li> Page views    页面浏览</li><li> Click-thru      点击</li><li> Search log     搜索记录</li></ul></li></ul></li><li>数据量/数据能否满足要求</li><li>特征工程</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002445.png" alt=""></p><ul><li>从数据中筛选特征<ul><li>一个给定的商品，可能被拥有类似品味或需求的用户购买</li><li>使用用户行为数据描述商品</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002501.png" alt=""></p><ul><li><p>用数据表示特征</p><ul><li><p>将所有用户行为合并在一起 ，形成一个user-item 矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002522.png" alt=""></p></li></ul></li><li><p>选择合适的算法</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002539.png" alt=""></p><ul><li><p>产生推荐结果</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002556.png" alt=""></p></li></ul><h3 id="二-最经典的推荐算法：协同过滤推荐算法（Collaborative-Filtering）"><a href="#二-最经典的推荐算法：协同过滤推荐算法（Collaborative-Filtering）" class="headerlink" title="二 最经典的推荐算法：协同过滤推荐算法（Collaborative Filtering）"></a>二 最经典的推荐算法：协同过滤推荐算法（Collaborative Filtering）</h3><p>算法思想：<strong>物以类聚，人以群分</strong></p><p>基本的协同过滤推荐算法基于以下假设：</p><ul><li>“跟你喜好<strong>相似的人</strong>喜欢的东西你也很有可能喜欢” ：基于用户的协同过滤推荐（User-based CF）——好哥们</li><li>“跟你喜欢的东西<strong>相似的东西</strong>你也很有可能喜欢 ”：基于物品的协同过滤推荐（Item-based CF）——iphone8、iphoneXs</li></ul><p>实现协同过滤推荐有以下几个步骤：</p><ol><li><p><strong>找出最相似的人或物品：TOP-N相似的人或物品</strong></p><p>通过计算两两的相似度来进行排序，即可找出TOP-N相似的人或物品</p></li><li><p><strong>根据相似的人或物品产生推荐结果</strong></p><p>利用TOP-N结果生成初始推荐结果，然后过滤掉用户已经有过记录的物品或明确表示不感兴趣的物品</p></li></ol><p>以下是一个简单的示例，数据集相当于一个用户对物品的购买记录表：打勾表示用户对物品的有购买记录</p><ul><li><p>关于相似度计算这里先用一个简单的思想：如有两个同学X和Y，X同学爱好[足球、篮球、乒乓球]，Y同学爱好[网球、足球、篮球、羽毛球]，可见他们的共同爱好有2个，那么他们的相似度可以用：2/3 * 2/4 = 1/3 ≈ 0.33 来表示。</p><p><strong>User-Based CF</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002706.png" alt=""></p><p><strong>Item-Based CF</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002804.png" alt=""></p></li></ul><p>  通过前面两个demo，相信大家应该已经对协同过滤推荐算法的设计与实现有了比较清晰的认识。</p><h3 id="三-相似度计算-Similarity-Calculation"><a href="#三-相似度计算-Similarity-Calculation" class="headerlink" title="三 相似度计算(Similarity Calculation)"></a>三 相似度计算(Similarity Calculation)</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002856.png" alt=""></p><ul><li><p>相似度的计算方法</p><ul><li>数据分类<ul><li>实数值(物品评分情况)</li><li>布尔值(用户的行为 是否点击 是否收藏)</li></ul></li><li>欧氏距离, 是一个欧式空间下度量距离的方法. 两个物体, 都在同一个空间下表示为两个点, 假如叫做p,q, 分别都是n个坐标, 那么欧式距离就是衡量这两个点之间的距离. 欧氏距离不适用于布尔向量之间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002930.png" alt=""></p><script type="math/tex; mode=display">E(p,q) = \sqrt{\sum_{i=1}^n (p_i - q_i)^2}</script></li></ul><p>  ​    欧氏距离的值是一个非负数, 最大值正无穷, 通常计算相似度的结果希望是[-1,1]或[0,1]之间,一般可以使用</p><p>  ​    如下转化公式:<img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002945.png" alt=""></p><p>  ​    </p><ul><li>杰卡德相似度&amp;余弦相似度&amp;皮尔逊相关系数<ul><li>余弦相似度<ul><li>度量的是两个向量之间的夹角, 用夹角的余弦值来度量相似的情况</li><li>两个向量的夹角为0是,余弦值为1, 当夹角为90度是余弦值为0,为180度是余弦值为-1</li><li>余弦相似度在度量文本相似度, 用户相似度 物品相似度的时候较为常用</li><li>余弦相似度的特点, 与向量长度无关,余弦相似度计算要对向量长度归一化, 两个向量只要方向一致,无论程度强弱, 都可以视为’相似’</li></ul></li><li>皮尔逊相关系数Pearson<ul><li>实际上也是一种余弦相似度, 不过先对向量做了中心化, 向量a b 各自减去向量的均值后, 再计算余弦相似度</li><li>皮尔逊相似度计算结果在-1,1之间 -1表示负相关, 1表示正相关</li><li>度量两个变量是不是同增同减</li><li>皮尔逊相关系数度量的是两个变量的变化趋势是否一致, <strong>不适合计算布尔值向量之间的相关度</strong></li></ul></li><li>杰卡德相似度 Jaccard<ul><li>两个集合的交集元素个数在并集中所占的比例, 非常适用于布尔向量表示</li><li>分子是两个布尔向量做点积计算, 得到的就是交集元素的个数</li><li>分母是两个布尔向量做或运算, 再求元素和</li></ul></li><li>余弦相似度适合用户评分数据(实数值), 杰卡德相似度适用于隐式反馈数据(0,1布尔值)(是否收藏,是否点击,是否加购物车)</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003009.png" alt=""></p><ul><li>余弦相似度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003028.png" alt=""></p><ul><li>皮尔逊相关系数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003053.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003109.png" alt=""></p><ul><li>计算出用户1和其它用户之间的相似度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003128.png" alt=""></p><ul><li>按照相似度大小排序, K近邻 如K取4: </li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003148.png" alt=""></p><ul><li>取出近邻用户的购物清单</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003201.png" alt=""></p><ul><li>去除用户1已经购买过的商品</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003217.png" alt=""></p><ul><li>在剩余的物品中根据评分排序</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003231.png" alt=""></p><ul><li>物品相似度计算<ul><li>余弦相似度对绝对值大小不敏感带来的问题<ul><li>用户A对两部电影评分分别是1分和2分, 用户B对同样这两部电影进行评分是4分,5分 用余弦相似度计算,两个用户的相似度达到0.98    </li><li>可以采用改进的余弦相似度, 先计算向量每个维度上的均值, 然后每个向量在各个维度上都减去均值后,在计算余弦相似度, 用调整的余弦相似度计算得到的相似度是-0.1</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003348.png" alt=""></p><ul><li>物品相似度计算案例</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003408.png" alt=""></p><ul><li>找出物品1的相似商品</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003454.png" alt=""></p><ul><li>选择最近似的物品</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003701.png" alt=""></p><ul><li>基于用户与物品的协同过滤比较</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003645.png" alt=""><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003610.png" alt=""></p><h3 id="协同过滤推荐算法代码实现："><a href="#协同过滤推荐算法代码实现：" class="headerlink" title="协同过滤推荐算法代码实现："></a>协同过滤推荐算法代码实现：</h3><ul><li><p>构建数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 构建数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>,<span class="string">&quot;buy&quot;</span>,<span class="literal">None</span>,<span class="string">&quot;buy&quot;</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>计算时我们数据通常都需要对数据进行处理，或者编码，目的是为了便于我们对数据进行运算处理，比如这里是比较简单的情形，我们用1、0分别来表示用户的是否购买过该物品，则我们的数据集其实应该是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></li><li><p>有了数据集，接下来我们就可以进行相似度的计算，不过对于相似度的计算其实是有很多专门的相似度计算方法的，比如余弦相似度、皮尔逊相关系数、杰卡德相似度等等。这里我们选择使用杰卡德相似系数[0,1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接计算某两项的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> jaccard_similarity_score</span><br><span class="line"><span class="comment"># 计算Item A 和Item B的相似度</span></span><br><span class="line">print(jaccard_similarity_score(df[<span class="string">&quot;Item A&quot;</span>], df[<span class="string">&quot;Item B&quot;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算用户间相似度</span></span><br><span class="line">user_similar = <span class="number">1</span> - pairwise_distances(df, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">user_similar = pd.DataFrame(user_similar, columns=users, index=users)</span><br><span class="line">print(<span class="string">&quot;用户之间的两两相似度：&quot;</span>)</span><br><span class="line">print(user_similar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算物品间相似度</span></span><br><span class="line">item_similar = <span class="number">1</span> - pairwise_distances(df.T, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">item_similar = pd.DataFrame(item_similar, columns=items, index=items)</span><br><span class="line">print(<span class="string">&quot;物品之间的两两相似度：&quot;</span>)</span><br><span class="line">print(item_similar)</span><br></pre></td></tr></table></figure><p>有了两两的相似度，接下来就可以筛选TOP-N相似结果，并进行推荐了</p></li><li><p>User-Based CF</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算用户间相似度</span></span><br><span class="line">user_similar = <span class="number">1</span> - pairwise_distances(df, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">user_similar = pd.DataFrame(user_similar, columns=users, index=users)</span><br><span class="line">print(<span class="string">&quot;用户之间的两两相似度：&quot;</span>)</span><br><span class="line">print(user_similar)</span><br><span class="line"></span><br><span class="line">topN_users = &#123;&#125;</span><br><span class="line"><span class="comment"># 遍历每一行数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> user_similar.index:</span><br><span class="line">    <span class="comment"># 取出每一列数据，并删除自身，然后排序数据</span></span><br><span class="line">    _df = user_similar.loc[i].drop([i])</span><br><span class="line">    _df_sorted = _df.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    top2 = <span class="built_in">list</span>(_df_sorted.index[:<span class="number">2</span>])</span><br><span class="line">    topN_users[i] = top2</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Top2相似用户：&quot;</span>)</span><br><span class="line">print(topN_users)</span><br><span class="line"></span><br><span class="line">rs_results = &#123;&#125;</span><br><span class="line"><span class="comment"># 构建推荐结果</span></span><br><span class="line"><span class="keyword">for</span> user, sim_users <span class="keyword">in</span> topN_users.items():</span><br><span class="line">    rs_result = <span class="built_in">set</span>()    <span class="comment"># 存储推荐结果</span></span><br><span class="line">    <span class="keyword">for</span> sim_user <span class="keyword">in</span> sim_users:</span><br><span class="line">        <span class="comment"># 构建初始的推荐结果</span></span><br><span class="line">        rs_result = rs_result.union(<span class="built_in">set</span>(df.ix[sim_user].replace(<span class="number">0</span>,np.nan).dropna().index))</span><br><span class="line">    <span class="comment"># 过滤掉已经购买过的物品</span></span><br><span class="line">    rs_result -= <span class="built_in">set</span>(df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index)</span><br><span class="line">    rs_results[user] = rs_result</span><br><span class="line">print(<span class="string">&quot;最终推荐结果：&quot;</span>)</span><br><span class="line">pprint(rs_results)</span><br></pre></td></tr></table></figure></li><li><p>Item-Based CF</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有的数据两两的杰卡德相似系数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances</span><br><span class="line"><span class="comment"># 计算物品间相似度</span></span><br><span class="line">item_similar = <span class="number">1</span> - pairwise_distances(df.T, metric=<span class="string">&quot;jaccard&quot;</span>)</span><br><span class="line">item_similar = pd.DataFrame(item_similar, columns=items, index=items)</span><br><span class="line">print(<span class="string">&quot;物品之间的两两相似度：&quot;</span>)</span><br><span class="line">print(item_similar)</span><br><span class="line"></span><br><span class="line">topN_items = &#123;&#125;</span><br><span class="line"><span class="comment"># 遍历每一行数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> item_similar.index:</span><br><span class="line">    <span class="comment"># 取出每一列数据，并删除自身，然后排序数据</span></span><br><span class="line">    _df = item_similar.loc[i].drop([i])</span><br><span class="line">    _df_sorted = _df.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    top2 = <span class="built_in">list</span>(_df_sorted.index[:<span class="number">2</span>])</span><br><span class="line">    topN_items[i] = top2</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Top2相似物品：&quot;</span>)</span><br><span class="line">pprint(topN_items)</span><br><span class="line"></span><br><span class="line">rs_results = &#123;&#125;</span><br><span class="line"><span class="comment"># 构建推荐结果</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> df.index:    <span class="comment"># 遍历所有用户</span></span><br><span class="line">    rs_result = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index:   <span class="comment"># 取出每个用户当前已购物品列表</span></span><br><span class="line">        <span class="comment"># 根据每个物品找出最相似的TOP-N物品，构建初始推荐结果</span></span><br><span class="line">        rs_result = rs_result.union(topN_items[item])</span><br><span class="line">    <span class="comment"># 过滤掉用户已购的物品</span></span><br><span class="line">    rs_result -= <span class="built_in">set</span>(df.ix[user].replace(<span class="number">0</span>,np.nan).dropna().index)</span><br><span class="line">    <span class="comment"># 添加到结果中</span></span><br><span class="line">    rs_results[user] = rs_result</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;最终推荐结果：&quot;</span>)</span><br><span class="line">pprint(rs_results)</span><br></pre></td></tr></table></figure></li></ul><p><strong>关于协同过滤推荐算法使用的数据集</strong></p><p>在前面的demo中，我们只是使用用户对物品的一个购买记录，类似也可以是比如浏览点击记录、收听记录等等。这样数据我们预测的结果其实相当于是在预测用户是否对某物品感兴趣，对于喜好程度不能很好的预测。</p><p>因此在协同过滤推荐算法中其实会更多的利用用户对物品的“评分”数据来进行预测，通过评分数据集，我们可以预测用户对于他没有评分过的物品的评分。其实现原理和思想和都是一样的，只是使用的数据集是用户-物品的评分数据。</p><p><strong>关于用户-物品评分矩阵</strong></p><p>用户-物品的评分矩阵，根据评分矩阵的稀疏程度会有不同的解决方案</p><ul><li><p>稠密评分矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003819.png" alt=""></p></li><li><p>稀疏评分矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003905.png" alt=""></p></li></ul><p>这里先介绍稠密评分矩阵的处理，稀疏矩阵的处理相对会复杂一些，我们到后面再来介绍。</p><h4 id="使用协同过滤推荐算法对用户进行评分预测"><a href="#使用协同过滤推荐算法对用户进行评分预测" class="headerlink" title="使用协同过滤推荐算法对用户进行评分预测"></a>使用协同过滤推荐算法对用户进行评分预测</h4><ul><li><p>数据集：<img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602003819.png" alt=""></p><p><strong>目的：预测用户1对物品E的评分</strong></p></li><li><p>构建数据集：注意这里构建评分数据时，对于缺失的部分我们需要保留为None，如果设置为0那么会被当作评分值为0去对待</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">&quot;User1&quot;</span>, <span class="string">&quot;User2&quot;</span>, <span class="string">&quot;User3&quot;</span>, <span class="string">&quot;User4&quot;</span>, <span class="string">&quot;User5&quot;</span>]</span><br><span class="line">items = [<span class="string">&quot;Item A&quot;</span>, <span class="string">&quot;Item B&quot;</span>, <span class="string">&quot;Item C&quot;</span>, <span class="string">&quot;Item D&quot;</span>, <span class="string">&quot;Item E&quot;</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>计算相似度：对于评分数据这里我们采用皮尔逊相关系数[-1,1]来计算，-1表示强负相关，+1表示强正相关</p><blockquote><p>pandas中corr方法可直接用于计算皮尔逊相关系数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;用户之间的两两相似度：&quot;</span>)</span><br><span class="line"><span class="comment"># 直接计算皮尔逊相关系数</span></span><br><span class="line"><span class="comment"># 默认是按列进行计算，因此如果计算用户间的相似度，当前需要进行转置</span></span><br><span class="line">user_similar = df.T.corr()</span><br><span class="line">print(user_similar.<span class="built_in">round</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;物品之间的两两相似度：&quot;</span>)</span><br><span class="line">item_similar = df.corr()</span><br><span class="line">print(item_similar.<span class="built_in">round</span>(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 运行结果：</span><br><span class="line">用户之间的两两相似度：</span><br><span class="line">        User1   User2   User3   User4   User5</span><br><span class="line">User1  1.0000  0.8528  0.7071  0.0000 -0.7921</span><br><span class="line">User2  0.8528  1.0000  0.4677  0.4900 -0.9001</span><br><span class="line">User3  0.7071  0.4677  1.0000 -0.1612 -0.4666</span><br><span class="line">User4  0.0000  0.4900 -0.1612  1.0000 -0.6415</span><br><span class="line">User5 -0.7921 -0.9001 -0.4666 -0.6415  1.0000</span><br><span class="line">物品之间的两两相似度：</span><br><span class="line">        Item A  Item B  Item C  Item D  Item E</span><br><span class="line">Item A  1.0000 -0.4767 -0.1231  0.5322  0.9695</span><br><span class="line">Item B -0.4767  1.0000  0.6455 -0.3101 -0.4781</span><br><span class="line">Item C -0.1231  0.6455  1.0000 -0.7206 -0.4276</span><br><span class="line">Item D  0.5322 -0.3101 -0.7206  1.0000  0.5817</span><br><span class="line">Item E  0.9695 -0.4781 -0.4276  0.5817  1.0000</span><br></pre></td></tr></table></figure><p>可以看到与用户1最相似的是用户2和用户3；与物品A最相似的物品分别是物品E和物品D。</p><p><strong>注意：</strong>我们在预测评分时，往往是通过与其有正相关的用户或物品进行预测，如果不存在正相关的情况，那么将无法做出预测。这一点尤其是在稀疏评分矩阵中尤为常见，因为稀疏评分矩阵中很难得出正相关系数。</p></li><li><p><strong>评分预测：</strong></p><p><strong>User-Based CF 评分预测：使用用户间的相似度进行预测</strong></p><p>关于评分预测的方法也有比较多的方案，下面介绍一种效果比较好的方案，该方案考虑了用户本身的评分评分以及近邻用户的加权平均相似度打分来进行预测：</p><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}</script></li></ul><p>  我们要预测用户1对物品E的评分，那么可以根据与用户1最近邻的用户2和用户3进行预测，计算如下：</p><p>  ​    </p><script type="math/tex; mode=display">pred(u_1, i_5) =\cfrac{0.85*3+0.71*5}{0.85+0.71} = 3.91</script><p>  最终预测出用户1对物品5的评分为3.91</p><p>  <strong>Item-Based CF 评分预测：使用物品间的相似度进行预测</strong></p><p>  这里利用物品相似度预测的计算同上，同样考虑了用户自身的平均打分因素，结合预测物品与相似物品的加权平均相似度打分进行来进行预测</p><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{j\in I_{rated}}sim(i,j)*r_{uj}}{\sum_{j\in I_{rated}}sim(i,j)}</script><p>  我们要预测用户1对物品E的评分，那么可以根据与物品E最近邻的物品A和物品D进行预测，计算如下：</p><script type="math/tex; mode=display">pred(u_1, i_5) = \cfrac {0.97*5+0.58*4}{0.97+0.58} = 4.63</script><p>  对比可见，User-Based CF预测评分和Item-Based CF的评分结果也是存在差异的，因为严格意义上他们其实应当属于两种不同的推荐算法，各自在不同的领域不同场景下，都会比另一种的效果更佳，但具体哪一种更佳，必须经过合理的效果评估，因此在实现推荐系统时这两种算法往往都是需要去实现的，然后对产生的推荐效果进行评估分析选出更优方案。</p><h3 id="基于模型的方法"><a href="#基于模型的方法" class="headerlink" title="基于模型的方法"></a>基于模型的方法</h3><ul><li><p>思想</p><ul><li>通过机器学习算法，在数据中找出模式，并将用户与物品间的互动方式模式化</li><li>基于模型的协同过滤方式是构建协同过滤更高级的算法</li></ul></li><li><p>近邻模型的问题</p><ul><li>物品之间存在相关性, 信息量并不随着向量维度增加而线性增加</li><li>矩阵元素稀疏, 计算结果不稳定,增减一个向量维度, 导致近邻结果差异很大的情况存在</li></ul></li><li><p>算法分类</p><ul><li>基于图的模型</li><li><strong>基于矩阵分解的方法</strong></li></ul></li><li><p>基于图的模型</p><ul><li>基于邻域的模型看做基于图的模型的简单形式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602004043.png" alt=""></p><ul><li>原理<ul><li>将用户的行为数据表示为二分图</li><li>基于二分图为用户进行推荐</li><li>根据两个顶点之间的路径数、路径长度和经过的顶点数来评价两个顶点的相关性</li></ul></li></ul></li><li><p>基于矩阵分解的模型</p><ul><li><p>原理</p><ul><li><p>根据用户与物品的潜在表现，我们就可以预测用户对未评分的物品的喜爱程度</p></li><li><p>把原来的大矩阵, 近似分解成两个小矩阵的乘积, 在实际推荐计算时不再使用大矩阵, 而是使用分解得到的两个小矩阵  </p></li><li><p>用户-物品评分矩阵A是M X N维, 即一共有M个用户, n个物品 我们选一个很小的数 K (K&lt;&lt; M, K&lt;&lt;N)</p></li><li><p>通过计算得到两个矩阵U V  U是M <em> K矩阵 , 矩阵V是 N </em> K</p><p>$U_{m<em>k} V^{T}_{n</em>k} 约等于 A_{m*n}$</p><p>类似这样的计算过程就是矩阵分解</p></li></ul></li><li><p>基于矩阵分解的方法</p><ul><li>ALS交替最小二乘<ul><li>ALS-WR(加权正则化交替最小二乘法): alternating-least-squares with weighted-λ –regularization</li><li>将用户(user)对商品(item)的评分矩阵分解为两个矩阵：一个是用户对商品隐含特征的偏好矩阵，另一个是商品所包含的隐含特征的矩阵。在这个矩阵分解的过程中，评分缺失项得到了填充，也就是说我们可以基于这个填充的评分来给用户做商品推荐了。</li></ul></li><li>SVD奇异值分解矩阵</li></ul></li></ul></li><li><p>ALS方法</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602004107.png" alt=""></p><ul><li>ALS的矩阵分解算法常应用于推荐系统中，将用户(user)对商品(item)的评分矩阵，分解为用户对商品隐含特征的偏好矩阵，和商品在隐含特征上的映射矩阵。</li><li>与传统的矩阵分解SVD方法来分解矩阵R(R∈ℝm×n)不同的是，ALS(alternating least squares)希望找到两个低维矩阵，以 R̃ =XY 来逼近矩阵R，其中 ，X∈ℝm×d，Y∈ℝd×n，这样，将问题的复杂度由O(m<em>n)转换为O((m+n)</em>d)。</li><li>计算X和Y过程：首先用一个小于1的随机数初始化Y，并根据公式求X，此时就可以得到初始的XY矩阵了，根据平方差和得到的X，重新计算并覆盖Y，计算差平方和，反复进行以上两步的计算，直到差平方和小于一个预设的数，或者迭代次数满足要求则停止</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;推荐算法&quot;&gt;&lt;a href=&quot;#推荐算法&quot; class=&quot;headerlink&quot; title=&quot;推荐算法&quot;&gt;&lt;/a&gt;推荐算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;推荐模型构建流程&lt;/li&gt;
&lt;li&gt;推荐算法概述&lt;/li&gt;
&lt;li&gt;基于协同过滤的推荐算法&lt;/li&gt;
&lt;li&gt;协</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>02-推荐系统设计</title>
    <link href="https://xxren8218.github.io/20210602/02-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html"/>
    <id>https://xxren8218.github.io/20210602/02-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html</id>
    <published>2021-06-01T16:16:15.000Z</published>
    <updated>2021-06-01T16:22:07.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二-推荐系统设计"><a href="#二-推荐系统设计" class="headerlink" title="二 推荐系统设计"></a>二 推荐系统设计</h2><h3 id="2-1-推荐系统要素"><a href="#2-1-推荐系统要素" class="headerlink" title="2.1 推荐系统要素"></a>2.1 推荐系统要素</h3><ul><li>UI 和 UE(前端界面)</li><li>数据 (Lambda架构)</li><li>业务知识</li><li>算法</li></ul><h3 id="2-2-推荐系统架构"><a href="#2-2-推荐系统架构" class="headerlink" title="2.2 推荐系统架构"></a>2.2 推荐系统架构</h3><ul><li><p>推荐系统整体架构</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602001914.png" alt=""></p></li><li><p>大数据Lambda架构</p><ul><li><p>由Twitter工程师Nathan Marz(storm项目发起人)提出</p></li><li><p>Lambda系统架构提供了一个结合实时数据和Hadoop预先计算的数据环境和混合平台, 提供一个实时的数据视图</p></li><li><p>分层架构</p><ul><li>批处理层<ul><li>数据不可变, 可进行任何计算, 可水平扩展</li><li>高延迟  几分钟~几小时(计算量和数据量不同)</li><li>日志收集 Flume</li><li>分布式存储 Hadoop hdfs</li><li>分布式计算 Hadoop MapReduce &amp; spark</li><li>视图存储数据库<ul><li>nosql(HBase/Cassandra)</li><li>Redis/memcache</li><li>MySQL</li></ul></li></ul></li><li>实时处理层<ul><li>流式处理, 持续计算</li><li>存储和分析某个窗口期内的数据</li><li>最终正确性(Eventual accuracy)</li><li>实时数据收集 flume &amp; kafka</li><li>实时数据分析  spark streaming/storm/flink</li></ul></li><li>服务层<ul><li>支持随机读</li><li>需要在非常短的时间内返回结果</li><li>读取批处理层和实时处理层结果并对其归并</li></ul></li></ul></li><li><p>Lambda架构图</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602001941.png" alt=""></p></li></ul></li><li><p>推荐算法架构</p><ul><li>召回阶段(<strong>海选</strong>)<ul><li>召回决定了最终推荐结果的天花板</li><li>常用算法:<ul><li>协同过滤(基于用户 基于物品的)</li><li>基于内容 (根据用户行为总结出自己的偏好 根据偏好 通过文本挖掘技术找到内容上相似的商品)</li><li>基于隐语义（矩阵分解）</li></ul></li></ul></li><li>排序阶段<ul><li>召回决定了最终推荐结果的天花板, 排序逼近这个极限, 决定了最终的推荐效果</li><li>CTR预估 (点击率预估 使用LR算法)  估计用户是否会点击某个商品 需要用户的点击数据</li></ul></li><li>策略调整</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002010.jpeg" alt=""></p><ul><li><p>推荐系统的整体架构</p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002137.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602002155.png" alt=""></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二-推荐系统设计&quot;&gt;&lt;a href=&quot;#二-推荐系统设计&quot; class=&quot;headerlink&quot; title=&quot;二 推荐系统设计&quot;&gt;&lt;/a&gt;二 推荐系统设计&lt;/h2&gt;&lt;h3 id=&quot;2-1-推荐系统要素&quot;&gt;&lt;a href=&quot;#2-1-推荐系统要素&quot; class=&quot;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>01-推荐系统简介</title>
    <link href="https://xxren8218.github.io/20210602/01-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B.html"/>
    <id>https://xxren8218.github.io/20210602/01-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B.html</id>
    <published>2021-06-01T16:12:16.000Z</published>
    <updated>2021-06-01T16:16:27.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-推荐系统简介"><a href="#一-推荐系统简介" class="headerlink" title="一 推荐系统简介"></a>一 推荐系统简介</h2><p>​        个性化推荐(推荐系统)经历了多年的发展，已经成为互联网产品的标配，也是AI成功落地的分支之一，在电商(淘宝/京东)、资讯(今日头条/微博)、音乐(网易云音乐/QQ音乐)、短视频(抖音/快手)等热门应用中,推荐系统都是核心组件之一。</p><ul><li><p>推荐系统产生背景</p><ul><li>信息过载 &amp; 用户需求不明确<ul><li>分类⽬录（1990s）：覆盖少量热门⽹站。Hao123 Yahoo</li><li>搜索引擎（2000s）：通过搜索词明确需求。Google Baidu</li><li>推荐系统（2010s）：不需要⽤户提供明确的需求，通过分析⽤<br>户的历史⾏为给⽤户的兴趣进⾏建模，从⽽主动给⽤户推荐能<br>够满⾜他们兴趣和需求的信息。</li></ul></li></ul></li><li><p>什么是推荐系统</p><ul><li>没有明确需求的用户访问了我们的服务, 且服务的物品对用户构成了信息过载, 系统通过一定的规则对物品进行排序,并将排在前面的物品展示给用户,这样的系统就是推荐系统</li></ul></li><li><p>推荐系统 V.S. 搜索引擎</p><table style="overflow: scroll;">  <tr>    <th></th>    <th>搜索</th>    <th>推荐</th>  </tr>  <tr>    <td> 行为方式 </td>    <td> 主动 </td>    <td> 被动 </td>  </tr>  <tr>    <td> 意图 </td>    <td> 明确 </td>    <td> 模糊 </td>  </tr>  <tr>    <td> 个性化 </td>    <td> 弱 </td>    <td> 强 </td>  </tr>  <tr>    <td> 流量分布 </td>    <td> 马太效应（二八效应），基本上返回的都是一样的优质的网站。如 CSDN </td>    <td> 长尾效应 （与马太效应相反），兼顾更多的小厂</td>  </tr>  <tr>    <td> 目标 </td>    <td> 快速满足  </td>    <td> 持续服务 （收集注意力，卖广告）</td>  </tr>  <tr>    <td> 评估指标 </td>    <td> 简明 </td>    <td> 复杂 </td>  </tr></table></li><li><p>推荐系统的作用</p><ul><li>高效连接用户和物品, 发现长尾商品</li><li>留住用户和内容生产者, 实现商业目标</li></ul></li><li><p>推荐系统的工作原理</p><ul><li><strong>社会化推荐</strong> 向朋友咨询, 社会化推荐, 让好友给自己推荐物品</li><li><strong>基于内容的推荐</strong> 打开搜索引擎, 输入自己喜欢的演员的名字, 然后看看返回结果中还有什么电影是自己没看过的</li><li><strong>基于流行度的推荐</strong> 查看票房排行榜, </li><li><strong>基于协同过滤的推荐</strong> 找到和自己历史兴趣相似的用户, 看看他们最近在看什么电影</li></ul></li><li><p>推荐系统的应用场景 feed 流 信息流 </p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602001521.png" alt=""></p><ul><li><p>推荐系统和Web项目的区别</p><ul><li>稳定的信息流通系统 V.S. 通过信息过滤实现目标提升 <ul><li>web项目: 处理复杂逻辑 处理高并发 实现高可用 为用户提供稳定服务, 构建一个稳定的信息流通的服务</li><li>推荐系统: 追求指标增长, 留存率/阅读时间/GMV (Gross Merchandise Volume电商网站成交金额)/视频网站VV (Video View)</li></ul></li><li>确定 V.S. 不确定思维<ul><li>web项目: 对结果有确定预期</li><li>推荐系统: 结果是概率问题</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-推荐系统简介&quot;&gt;&lt;a href=&quot;#一-推荐系统简介&quot; class=&quot;headerlink&quot; title=&quot;一 推荐系统简介&quot;&gt;&lt;/a&gt;一 推荐系统简介&lt;/h2&gt;&lt;p&gt;​        个性化推荐(推荐系统)经历了多年的发展，已经成为互联网产品的标配，也是AI</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="推荐系统基础" scheme="https://xxren8218.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（五十一）：构建乘积数组</title>
    <link href="https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.html"/>
    <id>https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.html</id>
    <published>2021-06-01T16:09:27.000Z</published>
    <updated>2021-06-01T16:11:16.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>暴力解法：直接构造一个B列表，使得B[i]都初始化为i，再分别乘a中除了i的所有元素。</p><h2 id="3-代码——力扣超时43-44"><a href="#3-代码——力扣超时43-44" class="headerlink" title="3.代码——力扣超时43/44"></a>3.代码——力扣超时43/44</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        B = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> B:</span><br><span class="line">            B[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> (A[:i]+A[i+<span class="number">1</span>:]):</span><br><span class="line">                B[i] *= j</span><br><span class="line">        <span class="keyword">return</span> B </span><br></pre></td></tr></table></figure><h2 id="新思路："><a href="#新思路：" class="headerlink" title="新思路："></a>新思路：</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602001037.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602001055.PNG" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span>(<span class="params">self, a: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        b, tmp = [<span class="number">1</span>] * <span class="built_in">len</span>(a), <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(a)):</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>] <span class="comment"># 下三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>): </span><br><span class="line">            tmp *= a[i + <span class="number">1</span>] <span class="comment"># 上三角</span></span><br><span class="line">            b[i] *= tmp <span class="comment"># 下三角 * 上三角</span></span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]&lt;em&gt;A[1</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（五十）：数组中重复的数字</title>
    <link href="https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html</id>
    <published>2021-06-01T16:08:08.000Z</published>
    <updated>2021-06-01T16:08:53.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>直接哈希表解决。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://xxren8218.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三十七）：数字在排序数组中出现的次数</title>
    <link href="https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.html</id>
    <published>2021-06-01T16:05:07.000Z</published>
    <updated>2021-06-01T16:07:33.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>统计一个数字在排序数组中出现的次数。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>我最先想到的是count方法，直接可以计数。那么就会失去本题原来的意义。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span>(<span class="params">self, data, k</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> data.count(k)</span><br></pre></td></tr></table></figure><h2 id="思路二——二分查找"><a href="#思路二——二分查找" class="headerlink" title="思路二——二分查找"></a>思路二——二分查找</h2><p>既然是排序的数组，那第一感觉肯定是二分查找；<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000617.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000638.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000650.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000703.PNG" alt=""></p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: [<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 搜索右边界 right</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt;= target: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">        right = i</span><br><span class="line">        <span class="comment"># 若数组中无 target ，则提前返回</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] != target: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 搜索左边界 left</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; target: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">        left = j</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000720.PNG" alt=""></p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">nums,target</span>):</span></span><br><span class="line">            i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">                m = (i + j)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt;= target:</span><br><span class="line">                    i = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(nums,target) - helper(nums,target-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;统计一个数字在排序数组中出现的次数。&lt;/p&gt;
&lt;h2 id=&quot;2-思路&quot;&gt;&lt;a href=&quot;#2-思路&quot; class=&quot;he</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分法" scheme="https://xxren8218.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四十）：数组中只出现一次的数字</title>
    <link href="https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>https://xxren8218.github.io/20210602/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html</id>
    <published>2021-06-01T16:03:24.000Z</published>
    <updated>2021-06-01T16:04:20.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>直接使用一个哈希表进行计数即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:dic[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> dic[j] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> j</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://xxren8218.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三十五）：数组中的逆序对</title>
    <link href="https://xxren8218.github.io/20210601/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.html"/>
    <id>https://xxren8218.github.io/20210601/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.html</id>
    <published>2021-06-01T15:58:50.000Z</published>
    <updated>2021-06-01T16:02:22.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。</p><p>题目保证输入的数组中没有的相同的数字</p><p>数据范围：</p><p>对于%50的数据,size&lt;=10^4</p><p>对于%75的数据,size&lt;=10^5</p><p>对于%100的数据,size&lt;=2*10^5</p><h2 id="2-思路——暴力解法"><a href="#2-思路——暴力解法" class="headerlink" title="2.思路——暴力解法"></a>2.思路——暴力解法</h2><p>直接暴力解法——O（n^2），代码超时</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="解法二——归并排序"><a href="#解法二——归并排序" class="headerlink" title="解法二——归并排序"></a>解法二——归并排序</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；。<br>分治思想，采用归并排序的思路来处理，如下图，先分后治：<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000121.PNG" alt=""><br>先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210602000140.PNG" alt=""><br>逆序对的总数 = 左边数组中的逆序对的数量 + 右边数组中逆序对的数量 + 左右结合成新的顺序数组时中出现的逆序对的数量<br>总结一下：</p><p>这是一个归并排序的合并过程，主要是考虑合并两个有序序列时，计算逆序对数。</p><p>对于两个升序序列，设置两个下标：两个有序序列的末尾。每次比较两个末尾值，如果前末尾大于后末尾值，则有”后序列当前长度“个逆序对；否则不构成逆序对。然后把较大值拷贝到辅助数组的末尾，即最终要将两个有序序列合并到辅助数组并有序。</p><p>这样，每次在合并前，先递归地处理左半段、右半段，则左、右半段有序，且左右半段的逆序对数可得到，再计算左右半段合并时逆序对的个数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment">#####</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">self, alist</span>):</span></span><br><span class="line">        <span class="comment"># 先进性拆分</span></span><br><span class="line">        n = <span class="built_in">len</span>(alist)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> alist</span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># left 采用归并排序后形成的有序的新的列表</span></span><br><span class="line">        left_li = self.merge_sort(alist[:mid])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># right 采用归并排序后形成的有序的新的列表</span></span><br><span class="line">        right_li = self.merge_sort(alist[mid:])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将两个有序的子序列合并为一个新的整体</span></span><br><span class="line">        <span class="comment"># merge(left, right)</span></span><br><span class="line">        left_pointer, right_pointer = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left_pointer &lt; <span class="built_in">len</span>(left_li) <span class="keyword">and</span> right_pointer &lt; <span class="built_in">len</span>(right_li):</span><br><span class="line">            <span class="keyword">if</span> left_li[left_pointer] &lt;= right_li[right_pointer]:</span><br><span class="line">                result.append(left_li[left_pointer])</span><br><span class="line">                left_pointer += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(right_li[right_pointer])</span><br><span class="line">                right_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">####### [3] 4 5     [1] 2 6  左边游标第一个比后面的大，则，后面的4,5肯定比 1 也大</span></span><br><span class="line">                self.count += (<span class="built_in">len</span>(left_li) - (left_pointer))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 其中一个列表取完了，另一个没有。进行判断。list[n:]返回空列表。可以同时判断两个列表情况。</span></span><br><span class="line">        result += left_li[left_pointer:]</span><br><span class="line">        result += right_li[right_pointer:]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.merge_sort(data)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="归并排序" scheme="https://xxren8218.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    <category term="递归" scheme="https://xxren8218.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>时间序列——ARIMA模型参数的选择</title>
    <link href="https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94ARIMA%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9.html"/>
    <id>https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94ARIMA%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9.html</id>
    <published>2021-05-25T16:57:08.000Z</published>
    <updated>2021-05-25T16:59:30.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARIMA的模型参数选择"><a href="#ARIMA的模型参数选择" class="headerlink" title="ARIMA的模型参数选择"></a>ARIMA的模型参数选择</h2><ul><li><p>AIC（赤池信息准则）</p></li><li><p>BIC（贝叶斯信息准则）</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">%load_ext autoreload</span><br><span class="line">%autoreload <span class="number">2</span></span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format=<span class="string">&#x27;retina&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, division, print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># TSA from Statsmodels</span></span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> statsmodels.formula.api <span class="keyword">as</span> smf</span><br><span class="line"><span class="keyword">import</span> statsmodels.tsa.api <span class="keyword">as</span> smt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display and Plotting</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x: <span class="string">&#x27;%.5f&#x27;</span> % x) <span class="comment"># pandas</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">5</span>, suppress=<span class="literal">True</span>) <span class="comment"># numpy</span></span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_columns&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># seaborn plotting style</span></span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&#x27;ticks&#x27;</span>, context=<span class="string">&#x27;poster&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filename_ts = <span class="string">&#x27;data/series1.csv&#x27;</span></span><br><span class="line">ts_df = pd.read_csv(filename_ts, index_col=<span class="number">0</span>, parse_dates=[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">n_sample = ts_df.shape[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ts_df.shape)</span><br><span class="line">print(ts_df.head())</span><br></pre></td></tr></table></figure><pre><code>(120, 1)              value2006-06-01  0.215072006-07-01  1.142252006-08-01  0.080772006-09-01 -0.739522006-10-01  0.53552</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a training sample and testing sample before analyzing the series</span></span><br><span class="line"></span><br><span class="line">n_train=<span class="built_in">int</span>(<span class="number">0.95</span>*n_sample)+<span class="number">1</span></span><br><span class="line">n_forecast=n_sample-n_train</span><br><span class="line"><span class="comment">#ts_df</span></span><br><span class="line">ts_train = ts_df.iloc[:n_train][<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">ts_test = ts_df.iloc[n_train:][<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">print(ts_train.shape)</span><br><span class="line">print(ts_test.shape)</span><br><span class="line">print(<span class="string">&quot;Training Series:&quot;</span>, <span class="string">&quot;\n&quot;</span>, ts_train.tail(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Testing Series:&quot;</span>, <span class="string">&quot;\n&quot;</span>, ts_test.head())</span><br></pre></td></tr></table></figure><pre><code>(115,)(5,)Training Series:  2015-08-01    0.603712015-09-01   -1.273722015-10-01   -0.932842015-11-01    0.085522015-12-01    1.20534Name: value, dtype: float64 Testing Series:  2016-01-01    2.164112016-02-01    0.952262016-03-01    0.364852016-04-01   -2.264872016-05-01   -2.38168Name: value, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tsplot</span>(<span class="params">y, lags=<span class="literal">None</span>, title=<span class="string">&#x27;&#x27;</span>, figsize=(<span class="params"><span class="number">14</span>, <span class="number">8</span></span>)</span>):</span></span><br><span class="line">    </span><br><span class="line">    fig = plt.figure(figsize=figsize)</span><br><span class="line">    layout = (<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ts_ax   = plt.subplot2grid(layout, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    hist_ax = plt.subplot2grid(layout, (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    acf_ax  = plt.subplot2grid(layout, (<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    pacf_ax = plt.subplot2grid(layout, (<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    y.plot(ax=ts_ax)</span><br><span class="line">    ts_ax.set_title(title)</span><br><span class="line">    y.plot(ax=hist_ax, kind=<span class="string">&#x27;hist&#x27;</span>, bins=<span class="number">25</span>)</span><br><span class="line">    hist_ax.set_title(<span class="string">&#x27;Histogram&#x27;</span>)</span><br><span class="line">    smt.graphics.plot_acf(y, lags=lags, ax=acf_ax)</span><br><span class="line">    smt.graphics.plot_pacf(y, lags=lags, ax=pacf_ax)</span><br><span class="line">    [ax.set_xlim(<span class="number">0</span>) <span class="keyword">for</span> ax <span class="keyword">in</span> [acf_ax, pacf_ax]]</span><br><span class="line">    sns.despine()</span><br><span class="line">    fig.tight_layout()</span><br><span class="line">    <span class="keyword">return</span> ts_ax, acf_ax, pacf_ax</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsplot(ts_train, title=<span class="string">&#x27;A Given Training Series&#x27;</span>, lags=<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005846.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Model Estimation</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit the model</span></span><br><span class="line">arima200 = sm.tsa.SARIMAX(ts_train, order=(<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>))  <span class="comment"># order 表示ARIMA模型的指定的参数 p, d，q</span></span><br><span class="line">model_results = arima200.fit()</span><br></pre></td></tr></table></figure><h3 id="有了不同的参数都满足如何选取呢？"><a href="#有了不同的参数都满足如何选取呢？" class="headerlink" title="有了不同的参数都满足如何选取呢？"></a>有了不同的参数都满足如何选取呢？</h3><ul><li><p>选取最简单的模型</p></li><li><p>AIC（赤池信息准则）</p></li><li><p>BIC（贝叶斯信息准则）</p></li></ul><p><strong>越小越好</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">p_min = <span class="number">0</span></span><br><span class="line">d_min = <span class="number">0</span></span><br><span class="line">q_min = <span class="number">0</span></span><br><span class="line">p_max = <span class="number">4</span></span><br><span class="line">d_max = <span class="number">0</span></span><br><span class="line">q_max = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a DataFrame to store the results</span></span><br><span class="line">results_bic = pd.DataFrame(index=[<span class="string">&#x27;AR&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p_min,p_max+<span class="number">1</span>)],</span><br><span class="line">                           columns=[<span class="string">&#x27;MA&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q_min,q_max+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p,d,q <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(p_min,p_max+<span class="number">1</span>),</span><br><span class="line">                               <span class="built_in">range</span>(d_min,d_max+<span class="number">1</span>),</span><br><span class="line">                               <span class="built_in">range</span>(q_min,q_max+<span class="number">1</span>)):</span><br><span class="line">    <span class="keyword">if</span> p==<span class="number">0</span> <span class="keyword">and</span> d==<span class="number">0</span> <span class="keyword">and</span> q==<span class="number">0</span>:</span><br><span class="line">        results_bic.loc[<span class="string">&#x27;AR&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(p), <span class="string">&#x27;MA&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(q)] = np.nan</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        model = sm.tsa.SARIMAX(ts_train, order=(p, d, q),</span><br><span class="line">                               <span class="comment">#enforce_stationarity=False,</span></span><br><span class="line">                               <span class="comment">#enforce_invertibility=False,</span></span><br><span class="line">                              )</span><br><span class="line">        results = model.fit()</span><br><span class="line">        results_bic.loc[<span class="string">&#x27;AR&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(p), <span class="string">&#x27;MA&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(q)] = results.bic</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">results_bic = results_bic[results_bic.columns].astype(<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">ax = sns.heatmap(results_bic,</span><br><span class="line">                 mask=results_bic.isnull(),</span><br><span class="line">                 ax=ax,</span><br><span class="line">                 annot=<span class="literal">True</span>,</span><br><span class="line">                 fmt=<span class="string">&#x27;.2f&#x27;</span>,</span><br><span class="line">                 );</span><br><span class="line">ax.set_title(<span class="string">&#x27;BIC&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005904.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Alternative model selection method, limited to only searching AR and MA parameters</span></span><br><span class="line"></span><br><span class="line">train_results = sm.tsa.arma_order_select_ic(ts_train, ic=[<span class="string">&#x27;aic&#x27;</span>, <span class="string">&#x27;bic&#x27;</span>], trend=<span class="string">&#x27;nc&#x27;</span>, max_ar=<span class="number">4</span>, max_ma=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;AIC&#x27;</span>, train_results.aic_min_order)</span><br><span class="line">print(<span class="string">&#x27;BIC&#x27;</span>, train_results.bic_min_order)</span><br></pre></td></tr></table></figure><pre><code>AIC (4, 2)BIC (1, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 残差分析 正态分布 QQ图线性</span></span><br><span class="line">model_results.plot_diagnostics(figsize=(<span class="number">16</span>, <span class="number">12</span>));</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005917.png" alt=""></p><p>QQ 图若是直线，则是正态分布。符合要求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ARIMA的模型参数选择&quot;&gt;&lt;a href=&quot;#ARIMA的模型参数选择&quot; class=&quot;headerlink&quot; title=&quot;ARIMA的模型参数选择&quot;&gt;&lt;/a&gt;ARIMA的模型参数选择&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AIC（赤池信息准则）&lt;/p&gt;
&lt;/li&gt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>时间序列——ARIMA的一些概念</title>
    <link href="https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94ARIMA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5.html"/>
    <id>https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94ARIMA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5.html</id>
    <published>2021-05-25T16:51:04.000Z</published>
    <updated>2021-05-25T16:54:41.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARIMA模型的一些概念"><a href="#ARIMA模型的一些概念" class="headerlink" title="ARIMA模型的一些概念"></a>ARIMA模型的一些概念</h2><ul><li>差分</li><li>ACF 自相关函数</li><li>PACF 偏自相关函数</li></ul><p><strong>需要用到statsmodels模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">%load_ext autoreload</span><br><span class="line">%autoreload <span class="number">2</span></span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format=<span class="string">&#x27;retina&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, division, print_function</span><br><span class="line"><span class="comment"># http://www.lfd.uci.edu/~gohlke/pythonlibs/#xgboost  # 很多可以装的python库</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># # Remote Data Access</span></span><br><span class="line"><span class="comment"># import pandas_datareader.data as web</span></span><br><span class="line"><span class="comment"># import datetime</span></span><br><span class="line"><span class="comment"># # reference: https://pandas-datareader.readthedocs.io/en/latest/remote_data.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TSA from Statsmodels</span></span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> statsmodels.formula.api <span class="keyword">as</span> smf</span><br><span class="line"><span class="keyword">import</span> statsmodels.tsa.api <span class="keyword">as</span> smt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display and Plotting</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x: <span class="string">&#x27;%.5f&#x27;</span> % x) <span class="comment"># pandas</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">5</span>, suppress=<span class="literal">True</span>) <span class="comment"># numpy</span></span><br><span class="line"></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_columns&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># seaborn plotting style</span></span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&#x27;ticks&#x27;</span>, context=<span class="string">&#x27;poster&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>The autoreload extension is already loaded. To reload it, use:  %reload_ext autoreload</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Read the data</span></span><br><span class="line"><span class="comment">#美国消费者信心指数</span></span><br><span class="line">Sentiment = <span class="string">&#x27;data/sentiment.csv&#x27;</span></span><br><span class="line">Sentiment = pd.read_csv(Sentiment, index_col=<span class="number">0</span>, parse_dates=[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sentiment.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>UMCSENT</th>    </tr>    <tr>      <th>DATE</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>2000-01-01</th>      <td>112.00000</td>    </tr>    <tr>      <th>2000-02-01</th>      <td>111.30000</td>    </tr>    <tr>      <th>2000-03-01</th>      <td>107.10000</td>    </tr>    <tr>      <th>2000-04-01</th>      <td>109.20000</td>    </tr>    <tr>      <th>2000-05-01</th>      <td>110.70000</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Select the series from 2005 - 2016</span></span><br><span class="line">sentiment_short = Sentiment.loc[<span class="string">&#x27;2005&#x27;</span>:<span class="string">&#x27;2016&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentiment_short.plot(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">plt.legend(bbox_to_anchor=(<span class="number">1.25</span>, <span class="number">0.5</span>))</span><br><span class="line">plt.title(<span class="string">&quot;Consumer Sentiment&quot;</span>)</span><br><span class="line">sns.despine()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005235.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentiment_short[<span class="string">&#x27;diff_1&#x27;</span>] = sentiment_short[<span class="string">&#x27;UMCSENT&#x27;</span>].diff(<span class="number">1</span>) <span class="comment"># 做一个是时间间隔算差分值</span></span><br><span class="line"></span><br><span class="line">sentiment_short[<span class="string">&#x27;diff_2&#x27;</span>] = sentiment_short[<span class="string">&#x27;diff_1&#x27;</span>].diff(<span class="number">1</span>) <span class="comment"># 对一阶差分的基础上进行算差分，得到二阶差分。</span></span><br><span class="line"></span><br><span class="line">sentiment_short.plot(subplots=<span class="literal">True</span>, figsize=(<span class="number">18</span>, <span class="number">12</span>))</span><br></pre></td></tr></table></figure><pre><code>array([&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000001D9383BACF8&gt;,       &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000001D939FAB6A0&gt;,       &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000001D93A139B70&gt;], dtype=object)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005300.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> sentiment_short[<span class="string">&#x27;diff_2&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> sentiment_short[<span class="string">&#x27;diff_1&#x27;</span>]</span><br><span class="line">sentiment_short.head()</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(sentiment_short))</span><br></pre></td></tr></table></figure><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">211</span>)</span><br><span class="line">fig = sm.graphics.tsa.plot_acf(sentiment_short, lags=<span class="number">20</span>,ax=ax1)</span><br><span class="line">ax1.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">fig.tight_layout();</span><br><span class="line"></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">212</span>)</span><br><span class="line">fig = sm.graphics.tsa.plot_pacf(sentiment_short, lags=<span class="number">20</span>, ax=ax2)</span><br><span class="line">ax2.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">fig.tight_layout();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005319.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 散点图也可以表示</span></span><br><span class="line"></span><br><span class="line">lags=<span class="number">9</span></span><br><span class="line"></span><br><span class="line">ncols=<span class="number">3</span></span><br><span class="line">nrows=<span class="built_in">int</span>(np.ceil(lags/ncols))</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=ncols, nrows=nrows, figsize=(<span class="number">4</span>*ncols, <span class="number">4</span>*nrows))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, lag <span class="keyword">in</span> <span class="built_in">zip</span>(axes.flat, np.arange(<span class="number">1</span>,lags+<span class="number">1</span>, <span class="number">1</span>)):</span><br><span class="line">    lag_str = <span class="string">&#x27;t-&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(lag)</span><br><span class="line">    X = (pd.concat([sentiment_short, sentiment_short.shift(-lag)], axis=<span class="number">1</span>,</span><br><span class="line">                   keys=[<span class="string">&#x27;y&#x27;</span>] + [lag_str]).dropna())</span><br><span class="line"></span><br><span class="line">    X.plot(ax=ax, kind=<span class="string">&#x27;scatter&#x27;</span>, y=<span class="string">&#x27;y&#x27;</span>, x=lag_str);</span><br><span class="line">    corr = X.corr().as_matrix()[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">    ax.set_title(<span class="string">&#x27;Lag: &#123;&#125; (corr=&#123;:.2f&#125;)&#x27;</span>.<span class="built_in">format</span>(lag_str, corr));</span><br><span class="line">    ax.set_aspect(<span class="string">&#x27;equal&#x27;</span>);</span><br><span class="line">    sns.despine();</span><br><span class="line"></span><br><span class="line">fig.tight_layout();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005340.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更直观一些</span></span><br><span class="line"><span class="comment"># 模板——只需要把自己的数据放进来，就可进行分析。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tsplot</span>(<span class="params">y, lags=<span class="literal">None</span>, title=<span class="string">&#x27;&#x27;</span>, figsize=(<span class="params"><span class="number">14</span>, <span class="number">8</span></span>)</span>):</span></span><br><span class="line">   </span><br><span class="line">    fig = plt.figure(figsize=figsize)</span><br><span class="line">    layout = (<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    ts_ax   = plt.subplot2grid(layout, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    hist_ax = plt.subplot2grid(layout, (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    acf_ax  = plt.subplot2grid(layout, (<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    pacf_ax = plt.subplot2grid(layout, (<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    y.plot(ax=ts_ax)</span><br><span class="line">    ts_ax.set_title(title)</span><br><span class="line">    y.plot(ax=hist_ax, kind=<span class="string">&#x27;hist&#x27;</span>, bins=<span class="number">25</span>)</span><br><span class="line">    hist_ax.set_title(<span class="string">&#x27;Histogram&#x27;</span>)</span><br><span class="line">    smt.graphics.plot_acf(y, lags=lags, ax=acf_ax)</span><br><span class="line">    smt.graphics.plot_pacf(y, lags=lags, ax=pacf_ax)</span><br><span class="line">    [ax.set_xlim(<span class="number">0</span>) <span class="keyword">for</span> ax <span class="keyword">in</span> [acf_ax, pacf_ax]]</span><br><span class="line">    sns.despine()</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    <span class="keyword">return</span> ts_ax, acf_ax, pacf_ax</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsplot(sentiment_short, title=<span class="string">&#x27;Consumer Sentiment&#x27;</span>, lags=<span class="number">36</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005359.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ARIMA模型的一些概念&quot;&gt;&lt;a href=&quot;#ARIMA模型的一些概念&quot; class=&quot;headerlink&quot; title=&quot;ARIMA模型的一些概念&quot;&gt;&lt;/a&gt;ARIMA模型的一些概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;差分&lt;/li&gt;
&lt;li&gt;ACF 自相关函数&lt;/l</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>时间序列——pandas的滑动窗口</title>
    <link href="https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.html"/>
    <id>https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.html</id>
    <published>2021-05-25T16:49:14.000Z</published>
    <updated>2021-05-25T16:55:27.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pandas滑动窗口"><a href="#pandas滑动窗口" class="headerlink" title="pandas滑动窗口"></a>pandas滑动窗口</h3><ul><li>进行预测单独拿某一天的值不合理，可以用一个滑动窗口，取一个平均值，比较平稳。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline </span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.Series(np.random.randn(<span class="number">600</span>), index = pd.date_range(<span class="string">&#x27;7/1/2021&#x27;</span>, freq = <span class="string">&#x27;D&#x27;</span>, periods = <span class="number">600</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure><pre><code>2021-07-01   -1.5072342021-07-02    1.4607542021-07-03   -0.0921462021-07-04    2.4869302021-07-05    1.214179Freq: D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = df.rolling(window = <span class="number">10</span>) <span class="comment"># 滑动窗口的大小。默认从左边开始滑动。</span></span><br><span class="line">r</span><br></pre></td></tr></table></figure><pre><code>Rolling [window=10,center=False,axis=0]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r.max, r.median, r.std, r.skew, r.sum, r.var</span></span><br><span class="line">print(r.mean()) <span class="comment"># 小于窗口长度不会计算！为NaN</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>2021-07-01         NaN2021-07-02         NaN2021-07-03         NaN2021-07-04         NaN2021-07-05         NaN2021-07-06         NaN2021-07-07         NaN2021-07-08         NaN2021-07-09         NaN2021-07-10    0.4131762021-07-11    0.4896582021-07-12    0.3425022021-07-28   -0.1628612021-07-29   -0.2144422021-07-30   -0.257007                ...   2023-02-17    0.2890902023-02-18   -0.0495742023-02-19   -0.0959742023-02-20   -0.226629Freq: D, Length: 600, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">df.plot(style=<span class="string">&#x27;r--&#x27;</span>)</span><br><span class="line">df.rolling(window=<span class="number">10</span>).mean().plot(style=<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x1bafae87630&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005000.png" alt=""></p><p><strong>可以看到滑动窗口的平均值更平稳一些</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pandas滑动窗口&quot;&gt;&lt;a href=&quot;#pandas滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;pandas滑动窗口&quot;&gt;&lt;/a&gt;pandas滑动窗口&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;进行预测单独拿某一天的值不合理，可以用一个滑动窗口，取一个平均值</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>时间序列——pandas的数据重采样</title>
    <link href="https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8D%E9%87%87%E6%A0%B7.html"/>
    <id>https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8D%E9%87%87%E6%A0%B7.html</id>
    <published>2021-05-25T16:48:15.000Z</published>
    <updated>2021-05-25T16:48:52.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pandas数据重采样"><a href="#pandas数据重采样" class="headerlink" title="pandas数据重采样"></a>pandas数据重采样</h3><ul><li>时间数据由一个频率转换到另一个频率</li><li>降采样</li><li>升采样</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">&#x27;1/1/2011&#x27;</span>, periods=<span class="number">90</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line">ts.head()</span><br></pre></td></tr></table></figure><pre><code>2011-01-01   -1.0255622011-01-02    0.4108952011-01-03    0.6603112011-01-04    0.7102932011-01-05    0.444985Freq: D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.resample(<span class="string">&#x27;M&#x27;</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><pre><code>2011-01-31    2.5101022011-02-28    0.5832092011-03-31    2.749411Freq: M, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.resample(<span class="string">&#x27;3D&#x27;</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0456432011-01-04   -2.2552062011-01-07    0.5711422011-01-10    0.8350322011-01-13   -0.3967662011-01-16   -1.1562532011-01-19   -1.2868842011-01-22    2.8839522011-01-25    1.5669082011-01-28    1.4355632011-01-31    0.3115652011-02-03   -2.5412352011-02-06    0.3170752011-02-09    1.5988772011-02-12   -1.9505092011-02-15    2.9283122011-02-18   -0.7337152011-02-21    1.6748172011-02-24   -2.0788722011-02-27    2.1723202011-03-02   -2.0221042011-03-05   -0.0703562011-03-08    1.2766712011-03-11   -2.8351322011-03-14   -1.3841132011-03-17    1.5175652011-03-20   -0.5504062011-03-23    0.7734302011-03-26    2.2443192011-03-29    2.951082Freq: 3D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">day3Ts = ts.resample(<span class="string">&#x27;3D&#x27;</span>).mean()</span><br><span class="line">day3Ts</span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0152142011-01-04   -0.7517352011-01-07    0.1903812011-01-10    0.2783442011-01-13   -0.1322552011-01-16   -0.3854182011-01-19   -0.4289612011-01-22    0.9613172011-01-25    0.5223032011-01-28    0.4785212011-01-31    0.1038552011-02-03   -0.8470782011-02-06    0.1056922011-02-09    0.5329592011-02-12   -0.6501702011-02-15    0.9761042011-02-18   -0.2445722011-02-21    0.5582722011-02-24   -0.6929572011-02-27    0.7241072011-03-02   -0.6740352011-03-05   -0.0234522011-03-08    0.4255572011-03-11   -0.9450442011-03-14   -0.4613712011-03-17    0.5058552011-03-20   -0.1834692011-03-23    0.2578102011-03-26    0.7481062011-03-29    0.983694Freq: 3D, dtype: float64</code></pre><h3 id="降采样容易，但是升采样就有些难度了。"><a href="#降采样容易，但是升采样就有些难度了。" class="headerlink" title="降采样容易，但是升采样就有些难度了。"></a>降采样容易，但是升采样就有些难度了。</h3><ul><li>将上面的3天的数据变成1天统计的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(day3Ts.resample(<span class="string">&#x27;D&#x27;</span>).asfreq()) </span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0152142011-01-02         NaN2011-01-03         NaN2011-01-04   -0.7517352011-01-05         NaN2011-01-06         NaN2011-01-07    0.1903812011-01-08         NaN2011-01-09         NaN2011-01-10    0.2783442011-01-11         NaN2011-01-12         NaN2011-01-13   -0.1322552011-01-14         NaN2011-01-15         NaN2011-01-16   -0.3854182011-01-17         NaN2011-01-18         NaN2011-01-19   -0.4289612011-01-20         NaN2011-01-21         NaN2011-01-22    0.9613172011-01-23         NaN2011-01-24         NaN2011-01-25    0.5223032011-01-26         NaN2011-01-27         NaN2011-01-28    0.4785212011-01-29         NaN2011-01-30         NaN                ...   2011-02-28         NaN2011-03-01         NaN2011-03-02   -0.6740352011-03-03         NaN2011-03-04         NaN2011-03-05   -0.0234522011-03-06         NaN2011-03-07         NaN2011-03-08    0.4255572011-03-09         NaN2011-03-10         NaN2011-03-11   -0.9450442011-03-12         NaN2011-03-13         NaN2011-03-14   -0.4613712011-03-15         NaN2011-03-16         NaN2011-03-17    0.5058552011-03-18         NaN2011-03-19         NaN2011-03-20   -0.1834692011-03-21         NaN2011-03-22         NaN2011-03-23    0.2578102011-03-24         NaN2011-03-25         NaN2011-03-26    0.7481062011-03-27         NaN2011-03-28         NaN2011-03-29    0.983694Freq: D, Length: 88, dtype: float64</code></pre><h3 id="插值方法："><a href="#插值方法：" class="headerlink" title="插值方法："></a>插值方法：</h3><ul><li>ffill 空值取前面的值</li><li>bfill 空值取后面的值</li><li>interpolate 线性取值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">day3Ts.resample(<span class="string">&#x27;D&#x27;</span>).ffill(<span class="number">1</span>) <span class="comment"># 按照前面的数据进行插值</span></span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0152142011-01-02    0.0152142011-01-03         NaN2011-01-04   -0.7517352011-01-05   -0.7517352011-01-06         NaN2011-01-07    0.1903812011-01-08    0.1903812011-01-09         NaN2011-01-10    0.2783442011-01-11    0.2783442011-01-12         NaN2011-01-13   -0.1322552011-01-14   -0.1322552011-01-15         NaN2011-01-16   -0.3854182011-01-17   -0.3854182011-01-18         NaN2011-01-19   -0.4289612011-01-20   -0.4289612011-01-21         NaN2011-01-22    0.9613172011-01-23    0.9613172011-01-24         NaN2011-01-25    0.5223032011-01-26    0.5223032011-01-27         NaN2011-01-28    0.4785212011-01-29    0.4785212011-01-30         NaN                ...   2011-02-28    0.7241072011-03-01         NaN2011-03-02   -0.6740352011-03-03   -0.6740352011-03-04         NaN2011-03-05   -0.0234522011-03-06   -0.0234522011-03-07         NaN2011-03-08    0.4255572011-03-09    0.4255572011-03-10         NaN2011-03-11   -0.9450442011-03-12   -0.9450442011-03-13         NaN2011-03-14   -0.4613712011-03-15   -0.4613712011-03-16         NaN2011-03-17    0.5058552011-03-18    0.5058552011-03-19         NaN2011-03-20   -0.1834692011-03-21   -0.1834692011-03-22         NaN2011-03-23    0.2578102011-03-24    0.2578102011-03-25         NaN2011-03-26    0.7481062011-03-27    0.7481062011-03-28         NaN2011-03-29    0.983694Freq: D, Length: 88, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">day3Ts.resample(<span class="string">&#x27;D&#x27;</span>).bfill(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0152142011-01-02         NaN2011-01-03   -0.7517352011-01-04   -0.7517352011-01-05         NaN2011-01-06    0.1903812011-01-07    0.1903812011-01-08         NaN2011-01-09    0.2783442011-01-10    0.2783442011-01-11         NaN2011-01-12   -0.1322552011-01-13   -0.1322552011-01-14         NaN2011-01-15   -0.3854182011-01-16   -0.3854182011-01-17         NaN2011-01-18   -0.4289612011-01-19   -0.4289612011-01-20         NaN2011-01-21    0.9613172011-01-22    0.9613172011-01-23         NaN2011-01-24    0.5223032011-01-25    0.5223032011-01-26         NaN2011-01-27    0.4785212011-01-28    0.4785212011-01-29         NaN2011-01-30    0.103855                ...   2011-02-28         NaN2011-03-01   -0.6740352011-03-02   -0.6740352011-03-03         NaN2011-03-04   -0.0234522011-03-05   -0.0234522011-03-06         NaN2011-03-07    0.4255572011-03-08    0.4255572011-03-09         NaN2011-03-10   -0.9450442011-03-11   -0.9450442011-03-12         NaN2011-03-13   -0.4613712011-03-14   -0.4613712011-03-15         NaN2011-03-16    0.5058552011-03-17    0.5058552011-03-18         NaN2011-03-19   -0.1834692011-03-20   -0.1834692011-03-21         NaN2011-03-22    0.2578102011-03-23    0.2578102011-03-24         NaN2011-03-25    0.7481062011-03-26    0.7481062011-03-27         NaN2011-03-28    0.9836942011-03-29    0.983694Freq: D, Length: 88, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">day3Ts.resample(<span class="string">&#x27;D&#x27;</span>).interpolate(<span class="string">&#x27;linear&#x27;</span>) <span class="comment"># 1和4有数据，连城线，在对应点取值。</span></span><br></pre></td></tr></table></figure><pre><code>2011-01-01    0.0152142011-01-02   -0.2404352011-01-03   -0.4960852011-01-04   -0.7517352011-01-05   -0.4376972011-01-06   -0.1236582011-01-07    0.1903812011-01-08    0.2197022011-01-09    0.2490232011-01-10    0.2783442011-01-11    0.1414782011-01-12    0.0046112011-01-13   -0.1322552011-01-14   -0.2166432011-01-15   -0.3010302011-01-16   -0.3854182011-01-17   -0.3999322011-01-18   -0.4144472011-01-19   -0.4289612011-01-20    0.0344652011-01-21    0.4978912011-01-22    0.9613172011-01-23    0.8149792011-01-24    0.6686412011-01-25    0.5223032011-01-26    0.5077092011-01-27    0.4931152011-01-28    0.4785212011-01-29    0.3536322011-01-30    0.228744                ...   2011-02-28    0.2580602011-03-01   -0.2079882011-03-02   -0.6740352011-03-03   -0.4571742011-03-04   -0.2403132011-03-05   -0.0234522011-03-06    0.1262182011-03-07    0.2758872011-03-08    0.4255572011-03-09   -0.0313102011-03-10   -0.4881772011-03-11   -0.9450442011-03-12   -0.7838202011-03-13   -0.6225952011-03-14   -0.4613712011-03-15   -0.1389622011-03-16    0.1834462011-03-17    0.5058552011-03-18    0.2760802011-03-19    0.0463062011-03-20   -0.1834692011-03-21   -0.0363762011-03-22    0.1107172011-03-23    0.2578102011-03-24    0.4212422011-03-25    0.5846742011-03-26    0.7481062011-03-27    0.8266362011-03-28    0.9051652011-03-29    0.983694Freq: D, Length: 88, dtype: float64</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pandas数据重采样&quot;&gt;&lt;a href=&quot;#pandas数据重采样&quot; class=&quot;headerlink&quot; title=&quot;pandas数据重采样&quot;&gt;&lt;/a&gt;pandas数据重采样&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;时间数据由一个频率转换到另一个频率&lt;/li&gt;
&lt;li&gt;降</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>时间序列——pandas生成时间序列</title>
    <link href="https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%94%9F%E6%88%90%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97.html"/>
    <id>https://xxren8218.github.io/20210526/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94pandas%E7%94%9F%E6%88%90%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97.html</id>
    <published>2021-05-25T16:46:08.000Z</published>
    <updated>2021-05-25T16:56:35.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pandas生成时间序列"><a href="#pandas生成时间序列" class="headerlink" title="pandas生成时间序列"></a>pandas生成时间序列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime <span class="keyword">as</span> dt</span><br></pre></td></tr></table></figure><h3 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h3><ul><li>时间戳（timestamp）具体到时间点</li><li>固定周期（period）</li><li>时间间隔（interval）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005603.png" alt=""></p><h3 id="date-range"><a href="#date-range" class="headerlink" title="date_range"></a>date_range</h3><ul><li>可以指定开始时间与周期</li><li>H：小时</li><li>D：天</li><li>M：月</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TIMES # 2021 Jul 1 7/1/2021 1/7/2021 2021-07-01 2021/07/01都可以</span></span><br><span class="line">rng = pd.date_range(<span class="string">&#x27;2021-07-01&#x27;</span>, periods = <span class="number">10</span>, freq = <span class="string">&#x27;3D&#x27;</span>)</span><br><span class="line">rng</span><br></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2021-07-01&#39;, &#39;2021-07-04&#39;, &#39;2021-07-07&#39;, &#39;2021-07-10&#39;,               &#39;2021-07-13&#39;, &#39;2021-07-16&#39;, &#39;2021-07-19&#39;, &#39;2021-07-22&#39;,               &#39;2021-07-25&#39;, &#39;2021-07-28&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;3D&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time=pd.Series(np.random.randn(<span class="number">20</span>),</span><br><span class="line">           index=pd.date_range(dt(<span class="number">2021</span>,<span class="number">1</span>,<span class="number">1</span>),periods=<span class="number">20</span>))</span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure><pre><code>2021-01-01    0.6083582021-01-02   -0.4024342021-01-03   -1.9176162021-01-04    1.5689362021-01-05   -0.6681692021-01-06   -0.1480382021-01-07   -0.3934292021-01-08    0.0520602021-01-09   -0.0747322021-01-10    1.4574572021-01-11   -0.1068782021-01-12    0.3405052021-01-13    0.6947552021-01-14    0.2615712021-01-15    0.2310212021-01-16   -0.4546392021-01-17   -0.3137792021-01-18    0.3115802021-01-19   -1.3759622021-01-20    1.450409Freq: D, dtype: float64</code></pre><h3 id="truncate过滤"><a href="#truncate过滤" class="headerlink" title="truncate过滤"></a>truncate过滤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.truncate(before=<span class="string">&#x27;2021-1-10&#x27;</span>) <span class="comment"># 之前的都没有了</span></span><br></pre></td></tr></table></figure><pre><code>2021-01-10    1.4574572021-01-11   -0.1068782021-01-12    0.3405052021-01-13    0.6947552021-01-14    0.2615712021-01-15    0.2310212021-01-16   -0.4546392021-01-17   -0.3137792021-01-18    0.3115802021-01-19   -1.3759622021-01-20    1.450409Freq: D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.truncate(after=<span class="string">&#x27;2021-1-10&#x27;</span>) <span class="comment"># 之后的都没了</span></span><br></pre></td></tr></table></figure><pre><code>2021-01-01    0.6083582021-01-02   -0.4024342021-01-03   -1.9176162021-01-04    1.5689362021-01-05   -0.6681692021-01-06   -0.1480382021-01-07   -0.3934292021-01-08    0.0520602021-01-09   -0.0747322021-01-10    1.457457Freq: D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(time[<span class="string">&#x27;2021-01-15&#x27;</span>])</span><br></pre></td></tr></table></figure><pre><code>0.2310208242057297</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(time[<span class="string">&#x27;2021-01-15&#x27;</span>:<span class="string">&#x27;2021-01-20&#x27;</span>])</span><br></pre></td></tr></table></figure><pre><code>2021-01-15    0.2310212021-01-16   -0.4546392021-01-17   -0.3137792021-01-18    0.3115802021-01-19   -1.3759622021-01-20    1.450409Freq: D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data=pd.date_range(<span class="string">&#x27;2020-01-01&#x27;</span>,<span class="string">&#x27;2021-01-01&#x27;</span>,freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2020-01-31&#39;, &#39;2020-02-29&#39;, &#39;2020-03-31&#39;, &#39;2020-04-30&#39;,               &#39;2020-05-31&#39;, &#39;2020-06-30&#39;, &#39;2020-07-31&#39;, &#39;2020-08-31&#39;,               &#39;2020-09-30&#39;, &#39;2020-10-31&#39;, &#39;2020-11-30&#39;, &#39;2020-12-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210526005622.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间戳</span></span><br><span class="line">pd.Timestamp(<span class="string">&#x27;2021-07-10&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2021-07-10 00:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以指定更多细节</span></span><br><span class="line">pd.Timestamp(<span class="string">&#x27;2021-07-10 10&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2021-07-10 10:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Timestamp(<span class="string">&#x27;2021-07-10 10:15&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2021-07-10 10:15:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How much detail can you add?</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = pd.Timestamp(<span class="string">&#x27;2021-07-10 10:15&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间区间</span></span><br><span class="line">pd.Period(<span class="string">&#x27;2021-01&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Period(&#39;2021-01&#39;, &#39;M&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Period(<span class="string">&#x27;2021-01-01&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Period(&#39;2021-01-01&#39;, &#39;D&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TIME OFFSETS 对时间的加减！</span></span><br><span class="line">pd.Timedelta(<span class="string">&#x27;1 day&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timedelta(&#39;1 days 00:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Period(<span class="string">&#x27;2021-01-01 10:10&#x27;</span>) + pd.Timedelta(<span class="string">&#x27;1 day&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Period(&#39;2021-01-02 10:10&#39;, &#39;T&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Timestamp(<span class="string">&#x27;2021-01-01 10:10&#x27;</span>) + pd.Timedelta(<span class="string">&#x27;1 day&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2021-01-02 10:10:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Timestamp(<span class="string">&#x27;2021-01-01 10:10&#x27;</span>) + pd.Timedelta(<span class="string">&#x27;15 ns&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Timestamp(&#39;2021-01-01 10:10:00.000000015&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = pd.period_range(<span class="string">&#x27;2021-01-01 10:10&#x27;</span>, freq = <span class="string">&#x27;25H&#x27;</span>, periods = <span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = pd.period_range(<span class="string">&#x27;2021-01-01 10:10&#x27;</span>, freq = <span class="string">&#x27;1D1H&#x27;</span>, periods = <span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1</span><br></pre></td></tr></table></figure><pre><code>PeriodIndex([&#39;2021-01-01 10:00&#39;, &#39;2021-01-02 11:00&#39;, &#39;2021-01-03 12:00&#39;,             &#39;2021-01-04 13:00&#39;, &#39;2021-01-05 14:00&#39;, &#39;2021-01-06 15:00&#39;,             &#39;2021-01-07 16:00&#39;, &#39;2021-01-08 17:00&#39;, &#39;2021-01-09 18:00&#39;,             &#39;2021-01-10 19:00&#39;],            dtype=&#39;period[25H]&#39;, freq=&#39;25H&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2</span><br></pre></td></tr></table></figure><pre><code>PeriodIndex([&#39;2021-01-01 10:00&#39;, &#39;2021-01-02 11:00&#39;, &#39;2021-01-03 12:00&#39;,             &#39;2021-01-04 13:00&#39;, &#39;2021-01-05 14:00&#39;, &#39;2021-01-06 15:00&#39;,             &#39;2021-01-07 16:00&#39;, &#39;2021-01-08 17:00&#39;, &#39;2021-01-09 18:00&#39;,             &#39;2021-01-10 19:00&#39;],            dtype=&#39;period[25H]&#39;, freq=&#39;25H&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定索引</span></span><br><span class="line">rng = pd.date_range(<span class="string">&#x27;2016 Jul 1&#x27;</span>, periods = <span class="number">10</span>, freq = <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">rng</span><br><span class="line">pd.Series(<span class="built_in">range</span>(<span class="built_in">len</span>(rng)), index = rng)</span><br></pre></td></tr></table></figure><pre><code>2016-07-01    02016-07-02    12016-07-03    22016-07-04    32016-07-05    42016-07-06    52016-07-07    62016-07-08    72016-07-09    82016-07-10    9Freq: D, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">periods = [pd.Period(<span class="string">&#x27;2021-01&#x27;</span>), pd.Period(<span class="string">&#x27;2021-02&#x27;</span>), pd.Period(<span class="string">&#x27;2021-03&#x27;</span>)]</span><br><span class="line">ts = pd.Series(np.random.randn(<span class="built_in">len</span>(periods)), index = periods)</span><br><span class="line">ts</span><br></pre></td></tr></table></figure><pre><code>2021-01    0.9974222021-02    2.0062482021-03    0.606481Freq: M, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(ts.index)</span><br></pre></td></tr></table></figure><pre><code>pandas.core.indexes.period.PeriodIndex</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间戳和时间周期可以转换</span></span><br><span class="line">ts = pd.Series(<span class="built_in">range</span>(<span class="number">10</span>), pd.date_range(<span class="string">&#x27;07-10-21 8:00&#x27;</span>, periods = <span class="number">10</span>, freq = <span class="string">&#x27;H&#x27;</span>))</span><br><span class="line">ts</span><br></pre></td></tr></table></figure><pre><code>2021-07-10 08:00:00    02021-07-10 09:00:00    12021-07-10 10:00:00    22021-07-10 11:00:00    32021-07-10 12:00:00    42021-07-10 13:00:00    52021-07-10 14:00:00    62021-07-10 15:00:00    72021-07-10 16:00:00    82021-07-10 17:00:00    9Freq: H, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ts_period = ts.to_period()</span><br><span class="line">ts_period</span><br></pre></td></tr></table></figure><pre><code>2021-07-10 08:00    02021-07-10 09:00    12021-07-10 10:00    22021-07-10 11:00    32021-07-10 12:00    42021-07-10 13:00    52021-07-10 14:00    62021-07-10 15:00    72021-07-10 16:00    82021-07-10 17:00    9Freq: H, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts_period[<span class="string">&#x27;2021-07-10 08:30&#x27;</span>:<span class="string">&#x27;2021-07-10 11:45&#x27;</span>]  <span class="comment"># 时间周期包括8:00</span></span><br></pre></td></tr></table></figure><pre><code>2021-07-10 08:00    02021-07-10 09:00    12021-07-10 10:00    22021-07-10 11:00    3Freq: H, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts[<span class="string">&#x27;2021-07-10 08:30&#x27;</span>:<span class="string">&#x27;2021-07-10 11:45&#x27;</span>]   <span class="comment"># 时间戳不包活8:00</span></span><br></pre></td></tr></table></figure><pre><code>2021-07-10 09:00:00    12021-07-10 10:00:00    22021-07-10 11:00:00    3Freq: H, dtype: int32</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pandas生成时间序列&quot;&gt;&lt;a href=&quot;#pandas生成时间序列&quot; class=&quot;headerlink&quot; title=&quot;pandas生成时间序列&quot;&gt;&lt;/a&gt;pandas生成时间序列&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>支持向量机</title>
    <link href="https://xxren8218.github.io/20210525/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html"/>
    <id>https://xxren8218.github.io/20210525/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html</id>
    <published>2021-05-25T10:42:17.000Z</published>
    <updated>2021-05-25T10:49:25.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="支持向量机（SVM）"><a href="#支持向量机（SVM）" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h1><ul><li>低纬不可分的东西转化为高纬可分割的东西</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"></span><br><span class="line"><span class="comment"># use seaborn plotting defaults</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns; sns.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><h3 id="支持向量基本原理"><a href="#支持向量基本原理" class="headerlink" title="支持向量基本原理"></a>支持向量基本原理</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184326.png" alt=""></p><p>如何解决这个线性不可分问题呢？咱们给它映射到高维来试试</p><p>$z=x^2+y^2$. </p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机来点数据</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">50</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">0.60</span>)  <span class="comment"># cluster_std=0.60 簇的离散程度。越小，越集中，越好分类</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1ba274e1ac8&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184358.png" alt=""></p><p>随便的画几条分割线，哪个好来这？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xfit = np.linspace(-<span class="number">1</span>, <span class="number">3.5</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">0.6</span>], [<span class="number">2.1</span>], <span class="string">&#x27;x&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>, markeredgewidth=<span class="number">2</span>, markersize=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m, b <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0.65</span>), (<span class="number">0.5</span>, <span class="number">1.6</span>), (-<span class="number">0.2</span>, <span class="number">2.9</span>)]:</span><br><span class="line">    plt.plot(xfit, m * xfit + b, <span class="string">&#x27;-k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">1</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184415.png" alt=""></p><h2 id="Support-Vector-Machines-最小化-雷区"><a href="#Support-Vector-Machines-最小化-雷区" class="headerlink" title="Support Vector Machines: 最小化 雷区"></a>Support Vector Machines: 最小化 <em>雷区</em></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xfit = np.linspace(-<span class="number">1</span>, <span class="number">3.5</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m, b, d <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0.65</span>, <span class="number">0.33</span>), (<span class="number">0.5</span>, <span class="number">1.6</span>, <span class="number">0.55</span>), (-<span class="number">0.2</span>, <span class="number">2.9</span>, <span class="number">0.2</span>)]:</span><br><span class="line">    yfit = m * xfit + b</span><br><span class="line">    plt.plot(xfit, yfit, <span class="string">&#x27;-k&#x27;</span>)</span><br><span class="line">    plt.fill_between(xfit, yfit - d, yfit + d, edgecolor=<span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">                     color=<span class="string">&#x27;#AAAAAA&#x27;</span>, alpha=<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">1</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184433.png" alt=""></p><h3 id="训练一个基本的SVM"><a href="#训练一个基本的SVM" class="headerlink" title="训练一个基本的SVM"></a>训练一个基本的SVM</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC <span class="comment"># &quot;Support vector classifier&quot;</span></span><br><span class="line">model = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">model.fit(X, y)</span><br></pre></td></tr></table></figure><pre><code>SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,  decision_function_shape=None, degree=3, gamma=&#39;auto&#39;, kernel=&#39;linear&#39;,  max_iter=-1, probability=False, random_state=None, shrinking=True,  tol=0.001, verbose=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘图函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_svc_decision_function</span>(<span class="params">model, ax=<span class="literal">None</span>, plot_support=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Plot the decision function for a 2D SVC&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ax = plt.gca()</span><br><span class="line">    xlim = ax.get_xlim()</span><br><span class="line">    ylim = ax.get_ylim()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># create grid to evaluate model</span></span><br><span class="line">    x = np.linspace(xlim[<span class="number">0</span>], xlim[<span class="number">1</span>], <span class="number">30</span>)</span><br><span class="line">    y = np.linspace(ylim[<span class="number">0</span>], ylim[<span class="number">1</span>], <span class="number">30</span>)</span><br><span class="line">    Y, X = np.meshgrid(y, x)</span><br><span class="line">    xy = np.vstack([X.ravel(), Y.ravel()]).T</span><br><span class="line">    P = model.decision_function(xy).reshape(X.shape)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plot decision boundary and margins</span></span><br><span class="line">    ax.contour(X, Y, P, colors=<span class="string">&#x27;k&#x27;</span>,</span><br><span class="line">               levels=[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], alpha=<span class="number">0.5</span>,</span><br><span class="line">               linestyles=[<span class="string">&#x27;--&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;--&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plot support vectors</span></span><br><span class="line">    <span class="keyword">if</span> plot_support:</span><br><span class="line">        ax.scatter(model.support_vectors_[:, <span class="number">0</span>],</span><br><span class="line">                   model.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">                   s=<span class="number">300</span>, linewidth=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    ax.set_xlim(xlim)</span><br><span class="line">    ax.set_ylim(ylim)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plot_svc_decision_function(model);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184519.png" alt=""></p><ul><li><p>这条线就是我们希望得到的决策边界啦</p></li><li><p>观察发现有3个点做了特殊的标记，它们恰好都是边界上的点</p></li><li><p>它们就是我们的<em>support vectors</em>（支持向量）</p></li><li><p>在Scikit-Learn中, 它们存储在这个位置 <code>support_vectors_</code>（一个属性）</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.support_vectors_</span><br></pre></td></tr></table></figure><pre><code>array([[ 0.44359863,  3.11530945],       [ 2.33812285,  3.43116792],       [ 2.06156753,  1.96918596]])</code></pre><ul><li><p>观察可以发现，只需要支持向量我们就可以把模型构建出来</p></li><li><p>接下来我们尝试一下，用不同多的数据点，看看效果会不会发生变化</p></li><li><p>分别使用60个和120个数据点</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_svm</span>(<span class="params">N=<span class="number">10</span>, ax=<span class="literal">None</span></span>):</span></span><br><span class="line">    X, y = make_blobs(n_samples=<span class="number">200</span>, centers=<span class="number">2</span>,</span><br><span class="line">                      random_state=<span class="number">0</span>, cluster_std=<span class="number">0.60</span>)</span><br><span class="line">    X = X[:N]</span><br><span class="line">    y = y[:N]</span><br><span class="line">    model = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>, C=<span class="number">1E10</span>)</span><br><span class="line">    model.fit(X, y)</span><br><span class="line">    </span><br><span class="line">    ax = ax <span class="keyword">or</span> plt.gca()</span><br><span class="line">    ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    ax.set_xlim(-<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    ax.set_ylim(-<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    plot_svc_decision_function(model, ax)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">6</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.0625</span>, right=<span class="number">0.95</span>, wspace=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">for</span> axi, N <span class="keyword">in</span> <span class="built_in">zip</span>(ax, [<span class="number">60</span>, <span class="number">120</span>]):</span><br><span class="line">    plot_svm(N, axi)</span><br><span class="line">    axi.set_title(<span class="string">&#x27;N = &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(N))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184545.png" alt=""></p><ul><li>左边是60个点的结果，右边的是120个点的结果</li><li>观察发现，只要支持向量没变，其他的数据怎么加无所谓！</li></ul><h3 id="引入核函数的SVM"><a href="#引入核函数的SVM" class="headerlink" title="引入核函数的SVM"></a>引入核函数的SVM</h3><ul><li>首先我们先用线性的核来看一下在下面这样比较难的数据集上还能分了吗？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_circles</span><br><span class="line">X, y = make_circles(<span class="number">100</span>, factor=<span class="number">.1</span>, noise=<span class="number">.1</span>)</span><br><span class="line"></span><br><span class="line">clf = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>).fit(X, y)</span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plot_svc_decision_function(clf, plot_support=<span class="literal">False</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184607.png" alt=""></p><ul><li><p>坏菜喽，分不了了，那咋办呢？试试高维核变换吧！</p></li><li><p>We can visualize this extra data dimension using a three-dimensional plot:</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入了新的维度r</span></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line">r = np.exp(-(X ** <span class="number">2</span>).<span class="built_in">sum</span>(<span class="number">1</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_3D</span>(<span class="params">elev=<span class="number">30</span>, azim=<span class="number">30</span>, X=X, y=y</span>):</span></span><br><span class="line">    ax = plt.subplot(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">    ax.scatter3D(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], r, c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    ax.view_init(elev=elev, azim=azim)</span><br><span class="line">    ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    ax.set_zlabel(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plot_3D(elev=<span class="number">45</span>, azim=<span class="number">45</span>, X=X, y=y)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184628.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入径向基函数（高斯核函数或者RBF核函数都一样）</span></span><br><span class="line">clf = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, C=<span class="number">1E6</span>)</span><br><span class="line">clf.fit(X, y)</span><br></pre></td></tr></table></figure><pre><code>SVC(C=1000000.0, cache_size=200, class_weight=None, coef0=0.0,  decision_function_shape=None, degree=3, gamma=&#39;auto&#39;, kernel=&#39;rbf&#39;,  max_iter=-1, probability=False, random_state=None, shrinking=True,  tol=0.001, verbose=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这回牛逼了！</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">plot_svc_decision_function(clf)</span><br><span class="line">plt.scatter(clf.support_vectors_[:, <span class="number">0</span>], clf.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">            s=<span class="number">300</span>, lw=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184658.png" alt=""></p><p>使用这种核支持向量机，我们学习一个合适的非线性决策边界。这种核变换策略在机器学习中经常被使用！</p><h3 id="调节SVM参数-Soft-Margin问题"><a href="#调节SVM参数-Soft-Margin问题" class="headerlink" title="调节SVM参数: Soft Margin问题"></a>调节SVM参数: Soft Margin问题</h3><h3 id="调节C参数"><a href="#调节C参数" class="headerlink" title="调节C参数"></a>调节C参数</h3><ul><li>当C趋近于无穷大时：意味着分类严格不能有错误</li><li>当C趋近于很小的时：意味着可以有更大的错误容忍</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">0.8</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184713.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">6</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.0625</span>, right=<span class="number">0.95</span>, wspace=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> axi, C <span class="keyword">in</span> <span class="built_in">zip</span>(ax, [<span class="number">10.0</span>, <span class="number">0.1</span>]):  <span class="comment"># 两个C参数 10.0和0.1</span></span><br><span class="line">    model = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>, C=C).fit(X, y)</span><br><span class="line">    axi.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    plot_svc_decision_function(model, axi)</span><br><span class="line">    axi.scatter(model.support_vectors_[:, <span class="number">0</span>],</span><br><span class="line">                model.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">                s=<span class="number">300</span>, lw=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    axi.set_title(<span class="string">&#x27;C = &#123;0:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(C), size=<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184732.png" alt=""></p><ul><li>左边的泛化能力小。</li><li>右边的泛化能力强一点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">2</span>,</span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">1.1</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">6</span>))</span><br><span class="line">fig.subplots_adjust(left=<span class="number">0.0625</span>, right=<span class="number">0.95</span>, wspace=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> axi, gamma <span class="keyword">in</span> <span class="built_in">zip</span>(ax, [<span class="number">10.0</span>, <span class="number">0.1</span>]):</span><br><span class="line">    model = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, gamma=gamma).fit(X, y)  <span class="comment"># gamma越高模型越复杂。返还能力越弱。</span></span><br><span class="line">    axi.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">50</span>, cmap=<span class="string">&#x27;autumn&#x27;</span>)</span><br><span class="line">    plot_svc_decision_function(model, axi)</span><br><span class="line">    axi.scatter(model.support_vectors_[:, <span class="number">0</span>],</span><br><span class="line">                model.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">                s=<span class="number">300</span>, lw=<span class="number">1</span>, facecolors=<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    axi.set_title(<span class="string">&#x27;gamma = &#123;0:.1f&#125;&#x27;</span>.<span class="built_in">format</span>(gamma), size=<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184758.png" alt=""></p><ul><li>越复杂的边界泛化能力越低。</li></ul><h2 id="Example-Face-Recognition"><a href="#Example-Face-Recognition" class="headerlink" title="Example: Face Recognition"></a>Example: Face Recognition</h2><p>As an example of support vector machines in action, let’s take a look at the facial recognition problem.<br>We will use the Labeled Faces in the Wild dataset, which consists of several thousand collated photos of various public figures.<br>A fetcher for the dataset is built into Scikit-Learn:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line">faces = fetch_lfw_people(min_faces_per_person=<span class="number">60</span>)</span><br><span class="line">print(faces.target_names)</span><br><span class="line">print(faces.images.shape)</span><br></pre></td></tr></table></figure><pre><code>[&#39;Ariel Sharon&#39; &#39;Colin Powell&#39; &#39;Donald Rumsfeld&#39; &#39;George W Bush&#39; &#39;Gerhard Schroeder&#39; &#39;Hugo Chavez&#39; &#39;Junichiro Koizumi&#39; &#39;Tony Blair&#39;](1348, 62, 47)</code></pre><p>Let’s plot a few of these faces to see what we’re working with:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i, axi <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.flat):</span><br><span class="line">    axi.imshow(faces.images[i], cmap=<span class="string">&#x27;bone&#x27;</span>)</span><br><span class="line">    axi.<span class="built_in">set</span>(xticks=[], yticks=[],</span><br><span class="line">            xlabel=faces.target_names[faces.target[i]])</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184821.png" alt=""></p><ul><li>每个图的大小是 [62×47] </li><li>在这里我们就把每一个像素点当成了一个特征，但是这样特征太多了，用PCA降维一下吧！</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="comment">#from sklearn.decomposition import RandomizedPCA</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"></span><br><span class="line">pca = PCA(n_components=<span class="number">150</span>, whiten=<span class="literal">True</span>, random_state=<span class="number">42</span>)</span><br><span class="line">svc = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, class_weight=<span class="string">&#x27;balanced&#x27;</span>)</span><br><span class="line">model = make_pipeline(pca, svc)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain, Xtest, ytrain, ytest = train_test_split(faces.data, faces.target,</span><br><span class="line">                                                random_state=<span class="number">40</span>)</span><br></pre></td></tr></table></figure><p>使用grid search cross-validation来选择我们的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">param_grid = &#123;<span class="string">&#x27;svc__C&#x27;</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">              <span class="string">&#x27;svc__gamma&#x27;</span>: [<span class="number">0.0001</span>, <span class="number">0.0005</span>, <span class="number">0.001</span>]&#125;</span><br><span class="line">grid = GridSearchCV(model, param_grid)</span><br><span class="line"></span><br><span class="line">%time grid.fit(Xtrain, ytrain)</span><br><span class="line">print(grid.best_params_)</span><br></pre></td></tr></table></figure><pre><code>Wall time: 51.5 s&#123;&#39;svc__C&#39;: 5, &#39;svc__gamma&#39;: 0.001&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = grid.best_estimator_</span><br><span class="line">yfit = model.predict(Xtest)</span><br><span class="line">yfit.shape</span><br></pre></td></tr></table></figure><pre><code>(337,)</code></pre><p>看看咋样吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> i, axi <span class="keyword">in</span> <span class="built_in">enumerate</span>(ax.flat):</span><br><span class="line">    axi.imshow(Xtest[i].reshape(<span class="number">62</span>, <span class="number">47</span>), cmap=<span class="string">&#x27;bone&#x27;</span>)</span><br><span class="line">    axi.<span class="built_in">set</span>(xticks=[], yticks=[])</span><br><span class="line">    axi.set_ylabel(faces.target_names[yfit[i]].split()[-<span class="number">1</span>],</span><br><span class="line">                   color=<span class="string">&#x27;black&#x27;</span> <span class="keyword">if</span> yfit[i] == ytest[i] <span class="keyword">else</span> <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">fig.suptitle(<span class="string">&#x27;Predicted Names; Incorrect Labels in Red&#x27;</span>, size=<span class="number">14</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184837.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line">print(classification_report(ytest, yfit,</span><br><span class="line">                            target_names=faces.target_names))</span><br></pre></td></tr></table></figure><pre><code>                   precision    recall  f1-score   support     Ariel Sharon       0.50      0.50      0.50        16     Colin Powell       0.69      0.81      0.75        54  Donald Rumsfeld       0.83      0.85      0.84        34    George W Bush       0.94      0.88      0.91       136Gerhard Schroeder       0.72      0.85      0.78        27      Hugo Chavez       0.81      0.72      0.76        18Junichiro Koizumi       0.87      0.87      0.87        15       Tony Blair       0.85      0.76      0.80        37      avg / total       0.83      0.82      0.82       337</code></pre><ul><li>精度(precision) = 正确预测的个数(TP)/被预测正确的个数(TP+FP)</li><li>召回率(recall)=正确预测的个数(TP)/预测个数(TP+FN)</li><li>F1 = 2<em>精度</em>召回率/(精度+召回率)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">mat = confusion_matrix(ytest, yfit)</span><br><span class="line">sns.heatmap(mat.T, square=<span class="literal">True</span>, annot=<span class="literal">True</span>, fmt=<span class="string">&#x27;d&#x27;</span>, cbar=<span class="literal">False</span>,</span><br><span class="line">            xticklabels=faces.target_names,</span><br><span class="line">            yticklabels=faces.target_names)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;true label&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;predicted label&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210525184906.png" alt=""></p><ul><li>这样显示出来能帮助我们查看哪些人更容易弄混</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;支持向量机（SVM）&quot;&gt;&lt;a href=&quot;#支持向量机（SVM）&quot; class=&quot;headerlink&quot; title=&quot;支持向量机（SVM）&quot;&gt;&lt;/a&gt;支持向量机（SVM）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;低纬不可分的东西转化为高纬可分割的东西&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（三十二）：把数组排成最小的数</title>
    <link href="https://xxren8218.github.io/20210525/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210525/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html</id>
    <published>2021-05-25T10:40:41.000Z</published>
    <updated>2021-05-25T10:41:45.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>遇到这个题，全排列当然可以做，但是时间复杂度为O(n!)。在这里我们自己定义一个规则，对拼接后的字符串进行比较。</p><p>排序规则如下</p><ul><li>若ab &gt; ba 则 a 大于 b，</li><li>若ab &lt; ba 则 a 小于 b，</li><li>若ab = ba 则 a 等于 b；</li></ul><p>根据上述规则，我们需要先将数字转换成字符串再进行比较，因为需要串起来进行比较。比较完之后，按顺序输出即可。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        compare = <span class="keyword">lambda</span> a,b:cmp(<span class="built_in">str</span>(a)+<span class="built_in">str</span>(b),<span class="built_in">str</span>(b)+<span class="built_in">str</span>(a))   <span class="comment"># 注意 lambda 匿名函数的使用。python2中sorted（可迭代对象,key,cmp）的使用,以及为什么要比较字符串。</span></span><br><span class="line">        li = <span class="built_in">sorted</span>(numbers, cmp=compare)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> li)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="字符串" scheme="https://xxren8218.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="排序" scheme="https://xxren8218.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="内置函数" scheme="https://xxren8218.github.io/tags/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
