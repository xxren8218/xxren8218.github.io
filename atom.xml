<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X.X.Ren</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://xxren8218.github.io/atom.xml" rel="self"/>
  
  <link href="https://xxren8218.github.io/"/>
  <updated>2021-05-20T11:23:18.013Z</updated>
  <id>https://xxren8218.github.io/</id>
  
  <author>
    <name>任晓雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer（十一）：二进制中1的个数</title>
    <link href="https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html</id>
    <published>2021-05-20T11:19:52.000Z</published>
    <updated>2021-05-20T11:23:18.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个二进制数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>先与1进行与运算，若为1，则该位为1，再判断前一位。</p><p>前一位的判断直接可以使用位运算 &gt;&gt; 向右移动一位。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += n &amp; <span class="number">1</span> <span class="comment"># 等价于 if n &amp; 1 == 1: res +=1，但是前一种判断次数更少。 </span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>将二进制转化为字符串，直接进行进行调用方法count</p><pre><code>- 由于输入的二进制比如1011，计算机不会将其对待为 0b1011,而是认为是一千零一十一，所以先转为二进制</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">bin</span>(n)).count(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路三-巧用-n-amp-n-1"><a href="#思路三-巧用-n-amp-n-1" class="headerlink" title="思路三 巧用 n&amp;(n-1)"></a>思路三 巧用 n&amp;(n-1)</h2><h2 id="此处若输入一个整数呢？注意消除负数位的影响。"><a href="#此处若输入一个整数呢？注意消除负数位的影响。" class="headerlink" title="此处若输入一个整数呢？注意消除负数位的影响。"></a>此处若输入一个整数呢？注意消除负数位的影响。</h2><div style="color: red;overflow: scroll;">如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</div><div style="color: red;overflow: scroll;">举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。    - 在Python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机是以补码存在的，往右移，符号位不变，符号位1往右移，最终可能会出现全1的情况，导致死循环。与0xffffffff相与，就可以消除负数的影响。</div><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: n = n &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= n-<span class="number">1</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个二进制数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;h2 id=&quot;2-思路&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="https://xxren8218.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="字符串" scheme="https://xxren8218.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十二）：数值的整数次方</title>
    <link href="https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html"/>
    <id>https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html</id>
    <published>2021-05-20T11:09:11.000Z</published>
    <updated>2021-05-20T11:19:14.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个double类型的浮点数x和int类型的整数n。求x的n次方。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>正常思路是：</p><ul><li>若n&gt;0: x<em>x</em>x<em>…</em>x,一共乘n次</li><li>若n&lt;0: 1/x<em>x</em>x<em>…</em>x,一共乘n次。</li><li>若n=0：返回零，但是代码在力扣超时。时间复杂度O（n）<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = x</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &lt; n-<span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &lt; -n-<span class="number">1</span>:</span><br><span class="line">                    res *= x</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/res</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="下面介绍快速幂的方法——时间复杂度O（logn）"><a href="#下面介绍快速幂的方法——时间复杂度O（logn）" class="headerlink" title="下面介绍快速幂的方法——时间复杂度O（logn）"></a>下面介绍快速幂的方法——时间复杂度O（logn）</h2><ul><li>指数减半，底数平方的方法。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如13，我们可以转换成1101，则X<strong>13就等于x</strong>1101b,然后展开，如图一<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191438.JPG" alt=""><br>同样我们也将所给的数字进行转化。如图二<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191508.JPG" alt=""><br>当bi=0，其数值为0<br>当bi=1，值为x的2<strong>i次方，如图三<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191524.JPG" alt=""><br>我们可以发现x</strong>i的规律就是从右向左看，后一个数字都是前一个数字的平方。如图、五<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191541.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191556.JPG" alt=""><br>所以：采用循环<br>我们可以将n与1进行与运算，看当前位数为0与否：</p><ul><li>不为零时候（为1），则结果 res * x</li><li>为零时候，则给结果不变<br>而后进行位运算右移动，移动以后的 x*= x<br>当n&lt;0, 我们可以令 x = 1/x, n = -n，则可以用同样的方法进行计算。<br>当x=0,分母不能为0，直接返回0<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191636.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520191705.JPG" alt=""><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            x,n = <span class="number">1</span>/x, -n</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">            x *= x</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;给定一个double类型的浮点数x和int类型的整数n。求x的n次方。&lt;/p&gt;
&lt;h2 id=&quot;2-思路&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="https://xxren8218.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="快速幂" scheme="https://xxren8218.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（十九）：顺时针打印矩阵</title>
    <link href="https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.html"/>
    <id>https://xxren8218.github.io/20210520/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%9A%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.html</id>
    <published>2021-05-20T11:05:09.000Z</published>
    <updated>2021-05-20T11:07:38.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520190659.PNG" alt=""><br>则依次打印出数组：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>可以发现，顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。<br>定义四个变量来确定边界。top、bottom、right、left。——注意他们范围的确定。<br>然后进行循环判断即可。具体如图。——注意循环终止条件。<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210520190718.JPG" alt=""></p><p><strong>注意：</strong></p><ul><li>对于range(a,b)，反向的话用range(b,a,-1)即可!(逗号)</li></ul><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> matrix == []: <span class="keyword">return</span> []</span><br><span class="line">        top = <span class="number">0</span></span><br><span class="line">        bottom = <span class="built_in">len</span>(matrix)-<span class="number">1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(matrix[<span class="number">0</span>])-<span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># →</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; bottom:<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ↓</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left:<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ←</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[bottom][i])</span><br><span class="line">            bottom -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> bottom &lt; top:<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ↑</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：&lt;br&gt;&lt;img src=&quot;https</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="多个指针" scheme="https://xxren8218.github.io/tags/%E5%A4%9A%E4%B8%AA%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统——协同过滤&amp;隐语义模型</title>
    <link href="https://xxren8218.github.io/20210520/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4-%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B.html"/>
    <id>https://xxren8218.github.io/20210520/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%BF%87%E6%BB%A4-%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B.html</id>
    <published>2021-05-19T16:47:00.000Z</published>
    <updated>2021-05-20T11:03:56.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推荐系统——协同过滤—-gt-基于统计方法"><a href="#推荐系统——协同过滤—-gt-基于统计方法" class="headerlink" title="推荐系统——协同过滤—&gt;基于统计方法"></a>推荐系统——协同过滤—&gt;基于统计方法</h2><h3 id="本节需要用到-scikit-surprise-库"><a href="#本节需要用到-scikit-surprise-库" class="headerlink" title="本节需要用到 scikit-surprise 库"></a>本节需要用到 scikit-surprise 库</h3><ul><li>pip install surprise 进行安装（需要C++编译环境）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> KNNBasic,SVD <span class="comment"># KNNBasic最基础的协同过滤算法（可以基于用户或者物品） SVD是基于矩阵分解的！</span></span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> Dataset <span class="comment"># Dataset默认的数据库进行练习。基础的电影的数据。（下方网址）</span></span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> evaluate, print_perf</span><br><span class="line"><span class="comment"># http://surprise.readthedocs.io/en/stable/index.html</span></span><br><span class="line"><span class="comment"># http://files.grouplens.org/datasets/movielens/ml-100k-README.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the movielens-100k dataset (download it if needed),</span></span><br><span class="line"><span class="comment"># and split it into 3 folds for cross-validation.</span></span><br><span class="line">data = Dataset.load_builtin(<span class="string">&#x27;ml-100k&#x27;</span>) <span class="comment"># 拿到内置的数据集</span></span><br><span class="line">data.split(n_folds=<span class="number">3</span>)  <span class="comment"># 进行交叉验证的折数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We&#x27;ll use the famous KNNBasic algorithm.</span></span><br><span class="line">algo = KNNBasic()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Evaluate performances of our algorithm on the dataset.</span></span><br><span class="line">perf = evaluate(algo, data, measures=[<span class="string">&#x27;RMSE&#x27;</span>, <span class="string">&#x27;MAE&#x27;</span>])  </span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"><span class="comment"># 之前的基本是 fit 这里不一样，可以自己指定三个参数（算法名字，数据，评估方法）</span></span><br><span class="line"><span class="comment"># 这里制定了均方误差和绝对误差</span></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line">print_perf(perf)</span><br></pre></td></tr></table></figure><pre><code>Evaluating RMSE, MAE of algorithm KNNBasic.------------Fold 1Computing the msd similarity matrix...Done computing similarity matrix.RMSE: 0.9876MAE:  0.7807------------Fold 2Computing the msd similarity matrix...Done computing similarity matrix.RMSE: 0.9871MAE:  0.7796------------Fold 3Computing the msd similarity matrix...Done computing similarity matrix.RMSE: 0.9902MAE:  0.7818------------------------Mean RMSE: 0.9883Mean MAE : 0.7807------------------------        Fold 1  Fold 2  Fold 3  Mean    MAE     0.7807  0.7796  0.7818  0.7807  RMSE    0.9876  0.9871  0.9902  0.9883  </code></pre><h2 id="推荐系统——进行矩阵分解求解（隐语义模型）—-gt-基于模型"><a href="#推荐系统——进行矩阵分解求解（隐语义模型）—-gt-基于模型" class="headerlink" title="推荐系统——进行矩阵分解求解（隐语义模型）—&gt;基于模型"></a>推荐系统——进行矩阵分解求解（隐语义模型）—&gt;基于模型</h2><ul><li>需要进行迭代求解，需要传一些参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> GridSearch</span><br><span class="line"></span><br><span class="line">param_grid = &#123;<span class="string">&#x27;n_epochs&#x27;</span>: [<span class="number">5</span>, <span class="number">10</span>], <span class="string">&#x27;lr_all&#x27;</span>: [<span class="number">0.002</span>, <span class="number">0.005</span>],</span><br><span class="line">              <span class="string">&#x27;reg_all&#x27;</span>: [<span class="number">0.4</span>, <span class="number">0.6</span>]&#125;</span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line"><span class="comment"># 指定了三个值，迭代次数，学习率，正则化的强度</span></span><br><span class="line"><span class="comment"># 做其8种组合。</span></span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line">grid_search = GridSearch(SVD, param_grid, measures=[<span class="string">&#x27;RMSE&#x27;</span>, <span class="string">&#x27;FCP&#x27;</span>]) <span class="comment"># SVD 矩阵分解！</span></span><br><span class="line">data = Dataset.load_builtin(<span class="string">&#x27;ml-100k&#x27;</span>)</span><br><span class="line">data.split(n_folds=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">grid_search.evaluate(data)</span><br></pre></td></tr></table></figure><pre><code>------------Parameters combination 1 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9972Mean FCP : 0.6843------------------------Parameters combination 2 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9734Mean FCP : 0.6946------------------------Parameters combination 3 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9777Mean FCP : 0.6926------------------------Parameters combination 4 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.4&#125;------------Mean RMSE: 0.9635Mean FCP : 0.6987------------------------Parameters combination 5 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 1.0029Mean FCP : 0.6875------------------------Parameters combination 6 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 5, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 0.9820Mean FCP : 0.6953------------------------Parameters combination 7 of 8params:  &#123;&#39;lr_all&#39;: 0.002, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 0.9860Mean FCP : 0.6943------------------------Parameters combination 8 of 8params:  &#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.6&#125;------------Mean RMSE: 0.9733Mean FCP : 0.6991------------</code></pre><p><strong>GridSearch会帮我们存一些函数值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># best RMSE score</span></span><br><span class="line">print(grid_search.best_score[<span class="string">&#x27;RMSE&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># combination of parameters that gave the best RMSE score</span></span><br><span class="line">print(grid_search.best_params[<span class="string">&#x27;RMSE&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># best FCP score</span></span><br><span class="line">print(grid_search.best_score[<span class="string">&#x27;FCP&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># combination of parameters that gave the best FCP score</span></span><br><span class="line">print(grid_search.best_params[<span class="string">&#x27;FCP&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>0.963501988854&#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.4&#125;0.699084153002&#123;&#39;lr_all&#39;: 0.005, &#39;n_epochs&#39;: 10, &#39;reg_all&#39;: 0.6&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line"></span><br><span class="line">results_df = pd.DataFrame.from_dict(grid_search.cv_results) </span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line"><span class="comment"># pd.DataFrame.from_dict可以传字典进行数据查看</span></span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line">results_df</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>FCP</th>      <th>RMSE</th>      <th>lr_all</th>      <th>n_epochs</th>      <th>params</th>      <th>scores</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.684266</td>      <td>0.997160</td>      <td>0.002</td>      <td>5</td>      <td>{'lr_all': 0.002, 'n_epochs': 5, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.997160189649, 'FCP': 0.684266412476}</td>    </tr>    <tr>      <th>1</th>      <td>0.694552</td>      <td>0.973383</td>      <td>0.005</td>      <td>5</td>      <td>{'lr_all': 0.005, 'n_epochs': 5, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.973383132387, 'FCP': 0.694551932996}</td>    </tr>    <tr>      <th>2</th>      <td>0.692616</td>      <td>0.977697</td>      <td>0.002</td>      <td>10</td>      <td>{'lr_all': 0.002, 'n_epochs': 10, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.977696629511, 'FCP': 0.692615513155}</td>    </tr>    <tr>      <th>3</th>      <td>0.698722</td>      <td>0.963502</td>      <td>0.005</td>      <td>10</td>      <td>{'lr_all': 0.005, 'n_epochs': 10, 'reg_all': 0.4}</td>      <td>{'RMSE': 0.963501988854, 'FCP': 0.698721750945}</td>    </tr>    <tr>      <th>4</th>      <td>0.687482</td>      <td>1.002855</td>      <td>0.002</td>      <td>5</td>      <td>{'lr_all': 0.002, 'n_epochs': 5, 'reg_all': 0.6}</td>      <td>{'RMSE': 1.00285516237, 'FCP': 0.687481665759}</td>    </tr>    <tr>      <th>5</th>      <td>0.695337</td>      <td>0.982047</td>      <td>0.005</td>      <td>5</td>      <td>{'lr_all': 0.005, 'n_epochs': 5, 'reg_all': 0.6}</td>      <td>{'RMSE': 0.98204676013, 'FCP': 0.695337489535}</td>    </tr>    <tr>      <th>6</th>      <td>0.694338</td>      <td>0.985981</td>      <td>0.002</td>      <td>10</td>      <td>{'lr_all': 0.002, 'n_epochs': 10, 'reg_all': 0.6}</td>      <td>{'RMSE': 0.985980855401, 'FCP': 0.694337564062}</td>    </tr>    <tr>      <th>7</th>      <td>0.699084</td>      <td>0.973282</td>      <td>0.005</td>      <td>10</td>      <td>{'lr_all': 0.005, 'n_epochs': 10, 'reg_all': 0.6}</td>      <td>{'RMSE': 0.973281870802, 'FCP': 0.699084153002}</td>    </tr>  </tbody></table></div><h3 id="模型搭建出来了，用它来推荐东西！"><a href="#模型搭建出来了，用它来推荐东西！" class="headerlink" title="模型搭建出来了，用它来推荐东西！"></a>模型搭建出来了，用它来推荐东西！</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> (absolute_import, division, print_function,</span><br><span class="line">                        unicode_literals)</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> KNNBaseline</span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_item_names</span>():</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot;把电影的名字做成了id的映射&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    file_name = (<span class="string">&#x27;./ml-100k/u.item&#x27;</span>)</span><br><span class="line">    rid_to_name = &#123;&#125;</span><br><span class="line">    name_to_rid = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> io.<span class="built_in">open</span>(file_name, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            line = line.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">            rid_to_name[line[<span class="number">0</span>]] = line[<span class="number">1</span>]</span><br><span class="line">            name_to_rid[line[<span class="number">1</span>]] = line[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rid_to_name, name_to_rid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.导入数据</span></span><br><span class="line">data = Dataset.load_builtin(<span class="string">&#x27;ml-100k&#x27;</span>)</span><br><span class="line"><span class="comment"># 2.数据是一行的，将其转换成矩阵（稀疏的）</span></span><br><span class="line">trainset = data.build_full_trainset()</span><br><span class="line"><span class="comment"># 3.指定相似度的方法——此处用了皮尔孙，指定了基于物品的相似度。</span></span><br><span class="line">sim_options = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;pearson_baseline&#x27;</span>, <span class="string">&#x27;user_based&#x27;</span>: <span class="literal">False</span>&#125;</span><br><span class="line">algo = KNNBaseline(sim_options=sim_options)</span><br><span class="line">algo.train(trainset)</span><br></pre></td></tr></table></figure><pre><code>Estimating biases using als...Computing the pearson_baseline similarity matrix...Done computing similarity matrix.</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rid_to_name, name_to_rid = read_item_names()</span><br><span class="line"></span><br><span class="line">toy_story_raw_id = name_to_rid[<span class="string">&#x27;Now and Then (1995)&#x27;</span>]</span><br><span class="line"><span class="comment"># 直接传电影名字不行，因为传的是id，先对其进行id的转换。</span></span><br><span class="line"></span><br><span class="line">toy_story_raw_id <span class="comment"># 在数据的id</span></span><br></pre></td></tr></table></figure><pre><code>&#39;1053&#39;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toy_story_inner_id = algo.trainset.to_inner_iid(toy_story_raw_id)</span><br><span class="line">toy_story_inner_id <span class="comment"># 在实际计算的(矩阵的)id</span></span><br></pre></td></tr></table></figure><pre><code>961</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toy_story_neighbors = algo.get_neighbors(toy_story_inner_id, k=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 找出最接近的10个电影id</span></span><br><span class="line">toy_story_neighbors</span><br></pre></td></tr></table></figure><pre><code>[291, 82, 366, 528, 179, 101, 556, 310, 431, 543]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">toy_story_neighbors = (algo.trainset.to_raw_iid(inner_id)</span><br><span class="line">                       <span class="keyword">for</span> inner_id <span class="keyword">in</span> toy_story_neighbors)</span><br><span class="line">toy_story_neighbors = (rid_to_name[rid]</span><br><span class="line">                       <span class="keyword">for</span> rid <span class="keyword">in</span> toy_story_neighbors)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(<span class="string">&#x27;The 10 nearest neighbors of Toy Story are:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> movie <span class="keyword">in</span> toy_story_neighbors:</span><br><span class="line">    print(movie)</span><br></pre></td></tr></table></figure><pre><code>The 10 nearest neighbors of Toy Story are:While You Were Sleeping (1995)Batman (1989)Dave (1993)Mrs. Doubtfire (1993)Groundhog Day (1993)Raiders of the Lost Ark (1981)Maverick (1994)French Kiss (1995)Stand by Me (1986)Net, The (1995)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;推荐系统——协同过滤—-gt-基于统计方法&quot;&gt;&lt;a href=&quot;#推荐系统——协同过滤—-gt-基于统计方法&quot; class=&quot;headerlink&quot; title=&quot;推荐系统——协同过滤—&amp;gt;基于统计方法&quot;&gt;&lt;/a&gt;推荐系统——协同过滤—&amp;gt;基于统计方法&lt;/</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>EM算法应用——GMM聚类</title>
    <link href="https://xxren8218.github.io/20210519/EM%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94GMM%E8%81%9A%E7%B1%BB.html"/>
    <id>https://xxren8218.github.io/20210519/EM%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94GMM%E8%81%9A%E7%B1%BB.html</id>
    <published>2021-05-18T16:55:06.000Z</published>
    <updated>2021-05-18T17:02:03.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GMM实例"><a href="#GMM实例" class="headerlink" title="GMM实例"></a>GMM实例</h1><ul><li>桥东西两个地方摆放了共享单车。统计使用共享单车的数量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv (<span class="string">&#x27;Fremont.csv&#x27;</span>, index_col=<span class="string">&#x27;Date&#x27;</span>, parse_dates=<span class="literal">True</span>)</span><br><span class="line">data.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Fremont Bridge West Sidewalk</th>      <th>Fremont Bridge East Sidewalk</th>    </tr>    <tr>      <th>Date</th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>2012-10-03 00:00:00</th>      <td>4.0</td>      <td>9.0</td>    </tr>    <tr>      <th>2012-10-03 01:00:00</th>      <td>4.0</td>      <td>6.0</td>    </tr>    <tr>      <th>2012-10-03 02:00:00</th>      <td>1.0</td>      <td>1.0</td>    </tr>    <tr>      <th>2012-10-03 03:00:00</th>      <td>2.0</td>      <td>3.0</td>    </tr>    <tr>      <th>2012-10-03 04:00:00</th>      <td>6.0</td>      <td>1.0</td>    </tr>  </tbody></table></div><h2 id="Visualizing-the-Dataset"><a href="#Visualizing-the-Dataset" class="headerlink" title="Visualizing the Dataset"></a>Visualizing the Dataset</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">data.plot();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010149.png" alt=""></p><p>可以看到数据太密集，因为是以小时为单位创建的，</p><ul><li>数据重采样，按周进行计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">data.resample(<span class="string">&#x27;w&#x27;</span>).<span class="built_in">sum</span>().plot(); <span class="comment"># 时间序列化</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010134.png" alt=""></p><p>可以看到东西边差别不大。<br>采用滑动窗口进行可视化——当前365天数据的总和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.resample(<span class="string">&#x27;D&#x27;</span>).<span class="built_in">sum</span>().rolling(<span class="number">365</span>).<span class="built_in">sum</span>().plot();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010117.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data.groupby(data.index.time).mean().plot();</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>)</span><br></pre></td></tr></table></figure><pre><code>(array([     0.,  10000.,  20000.,  30000.,  40000.,  50000.,  60000.,         70000.,  80000.,  90000.]), &lt;a list of 10 Text xticklabel objects&gt;)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010104.png" alt=""></p><ul><li>蓝线和绿线满足不同分布规则。</li><li>隐变量有两个。桥东和桥西。</li></ul><p>做GMM模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pivot table</span></span><br><span class="line">data.columns =[<span class="string">&#x27;West&#x27;</span>, <span class="string">&#x27;East&#x27;</span>]</span><br><span class="line">data [<span class="string">&#x27;Total&#x27;</span>] =data[<span class="string">&#x27;West&#x27;</span>]+data[<span class="string">&#x27;East&#x27;</span>]</span><br><span class="line">pivoted = data.pivot_table(<span class="string">&#x27;Total&#x27;</span>, index=data.index.time, columns=data.index.date) <span class="comment"># 做一个透视表</span></span><br><span class="line">pivoted.iloc[:<span class="number">5</span>,:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>2012-10-03</th>      <th>2012-10-04</th>      <th>2012-10-05</th>      <th>2012-10-06</th>      <th>2012-10-07</th>    </tr>  </thead>  <tbody>    <tr>      <th>00:00:00</th>      <td>13.0</td>      <td>18.0</td>      <td>11.0</td>      <td>15.0</td>      <td>11.0</td>    </tr>    <tr>      <th>01:00:00</th>      <td>10.0</td>      <td>3.0</td>      <td>8.0</td>      <td>15.0</td>      <td>17.0</td>    </tr>    <tr>      <th>02:00:00</th>      <td>2.0</td>      <td>9.0</td>      <td>7.0</td>      <td>9.0</td>      <td>3.0</td>    </tr>    <tr>      <th>03:00:00</th>      <td>5.0</td>      <td>3.0</td>      <td>4.0</td>      <td>3.0</td>      <td>6.0</td>    </tr>    <tr>      <th>04:00:00</th>      <td>7.0</td>      <td>8.0</td>      <td>9.0</td>      <td>5.0</td>      <td>3.0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pivoted.plot(legend=<span class="literal">False</span>, alpha =<span class="number">0.01</span>);</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>)</span><br></pre></td></tr></table></figure><pre><code>(array([     0.,  10000.,  20000.,  30000.,  40000.,  50000.,  60000.,         70000.,  80000.,  90000.]), &lt;a list of 10 Text xticklabel objects&gt;)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010042.png" alt=""></p><p><strong>可以看到有两种分布，能否用GMM进行聚类任务，然后分开呢？</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pivoted.shape</span><br></pre></td></tr></table></figure><pre><code>(24, 1763)</code></pre><p><strong>样本数24，特征数1763不合适</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = pivoted.fillna(<span class="number">0</span>).T.values</span><br><span class="line">X.shape</span><br></pre></td></tr></table></figure><pre><code>(1763, 24)</code></pre><p><strong>然后拿它GMM进行聚类的任务</strong></p><ul><li>拿到了1763个数据，以及它每天24小时的数据，我们想做个聚类，看他是东还是西。</li></ul><p>为了方便演示，将图像画在2D空间——进行PCA的降维</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">X2 = PCA(<span class="number">2</span>).fit_transform(X)</span><br><span class="line">X2.shape</span><br></pre></td></tr></table></figure><pre><code>(1763, 2)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X2[:,<span class="number">0</span>],X2[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1b92c86a630&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519010015.png" alt=""></p><p><strong>PCA降维以后数据特征不存在具体物理意义、但是空间意义还在</strong></p><p>然后进行聚类分析：</p><ul><li>GMM聚类与KMEANS有些类似，因为kmeans需要知道K点个数。而此处需要知道隐变量的个数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line">gmm =GaussianMixture(<span class="number">2</span>)</span><br><span class="line">gmm.fit(X)</span><br><span class="line">labels = gmm.predict_proba(X) <span class="comment"># 得到的是概率值，即每一个样本属于（第一个类别【分布】的可能性，第二个类别【分布】的可能性）</span></span><br><span class="line">labels</span><br></pre></td></tr></table></figure><pre><code>array([[  1.00000000e+000,   4.27200703e-157],       [  1.00000000e+000,   2.97606604e-125],       [  1.00000000e+000,   1.00461289e-101],       ...,        [  2.50152395e-030,   1.00000000e+000],       [  2.49747986e-025,   1.00000000e+000],       [  1.00000000e+000,   1.79108465e-301]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">labels = gmm.predict(X) <span class="comment"># 得到的是概类别的标签</span></span><br><span class="line">labels</span><br></pre></td></tr></table></figure><pre><code>array([0, 0, 0, ..., 1, 1, 0], dtype=int64)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X2[:,<span class="number">0</span>],X2[:,<span class="number">1</span>], c=labels, cmap=<span class="string">&#x27;rainbow&#x27;</span>) </span><br><span class="line"><span class="comment">#plt.colorbar()</span></span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1b92cdd0f98&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005957.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize =(<span class="number">14</span>, <span class="number">6</span>))</span><br><span class="line">                      </span><br><span class="line">pivoted.T[labels == <span class="number">0</span>].T.plot(legend =<span class="literal">False</span>, alpha =<span class="number">0.1</span>, ax=ax[<span class="number">0</span>])  <span class="comment"># 进行数据的还原，显示数据的样子</span></span><br><span class="line">pivoted.T[labels == <span class="number">1</span>].T.plot(legend =<span class="literal">False</span>, alpha =<span class="number">0.1</span>, ax=ax[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].set_title (<span class="string">&#x27;Purple Cluster&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>].set_title (<span class="string">&#x27;Red Cluster&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.text.Text at 0x1b932208b38&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005941.png" alt=""></p><p><strong>来看看GMM和KMEANS的差异吧！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line">X, y_true = make_blobs(n_samples=<span class="number">800</span>, centers=<span class="number">4</span>, random_state=<span class="number">11</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005926.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">4</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">y_kmeans = kmeans.predict(X)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_kmeans, s=<span class="number">50</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">centers = kmeans.cluster_centers_</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005911.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture</span><br><span class="line">gmm = GaussianMixture(n_components=<span class="number">4</span>).fit(X)</span><br><span class="line">labels = gmm.predict(X)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=labels, s=<span class="number">40</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005856.png" alt=""></p><p><strong>GMM和KMEANS在规则数据上基本一样！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">13</span>)</span><br><span class="line">X_stretched = np.dot(X, rng.randn(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">4</span>, random_state=<span class="number">1</span>)</span><br><span class="line">kmeans.fit(X_stretched)</span><br><span class="line">y_kmeans = kmeans.predict(X_stretched)</span><br><span class="line">plt.scatter(X_stretched[:, <span class="number">0</span>], X_stretched[:, <span class="number">1</span>], c=y_kmeans, s=<span class="number">50</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">centers = kmeans.cluster_centers_</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005837.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gmm = GaussianMixture(n_components=<span class="number">4</span>)        </span><br><span class="line">gmm.fit(X_stretched)</span><br><span class="line">y_gmm = gmm.predict(X_stretched)</span><br><span class="line">plt.scatter(X_stretched[:, <span class="number">0</span>], X_stretched[:, <span class="number">1</span>], c=y_gmm, s=<span class="number">50</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x1b932008208&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210519005822.png" alt=""></p><p><strong> GMM比KMEANS好！ </strong></p><h2 id="所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好"><a href="#所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好" class="headerlink" title="所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好"></a>所以，如果数据内部有多个类别，且服从不同的分布，用GMM比KMEANS好</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GMM实例&quot;&gt;&lt;a href=&quot;#GMM实例&quot; class=&quot;headerlink&quot; title=&quot;GMM实例&quot;&gt;&lt;/a&gt;GMM实例&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;桥东西两个地方摆放了共享单车。统计使用共享单车的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>力扣（一）：两数之和</title>
    <link href="https://xxren8218.github.io/20210518/%E5%8A%9B%E6%89%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html"/>
    <id>https://xxren8218.github.io/20210518/%E5%8A%9B%E6%89%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</id>
    <published>2021-05-18T10:00:40.000Z</published>
    <updated>2021-05-18T10:01:48.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h2 id="2-思路1"><a href="#2-思路1" class="headerlink" title="2.思路1"></a>2.思路1</h2><p>方法一：暴力枚举<br>思路及算法</p><p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p><p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>方法二：哈希表<br>思路及算法</p><p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。</p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums): </span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="哈希表" scheme="https://xxren8218.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（二十）：包含min函数的栈</title>
    <link href="https://xxren8218.github.io/20210517/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.html"/>
    <id>https://xxren8218.github.io/20210517/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%9A%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.html</id>
    <published>2021-05-17T10:05:38.000Z</published>
    <updated>2021-05-17T10:08:06.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>定义栈的数据结构，请在类型中实现一个能够得到栈最小元素的min函数。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>使用两个stack，一个为数据栈，另一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。</p><p>若加入的元素比辅助栈的栈顶元素小，则再辅助栈增加该元素，否则，增加辅助栈的栈顶元素。</p><p>Data = [1,2,-2,3,-4,6]<br>Min = [1,1,-2,-2,-4,-4]</p><p>在Data出栈的时候，同时将Data和Min出栈即可。</p><p>获得栈顶元素的时候：直接返回数据栈的栈顶元素。</p><p>栈最小元素：直接返回辅助栈的栈顶元素。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.Data = []</span><br><span class="line">        self.Min = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.Data.append(node)</span><br><span class="line">        <span class="keyword">if</span> self.Min:</span><br><span class="line">            <span class="keyword">if</span> self.Min[-<span class="number">1</span>] &gt; node:</span><br><span class="line">                self.Min.append(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.Min.append(self.Min[-<span class="number">1</span>])   <span class="comment">#保证Data出栈的时候Min也是出栈的，且最小数字不会改变。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Min.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.Min.pop()</span><br><span class="line">        <span class="keyword">return</span> self.Data.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Data[-<span class="number">1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.Min == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Min[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="还有一种思路——使用单调栈。"><a href="#还有一种思路——使用单调栈。" class="headerlink" title="还有一种思路——使用单调栈。"></a>还有一种思路——使用单调栈。</h2><p>入栈的时候：首先往空的数据栈里压入数字3，显然现在3是最小值，我们也把最小值压入辅助栈。接下来往数据栈里压入数字4。<br>由于4大于之前的最小值，因此我们只要入数据栈，不压入辅助栈。</p><p>出栈的时候：当数据栈和辅助栈的栈顶元素相同的时候，辅助栈的栈顶元素出栈。否则，数据栈的栈顶元素出栈。</p><p>Data = [1,2,-2,3,-4,6]<br>Min = [1,-2,-4]</p><p><strong>这个与上个不同的是：Data出栈时候需要判断是否为Min的栈顶元素,若是，则需要同时出栈。上面的方法不需要判断，只需要同时出栈</strong></p><p>获得栈顶元素的时候：直接返回数据栈的栈顶元素。</p><p>栈最小元素：直接返回辅助栈的栈顶元素。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.Data = []</span><br><span class="line">        self.Min = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.Data.append(x)</span><br><span class="line">        <span class="keyword">if</span> self.Min:</span><br><span class="line">            <span class="keyword">if</span> self.Min[-<span class="number">1</span>] &gt;= x:</span><br><span class="line">                self.Min.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Min.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.Data[-<span class="number">1</span>] == self.Min[-<span class="number">1</span>]: self.Min.pop()</span><br><span class="line">        self.Data.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.Data == []:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Data[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.Min == []:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.Min[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;p&gt;定义栈的数据结构，请在类型中实现一个能够得到栈最小元素的min函数。&lt;/p&gt;
&lt;h2 id=&quot;2-思路&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="辅助栈" scheme="https://xxren8218.github.io/tags/%E8%BE%85%E5%8A%A9%E6%A0%88/"/>
    
    <category term="栈" scheme="https://xxren8218.github.io/tags/%E6%A0%88/"/>
    
    <category term="单调栈" scheme="https://xxren8218.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>降维算法——PCA(主成分分析)</title>
    <link href="https://xxren8218.github.io/20210515/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94PCA-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.html"/>
    <id>https://xxren8218.github.io/20210515/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94PCA-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.html</id>
    <published>2021-05-15T06:31:02.000Z</published>
    <updated>2021-05-15T06:39:58.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="鸢尾花数据集的降维——PCA"><a href="#鸢尾花数据集的降维——PCA" class="headerlink" title="鸢尾花数据集的降维——PCA"></a>鸢尾花数据集的降维——PCA</h1><ul><li>PCA的降维是不依赖标签（分类的），而是依赖样本的方差（协方差）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;iris.data&#x27;</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>5.1</th>      <th>3.5</th>      <th>1.4</th>      <th>0.2</th>      <th>Iris-setosa</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>4.9</td>      <td>3.0</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>1</th>      <td>4.7</td>      <td>3.2</td>      <td>1.3</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>2</th>      <td>4.6</td>      <td>3.1</td>      <td>1.5</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>3</th>      <td>5.0</td>      <td>3.6</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>4</th>      <td>5.4</td>      <td>3.9</td>      <td>1.7</td>      <td>0.4</td>      <td>Iris-setosa</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.columns=[<span class="string">&#x27;sepal_len&#x27;</span>, <span class="string">&#x27;sepal_wid&#x27;</span>, <span class="string">&#x27;petal_len&#x27;</span>, <span class="string">&#x27;petal_wid&#x27;</span>, <span class="string">&#x27;class&#x27;</span>]</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>sepal_len</th>      <th>sepal_wid</th>      <th>petal_len</th>      <th>petal_wid</th>      <th>class</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>4.9</td>      <td>3.0</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>1</th>      <td>4.7</td>      <td>3.2</td>      <td>1.3</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>2</th>      <td>4.6</td>      <td>3.1</td>      <td>1.5</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>3</th>      <td>5.0</td>      <td>3.6</td>      <td>1.4</td>      <td>0.2</td>      <td>Iris-setosa</td>    </tr>    <tr>      <th>4</th>      <td>5.4</td>      <td>3.9</td>      <td>1.7</td>      <td>0.4</td>      <td>Iris-setosa</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># split data table into data X and class labels y</span></span><br><span class="line"></span><br><span class="line">X = df.ix[:,<span class="number">0</span>:<span class="number">4</span>].values</span><br><span class="line">y = df.ix[:,<span class="number">4</span>].values</span><br></pre></td></tr></table></figure><p><strong> 数据的可视化 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">label_dict = &#123;<span class="number">1</span>: <span class="string">&#x27;Iris-Setosa&#x27;</span>,</span><br><span class="line">              <span class="number">2</span>: <span class="string">&#x27;Iris-Versicolor&#x27;</span>,</span><br><span class="line">              <span class="number">3</span>: <span class="string">&#x27;Iris-Virgnica&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">feature_dict = &#123;<span class="number">0</span>: <span class="string">&#x27;sepal length [cm]&#x27;</span>,</span><br><span class="line">                <span class="number">1</span>: <span class="string">&#x27;sepal width [cm]&#x27;</span>,</span><br><span class="line">                <span class="number">2</span>: <span class="string">&#x27;petal length [cm]&#x27;</span>,</span><br><span class="line">                <span class="number">3</span>: <span class="string">&#x27;petal width [cm]&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> cnt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, cnt+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> lab <span class="keyword">in</span> (<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>):</span><br><span class="line">        plt.hist(X[y==lab, cnt],</span><br><span class="line">                     label=lab,</span><br><span class="line">                     bins=<span class="number">10</span>,</span><br><span class="line">                     alpha=<span class="number">0.3</span>,)</span><br><span class="line">    plt.xlabel(feature_dict[cnt])</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>, fontsize=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143327.png" alt=""></p><p><strong> 一般要先进行数据的标准化，归一化，或正态化的预处理 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">X_std = StandardScaler().fit_transform(X)</span><br><span class="line"><span class="built_in">print</span> (X_std)</span><br></pre></td></tr></table></figure><pre><code>[[-1.1483555  -0.11805969 -1.35396443 -1.32506301] [-1.3905423   0.34485856 -1.41098555 -1.32506301] [-1.51163569  0.11339944 -1.29694332 -1.32506301] [-1.02726211  1.27069504 -1.35396443 -1.32506301] [-0.54288852  1.9650724  -1.18290109 -1.0614657 ] [-1.51163569  0.8077768  -1.35396443 -1.19326436] [-1.02726211  0.8077768  -1.29694332 -1.32506301] [-1.75382249 -0.34951881 -1.35396443 -1.32506301] [-1.1483555   0.11339944 -1.29694332 -1.45686167] [-0.54288852  1.50215416 -1.29694332 -1.32506301] [-1.2694489   0.8077768  -1.23992221 -1.32506301] [-1.2694489  -0.11805969 -1.35396443 -1.45686167] [-1.87491588 -0.11805969 -1.52502777 -1.45686167] [-0.05851493  2.19653152 -1.46800666 -1.32506301] ... [-0.54288852  1.9650724  -1.41098555 -1.0614657 ] [-0.90616871  1.03923592 -1.35396443 -1.19326436] [-0.17960833  1.73361328 -1.18290109 -1.19326436] [-0.90616871  1.73361328 -1.29694332 -1.19326436] [ 1.15241904  0.34485856  1.21198569  1.4427088 ] [ 1.03132564  0.57631768  1.09794346  1.70630611] [ 1.03132564 -0.11805969  0.81283789  1.4427088 ] [ 0.54695205 -1.27535529  0.69879566  0.91551417] [ 0.78913885 -0.11805969  0.81283789  1.04731282] [ 0.42585866  0.8077768   0.92688012  1.4427088 ] [ 0.06257847 -0.11805969  0.75581678  0.78371551]]</code></pre><p><strong> 手撕协方差 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean_vec = np.mean(X_std, axis=<span class="number">0</span>)</span><br><span class="line">cov_mat = (X_std - mean_vec).T.dot((X_std - mean_vec)) / (X_std.shape[<span class="number">0</span>]-<span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;Covariance matrix \n%s&#x27;</span> %cov_mat)</span><br></pre></td></tr></table></figure><pre><code>Covariance matrix [[ 1.00675676 -0.10448539  0.87716999  0.82249094] [-0.10448539  1.00675676 -0.41802325 -0.35310295] [ 0.87716999 -0.41802325  1.00675676  0.96881642] [ 0.82249094 -0.35310295  0.96881642  1.00675676]]</code></pre><p><strong> 直接可以在numpy中调用cov（）,协方差函数 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;NumPy covariance matrix: \n%s&#x27;</span> %np.cov(X_std.T))</span><br></pre></td></tr></table></figure><pre><code>NumPy covariance matrix: [[ 1.00675676 -0.10448539  0.87716999  0.82249094] [-0.10448539  1.00675676 -0.41802325 -0.35310295] [ 0.87716999 -0.41802325  1.00675676  0.96881642] [ 0.82249094 -0.35310295  0.96881642  1.00675676]]</code></pre><p>可以看到对角线上的都为1，因为自身与自身的协方差肯定是1</p><ul><li>标准化以后是1。——相关系数。</li><li>没有标准化的数据，仅仅是方差。</li></ul><h3 id="计算协方差矩阵的特征值和特征向量"><a href="#计算协方差矩阵的特征值和特征向量" class="headerlink" title="计算协方差矩阵的特征值和特征向量"></a>计算协方差矩阵的特征值和特征向量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cov_mat = np.cov(X_std.T)</span><br><span class="line"></span><br><span class="line">eig_vals, eig_vecs = np.linalg.eig(cov_mat)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Eigenvectors \n%s&#x27;</span> %eig_vecs)</span><br><span class="line">print(<span class="string">&#x27;\nEigenvalues \n%s&#x27;</span> %eig_vals)</span><br></pre></td></tr></table></figure><pre><code>Eigenvectors [[ 0.52308496 -0.36956962 -0.72154279  0.26301409] [-0.25956935 -0.92681168  0.2411952  -0.12437342] [ 0.58184289 -0.01912775  0.13962963 -0.80099722] [ 0.56609604 -0.06381646  0.63380158  0.52321917]]Eigenvalues [ 2.92442837  0.93215233  0.14946373  0.02098259]</code></pre><p><strong> 特征值的大小代表特征向量的重要程度 </strong></p><p>下面的代码将其进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Make a list of (eigenvalue, eigenvector) tuples</span></span><br><span class="line">eig_pairs = [(np.<span class="built_in">abs</span>(eig_vals[i]), eig_vecs[:,i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_vals))]</span><br><span class="line"><span class="built_in">print</span> (eig_pairs)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;----------&#x27;</span>)</span><br><span class="line"><span class="comment"># Sort the (eigenvalue, eigenvector) tuples from high to low</span></span><br><span class="line">eig_pairs.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visually confirm that the list is correctly sorted by decreasing eigenvalues</span></span><br><span class="line">print(<span class="string">&#x27;Eigenvalues in descending order:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eig_pairs:</span><br><span class="line">    print(i[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>[(2.9244283691111144, array([ 0.52308496, -0.25956935,  0.58184289,  0.56609604])), (0.93215233025350641, array([-0.36956962, -0.92681168, -0.01912775, -0.06381646])), (0.14946373489813314, array([-0.72154279,  0.2411952 ,  0.13962963,  0.63380158])), (0.020982592764270606, array([ 0.26301409, -0.12437342, -0.80099722,  0.52321917]))]----------Eigenvalues in descending order:2.924428369110.9321523302540.1494637348980.0209825927643</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tot = <span class="built_in">sum</span>(eig_vals)</span><br><span class="line">var_exp = [(i / tot)*<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(eig_vals, reverse=<span class="literal">True</span>)]</span><br><span class="line"><span class="built_in">print</span> (var_exp)</span><br><span class="line">cum_var_exp = np.cumsum(var_exp)  <span class="comment"># 来验证最后的和是否为100% 以及维度的选择——cumsum()的解释在下面。</span></span><br><span class="line">cum_var_exp</span><br></pre></td></tr></table></figure><pre><code>[72.620033326920336, 23.147406858644135, 3.7115155645845164, 0.52104424985101538]array([  72.62003333,   95.76744019,   99.47895575,  100.        ])</code></pre><h3 id="cumsum-函数的解释："><a href="#cumsum-函数的解释：" class="headerlink" title="cumsum()函数的解释："></a>cumsum()函数的解释：</h3><ul><li>为什么要用它呢？<ul><li>可以判断到底降维到几维。（设置阈值。比如百分之95%，那么降到2维即可）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;-----------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (np.cumsum(a))</span><br></pre></td></tr></table></figure><pre><code>[1 2 3 4]-----------[ 1  3  6 10]</code></pre><p><strong> 作图展示特征值所占的百分比 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">plt.bar(<span class="built_in">range</span>(<span class="number">4</span>), var_exp, alpha=<span class="number">0.5</span>, align=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">            label=<span class="string">&#x27;individual explained variance&#x27;</span>)</span><br><span class="line">plt.step(<span class="built_in">range</span>(<span class="number">4</span>), cum_var_exp, where=<span class="string">&#x27;mid&#x27;</span>,                <span class="comment"># 阶梯图。where，表示在哪里开始跳跃。</span></span><br><span class="line">             label=<span class="string">&#x27;cumulative explained variance&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Explained variance ratio&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Principal components&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.tight_layout() <span class="comment"># 最自动调整图的大小。使其填满图像区域。</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143458.png" alt=""></p><p><strong> 确定w的维度 </strong></p><ul><li>拿前两个特征向量。——基变换:w.T * x0 = x1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix_w = np.hstack((eig_pairs[<span class="number">0</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">                      eig_pairs[<span class="number">1</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Matrix W:\n&#x27;</span>, matrix_w)</span><br></pre></td></tr></table></figure><pre><code>Matrix W: [[ 0.52308496 -0.36956962] [-0.25956935 -0.92681168] [ 0.58184289 -0.01912775] [ 0.56609604 -0.06381646]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y = X_std.dot(matrix_w)</span><br><span class="line">Y</span><br></pre></td></tr></table></figure><pre><code>array([[-2.10795032,  0.64427554],       [-2.38797131,  0.30583307],       [-2.32487909,  0.56292316],       [-2.40508635, -0.687591  ],       [-2.08320351, -1.53025171],       [-2.4636848 , -0.08795413],       [-2.25174963, -0.25964365],       [-2.3645813 ,  1.08255676],       [-2.20946338,  0.43707676],       [-2.17862017, -1.08221046],       [-2.34525657, -0.17122946],       ...       [ 2.00701161, -0.60663655],       [ 1.89319854, -0.68227708],       [ 1.13831104,  0.70171953],       [ 2.03519535, -0.86076914],       [ 1.99464025, -1.04517619],       [ 1.85977129, -0.37934387],       [ 1.54200377,  0.90808604],       [ 1.50925493, -0.26460621],       [ 1.3690965 , -1.01583909],       [ 0.94680339,  0.02182097]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> lab, col <span class="keyword">in</span> <span class="built_in">zip</span>((<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>),</span><br><span class="line">                        (<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line">     plt.scatter(X[y==lab, <span class="number">0</span>],</span><br><span class="line">                X[y==lab, <span class="number">1</span>],</span><br><span class="line">                label=lab,</span><br><span class="line">                c=col)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;sepal_len&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;sepal_wid&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143541.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> lab, col <span class="keyword">in</span> <span class="built_in">zip</span>((<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>),</span><br><span class="line">                        (<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line">     plt.scatter(Y[y==lab, <span class="number">0</span>],</span><br><span class="line">                Y[y==lab, <span class="number">1</span>],</span><br><span class="line">                label=lab,</span><br><span class="line">                c=col)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Principal Component 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Principal Component 2&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower center&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515143554.png" alt=""></p><h2 id="PCA使得结果更容易分类"><a href="#PCA使得结果更容易分类" class="headerlink" title="PCA使得结果更容易分类"></a>PCA使得结果更容易分类</h2><p><strong> 降维后数据的意义不存在了 </strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;鸢尾花数据集的降维——PCA&quot;&gt;&lt;a href=&quot;#鸢尾花数据集的降维——PCA&quot; class=&quot;headerlink&quot; title=&quot;鸢尾花数据集的降维——PCA&quot;&gt;&lt;/a&gt;鸢尾花数据集的降维——PCA&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;PCA的降维是不依赖标签（分类的</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>降维算法——LDA(线性判别分析)</title>
    <link href="https://xxren8218.github.io/20210515/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94LDA-%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90.html"/>
    <id>https://xxren8218.github.io/20210515/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94LDA-%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90.html</id>
    <published>2021-05-15T06:16:53.000Z</published>
    <updated>2021-05-15T06:29:10.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="鸢尾花的数据集进行降维"><a href="#鸢尾花的数据集进行降维" class="headerlink" title="鸢尾花的数据集进行降维"></a>鸢尾花的数据集进行降维</h1><ul><li>有四个维度，萼片的长度。萼片的宽度，花瓣的长度，花瓣的宽度——将其降低维度为2维</li><li>数据集大概有150条</li><li>数据集没有列名，给其进行指定，使用zip()函数，将其进行对应</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">feature_dict = &#123;i:label <span class="keyword">for</span> i,label <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">                <span class="built_in">range</span>(<span class="number">4</span>),</span><br><span class="line">                  (<span class="string">&#x27;sepal length in cm&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;sepal width in cm&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;petal length in cm&#x27;</span>,                <span class="comment"># 用到了字典推导式！</span></span><br><span class="line">                  <span class="string">&#x27;petal width in cm&#x27;</span>, ))&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"><span class="comment"># feature_dict = &#123;0: &#x27;sepal length in cm&#x27;, </span></span><br><span class="line"><span class="comment">#                 1: &#x27;sepal width in cm&#x27;, </span></span><br><span class="line"><span class="comment">#                 2: &#x27;petal length in cm&#x27;, </span></span><br><span class="line"><span class="comment">#                 3: &#x27;petal width in cm&#x27;&#125;</span></span><br><span class="line"><span class="comment">#########################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.io.parsers.read_csv(</span><br><span class="line">    filepath_or_buffer=<span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span>,</span><br><span class="line">    header=<span class="literal">None</span>,</span><br><span class="line">    sep=<span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"><span class="comment"># 数据加列名</span></span><br><span class="line">df.columns = [l <span class="keyword">for</span> i,l <span class="keyword">in</span> <span class="built_in">sorted</span>(feature_dict.items())] + [<span class="string">&#x27;class label&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">sorted()得到的是一个列表，需要接收，而list.sort()原地排序。O(nlogn)</span></span><br><span class="line"><span class="string">若排序的是字典，会将字典的键值，放入元祖中，则可以通过 i,j 进行取元祖里的值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string">z = [i for i in sorted(feature_dict.items())]</span></span><br><span class="line"><span class="string"># [(0, &#x27;sepal length in cm&#x27;), (1, &#x27;sepal width in cm&#x27;), (2, &#x27;petal length in cm&#x27;), (3, &#x27;petal width in cm&#x27;)]</span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string">x = [l for i,l in sorted(feature_dict.items())]</span></span><br><span class="line"><span class="string"># [&#x27;sepal length in cm&#x27;, &#x27;sepal width in cm&#x27;, &#x27;petal length in cm&#x27;, &#x27;petal width in cm&#x27;]</span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">df.dropna(how=<span class="string">&quot;all&quot;</span>, inplace=<span class="literal">True</span>) <span class="comment"># to drop the empty line at file-end</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string">dropna()方法，能够找到DataFrame类型数据的空值（缺失值），将空值所在的行/列删除后，将新的DataFrame作为返回值返回。</span></span><br><span class="line"><span class="string">#######################################</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">axis：轴。0或&#x27;index&#x27;，表示按行删除；1或&#x27;columns&#x27;，表示按列删除。</span></span><br><span class="line"><span class="string">how：筛选方式。‘any’，表示该行/列只要有一个以上的空值，就删除该行/列；</span></span><br><span class="line"><span class="string">    ‘all’，表示该行/列全部都为空值，就删除该行/列。</span></span><br><span class="line"><span class="string">thresh：非空元素最低数量。int型，默认为None。如果该行/列中，非空元素数量小于这个值，就删除该行/列</span></span><br><span class="line"><span class="string">inplace：是否原地替换。布尔值，默认为False。如果为True，则在原DataFrame上进行操作，返回值为None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">df.tail()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>sepal length in cm</th>      <th>sepal width in cm</th>      <th>petal length in cm</th>      <th>petal width in cm</th>      <th>class label</th>    </tr>  </thead>  <tbody>    <tr>      <th>145</th>      <td>6.7</td>      <td>3.0</td>      <td>5.2</td>      <td>2.3</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>146</th>      <td>6.3</td>      <td>2.5</td>      <td>5.0</td>      <td>1.9</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>147</th>      <td>6.5</td>      <td>3.0</td>      <td>5.2</td>      <td>2.0</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>148</th>      <td>6.2</td>      <td>3.4</td>      <td>5.4</td>      <td>2.3</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>149</th>      <td>5.9</td>      <td>3.0</td>      <td>5.1</td>      <td>1.8</td>      <td>Iris-virginica</td>    </tr>  </tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142217.png" alt=""></p><p><strong> 可以看到y数据的（lebal）是字符串，不好。可以将其转化成数字。</strong></p><ul><li>使用sklearn.preprocessing的LabelEncoder模块实现 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line">X = df[[<span class="string">&#x27;sepal length in cm&#x27;</span>,<span class="string">&#x27;sepal width in cm&#x27;</span>,<span class="string">&#x27;petal length in cm&#x27;</span>,<span class="string">&#x27;petal width in cm&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;class label&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">enc = LabelEncoder()</span><br><span class="line">label_encoder = enc.fit(y)  <span class="comment"># 与之前不同的是，它在y上进行 fit !</span></span><br><span class="line">y = label_encoder.transform(y) + <span class="number">1</span> <span class="comment"># 默认从零开始，可以改为从一开始，</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># label_dict = &#123;1: &#x27;Setosa&#x27;, 2: &#x27;Versicolor&#x27;, 3:&#x27;Virginica&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142251.png" alt=""></p><h3 id="分别求三种鸢尾花数据在不同特征维度上的均值向量-mi"><a href="#分别求三种鸢尾花数据在不同特征维度上的均值向量-mi" class="headerlink" title="分别求三种鸢尾花数据在不同特征维度上的均值向量 mi"></a>分别求三种鸢尾花数据在不同特征维度上的均值向量 mi</h3><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142312.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.set_printoptions(precision=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 输出时，小数点后面四位，若没有四位的话，不输出。（0不输出！）</span></span><br><span class="line"></span><br><span class="line">mean_vectors = []</span><br><span class="line"><span class="keyword">for</span> cl <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">    mean_vectors.append(np.mean(X[y==cl], axis=<span class="number">0</span>))</span><br><span class="line">    print(<span class="string">&#x27;Mean Vector class %s: %s\n&#x27;</span> %(cl, mean_vectors[cl-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><pre><code>Mean Vector class 1: [ 5.006  3.418  1.464  0.244]Mean Vector class 2: [ 5.936  2.77   4.26   1.326]Mean Vector class 3: [ 6.588  2.974  5.552  2.026]</code></pre><h3 id="计算两个-4×4-维矩阵：类内散布矩阵和类间散布矩阵"><a href="#计算两个-4×4-维矩阵：类内散布矩阵和类间散布矩阵" class="headerlink" title="计算两个 4×4 维矩阵：类内散布矩阵和类间散布矩阵"></a>计算两个 4×4 维矩阵：类内散布矩阵和类间散布矩阵</h3><ul><li><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142459.png" alt=""></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">S_W = np.zeros((<span class="number">4</span>,<span class="number">4</span>))                               <span class="comment"># 每个类有4个特征值。即协方差矩阵——收藏的！</span></span><br><span class="line"><span class="keyword">for</span> cl,mv <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>), mean_vectors):         <span class="comment"># 3个类</span></span><br><span class="line">    class_sc_mat = np.zeros((<span class="number">4</span>,<span class="number">4</span>))                  <span class="comment"># scatter matrix for every class 由协方差决定其是4x4的！</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> X[y == cl]:                          <span class="comment"># 选取第 c1 类的 X</span></span><br><span class="line">        row, mv = row.reshape(<span class="number">4</span>,<span class="number">1</span>), mv.reshape(<span class="number">4</span>,<span class="number">1</span>) <span class="comment"># make column vectors 将矩阵组成 4x4 的形式！</span></span><br><span class="line">        class_sc_mat += (row-mv).dot((row-mv).T)</span><br><span class="line">    S_W += class_sc_mat                             <span class="comment"># sum class scatter matrices</span></span><br><span class="line">print(<span class="string">&#x27;within-class Scatter Matrix:\n&#x27;</span>, S_W)</span><br></pre></td></tr></table></figure><pre><code>within-class Scatter Matrix: [[ 38.9562  13.683   24.614    5.6556] [ 13.683   17.035    8.12     4.9132] [ 24.614    8.12    27.22     6.2536] [  5.6556   4.9132   6.2536   6.1756]]</code></pre><ul><li><p>类间的散布矩阵进行简化。不是m1-m2了，而是与全局均值的作比较</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142528.png" alt=""></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">overall_mean = np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">zip()和enumerate()类似，但是有所不同。</span></span><br><span class="line"><span class="string">zip()可以跟多对象，</span></span><br><span class="line"><span class="string">########################</span></span><br><span class="line"><span class="string">names = [&#x27;张三&#x27;,&#x27;李四&#x27;,&#x27;王五&#x27;]</span></span><br><span class="line"><span class="string">sexs = [&#x27;boy&#x27;,&#x27;girl&#x27;,&#x27;boy&#x27;]</span></span><br><span class="line"><span class="string">scores = [86, 92]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for name, sex, score in zip(names,sexs,scores):</span></span><br><span class="line"><span class="string">    print(&#x27;&#123;&#125;: &#123;&#125;, &#123;&#125;&#x27;.format(name, sex, score))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out[]:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">张三: boy, 86</span></span><br><span class="line"><span class="string">李四: girl, 92</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">########################</span></span><br><span class="line"><span class="string">enumerate()不可以。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">S_B = np.zeros((<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i,mean_vec <span class="keyword">in</span> <span class="built_in">enumerate</span>(mean_vectors):  </span><br><span class="line">    n = X[y==i+<span class="number">1</span>,:].shape[<span class="number">0</span>]  <span class="comment"># 获得数据的个数</span></span><br><span class="line">    mean_vec = mean_vec.reshape(<span class="number">4</span>,<span class="number">1</span>) <span class="comment"># make column vector</span></span><br><span class="line">    overall_mean = overall_mean.reshape(<span class="number">4</span>,<span class="number">1</span>) <span class="comment"># make column vector</span></span><br><span class="line">    S_B += n * (mean_vec - overall_mean).dot((mean_vec - overall_mean).T)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;between-class Scatter Matrix:\n&#x27;</span>, S_B)</span><br></pre></td></tr></table></figure><pre><code>between-class Scatter Matrix: [[  63.2121  -19.534   165.1647   71.3631] [ -19.534    10.9776  -56.0552  -22.4924] [ 165.1647  -56.0552  436.6437  186.9081] [  71.3631  -22.4924  186.9081   80.6041]]</code></pre><ul><li><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142553.png" alt=""></li></ul><p><strong> np.linalg.inv()可以求逆，np.linalg.eig()可以求特征值，特征向量 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eig_vals, eig_vecs = np.linalg.eig(np.linalg.inv(S_W).dot(S_B))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_vals)):</span><br><span class="line">    eigvec_sc = eig_vecs[:,i].reshape(<span class="number">4</span>,<span class="number">1</span>)   </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回的v是归一化后的特征向量（length为1）。特征向量v[:,i]对应特征值w[i]。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&#x27;\nEigenvector &#123;&#125;: \n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>, eigvec_sc.real))  <span class="comment"># 取实部</span></span><br><span class="line">    print(<span class="string">&#x27;Eigenvalue &#123;:&#125;: &#123;:.2e&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>, eig_vals[i].real))</span><br></pre></td></tr></table></figure><pre><code>Eigenvector 1: [[ 0.2049] [ 0.3871] [-0.5465] [-0.7138]]Eigenvalue 1: 3.23e+01Eigenvector 2: [[-0.009 ] [-0.589 ] [ 0.2543] [-0.767 ]]Eigenvalue 2: 2.78e-01Eigenvector 3: [[-0.7113] [ 0.0353] [-0.0267] [ 0.7015]]Eigenvalue 3: -5.76e-15Eigenvector 4: [[ 0.422 ] [-0.4364] [-0.4851] [ 0.6294]]Eigenvalue 4: 7.80e-15</code></pre><h3 id="特征值与特征向量："><a href="#特征值与特征向量：" class="headerlink" title="特征值与特征向量："></a>特征值与特征向量：</h3><ul><li>特征向量：表示映射方向</li><li>特征值：特征向量的重要程度</li><li>假设我们投影到的低维空间的维度为d，(n-&gt;d维的转换)对应的基向量为：W = (w1,w2,w3…wd)——收藏的！<ul><li>将x = W.T * x ((d,n) x (n,1)=(d,1))</li><li>这里是先求整体的四个映射方向，再进行筛选，选择两个，特征值大的。(具体看收藏的多分类LDA),然后进行降维。</li></ul></li></ul><p><strong>对本征值进行排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Make a list of (eigenvalue, eigenvector) tuples</span></span><br><span class="line">eig_pairs = [(np.<span class="built_in">abs</span>(eig_vals[i]), eig_vecs[:,i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_vals))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sort the (eigenvalue, eigenvector) tuples from high to low</span></span><br><span class="line">eig_pairs = <span class="built_in">sorted</span>(eig_pairs, key=<span class="keyword">lambda</span> k: k[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">key = lambda k:k[0]的意义：</span></span><br><span class="line"><span class="string">若可迭代对象是单个数字等，则可以直接排序。</span></span><br><span class="line"><span class="string">若是元祖，字典等，则需要指定根据什么进行排序了。即k[0]的第零个元素进行排序。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Visually confirm that the list is correctly sorted by decreasing eigenvalues</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Eigenvalues in decreasing order:\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eig_pairs:</span><br><span class="line">    print(i[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>Eigenvalues in decreasing order:32.27195779970.277566863847.7995841654e-155.76433252705e-15</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;Variance explained:\n&#x27;</span>)</span><br><span class="line">eigv_sum = <span class="built_in">sum</span>(eig_vals)</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(eig_pairs):</span><br><span class="line">    print(<span class="string">&#x27;eigenvalue &#123;0:&#125;: &#123;1:.2%&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>, (j[<span class="number">0</span>]/eigv_sum).real))</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">     print  &#x27;hello &#123;&#125; i am &#123;&#125;&#x27;.format(&#x27;Kevin&#x27;,&#x27;Tom&#x27;)</span></span><br><span class="line"><span class="string">                             </span></span><br><span class="line"><span class="string">     # hello Kevin i am Tom    </span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">     print  &#x27;&#123;0&#125; i am &#123;1&#125; . my name is &#123;0&#125;&#x27;.format(&#x27;Kevin&#x27;,&#x27;Tom&#x27;)</span></span><br><span class="line"><span class="string">                             </span></span><br><span class="line"><span class="string">     # hello Kevin i am Tom . my name is Kevin</span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">     &#123;0:&#125;冒号后面可以跟需要的操作，如保留两位小数</span></span><br><span class="line"><span class="string">     ###############################################</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><pre><code>Variance explained:eigenvalue 1: 99.15%eigenvalue 2: 0.85%eigenvalue 3: 0.00%eigenvalue 4: 0.00%</code></pre><p>选择前两维特征</p><p>x ((1,n)-&gt;(1,d))</p><p>x1 = x0 * W ((1,n) x (n,d)) =&gt; 所以W为(n,d)，此题为(4,2) </p><ul><li>理解意思即可，此题x=(1,n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">W = np.hstack((eig_pairs[<span class="number">0</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>), eig_pairs[<span class="number">1</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>)))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">np.vstack():在竖直方向上堆叠</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">np.hstack():在水平方向上平铺</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">print(<span class="string">&#x27;Matrix W:\n&#x27;</span>, W.real)</span><br></pre></td></tr></table></figure><pre><code>Matrix W: [[ 0.2049 -0.009 ] [ 0.3871 -0.589 ] [-0.5465  0.2543] [-0.7138 -0.767 ]]</code></pre><h3 id="进行数据的降维"><a href="#进行数据的降维" class="headerlink" title="进行数据的降维"></a>进行数据的降维</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_lda = X.dot(W)</span><br><span class="line"><span class="keyword">assert</span> X_lda.shape == (<span class="number">150</span>,<span class="number">2</span>), <span class="string">&quot;The matrix is not 150x2 dimensional.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_step_lda</span>():</span></span><br><span class="line"></span><br><span class="line">    ax = plt.subplot(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">for</span> label,marker,color <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">        <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>),(<span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;o&#x27;</span>),(<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line"></span><br><span class="line">        plt.scatter(x=X_lda[:,<span class="number">0</span>].real[y == label],</span><br><span class="line">                y=X_lda[:,<span class="number">1</span>].real[y == label],</span><br><span class="line">                marker=marker,</span><br><span class="line">                color=color,</span><br><span class="line">                alpha=<span class="number">0.5</span>,</span><br><span class="line">                label=label_dict[label]</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;LD1&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;LD2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    leg = plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>)</span><br><span class="line">    leg.get_frame().set_alpha(<span class="number">0.5</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;LDA: Iris projection onto the first 2 linear discriminants&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hide axis ticks</span></span><br><span class="line">    plt.tick_params(axis=<span class="string">&quot;both&quot;</span>, which=<span class="string">&quot;both&quot;</span>, bottom=<span class="string">&quot;off&quot;</span>, top=<span class="string">&quot;off&quot;</span>,  </span><br><span class="line">            labelbottom=<span class="string">&quot;on&quot;</span>, left=<span class="string">&quot;off&quot;</span>, right=<span class="string">&quot;off&quot;</span>, labelleft=<span class="string">&quot;on&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove axis spines</span></span><br><span class="line">    ax.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)  </span><br><span class="line">    ax.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)    </span><br><span class="line"></span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.tight_layout</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_step_lda()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142652.png" alt=""></p><h3 id="sklearn-有LDA模块可以调用。"><a href="#sklearn-有LDA模块可以调用。" class="headerlink" title="sklearn 有LDA模块可以调用。"></a>sklearn 有LDA模块可以调用。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis <span class="keyword">as</span> LDA</span><br><span class="line"></span><br><span class="line"><span class="comment"># LDA</span></span><br><span class="line">sklearn_lda = LDA(n_components=<span class="number">2</span>) <span class="comment"># 降低成2D</span></span><br><span class="line">X_lda_sklearn = sklearn_lda.fit_transform(X, y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis <span class="keyword">as</span> LDA</span><br><span class="line"></span><br><span class="line"><span class="comment"># LDA</span></span><br><span class="line">sklearn_lda = LDA(n_components=<span class="number">2</span>)</span><br><span class="line">X_lda_sklearn = sklearn_lda.fit_transform(X, y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_scikit_lda</span>(<span class="params">X, title</span>):</span></span><br><span class="line"></span><br><span class="line">    ax = plt.subplot(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">for</span> label,marker,color <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">        <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>),(<span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;o&#x27;</span>),(<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line"></span><br><span class="line">        plt.scatter(x=X[:,<span class="number">0</span>][y == label],</span><br><span class="line">                    y=X[:,<span class="number">1</span>][y == label] * -<span class="number">1</span>, <span class="comment"># flip the figure</span></span><br><span class="line">                    marker=marker,</span><br><span class="line">                    color=color,</span><br><span class="line">                    alpha=<span class="number">0.5</span>,</span><br><span class="line">                    label=label_dict[label])</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;LD1&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;LD2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    leg = plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>)</span><br><span class="line">    leg.get_frame().set_alpha(<span class="number">0.5</span>)</span><br><span class="line">    plt.title(title)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hide axis ticks</span></span><br><span class="line">    plt.tick_params(axis=<span class="string">&quot;both&quot;</span>, which=<span class="string">&quot;both&quot;</span>, bottom=<span class="string">&quot;off&quot;</span>, top=<span class="string">&quot;off&quot;</span>,  </span><br><span class="line">            labelbottom=<span class="string">&quot;on&quot;</span>, left=<span class="string">&quot;off&quot;</span>, right=<span class="string">&quot;off&quot;</span>, labelleft=<span class="string">&quot;on&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove axis spines</span></span><br><span class="line">    ax.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)  </span><br><span class="line">    ax.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)    </span><br><span class="line"></span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.tight_layout</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plot_step_lda()</span><br><span class="line">plot_scikit_lda(X_lda_sklearn, title=<span class="string">&#x27;Default LDA via scikit-learn&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142828.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515142842.png" alt=""></p><p><strong> 可以看出来sklearn和自己做的效果是差不多的 </strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;鸢尾花的数据集进行降维&quot;&gt;&lt;a href=&quot;#鸢尾花的数据集进行降维&quot; class=&quot;headerlink&quot; title=&quot;鸢尾花的数据集进行降维&quot;&gt;&lt;/a&gt;鸢尾花的数据集进行降维&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;有四个维度，萼片的长度。萼片的宽度，花瓣的长度，花瓣的宽</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>聚类基础——KMEANS &amp; DBSCAN</title>
    <link href="https://xxren8218.github.io/20210513/%E8%81%9A%E7%B1%BB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94KMEANS-DBSCAN.html"/>
    <id>https://xxren8218.github.io/20210513/%E8%81%9A%E7%B1%BB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94KMEANS-DBSCAN.html</id>
    <published>2021-05-13T10:05:21.000Z</published>
    <updated>2021-05-13T10:34:24.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="聚类——啤酒分类"><a href="#聚类——啤酒分类" class="headerlink" title="聚类——啤酒分类"></a>聚类——啤酒分类</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># beer dataset</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">beer = pd.read_csv(<span class="string">&#x27;data.txt&#x27;</span>, sep=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">beer</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>name</th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Budweiser</td>      <td>144</td>      <td>15</td>      <td>4.7</td>      <td>0.43</td>    </tr>    <tr>      <th>1</th>      <td>Schlitz</td>      <td>151</td>      <td>19</td>      <td>4.9</td>      <td>0.43</td>    </tr>    <tr>      <th>2</th>      <td>Lowenbrau</td>      <td>157</td>      <td>15</td>      <td>0.9</td>      <td>0.48</td>    </tr>    <tr>      <th>3</th>      <td>Kronenbourg</td>      <td>170</td>      <td>7</td>      <td>5.2</td>      <td>0.73</td>    </tr>    <tr>      <th>4</th>      <td>Heineken</td>      <td>152</td>      <td>11</td>      <td>5.0</td>      <td>0.77</td>    </tr>    <tr>      <th>5</th>      <td>Old_Milwaukee</td>      <td>145</td>      <td>23</td>      <td>4.6</td>      <td>0.28</td>    </tr>    <tr>      <th>6</th>      <td>Augsberger</td>      <td>175</td>      <td>24</td>      <td>5.5</td>      <td>0.40</td>    </tr>    <tr>      <th>7</th>      <td>Srohs_Bohemian_Style</td>      <td>149</td>      <td>27</td>      <td>4.7</td>      <td>0.42</td>    </tr>    <tr>      <th>8</th>      <td>Miller_Lite</td>      <td>99</td>      <td>10</td>      <td>4.3</td>      <td>0.43</td>    </tr>    <tr>      <th>9</th>      <td>Budweiser_Light</td>      <td>113</td>      <td>8</td>      <td>3.7</td>      <td>0.40</td>    </tr>    <tr>      <th>10</th>      <td>Coors</td>      <td>140</td>      <td>18</td>      <td>4.6</td>      <td>0.44</td>    </tr>    <tr>      <th>11</th>      <td>Coors_Light</td>      <td>102</td>      <td>15</td>      <td>4.1</td>      <td>0.46</td>    </tr>    <tr>      <th>12</th>      <td>Michelob_Light</td>      <td>135</td>      <td>11</td>      <td>4.2</td>      <td>0.50</td>    </tr>    <tr>      <th>13</th>      <td>Becks</td>      <td>150</td>      <td>19</td>      <td>4.7</td>      <td>0.76</td>    </tr>    <tr>      <th>14</th>      <td>Kirin</td>      <td>149</td>      <td>6</td>      <td>5.0</td>      <td>0.79</td>    </tr>    <tr>      <th>15</th>      <td>Pabst_Extra_Light</td>      <td>68</td>      <td>15</td>      <td>2.3</td>      <td>0.38</td>    </tr>    <tr>      <th>16</th>      <td>Hamms</td>      <td>139</td>      <td>19</td>      <td>4.4</td>      <td>0.43</td>    </tr>    <tr>      <th>17</th>      <td>Heilemans_Old_Style</td>      <td>144</td>      <td>24</td>      <td>4.9</td>      <td>0.43</td>    </tr>    <tr>      <th>18</th>      <td>Olympia_Goled_Light</td>      <td>72</td>      <td>6</td>      <td>2.9</td>      <td>0.46</td>    </tr>    <tr>      <th>19</th>      <td>Schlitz_Light</td>      <td>97</td>      <td>7</td>      <td>4.2</td>      <td>0.47</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = beer[[<span class="string">&quot;calories&quot;</span>,<span class="string">&quot;sodium&quot;</span>,<span class="string">&quot;alcohol&quot;</span>,<span class="string">&quot;cost&quot;</span>]]</span><br></pre></td></tr></table></figure><h2 id="K-means-clustering"><a href="#K-means-clustering" class="headerlink" title="K-means clustering"></a>K-means clustering</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line">km = KMeans(n_clusters=<span class="number">3</span>).fit(X) <span class="comment"># n_cluster就是聚集成几个簇</span></span><br><span class="line">km2 = KMeans(n_clusters=<span class="number">2</span>).fit(X)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">km.labels_  <span class="comment"># 调用函数直接返回结果了！</span></span><br></pre></td></tr></table></figure><pre><code>array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 2, 0, 0, 2, 1])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beer[<span class="string">&#x27;cluster&#x27;</span>] = km.labels_</span><br><span class="line">beer[<span class="string">&#x27;cluster2&#x27;</span>] = km2.labels_</span><br><span class="line">beer.sort_values(<span class="string">&#x27;cluster&#x27;</span>)</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>name</th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>      <th>cluster2</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Budweiser</td>      <td>144</td>      <td>15</td>      <td>4.7</td>      <td>0.43</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>Schlitz</td>      <td>151</td>      <td>19</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>Lowenbrau</td>      <td>157</td>      <td>15</td>      <td>0.9</td>      <td>0.48</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>Kronenbourg</td>      <td>170</td>      <td>7</td>      <td>5.2</td>      <td>0.73</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>Heineken</td>      <td>152</td>      <td>11</td>      <td>5.0</td>      <td>0.77</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>5</th>      <td>Old_Milwaukee</td>      <td>145</td>      <td>23</td>      <td>4.6</td>      <td>0.28</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>6</th>      <td>Augsberger</td>      <td>175</td>      <td>24</td>      <td>5.5</td>      <td>0.40</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>7</th>      <td>Srohs_Bohemian_Style</td>      <td>149</td>      <td>27</td>      <td>4.7</td>      <td>0.42</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>17</th>      <td>Heilemans_Old_Style</td>      <td>144</td>      <td>24</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>16</th>      <td>Hamms</td>      <td>139</td>      <td>19</td>      <td>4.4</td>      <td>0.43</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>10</th>      <td>Coors</td>      <td>140</td>      <td>18</td>      <td>4.6</td>      <td>0.44</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>14</th>      <td>Kirin</td>      <td>149</td>      <td>6</td>      <td>5.0</td>      <td>0.79</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>12</th>      <td>Michelob_Light</td>      <td>135</td>      <td>11</td>      <td>4.2</td>      <td>0.50</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>13</th>      <td>Becks</td>      <td>150</td>      <td>19</td>      <td>4.7</td>      <td>0.76</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>9</th>      <td>Budweiser_Light</td>      <td>113</td>      <td>8</td>      <td>3.7</td>      <td>0.40</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>8</th>      <td>Miller_Lite</td>      <td>99</td>      <td>10</td>      <td>4.3</td>      <td>0.43</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>11</th>      <td>Coors_Light</td>      <td>102</td>      <td>15</td>      <td>4.1</td>      <td>0.46</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>19</th>      <td>Schlitz_Light</td>      <td>97</td>      <td>7</td>      <td>4.2</td>      <td>0.47</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>15</th>      <td>Pabst_Extra_Light</td>      <td>68</td>      <td>15</td>      <td>2.3</td>      <td>0.38</td>      <td>2</td>      <td>0</td>    </tr>    <tr>      <th>18</th>      <td>Olympia_Goled_Light</td>      <td>72</td>      <td>6</td>      <td>2.9</td>      <td>0.46</td>      <td>2</td>      <td>0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tools.plotting <span class="keyword">import</span> scatter_matrix  <span class="comment"># 导入scatter_matrix可以画多福图形。</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">cluster_centers = km.cluster_centers_</span><br><span class="line"></span><br><span class="line">cluster_centers_2 = km2.cluster_centers_</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beer.groupby(<span class="string">&quot;cluster&quot;</span>).mean()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster2</th>    </tr>    <tr>      <th>cluster</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>150.00</td>      <td>17.0</td>      <td>4.521429</td>      <td>0.520714</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>102.75</td>      <td>10.0</td>      <td>4.075000</td>      <td>0.440000</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>70.00</td>      <td>10.5</td>      <td>2.600000</td>      <td>0.420000</td>      <td>0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beer.groupby(<span class="string">&quot;cluster2&quot;</span>).mean()</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>    </tr>    <tr>      <th>cluster2</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>91.833333</td>      <td>10.166667</td>      <td>3.583333</td>      <td>0.433333</td>      <td>1.333333</td>    </tr>    <tr>      <th>1</th>      <td>150.000000</td>      <td>17.000000</td>      <td>4.521429</td>      <td>0.520714</td>      <td>0.000000</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centers = beer.groupby(<span class="string">&quot;cluster&quot;</span>).mean().reset_index() <span class="comment"># 中心点，为后面作图做准备！</span></span><br><span class="line">                                        <span class="comment"># reset_index(默认drop=False)，表示获取新的索引，并保留原来索引</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.size&#x27;</span>] = <span class="number">14</span>  <span class="comment"># rcParams 可以设置图形整体的字体大小等。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">colors = np.array([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>])</span><br></pre></td></tr></table></figure><p><strong> 先看其中两个特征的分布情况 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(beer[<span class="string">&quot;calories&quot;</span>], beer[<span class="string">&quot;alcohol&quot;</span>],c=colors[beer[<span class="string">&quot;cluster&quot;</span>]])</span><br><span class="line"></span><br><span class="line">plt.scatter(centers.calories, centers.alcohol, linewidths=<span class="number">3</span>, marker=<span class="string">&#x27;+&#x27;</span>, s=<span class="number">300</span>, c=<span class="string">&#x27;black&#x27;</span>) <span class="comment"># centers.calories获取质心</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;Calories&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Alcohol&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.text.Text at 0x18a25af4ac8&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181033.png" alt=""></p><p><strong> 再看其中各个维度特征的分布 </strong> scatter_matrix</p><ul><li><p>数据是多维的，要么PCA，要么这种方式进行可视化</p></li><li><p>条形图代表自身的特征的分布情况</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scatter_matrix(beer[[<span class="string">&quot;calories&quot;</span>,<span class="string">&quot;sodium&quot;</span>,<span class="string">&quot;alcohol&quot;</span>,<span class="string">&quot;cost&quot;</span>]],s=<span class="number">100</span>, alpha=<span class="number">1</span>, c=colors[beer[<span class="string">&quot;cluster&quot;</span>]], figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">plt.suptitle(<span class="string">&quot;With 3 centroids initialized&quot;</span>)</span><br></pre></td></tr></table></figure><div style="color: red">    C:\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: 'pandas.tools.plotting.scatter_matrix' is deprecated, import 'pandas.plotting.scatter_matrix' instead.      if __name__ == '__main__':</div><pre><code>&lt;matplotlib.text.Text at 0x18a25b67e80&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181104.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scatter_matrix(beer[[<span class="string">&quot;calories&quot;</span>,<span class="string">&quot;sodium&quot;</span>,<span class="string">&quot;alcohol&quot;</span>,<span class="string">&quot;cost&quot;</span>]],s=<span class="number">100</span>, alpha=<span class="number">1</span>, c=colors[beer[<span class="string">&quot;cluster2&quot;</span>]], figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">plt.suptitle(<span class="string">&quot;With 2 centroids initialized&quot;</span>)</span><br></pre></td></tr></table></figure><div style="color: red">    C:\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: 'pandas.tools.plotting.scatter_matrix' is deprecated, import 'pandas.plotting.scatter_matrix' instead.      if __name__ == '__main__':</div><pre><code>&lt;matplotlib.text.Text at 0x18a2613c710&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181130.png" alt=""></p><h3 id="Scaled-data"><a href="#Scaled-data" class="headerlink" title="Scaled data"></a>Scaled data</h3><p><strong> sklearn进行数据标准化 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_scaled = scaler.fit_transform(X)</span><br><span class="line">X_scaled</span><br></pre></td></tr></table></figure><pre><code>array([[ 0.38791334,  0.00779468,  0.43380786, -0.45682969],       [ 0.6250656 ,  0.63136906,  0.62241997, -0.45682969],       [ 0.82833896,  0.00779468, -3.14982226, -0.10269815],       [ 1.26876459, -1.23935408,  0.90533814,  1.66795955],       [ 0.65894449, -0.6157797 ,  0.71672602,  1.95126478],       [ 0.42179223,  1.25494344,  0.3395018 , -1.5192243 ],       [ 1.43815906,  1.41083704,  1.1882563 , -0.66930861],       [ 0.55730781,  1.87851782,  0.43380786, -0.52765599],       [-1.1366369 , -0.7716733 ,  0.05658363, -0.45682969],       [-0.66233238, -1.08346049, -0.5092527 , -0.66930861],       [ 0.25239776,  0.47547547,  0.3395018 , -0.38600338],       [-1.03500022,  0.00779468, -0.13202848, -0.24435076],       [ 0.08300329, -0.6157797 , -0.03772242,  0.03895447],       [ 0.59118671,  0.63136906,  0.43380786,  1.88043848],       [ 0.55730781, -1.39524768,  0.71672602,  2.0929174 ],       [-2.18688263,  0.00779468, -1.82953748, -0.81096123],       [ 0.21851887,  0.63136906,  0.15088969, -0.45682969],       [ 0.38791334,  1.41083704,  0.62241997, -0.45682969],       [-2.05136705, -1.39524768, -1.26370115, -0.24435076],       [-1.20439469, -1.23935408, -0.03772242, -0.17352445]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">km = KMeans(n_clusters=<span class="number">3</span>).fit(X_scaled)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beer[<span class="string">&quot;scaled_cluster&quot;</span>] = km.labels_</span><br><span class="line">beer.sort_values(<span class="string">&quot;scaled_cluster&quot;</span>)</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>name</th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>      <th>cluster2</th>      <th>scaled_cluster</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Budweiser</td>      <td>144</td>      <td>15</td>      <td>4.7</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>Schlitz</td>      <td>151</td>      <td>19</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>17</th>      <td>Heilemans_Old_Style</td>      <td>144</td>      <td>24</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>16</th>      <td>Hamms</td>      <td>139</td>      <td>19</td>      <td>4.4</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>5</th>      <td>Old_Milwaukee</td>      <td>145</td>      <td>23</td>      <td>4.6</td>      <td>0.28</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>6</th>      <td>Augsberger</td>      <td>175</td>      <td>24</td>      <td>5.5</td>      <td>0.40</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>7</th>      <td>Srohs_Bohemian_Style</td>      <td>149</td>      <td>27</td>      <td>4.7</td>      <td>0.42</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>10</th>      <td>Coors</td>      <td>140</td>      <td>18</td>      <td>4.6</td>      <td>0.44</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>15</th>      <td>Pabst_Extra_Light</td>      <td>68</td>      <td>15</td>      <td>2.3</td>      <td>0.38</td>      <td>2</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>12</th>      <td>Michelob_Light</td>      <td>135</td>      <td>11</td>      <td>4.2</td>      <td>0.50</td>      <td>0</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>11</th>      <td>Coors_Light</td>      <td>102</td>      <td>15</td>      <td>4.1</td>      <td>0.46</td>      <td>1</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>9</th>      <td>Budweiser_Light</td>      <td>113</td>      <td>8</td>      <td>3.7</td>      <td>0.40</td>      <td>1</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>8</th>      <td>Miller_Lite</td>      <td>99</td>      <td>10</td>      <td>4.3</td>      <td>0.43</td>      <td>1</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>Lowenbrau</td>      <td>157</td>      <td>15</td>      <td>0.9</td>      <td>0.48</td>      <td>0</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>18</th>      <td>Olympia_Goled_Light</td>      <td>72</td>      <td>6</td>      <td>2.9</td>      <td>0.46</td>      <td>2</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>19</th>      <td>Schlitz_Light</td>      <td>97</td>      <td>7</td>      <td>4.2</td>      <td>0.47</td>      <td>1</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>13</th>      <td>Becks</td>      <td>150</td>      <td>19</td>      <td>4.7</td>      <td>0.76</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>    <tr>      <th>14</th>      <td>Kirin</td>      <td>149</td>      <td>6</td>      <td>5.0</td>      <td>0.79</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>    <tr>      <th>4</th>      <td>Heineken</td>      <td>152</td>      <td>11</td>      <td>5.0</td>      <td>0.77</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>    <tr>      <th>3</th>      <td>Kronenbourg</td>      <td>170</td>      <td>7</td>      <td>5.2</td>      <td>0.73</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>  </tbody></table></div><p>What are the “characteristics” of each cluster?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beer.groupby(<span class="string">&quot;scaled_cluster&quot;</span>).mean()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>      <th>cluster2</th>    </tr>    <tr>      <th>scaled_cluster</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>148.375</td>      <td>21.125</td>      <td>4.7875</td>      <td>0.4075</td>      <td>0.0</td>      <td>1.00</td>    </tr>    <tr>      <th>1</th>      <td>105.375</td>      <td>10.875</td>      <td>3.3250</td>      <td>0.4475</td>      <td>1.0</td>      <td>0.25</td>    </tr>    <tr>      <th>2</th>      <td>155.250</td>      <td>10.750</td>      <td>4.9750</td>      <td>0.7625</td>      <td>0.0</td>      <td>1.00</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.scatter_matrix(X, c=colors[beer.scaled_cluster], alpha=<span class="number">1</span>, figsize=(<span class="number">10</span>,<span class="number">10</span>), s=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><div style="color: red">    C:\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: pandas.scatter_matrix is deprecated. Use pandas.plotting.scatter_matrix instead      if __name__ == '__main__':</div>    <pre><code>array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A279F8F28&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A282989B0&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27B5E2E8&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27B94F60&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27BE41D0&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27C19F28&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27C61F60&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27C71C88&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27CF1860&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27D3B7B8&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27D7C5C0&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27DC6F98&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27E02748&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27E4FEB8&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27E8D588&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000018A27ED47B8&gt;]], dtype=object)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181223.png" alt=""></p><h2 id="聚类评估：轮廓系数（Silhouette-Coefficient-）（常用）"><a href="#聚类评估：轮廓系数（Silhouette-Coefficient-）（常用）" class="headerlink" title="聚类评估：轮廓系数（Silhouette Coefficient ）（常用）"></a>聚类评估：轮廓系数（Silhouette Coefficient ）（常用）</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513183410.png" alt=""></p><ul><li>计算样本i到同簇其他样本的平均距离ai。ai 越小，说明样本i越应该被聚类到该簇。将ai 称为样本i的簇内不相似度。越小越好。</li><li>计算样本i到其他某簇Cj 的所有样本的平均距离bij，称为样本i与簇Cj 的不相似度。定义为样本i的簇间不相似度：bi =min{bi1, bi2, …, bik}。越大越好。</li></ul><ul><li>si接近1，则说明样本i聚类合理</li><li>si接近-1，则说明样本i更应该分类到另外的簇</li><li>若si 近似为0，则说明样本i在两个簇的边界上。</li></ul><p><strong> 使用sklearn模块的metrics进行聚类评估 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">score_scaled = metrics.silhouette_score(X,beer.scaled_cluster) <span class="comment"># 做归一化的结果</span></span><br><span class="line">score = metrics.silhouette_score(X,beer.cluster) <span class="comment"># 不做归一化的结果</span></span><br><span class="line">print(score_scaled, score)</span><br></pre></td></tr></table></figure><pre><code>0.179780680894 0.673177504646</code></pre><p><strong> 做归一化的结果反而低了。</strong> 做归一化不一定会得到好结果。</p><h2 id="尝试计算不同的k值对结果的影响。"><a href="#尝试计算不同的k值对结果的影响。" class="headerlink" title="尝试计算不同的k值对结果的影响。"></a>尝试计算不同的k值对结果的影响。</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scores = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">20</span>):</span><br><span class="line">    labels = KMeans(n_clusters=k).fit(X).labels_</span><br><span class="line">    score = metrics.silhouette_score(X, labels)</span><br><span class="line">    scores.append(score)</span><br><span class="line"></span><br><span class="line">scores</span><br></pre></td></tr></table></figure><pre><code>[0.69176560340794857, 0.67317750464557957, 0.58570407211277953, 0.42254873351720201, 0.4559182167013377, 0.43776116697963124, 0.38946337473125997, 0.39746405172426014, 0.33061511213823314, 0.34131096180393328, 0.34597752371272478, 0.31221439248428434, 0.30707782144770296, 0.31834561839139497, 0.28495140011748982, 0.23498077333071996, 0.15880910174962809, 0.084230513801511767]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">20</span>)), scores)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Number of Clusters Initialized&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Sihouette Score&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.text.Text at 0x18a288239e8&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181248.png" alt=""></p><p><strong> 可以看出K=2的时候比较合适 </strong></p><h2 id="DBSCAN-clustering"><a href="#DBSCAN-clustering" class="headerlink" title="DBSCAN clustering"></a>DBSCAN clustering</h2><ul><li>在不规则的数据集上比较强大，简单数据集可能还不如kmeans.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line">db = DBSCAN(eps=<span class="number">10</span>, min_samples=<span class="number">2</span>).fit(X)  <span class="comment"># eps半径，min_samples指密度</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labels = db.labels_</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beer[<span class="string">&#x27;cluster_db&#x27;</span>] = labels</span><br><span class="line">beer.sort_values(<span class="string">&#x27;cluster_db&#x27;</span>)</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>name</th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>      <th>cluster2</th>      <th>scaled_cluster</th>      <th>cluster_db</th>    </tr>  </thead>  <tbody>    <tr>      <th>9</th>      <td>Budweiser_Light</td>      <td>113</td>      <td>8</td>      <td>3.7</td>      <td>0.40</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>-1</td>    </tr>    <tr>      <th>3</th>      <td>Kronenbourg</td>      <td>170</td>      <td>7</td>      <td>5.2</td>      <td>0.73</td>      <td>0</td>      <td>1</td>      <td>2</td>      <td>-1</td>    </tr>    <tr>      <th>6</th>      <td>Augsberger</td>      <td>175</td>      <td>24</td>      <td>5.5</td>      <td>0.40</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>-1</td>    </tr>    <tr>      <th>17</th>      <td>Heilemans_Old_Style</td>      <td>144</td>      <td>24</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>16</th>      <td>Hamms</td>      <td>139</td>      <td>19</td>      <td>4.4</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>14</th>      <td>Kirin</td>      <td>149</td>      <td>6</td>      <td>5.0</td>      <td>0.79</td>      <td>0</td>      <td>1</td>      <td>2</td>      <td>0</td>    </tr>    <tr>      <th>13</th>      <td>Becks</td>      <td>150</td>      <td>19</td>      <td>4.7</td>      <td>0.76</td>      <td>0</td>      <td>1</td>      <td>2</td>      <td>0</td>    </tr>    <tr>      <th>12</th>      <td>Michelob_Light</td>      <td>135</td>      <td>11</td>      <td>4.2</td>      <td>0.50</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>10</th>      <td>Coors</td>      <td>140</td>      <td>18</td>      <td>4.6</td>      <td>0.44</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>0</th>      <td>Budweiser</td>      <td>144</td>      <td>15</td>      <td>4.7</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>7</th>      <td>Srohs_Bohemian_Style</td>      <td>149</td>      <td>27</td>      <td>4.7</td>      <td>0.42</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>5</th>      <td>Old_Milwaukee</td>      <td>145</td>      <td>23</td>      <td>4.6</td>      <td>0.28</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>Heineken</td>      <td>152</td>      <td>11</td>      <td>5.0</td>      <td>0.77</td>      <td>0</td>      <td>1</td>      <td>2</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>Lowenbrau</td>      <td>157</td>      <td>15</td>      <td>0.9</td>      <td>0.48</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>Schlitz</td>      <td>151</td>      <td>19</td>      <td>4.9</td>      <td>0.43</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>8</th>      <td>Miller_Lite</td>      <td>99</td>      <td>10</td>      <td>4.3</td>      <td>0.43</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>11</th>      <td>Coors_Light</td>      <td>102</td>      <td>15</td>      <td>4.1</td>      <td>0.46</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>19</th>      <td>Schlitz_Light</td>      <td>97</td>      <td>7</td>      <td>4.2</td>      <td>0.47</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>15</th>      <td>Pabst_Extra_Light</td>      <td>68</td>      <td>15</td>      <td>2.3</td>      <td>0.38</td>      <td>2</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>    <tr>      <th>18</th>      <td>Olympia_Goled_Light</td>      <td>72</td>      <td>6</td>      <td>2.9</td>      <td>0.46</td>      <td>2</td>      <td>0</td>      <td>1</td>      <td>2</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beer.groupby(<span class="string">&#x27;cluster_db&#x27;</span>).mean()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>calories</th>      <th>sodium</th>      <th>alcohol</th>      <th>cost</th>      <th>cluster</th>      <th>cluster2</th>      <th>scaled_cluster</th>    </tr>    <tr>      <th>cluster_db</th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>-1</th>      <td>152.666667</td>      <td>13.000000</td>      <td>4.800000</td>      <td>0.510000</td>      <td>0.333333</td>      <td>0.666667</td>      <td>1.000000</td>    </tr>    <tr>      <th>0</th>      <td>146.250000</td>      <td>17.250000</td>      <td>4.383333</td>      <td>0.513333</td>      <td>0.000000</td>      <td>1.000000</td>      <td>0.666667</td>    </tr>    <tr>      <th>1</th>      <td>99.333333</td>      <td>10.666667</td>      <td>4.200000</td>      <td>0.453333</td>      <td>1.000000</td>      <td>0.000000</td>      <td>1.000000</td>    </tr>    <tr>      <th>2</th>      <td>70.000000</td>      <td>10.500000</td>      <td>2.600000</td>      <td>0.420000</td>      <td>2.000000</td>      <td>0.000000</td>      <td>1.000000</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.scatter_matrix(X, c=colors[beer.cluster_db], figsize=(<span class="number">10</span>,<span class="number">10</span>), s=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><div style="color: red">    C:\Anaconda3\lib\site-packages\ipykernel\__main__.py:1: FutureWarning: pandas.scatter_matrix is deprecated. Use pandas.plotting.scatter_matrix instead      if __name__ == '__main__':</div>    <div style="overflow: scroll;">    array([[<matplotlib.axes._subplots.AxesSubplot object at 0x0000018A278A3940>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A284C56D8>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A28501CF8>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A28550080>],           [<matplotlib.axes._subplots.AxesSubplot object at 0x0000018A2856C588>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A285D1F60>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A286211D0>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A2865AF98>],           [<matplotlib.axes._subplots.AxesSubplot object at 0x0000018A286AABA8>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A286E7278>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A2872E390>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A287396A0>],           [<matplotlib.axes._subplots.AxesSubplot object at 0x0000018A287BC358>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A28B356A0>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A28B71240>,            <matplotlib.axes._subplots.AxesSubplot object at 0x0000018A28BBC470>]], dtype=object)</div><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210513181312.png" alt=""></p><p><strong> DBSCAN的后续过程一样，可以用轮廓系数进行评估。for循环eps和min_samples。也可以做数据增强。（看哪个数据的维度对结果有比较好的影响） </strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;聚类——啤酒分类&quot;&gt;&lt;a href=&quot;#聚类——啤酒分类&quot; class=&quot;headerlink&quot; title=&quot;聚类——啤酒分类&quot;&gt;&lt;/a&gt;聚类——啤酒分类&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="机器学习" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习基础" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（六十七）：剪绳子</title>
    <link href="https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E5%89%AA%E7%BB%B3%E5%AD%90.html"/>
    <id>https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E5%89%AA%E7%BB%B3%E5%AD%90.html</id>
    <published>2021-05-12T08:49:55.000Z</published>
    <updated>2021-05-19T16:53:47.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><div style="color: red;">    给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1，m<=n），每段绳子的长度记为k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</div><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>这道题可以用数学的方法来解决——基本不等式。如下图<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512165604.JPG" alt=""><br>即将 x1+x2+…+xm=n 分成 m 份，然后求导得到极大值<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512170104.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512170218.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512170240.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512170257.JPG" alt=""><br>得到应该均分成3份，又分三种情况，能整除。余数为1时，（4=2+2=1+3），明显2x2&gt;1x3，余数为2时正常写（5的话2x3是最大的。）<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210512170344.JPG" alt=""></p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> number-<span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        a, b = number//<span class="number">3</span>, number%<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>**a</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>**(a-<span class="number">1</span>)*<span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>**a*<span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;div style=&quot;color: red;&quot;&gt;
    给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数学" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（六十三）：数据流中的中位数</title>
    <link href="https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.html"/>
    <id>https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.html</id>
    <published>2021-05-12T08:38:58.000Z</published>
    <updated>2021-05-15T13:52:18.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><div style="color: red">    如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</div><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p><div style="color: red">    可以建立一个列表来append所给的数据    然后将列表排序，计算列表的长度。只需要区分奇数和偶数情况即可。</div></p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.s.append(num)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.s = <span class="built_in">sorted</span>(self.s)</span><br><span class="line">        n = <span class="built_in">len</span>(self.s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 奇数</span></span><br><span class="line">            <span class="keyword">return</span> self.s[n/<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 偶数</span></span><br><span class="line">            <span class="keyword">return</span> (self.s[n/<span class="number">2</span>]+self.s[n/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2.0</span> <span class="comment"># 注意如果这里写2的话，得到的是向下取整的整数，所以需要写成浮点型。</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure><h2 id="上述的代码虽然可以，但是在力扣上执行时间长。提出另一种思路——最大堆，最小堆。"><a href="#上述的代码虽然可以，但是在力扣上执行时间长。提出另一种思路——最大堆，最小堆。" class="headerlink" title="上述的代码虽然可以，但是在力扣上执行时间长。提出另一种思路——最大堆，最小堆。"></a>上述的代码虽然可以，但是在力扣上执行时间长。提出另一种思路——最大堆，最小堆。</h2><ol><li><p>如果我们可以对数据进行排序，分成小的一半和大的一半。找小的最大值和大的最小值即可。这个不就是最小、最大堆嘛！</p><ul><li>最大堆（找出最小的k个元素）</li><li>最小堆（找出最大的k个元素）</li></ul></li></ol><p>如图所示过程。用最大堆存最小的k个元素，最小堆存最大k个元素。我们就可以用O（1）的复杂度找到值max和min了<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515205757.JPG" alt=""></p><ol><li><p>在数据存放的时候我们可以这样，当最小堆和最大堆的尺寸相等时，存放进入最大堆maxheap，不等时，存放进最小堆minheap。<br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515211539.JPG" alt=""></p></li><li><p>但是这存在一个问题，若将a1存放进入minheap的时候，若a1的值比maxheap的一些数字还要小，则不满足我们之前的假设——maxheap的数字比minheap的数字小；若将a2的存放到maxheap的时候，若a2比minheap的某些值还要大，那么也不符合我们的假定；那么我们可以这样做；</p><ul><li>将a1先插入到maxheap中，再将maxheap的队顶元素插入到minheap，这样就保证了maxheap始终为最小的元素。</li><li>同理，将a2先放入到minheap中，再将minheap的队顶元素放入maxheap中</li><li>python没有最大堆，只需要把最小堆取反。</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515211558.JPG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210515211618.JPG" alt=""></p><p><strong> heappushpop()相当于先推后弹出，这意味着堆大小可能会在进程中发生变化. </strong></p><p><strong> heapreplace()相当于先弹出，然后推送，附加的限制是保证堆大小在这个过程中不会改变。</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.maxheap = []</span><br><span class="line">        self.minheap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 为了使得数据平均分配到两个堆，当两个堆的尺寸一样时，将新增加的元素放到minheap中</span></span><br><span class="line">        <span class="comment"># 具体做法分两步：1.现将新元素放到maxheap中，2.再将maxheap的堆顶元素放入minheap</span></span><br><span class="line">        <span class="comment"># python没有最大堆，可以用最小堆取反实现</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.maxheap) == <span class="built_in">len</span>(self.minheap):</span><br><span class="line">            heapq.heappush(self.minheap,-heapq.heappushpop(self.maxheap,-num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self.maxheap,-heapq.heappushpop(self.minheap,num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.maxheap) == <span class="built_in">len</span>(self.minheap):</span><br><span class="line">            <span class="keyword">return</span> (-self.maxheap[<span class="number">0</span>]+self.minheap[<span class="number">0</span>])/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.minheap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MedianFinder()</span></span><br><span class="line"><span class="comment"># obj.addNum(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.findMedian()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;div style=&quot;color: red&quot;&gt;
    如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://xxren8218.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="最小堆" scheme="https://xxren8218.github.io/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（六十四）：滑动窗口的最大值</title>
    <link href="https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.html"/>
    <id>https://xxren8218.github.io/20210512/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%85%AD%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.html</id>
    <published>2021-05-12T08:25:59.000Z</published>
    <updated>2021-05-17T10:13:35.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><div style="color: red;">    给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}。</div><h2 id="2-思路—暴力解法"><a href="#2-思路—暴力解法" class="headerlink" title="2.思路—暴力解法"></a>2.思路—暴力解法</h2><div style="color: red">    创建一个列表res来存储最终结果    创建一个临时列表temp来存储目前窗口内的数字    python有内置的max()函数可以找出列表中的最大数字。将其放入结果列表中即可。    while循环，直到窗口的右边界到达给定列表长度时，停止。</div>  ## 3.代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span>(<span class="params">self, num, size</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num <span class="keyword">or</span> size &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = start + size</span><br><span class="line">        <span class="keyword">while</span> end &lt;= <span class="built_in">len</span>(num):</span><br><span class="line">            temp_list = num[start:end]</span><br><span class="line">            res.append(<span class="built_in">max</span>(temp_list)) <span class="comment"># 其实可以和上面一步的合并在一起。</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>- max的时间复杂度为O(n)<div style="color: red;">对于每个滑动窗口，我们可以使用 O(k)的时间遍历其中的每一个元素，找出其中的最大值。对于长度为 n 的数组 nums 而言，窗口的数量为 n-k+1，因此该算法的时间复杂度为 O((n-k+1)k)=O(nk)<br>会超出时间限制，因此我们需要进行一些优化。——需要将取最大值的操作进行降低时间复杂度。</div><h2 id="在力扣上提交时，超时，时间复杂度为O-nk-想办法对其进行改进。"><a href="#在力扣上提交时，超时，时间复杂度为O-nk-想办法对其进行改进。" class="headerlink" title="在力扣上提交时，超时，时间复杂度为O(nk),想办法对其进行改进。"></a>在力扣上提交时，超时，时间复杂度为O(nk),想办法对其进行改进。</h2><p>对于实现栈min函数的题目使用 单调栈 实现了随意入栈、出栈情况下的 O(1)时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，而 “窗口滑动” 删除的是 “列表首部元素” ——为单调递减队列。</p><p>** 理解了栈的min函数，再理解队的最大函数，再写这道题容易些。</p><p>队的最大函数的理解</p><p>入队顺序为：                 [5]-&gt;[5,-1]-&gt;[5,-1,3]-&gt;[5,-1,3,6]-&gt;[5,-1,3,6,2]<br>队的最大函数时的辅助队列：     [5]-&gt;[5,-1]-&gt;[5,3]   -&gt;[6]       -&gt;[6,2]<br>最大值为：                   [5]-&gt;[5]  -&gt;[5]     -&gt;[6]      -&gt;[6]</p><p>出队顺序为：(先进先出)。        [5,-1,3,6,2]-&gt;[-1,3,6,2]-&gt;[3,6,2]-&gt;[6,2]-&gt;[6]<br>队的最大函数时的辅助队列：       [6,2]      -&gt;[6,2]     -&gt;[6,2]  -&gt;[6,2]-&gt;[2]</p><ul><li>(若出队和辅助队的元素相同-删除)<br>最大值为：                    [6]        -&gt;[6]       -&gt;[6]    -&gt;[6]  -&gt;[2]</li></ul><p>还有一点不同的是：在未形成窗口时是不需要“出队操作”的</p><ol><li>未形成窗口时：相当于一直为进队的操作。并保障其单调.</li><li>形成窗口后：相当于进队和出队操作同时进行。需要用到双端队列。——能使得leftpop为O(1)<ul><li>在向右移动一次后，相当于最右边值入队，使新队列满足单调。</li><li>如果在移动一次后的最左边-1值等于队列的最大的值，则将其删除</li></ul></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 当窗口未形成的时候：将nums的元素加入双端队列中，并保证其单调（增减都可，只不过后面处理一个头一个尾而已，我这里取递减）</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> k &gt; n:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        dq = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> dq[-<span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                dq.pop()</span><br><span class="line">            dq.append(nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 此时窗口形成。因为加了k个数字到dq了</span></span><br><span class="line">        res.append(dq[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 窗口形成以后相当于队列的入队和出队同时进行了。需要进行两步</span></span><br><span class="line">        <span class="comment"># 1.移动以后的窗口的最左边值若等于dp[0]，则dp[0]需删除</span></span><br><span class="line">        <span class="comment"># 2.入队的元素与dp保证递减</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i-k] == dq[<span class="number">0</span>]:</span><br><span class="line">                dq.popleft()</span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> dq[-<span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                dq.pop()</span><br><span class="line">            dq.append(nums[i])</span><br><span class="line">            res.append(dq[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;div style=&quot;color: red;&quot;&gt;
    给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="双指针" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="双端队列" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="单调队列" scheme="https://xxren8218.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="辅助队列" scheme="https://xxren8218.github.io/tags/%E8%BE%85%E5%8A%A9%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>贝叶斯实战-新闻分类</title>
    <link href="https://xxren8218.github.io/20210511/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9E%E6%88%98-%E6%96%B0%E9%97%BB%E5%88%86%E7%B1%BB.html"/>
    <id>https://xxren8218.github.io/20210511/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9E%E6%88%98-%E6%96%B0%E9%97%BB%E5%88%86%E7%B1%BB.html</id>
    <published>2021-05-11T06:25:35.000Z</published>
    <updated>2021-05-11T10:39:40.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文本分析——新闻分类"><a href="#文本分析——新闻分类" class="headerlink" title="文本分析——新闻分类"></a>文本分析——新闻分类</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="comment"># pip install jieba</span></span><br></pre></td></tr></table></figure><h3 id="数据来源：http-www-sogou-com-labs-resource-ca-php"><a href="#数据来源：http-www-sogou-com-labs-resource-ca-php" class="headerlink" title="数据来源：http://www.sogou.com/labs/resource/ca.php"></a>数据来源：<a href="http://www.sogou.com/labs/resource/ca.php">http://www.sogou.com/labs/resource/ca.php</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_news = pd.read_table(<span class="string">&#x27;./data/val.txt&#x27;</span>,names=[<span class="string">&#x27;category&#x27;</span>,<span class="string">&#x27;theme&#x27;</span>,<span class="string">&#x27;URL&#x27;</span>,<span class="string">&#x27;content&#x27;</span>],encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># 涉及中文，用encoding</span></span><br><span class="line">df_news = df_news.dropna() <span class="comment"># 缺失值直接drop掉</span></span><br><span class="line">df_news.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>category</th>      <th>theme</th>      <th>URL</th>      <th>content</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>汽车</td>      <td>新辉腾　４．２　Ｖ８　４座加长Ｉｎｄｉｖｉｄｕａｌ版２０１１款　最新报价</td>      <td>http://auto.data.people.com.cn/model_15782/</td>      <td>经销商　电话　试驾／订车Ｕ憬杭州滨江区江陵路１７８０号４００８－１１２２３３转５８６４＃保常...</td>    </tr>    <tr>      <th>1</th>      <td>汽车</td>      <td>９１８　Ｓｐｙｄｅｒ概念车</td>      <td>http://auto.data.people.com.cn/prdview_165423....</td>      <td>呼叫热线　４００８－１００－３００　服务邮箱　ｋｆ＠ｐｅｏｐｌｅｄａｉｌｙ．ｃｏｍ．ｃｎ</td>    </tr>    <tr>      <th>2</th>      <td>汽车</td>      <td>日内瓦亮相　ＭＩＮＩ性能版／概念车－１．６Ｔ引擎</td>      <td>http://auto.data.people.com.cn/news/story_5249...</td>      <td>ＭＩＮＩ品牌在二月曾经公布了最新的ＭＩＮＩ新概念车Ｃｌｕｂｖａｎ效果图，不过现在在日内瓦车展...</td>    </tr>    <tr>      <th>3</th>      <td>汽车</td>      <td>清仓大甩卖一汽夏利Ｎ５威志Ｖ２低至３．３９万</td>      <td>http://auto.data.people.com.cn/news/story_6144...</td>      <td>清仓大甩卖！一汽夏利Ｎ５、威志Ｖ２低至３．３９万＝日，启新中国一汽强势推出一汽夏利Ｎ５、威志...</td>    </tr>    <tr>      <th>4</th>      <td>汽车</td>      <td>大众敞篷家族新成员　高尔夫敞篷版实拍</td>      <td>http://auto.data.people.com.cn/news/story_5686...</td>      <td>在今年３月的日内瓦车展上，我们见到了高尔夫家族的新成员，高尔夫敞篷版，这款全新敞篷车受到了众...</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_news.shape</span><br></pre></td></tr></table></figure><pre><code>(5000, 4)</code></pre><h3 id="分词：使用结吧分词器"><a href="#分词：使用结吧分词器" class="headerlink" title="分词：使用结吧分词器"></a>分词：使用结吧分词器</h3><p><strong> 结巴分词器需要转换成list的格式 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content = df_news.content.values.tolist()</span><br><span class="line"><span class="built_in">print</span> (content[<span class="number">1000</span>])</span><br></pre></td></tr></table></figure><div style="overflow: scroll;">      阿里巴巴集团昨日宣布，将在集团管理层面设立首席数据官岗位（Ｃｈｉｅｆ　Ｄａｔａ　Ｏｆｆｉｃｅｒ），阿里巴巴Ｂ２Ｂ公司ＣＥＯ陆兆禧将会出任上述职务，向集团ＣＥＯ马云直接汇报。＞菹ぃ和６月初的首席风险官职务任命相同，首席数据官亦为阿里巴巴集团在完成与雅虎股权谈判，推进“ｏｎｅ　ｃｏｍｐａｎｙ”目标后，在集团决策层面新增的管理岗位。０⒗锛团昨日表示，“变成一家真正意义上的数据公司”已是战略共识。记者刘夏</div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">content_S = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">    current_segment = jieba.lcut(line)  <span class="comment"># lcut可以进行分词</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(current_segment) &gt; <span class="number">1</span> <span class="keyword">and</span> current_segment != <span class="string">&#x27;\r\n&#x27;</span>: <span class="comment"># \n换行符,\r回车符号</span></span><br><span class="line">        content_S.append(current_segment)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content_S[<span class="number">1000</span>]</span><br></pre></td></tr></table></figure><pre><code>[&#39;阿里巴巴&#39;, &#39;集团&#39;, &#39;昨日&#39;, &#39;宣布&#39;, &#39;，&#39;, &#39;将&#39;, &#39;在&#39;, &#39;集团&#39;, &#39;管理&#39;, &#39;层面&#39;, &#39;设立&#39;, &#39;首席&#39;, &#39;数据&#39;, &#39;官&#39;, &#39;岗位&#39;, &#39;（&#39;, &#39;Ｃ&#39;, &#39;ｈ&#39;, &#39;ｉ&#39;, &#39;ｅ&#39;, &#39;ｆ&#39;, &#39;\u3000&#39;, &#39;Ｄ&#39;, &#39;ａ&#39;, &#39;ｔ&#39;, &#39;ａ&#39;, &#39;\u3000&#39;, &#39;Ｏ&#39;, &#39;ｆ&#39;, &#39;ｆ&#39;, &#39;ｉ&#39;, &#39;ｃ&#39;, &#39;ｅ&#39;, &#39;ｒ&#39;, &#39;）&#39;, &#39;，&#39;, &#39;阿里巴巴&#39;, &#39;Ｂ&#39;, &#39;２&#39;, &#39;Ｂ&#39;, &#39;公司&#39;, &#39;Ｃ&#39;, &#39;Ｅ&#39;, &#39;Ｏ&#39;, &#39;陆兆禧&#39;, &#39;将&#39;, &#39;会&#39;, &#39;出任&#39;, &#39;上述&#39;, &#39;职务&#39;, &#39;，&#39;, &#39;向&#39;, &#39;集团&#39;, &#39;Ｃ&#39;, &#39;Ｅ&#39;, &#39;Ｏ&#39;, &#39;马云&#39;, &#39;直接&#39;, &#39;汇报&#39;, &#39;。&#39;, &#39;＞&#39;, &#39;菹&#39;, &#39;ぃ&#39;, &#39;和&#39;, &#39;６&#39;, &#39;月初&#39;, &#39;的&#39;, &#39;首席&#39;, &#39;风险&#39;, &#39;官&#39;, &#39;职务&#39;, &#39;任命&#39;, &#39;相同&#39;, &#39;，&#39;, &#39;首席&#39;, &#39;数据&#39;, &#39;官亦为&#39;, &#39;阿里巴巴&#39;, &#39;集团&#39;, &#39;在&#39;, &#39;完成&#39;, &#39;与&#39;, &#39;雅虎&#39;, &#39;股权&#39;, &#39;谈判&#39;, &#39;，&#39;, &#39;推进&#39;, &#39;“&#39;, &#39;ｏ&#39;, &#39;ｎ&#39;, &#39;ｅ&#39;, &#39;\u3000&#39;, &#39;ｃ&#39;, &#39;ｏ&#39;, &#39;ｍ&#39;, &#39;ｐ&#39;, &#39;ａ&#39;, &#39;ｎ&#39;, &#39;ｙ&#39;, &#39;”&#39;, &#39;目标&#39;, &#39;后&#39;, &#39;，&#39;, &#39;在&#39;, &#39;集团&#39;, &#39;决策&#39;, &#39;层面&#39;, &#39;新增&#39;, &#39;的&#39;, &#39;管理&#39;, &#39;岗位&#39;, &#39;。&#39;, &#39;０&#39;, &#39;⒗&#39;, &#39;锛&#39;, &#39;团&#39;, &#39;昨日&#39;, &#39;表示&#39;, &#39;，&#39;, &#39;“&#39;, &#39;变成&#39;, &#39;一家&#39;, &#39;真正&#39;, &#39;意义&#39;, &#39;上&#39;, &#39;的&#39;, &#39;数据&#39;, &#39;公司&#39;, &#39;”&#39;, &#39;已&#39;, &#39;是&#39;, &#39;战略&#39;, &#39;共识&#39;, &#39;。&#39;, &#39;记者&#39;, &#39;刘夏&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_content=pd.DataFrame(&#123;<span class="string">&#x27;content_S&#x27;</span>:content_S&#125;) <span class="comment"># DataFrame可以使用键值对的方式来获得下面的数据形式。</span></span><br><span class="line">df_content.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"> <style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>content_S</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>[经销商, 　, 电话, 　, 试驾, ／, 订车, Ｕ, 憬, 杭州, 滨江区, 江陵, ...</td>    </tr>    <tr>      <th>1</th>      <td>[呼叫, 热线, 　, ４, ０, ０, ８, －, １, ０, ０, －, ３, ０, ０...</td>    </tr>    <tr>      <th>2</th>      <td>[Ｍ, Ｉ, Ｎ, Ｉ, 品牌, 在, 二月, 曾经, 公布, 了, 最新, 的, Ｍ, Ｉ...</td>    </tr>    <tr>      <th>3</th>      <td>[清仓, 大, 甩卖, ！, 一汽, 夏利, Ｎ, ５, 、, 威志, Ｖ, ２, 低至, ...</td>    </tr>    <tr>      <th>4</th>      <td>[在, 今年, ３, 月, 的, 日内瓦, 车展, 上, ，, 我们, 见到, 了, 高尔夫...</td>    </tr>  </tbody></table></div><h3 id="进行数据的清洗，去掉停用词。—停用词表，可以网上下载。"><a href="#进行数据的清洗，去掉停用词。—停用词表，可以网上下载。" class="headerlink" title="进行数据的清洗，去掉停用词。—停用词表，可以网上下载。"></a>进行数据的清洗，去掉停用词。—停用词表，可以网上下载。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stopwords=pd.read_csv(<span class="string">&quot;stopwords.txt&quot;</span>,index_col=<span class="literal">False</span>,sep=<span class="string">&quot;\t&quot;</span>,quoting=<span class="number">3</span>,names=[<span class="string">&#x27;stopword&#x27;</span>], encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">stopwords.head(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>stopword</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>!</td>    </tr>    <tr>      <th>1</th>      <td>"</td>    </tr>    <tr>      <th>2</th>      <td>#</td>    </tr>    <tr>      <th>3</th>      <td>$</td>    </tr>    <tr>      <th>4</th>      <td>%</td>    </tr>    <tr>      <th>5</th>      <td>&amp;</td>    </tr>    <tr>      <th>6</th>      <td>'</td>    </tr>    <tr>      <th>7</th>      <td>(</td>    </tr>    <tr>      <th>8</th>      <td>)</td>    </tr>    <tr>      <th>9</th>      <td>*</td>    </tr>    <tr>      <th>10</th>      <td>+</td>    </tr>    <tr>      <th>11</th>      <td>,</td>    </tr>    <tr>      <th>12</th>      <td>-</td>    </tr>    <tr>      <th>13</th>      <td>--</td>    </tr>    <tr>      <th>14</th>      <td>.</td>    </tr>    <tr>      <th>15</th>      <td>..</td>    </tr>    <tr>      <th>16</th>      <td>...</td>    </tr>    <tr>      <th>17</th>      <td>......</td>    </tr>    <tr>      <th>18</th>      <td>...................</td>    </tr>    <tr>      <th>19</th>      <td>./</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop_stopwords</span>(<span class="params">contents,stopwords</span>):</span></span><br><span class="line">    contents_clean = []</span><br><span class="line">    all_words = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> contents:</span><br><span class="line">        line_clean = []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> stopwords:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line_clean.append(word)</span><br><span class="line">            all_words.append(<span class="built_in">str</span>(word)) <span class="comment"># 一会做一个词云。有现成的库，可以轻松实现出来。</span></span><br><span class="line">        contents_clean.append(line_clean)</span><br><span class="line">    <span class="keyword">return</span> contents_clean,all_words</span><br><span class="line">    <span class="comment"># print (contents_clean)</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">contents = df_content.content_S.values.tolist()    </span><br><span class="line">stopwords = stopwords.stopword.values.tolist()</span><br><span class="line">contents_clean,all_words = drop_stopwords(contents,stopwords)</span><br><span class="line"></span><br><span class="line"><span class="comment"># df_content.content_S.isin(stopwords.stopword)</span></span><br><span class="line"><span class="comment"># df_content=df_content[~df_content.content_S.isin(stopwords.stopword)]</span></span><br><span class="line"><span class="comment"># df_content.head()</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_content=pd.DataFrame(&#123;<span class="string">&#x27;contents_clean&#x27;</span>:contents_clean&#125;)</span><br><span class="line">df_content.head() <span class="comment"># 也可以在停用词里面增加字母，将字母去掉。</span></span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>contents_clean</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>[经销商, 电话, 试驾, 订车, Ｕ, 憬, 杭州, 滨江区, 江陵, 路, 号, 转, ...</td>    </tr>    <tr>      <th>1</th>      <td>[呼叫, 热线, 服务, 邮箱, ｋ, ｆ, ｐ, ｅ, ｏ, ｐ, ｌ, ｅ, ｄ, ａ,...</td>    </tr>    <tr>      <th>2</th>      <td>[Ｍ, Ｉ, Ｎ, Ｉ, 品牌, 二月, 公布, 最新, Ｍ, Ｉ, Ｎ, Ｉ, 新, 概念...</td>    </tr>    <tr>      <th>3</th>      <td>[清仓, 甩卖, 一汽, 夏利, Ｎ, 威志, Ｖ, 低至, 万, 启新, 中国, 一汽, ...</td>    </tr>    <tr>      <th>4</th>      <td>[日内瓦, 车展, 见到, 高尔夫, 家族, 新, 成员, 高尔夫, 敞篷版, 款, 全新,...</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_all_words=pd.DataFrame(&#123;<span class="string">&#x27;all_words&#x27;</span>:all_words&#125;)</span><br><span class="line">df_all_words.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>all_words</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>经销商</td>    </tr>    <tr>      <th>1</th>      <td>电话</td>    </tr>    <tr>      <th>2</th>      <td>试驾</td>    </tr>    <tr>      <th>3</th>      <td>订车</td>    </tr>    <tr>      <th>4</th>      <td>Ｕ</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">words_count=df_all_words.groupby(by=[<span class="string">&#x27;all_words&#x27;</span>])[<span class="string">&#x27;all_words&#x27;</span>].agg(&#123;<span class="string">&quot;count&quot;</span>:numpy.size&#125;) <span class="comment"># 先分组再agg求和。</span></span><br><span class="line">words_count=words_count.reset_index().sort_values(by=[<span class="string">&quot;count&quot;</span>],ascending=<span class="literal">False</span>) <span class="comment"># 按值进行排序</span></span><br><span class="line">words_count.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>all_words</th>      <th>count</th>    </tr>  </thead>  <tbody>    <tr>      <th>4077</th>      <td>中</td>      <td>5199</td>    </tr>    <tr>      <th>4209</th>      <td>中国</td>      <td>3115</td>    </tr>    <tr>      <th>88255</th>      <td>说</td>      <td>3055</td>    </tr>    <tr>      <th>104747</th>      <td>Ｓ</td>      <td>2646</td>    </tr>    <tr>      <th>1373</th>      <td>万</td>      <td>2390</td>    </tr>  </tbody></table></div><p><strong> 词云的展示 </strong> ——在github上面直接搜wordcloud就行！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud <span class="comment"># 导入词云</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = (<span class="number">10.0</span>, <span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">wordcloud=WordCloud(font_path=<span class="string">&quot;./data/simhei.ttf&quot;</span>,background_color=<span class="string">&quot;white&quot;</span>,max_font_size=<span class="number">80</span>)</span><br><span class="line">word_frequence = &#123;x[<span class="number">0</span>]:x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> words_count.head(<span class="number">100</span>).values&#125; <span class="comment"># 画前100个词</span></span><br><span class="line">wordcloud=wordcloud.fit_words(word_frequence)</span><br><span class="line">plt.imshow(wordcloud)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x186064c64e0&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210511142559.png" alt=""></p><h3 id="TF-IDF-：提取关键词"><a href="#TF-IDF-：提取关键词" class="headerlink" title="TF-IDF ：提取关键词"></a>TF-IDF ：提取关键词</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.analyse <span class="comment"># jieba和sklearn都可以进行词频的提取</span></span><br><span class="line">index = <span class="number">2400</span></span><br><span class="line"><span class="built_in">print</span> (df_news[<span class="string">&#x27;content&#x27;</span>][index])</span><br><span class="line">content_S_str = <span class="string">&quot;&quot;</span>.join(content_S[index])  <span class="comment"># 将分词完的数据拿出来！</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;  &quot;</span>.join(jieba.analyse.extract_tags(content_S_str, topK=<span class="number">5</span>, withWeight=<span class="literal">False</span>))) <span class="comment"># jieba里面有提取关键词的模块</span></span><br></pre></td></tr></table></figure><div style="overflow: scroll;">    法国ＶＳ西班牙、里贝里ＶＳ哈维，北京时间６月２４日凌晨一场的大战举世瞩目，而这场胜利不仅仅关乎两支顶级强队的命运，同时也是他们背后的球衣赞助商耐克和阿迪达斯之间的一次角逐。Ｔ谌胙”窘炫分薇的１６支球队之中，阿迪达斯和耐克的势力范围也是几乎旗鼓相当：其中有５家球衣由耐克提供，而阿迪达斯则赞助了６家，此外茵宝有３家，而剩下的两家则由彪马赞助。而当比赛进行到现在，率先挺进四强的两支球队分别被耐克支持的葡萄牙和阿迪达斯支持的德国占据，而由于最后一场１／４决赛是茵宝（英格兰）和彪马（意大利）的对决，这也意味着明天凌晨西班牙同法国这场阿迪达斯和耐克在１／４决赛的唯一一次直接交手将直接决定两家体育巨头在此次欧洲杯上的胜负。８据评估，在２０１２年足球商品的销售额能总共超过４０亿欧元，而单单是不足一个月的欧洲杯就有高达５亿的销售额，也就是说在欧洲杯期间将有７００万件球衣被抢购一空。根据市场评估，两大巨头阿迪达斯和耐克的市场占有率也是并驾齐驱，其中前者占据３８％，而后者占据３６％。体育权利顾问奥利弗－米歇尔在接受《队报》采访时说：“欧洲杯是耐克通过法国翻身的一个绝佳机会！”Ｃ仔尔接着谈到两大赞助商的经营策略：“竞技体育的成功会燃起球衣购买的热情，不过即便是水平相当，不同国家之间的欧洲杯效应却存在不同。在德国就很出色，大约１／４的德国人通过电视观看了比赛，而在西班牙效果则差很多，由于民族主义高涨的加泰罗尼亚地区只关注巴萨和巴萨的球衣，他们对西班牙国家队根本没什么兴趣。”因此尽管西班牙接连拿下欧洲杯和世界杯，但是阿迪达斯只为西班牙足协支付每年２６００万的赞助费＃相比之下尽管最近两届大赛表现糟糕法国足协将从耐克手中每年可以得到４０００万欧元。米歇尔解释道：“法国创纪录的４０００万欧元赞助费得益于阿迪达斯和耐克竞逐未来１５年欧洲市场的竞争。耐克需要笼络一个大国来打赢这场欧洲大陆的战争，而尽管德国拿到的赞助费并不太高，但是他们却显然牢牢掌握在民族品牌阿迪达斯手中。从长期投资来看，耐克给法国的赞助并不算过高。”    耐克  阿迪达斯  欧洲杯  球衣  西班牙</div><h3 id="LDA-：主题模型"><a href="#LDA-：主题模型" class="headerlink" title="LDA ：主题模型"></a>LDA ：主题模型</h3><p>格式要求（很重要）：list（分好词的语料） of list（不同的文章）形式，分词好的的整个语料</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gensim <span class="keyword">import</span> corpora, models, similarities</span><br><span class="line"><span class="keyword">import</span> gensim</span><br><span class="line"><span class="comment"># http://radimrehurek.com/gensim/</span></span><br></pre></td></tr></table></figure><pre><code>C:\Anaconda3\lib\site-packages\gensim\utils.py:860: UserWarning: detected Windows; aliasing chunkize to chunkize_serial  warnings.warn(&quot;detected Windows; aliasing chunkize to chunkize_serial&quot;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 做映射，相当于词袋</span></span><br><span class="line">dictionary = corpora.Dictionary(contents_clean)</span><br><span class="line">corpus = [dictionary.doc2bow(sentence) <span class="keyword">for</span> sentence <span class="keyword">in</span> contents_clean]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lda = gensim.models.ldamodel.LdaModel(corpus=corpus, id2word=dictionary, num_topics=<span class="number">20</span>) <span class="comment"># 类似Kmeans自己指定K值。无监督</span></span><br><span class="line">                                                                                        <span class="comment">#    自定义主题数目</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一号分类结果</span></span><br><span class="line"><span class="built_in">print</span> (lda.print_topic(<span class="number">1</span>, topn=<span class="number">5</span>))</span><br></pre></td></tr></table></figure><pre><code>0.007*&quot;中&quot; + 0.006*&quot;说&quot; + 0.004*&quot;观众&quot; + 0.002*&quot;赛区&quot; + 0.002*&quot;岁&quot;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> topic <span class="keyword">in</span> lda.print_topics(num_topics=<span class="number">20</span>, num_words=<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span> (topic[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>0.007*&quot;女人&quot; + 0.006*&quot;男人&quot; + 0.006*&quot;Ｍ&quot; + 0.004*&quot;Ｓ&quot; + 0.004*&quot;说&quot;0.004*&quot;中&quot; + 0.004*&quot;训练&quot; + 0.003*&quot;说&quot; + 0.003*&quot;学校&quot; + 0.002*&quot;研究生&quot;0.006*&quot;戏&quot; + 0.006*&quot;导演&quot; + 0.005*&quot;该剧&quot; + 0.004*&quot;中&quot; + 0.004*&quot;演员&quot;0.007*&quot;中&quot; + 0.006*&quot;说&quot; + 0.004*&quot;观众&quot; + 0.002*&quot;赛区&quot; + 0.002*&quot;岁&quot;0.004*&quot;万&quot; + 0.003*&quot;号&quot; + 0.003*&quot;中&quot; + 0.002*&quot;Ｓ&quot; + 0.002*&quot;Ｒ&quot;0.014*&quot;电影&quot; + 0.009*&quot;导演&quot; + 0.007*&quot;影片&quot; + 0.006*&quot;中国&quot; + 0.005*&quot;中&quot;0.006*&quot;中&quot; + 0.005*&quot;比赛&quot; + 0.004*&quot;说&quot; + 0.003*&quot;撒&quot; + 0.002*&quot;时间&quot;0.006*&quot;赛季&quot; + 0.005*&quot;中&quot; + 0.003*&quot;联赛&quot; + 0.003*&quot;中国&quot; + 0.002*&quot;航母&quot;0.005*&quot;李小璐&quot; + 0.004*&quot;中&quot; + 0.002*&quot;贾乃亮&quot; + 0.002*&quot;Ｗ&quot; + 0.002*&quot;皮肤&quot;0.004*&quot;万&quot; + 0.003*&quot;号&quot; + 0.003*&quot;Ｖ&quot; + 0.003*&quot;Ｔ&quot; + 0.003*&quot;刘涛&quot;0.021*&quot;男人&quot; + 0.008*&quot;女人&quot; + 0.007*&quot;考生&quot; + 0.004*&quot;说&quot; + 0.003*&quot;中&quot;0.005*&quot;中&quot; + 0.005*&quot;食物&quot; + 0.004*&quot;ｉ&quot; + 0.004*&quot;ａ&quot; + 0.004*&quot;吃&quot;0.006*&quot;中&quot; + 0.004*&quot;电影&quot; + 0.004*&quot;说&quot; + 0.002*&quot;中国&quot; + 0.002*&quot;高考&quot;0.007*&quot;中&quot; + 0.006*&quot;孩子&quot; + 0.004*&quot;说&quot; + 0.003*&quot;教育&quot; + 0.003*&quot;中国&quot;0.005*&quot;中&quot; + 0.005*&quot;节目&quot; + 0.004*&quot;说&quot; + 0.004*&quot;表演&quot; + 0.003*&quot;岁&quot;0.007*&quot;电视剧&quot; + 0.004*&quot;中&quot; + 0.003*&quot;说&quot; + 0.003*&quot;飞行&quot; + 0.002*&quot;飞机&quot;0.007*&quot;中&quot; + 0.006*&quot;球队&quot; + 0.005*&quot;选手&quot; + 0.004*&quot;观众&quot; + 0.004*&quot;ｉ&quot;0.005*&quot;中&quot; + 0.005*&quot;天籁&quot; + 0.004*&quot;产品&quot; + 0.004*&quot;肌肤&quot; + 0.003*&quot;职场&quot;0.008*&quot;中国&quot; + 0.008*&quot;饰演&quot; + 0.007*&quot;中&quot; + 0.004*&quot;说&quot; + 0.004*&quot;节目&quot;0.021*&quot;ｅ&quot; + 0.021*&quot;ａ&quot; + 0.016*&quot;ｏ&quot; + 0.013*&quot;ｉ&quot; + 0.013*&quot;ｎ&quot;</code></pre><h3 id="贝叶斯算法进行新闻的分类"><a href="#贝叶斯算法进行新闻的分类" class="headerlink" title="贝叶斯算法进行新闻的分类"></a>贝叶斯算法进行新闻的分类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_train=pd.DataFrame(&#123;<span class="string">&#x27;contents_clean&#x27;</span>:contents_clean,<span class="string">&#x27;label&#x27;</span>:df_news[<span class="string">&#x27;category&#x27;</span>]&#125;)</span><br><span class="line">df_train.tail()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>contents_clean</th>      <th>label</th>    </tr>  </thead>  <tbody>    <tr>      <th>4995</th>      <td>[天气, 炎热, 补水, 变得, 美国, 跑步, 世界, 杂志, 报道, 喝水, 身体, 补...</td>      <td>时尚</td>    </tr>    <tr>      <th>4996</th>      <td>[不想, 说, 话, 刺激, 说, 做, 只能, 走, 离开, 伤心地, 想起, 一句, 话...</td>      <td>时尚</td>    </tr>    <tr>      <th>4997</th>      <td>[岁, 刘晓庆, 最新, 嫩照, Ｏ, 衷, 诘, 牧跸, 庆, 看不出, 岁, 秒杀, 刘...</td>      <td>时尚</td>    </tr>    <tr>      <th>4998</th>      <td>[导语, 做, 爸爸, 一种, 幸福, 无论是, 领养, 亲生, 更何况, 影视剧, 中, ...</td>      <td>时尚</td>    </tr>    <tr>      <th>4999</th>      <td>[全球, 最美, 女人, 合成图, 国, 整形外科, 教授, 李承哲, 国际, 学术, 杂志...</td>      <td>时尚</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_train.label.unique()</span><br></pre></td></tr></table></figure><pre><code>array([&#39;汽车&#39;, &#39;财经&#39;, &#39;科技&#39;, &#39;健康&#39;, &#39;体育&#39;, &#39;教育&#39;, &#39;文化&#39;, &#39;军事&#39;, &#39;娱乐&#39;, &#39;时尚&#39;], dtype=object)</code></pre><p><strong> pandas 容易可以很容易进行打标签 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label_mapping = &#123;<span class="string">&quot;汽车&quot;</span>: <span class="number">1</span>, <span class="string">&quot;财经&quot;</span>: <span class="number">2</span>, <span class="string">&quot;科技&quot;</span>: <span class="number">3</span>, <span class="string">&quot;健康&quot;</span>: <span class="number">4</span>, <span class="string">&quot;体育&quot;</span>:<span class="number">5</span>, <span class="string">&quot;教育&quot;</span>: <span class="number">6</span>,<span class="string">&quot;文化&quot;</span>: <span class="number">7</span>,<span class="string">&quot;军事&quot;</span>: <span class="number">8</span>,<span class="string">&quot;娱乐&quot;</span>: <span class="number">9</span>,<span class="string">&quot;时尚&quot;</span>: <span class="number">0</span>&#125;</span><br><span class="line">df_train[<span class="string">&#x27;label&#x27;</span>] = df_train[<span class="string">&#x27;label&#x27;</span>].<span class="built_in">map</span>(label_mapping) <span class="comment"># label的替换</span></span><br><span class="line">df_train.head()</span><br></pre></td></tr></table></figure><div style="overflow: scroll;"><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>contents_clean</th>      <th>label</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>[经销商, 电话, 试驾, 订车, Ｕ, 憬, 杭州, 滨江区, 江陵, 路, 号, 转, ...</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>[呼叫, 热线, 服务, 邮箱, ｋ, ｆ, ｐ, ｅ, ｏ, ｐ, ｌ, ｅ, ｄ, ａ,...</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>[Ｍ, Ｉ, Ｎ, Ｉ, 品牌, 二月, 公布, 最新, Ｍ, Ｉ, Ｎ, Ｉ, 新, 概念...</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>[清仓, 甩卖, 一汽, 夏利, Ｎ, 威志, Ｖ, 低至, 万, 启新, 中国, 一汽, ...</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>[日内瓦, 车展, 见到, 高尔夫, 家族, 新, 成员, 高尔夫, 敞篷版, 款, 全新,...</td>      <td>1</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(df_train[<span class="string">&#x27;contents_clean&#x27;</span>].values, df_train[<span class="string">&#x27;label&#x27;</span>].values, random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x_train = x_train.flatten()</span></span><br><span class="line">x_train[<span class="number">0</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><pre><code>&#39;上海&#39;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">words = []  </span><br><span class="line"><span class="keyword">for</span> line_index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_train)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># x_train[line_index][word_index] = str(x_train[line_index][word_index])</span></span><br><span class="line">        words.append(<span class="string">&#x27; &#x27;</span>.join(x_train[line_index])) <span class="comment"># python的list往字符串转化</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> (line_index,word_index)</span><br><span class="line">words[<span class="number">0</span>]  <span class="comment"># 格式转换，不是list of list格式（下文的CoountVector的格式）      </span></span><br></pre></td></tr></table></figure><div style="overflow: scroll;">    '中新网 上海 日电 于俊 父亲节 网络 吃 一顿 电影 快餐 微 电影 爸 对不起 我爱你 定于 本月 父亲节 当天 各大 视频 网站 首映 葜 谱 鞣 剑 保慈 障蚣 钦 呓 樯 埽 ⒌ 缬 埃 ǎ 停 椋 悖 颍 铩 妫 椋 恚 称 微型 电影 新 媒体 平台 播放 状态 短时 休闲 状态 观看 完整 策划 系统 制作 体系 支持 显示 较完整 故事情节 电影 微 超短 放映 微 周期 制作 天 数周 微 规模 投资 人民币 几千 数万元 每部 内容 融合 幽默 搞怪 时尚 潮流 人文 言情 公益 教育 商业 定制 主题 单独 成篇 系列 成剧 唇 开播 微 电影 爸 对不起 我爱你 讲述 一对 父子 观念 缺少 沟通 导致 关系 父亲 传统 固执 钟情 传统 生活 方式 儿子 新派 音乐 达 习惯 晚出 早 生活 性格 张扬 叛逆 两种 截然不同 生活 方式 理念 差异 一场 父子 间 拉开序幕 子 失手 打破 父亲 心爱 物品 父亲 赶出 家门 剧情 演绎 父亲节 妹妹 哥哥 化解 父亲 这场 矛盾 映逋坏 嚼 斫 狻 ⒍ 粤 ⒌ 桨容 争执 退让 传统 尴尬 父子 尴尬 情 男人 表达 心中 那份 感恩 一杯 滤挂 咖啡 父亲节 变得 温馨 镁 缬 缮 虾 Ｎ 逄 煳 幕 传播 迪欧 咖啡 联合 出品 出品人 希望 观摩 扪心自问 父亲节 父亲 记得 父亲 生日 哪一天 父亲 爱喝 跨出 家门 那一刻 感觉 一颗 颤动 心 操劳 天下 儿女 父亲节 大声 喊出 父亲 家人 爱 完'</div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(words))</span><br></pre></td></tr></table></figure><pre><code>3750</code></pre><p><strong>CountVectorizer的简要介绍</strong>↓——将词转换成向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line">texts=[<span class="string">&quot;dog cat fish&quot;</span>,<span class="string">&quot;dog cat cat&quot;</span>,<span class="string">&quot;fish bird&quot;</span>, <span class="string">&#x27;bird&#x27;</span>] <span class="comment"># 四篇文章，注意其格式，不是list of list格式</span></span><br><span class="line">cv = CountVectorizer()</span><br><span class="line">cv_fit=cv.fit_transform(texts)</span><br><span class="line"></span><br><span class="line">print(cv.get_feature_names()) <span class="comment"># 获得语料库中不重复的词</span></span><br><span class="line">print(cv_fit.toarray())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(cv_fit.toarray().<span class="built_in">sum</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><pre><code>[&#39;bird&#39;, &#39;cat&#39;, &#39;dog&#39;, &#39;fish&#39;][[0 1 1 1] [0 2 1 0] [1 0 0 1] [1 0 0 0]][2 3 2 2]</code></pre><p>ngram_range=(1,4)可以将特征值进行组合，让向量更复杂，一般2就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line">texts=[<span class="string">&quot;dog cat fish&quot;</span>,<span class="string">&quot;dog cat cat&quot;</span>,<span class="string">&quot;fish bird&quot;</span>, <span class="string">&#x27;bird&#x27;</span>]</span><br><span class="line">cv = CountVectorizer(ngram_range=(<span class="number">1</span>,<span class="number">4</span>))  <span class="comment"># 词可以组合。可以让向量更复杂！</span></span><br><span class="line">cv_fit=cv.fit_transform(texts)</span><br><span class="line"></span><br><span class="line">print(cv.get_feature_names())</span><br><span class="line">print(cv_fit.toarray())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(cv_fit.toarray().<span class="built_in">sum</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><pre><code>[&#39;bird&#39;, &#39;cat&#39;, &#39;cat cat&#39;, &#39;cat fish&#39;, &#39;dog&#39;, &#39;dog cat&#39;, &#39;dog cat cat&#39;, &#39;dog cat fish&#39;, &#39;fish&#39;, &#39;fish bird&#39;][[0 1 0 1 1 1 0 1 1 0] [0 2 1 0 1 1 1 0 0 0] [1 0 0 0 0 0 0 0 1 1] [1 0 0 0 0 0 0 0 0 0]][2 3 1 1 2 2 1 1 2 1]</code></pre><p><strong> 数据准备好后可以开始进行操作了 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"></span><br><span class="line">vec = CountVectorizer(analyzer=<span class="string">&#x27;word&#x27;</span>, max_features=<span class="number">4000</span>,  lowercase = <span class="literal">False</span>)</span><br><span class="line">vec.fit(words) <span class="comment"># fit,以某种规则传化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong> 进行贝叶斯的计算 </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line">classifier = MultinomialNB()</span><br><span class="line">classifier.fit(vec.transform(words), y_train) <span class="comment"># transform,规则训练好，进行转换为向量。为特征</span></span><br></pre></td></tr></table></figure><pre><code>MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test_words = []</span><br><span class="line"><span class="keyword">for</span> line_index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_test)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#x_train[line_index][word_index] = str(x_train[line_index][word_index])</span></span><br><span class="line">        test_words.append(<span class="string">&#x27; &#x27;</span>.join(x_test[line_index]))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">         <span class="built_in">print</span> (line_index,word_index)</span><br><span class="line">test_words[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><div style="overflow: scroll;">     '国家 公务员 考试 申论 应用文 类 试题 实质 一道 集 概括 分析 提出 解决问题 一体 综合性 试题 说 一道 客观 凝练 申发 论述 文章 题目 分析 历年 国考 申论 真题 公文 类 试题 类型 多样 包括 公文 类 事务性 文书 类 题材 从题 干 作答 材料 内容 整合 分析 无需 太 创造性 发挥 纵观 历年 申论 真题 作答 应用文 类 试题 文种 格式 作出 特别 重在 内容 考查 行文 格式 考生 平常心 面对 应用文 类 试题 准确 把握 作答 领会 内在 含义 把握 题材 主旨 材料 结构 轻松 应对 应用文 类 试题 Ｒ 弧 ⒆ 钒 盐 展文 写作 原则 Ｔ 材料 中来 应用文 类 试题 材料 总体 把握 客观 考生 材料 中来 材料 中 把握 材料 准确 理解 题材 主旨 Ｔ 政府 角度 作答 应用文 类 试题 更应 注重 政府 角度 观点 政府 角度 出发 原则 表述 观点 提出 解决 之策 考生 作答 站 政府 人员 角度 看待 提出 解决问题 Ｔ 文体 结构 形式 考查 重点 文体 结构 大部分 评分 关键点 解答 方法 薄 ⒆ ス 丶 词 明 方向 作答 题目 题干 作答 作答 方向 作答 角度 关键 向导 考生 仔细阅读 题干 作答 抓住 关键词 作答 方向 相关 要点 整理 作答 思路 年国考 地市级 真 题为 例 潦惺姓 府 宣传 推进 近海 水域 污染 整治 工作 请 给定 资料 市政府 工作人员 身份 草拟 一份 宣传 纲要 Ｒ 求 保对 宣传 内容 要点 提纲挈领 陈述 玻 体现 政府 精神 全市 各界 关心 支持 污染 整治 工作 通俗易懂 超过 字 肮 丶 词 近海 水域 污染 整治 工作 市政府 工作人员 身份 宣传 纲要 提纲挈领 陈述 体现 政府 精神 全市 各界 关心 支持 污染 整治 工作 通俗易懂 提示 归结 作答 要点 包括 污染 情况 原因 解决 对策 作答 思路 情况 原因 对策 意义 逻辑 顺序 安排 文章 结构 病 ⒋ 缶殖 龇 ⅲ 明 结构 解答 应用文 类 试题 考生 材料 整体 出发 大局 出发 高屋建瓴 把握 材料 主题 思想 事件 起因 解决 对策 阅读文章 构建 文章 结构 直至 快速 解答 场 ⒗ 硭 乘悸 罚明 逻辑 应用文 类 试题 严密 逻辑思维 情况 原因 对策 意义 考生 作答 先 弄清楚 解答 思路 统筹安排 脉络 清晰 逻辑 表达 内容 表述 础 把握 明 详略 考生 仔细阅读 分析 揣摩 应用文 类 试题 内容 答题 时要 详略 得当 主次 分明 安排 内容 增加 文章 层次感 阅卷 老师 阅卷 时能 明白 清晰 一目了然 玻埃 保蹦旯 考 考试 申论 试卷 分为 省级 地市级 两套 试卷 能力 大有 省级 申论 试题 考生 宏观 角度看 注重 深度 广度 考生 深谋远虑 地市级 试题 考生 微观 视角 观察 侧重 考查 解决 能力 考生 贯彻执行 作答 区别对待'</div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.score(vec.transform(test_words), y_test)</span><br></pre></td></tr></table></figure><pre><code>0.80400000000000005</code></pre><h3 id="TF-IDF的到导入计算"><a href="#TF-IDF的到导入计算" class="headerlink" title="TF-IDF的到导入计算"></a>TF-IDF的到导入计算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line">vectorizer = TfidfVectorizer(analyzer=<span class="string">&#x27;word&#x27;</span>, max_features=<span class="number">4000</span>,  lowercase = <span class="literal">False</span>)</span><br><span class="line">vectorizer.fit(words)</span><br></pre></td></tr></table></figure><pre><code>TfidfVectorizer(analyzer=&#39;word&#39;, binary=False, decode_error=&#39;strict&#39;,        dtype=&lt;class &#39;numpy.int64&#39;&gt;, encoding=&#39;utf-8&#39;, input=&#39;content&#39;,        lowercase=False, max_df=1.0, max_features=4000, min_df=1,        ngram_range=(1, 1), norm=&#39;l2&#39;, preprocessor=None, smooth_idf=True,        stop_words=None, strip_accents=None, sublinear_tf=False,        token_pattern=&#39;(?u)\\b\\w\\w+\\b&#39;, tokenizer=None, use_idf=True,        vocabulary=None)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line">classifier = MultinomialNB()</span><br><span class="line">classifier.fit(vectorizer.transform(words), y_train)</span><br></pre></td></tr></table></figure><pre><code>MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.score(vectorizer.transform(test_words), y_test)</span><br></pre></td></tr></table></figure><pre><code>0.81520000000000004</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文本分析——新闻分类&quot;&gt;&lt;a href=&quot;#文本分析——新闻分类&quot; class=&quot;headerlink&quot; title=&quot;文本分析——新闻分类&quot;&gt;&lt;/a&gt;文本分析——新闻分类&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    <category term="机器学习基础实战" scheme="https://xxren8218.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="机器学习基础实战" scheme="https://xxren8218.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（五十四）：字符流中第一个不重复的字符</title>
    <link href="https://xxren8218.github.io/20210511/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.html"/>
    <id>https://xxren8218.github.io/20210511/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%94%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.html</id>
    <published>2021-05-11T06:17:23.000Z</published>
    <updated>2021-05-11T06:21:39.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><pre><code>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。如果当前字符流没有存在出现一次的字符，返回#字符。</code></pre><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><pre><code>可以创建一个列表进行字符的记录。然后按顺序进行遍历列表有count方法可以进行计数。</code></pre><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应char</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>       </span><br><span class="line">        self.s = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span>(<span class="params">self, char</span>):</span></span><br><span class="line">        self.s.append(char)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> self.s.count(i) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&amp;quot;go&amp;q</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="其他" scheme="https://xxren8218.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四十八）：不用加减乘除的加法</title>
    <link href="https://xxren8218.github.io/20210511/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E7%9A%84%E5%8A%A0%E6%B3%95.html"/>
    <id>https://xxren8218.github.io/20210511/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E7%9A%84%E5%8A%A0%E6%B3%95.html</id>
    <published>2021-05-11T06:12:44.000Z</published>
    <updated>2021-05-17T10:10:35.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><pre><code>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</code></pre><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><pre><code>首先看十进制是如何做的： 5+7=12，可以使用三步走：第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以三步走的方式计算二进制值相加： 5-101，7-111第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。第三步：重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</code></pre><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span>(<span class="params">self, num1, num2</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># python2.7的int取值范围为：-2147483648至2147483647</span></span><br><span class="line">        <span class="comment"># 将数字 n &amp; 0xffffffff，得到32位二进制。python的二进制不一样。可以用 ~(num1 ^ 0xffffffff)将负数还原存储形式。。</span></span><br><span class="line">        MAX = <span class="number">0x7fffffff</span></span><br><span class="line">        mask = <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">while</span> num2 != <span class="number">0</span>:</span><br><span class="line">            num1, num2 = (num1 ^ num2), ((num1 &amp; num2) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            num1 = num1 &amp; mask</span><br><span class="line">            num2 = num2 &amp; mask</span><br><span class="line">        <span class="keyword">return</span> num1 <span class="keyword">if</span> num1 &lt;= MAX <span class="keyword">else</span> ~(num1 ^ mask)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 解释</span></span><br><span class="line">```python</span><br><span class="line">print(<span class="built_in">hex</span>(<span class="number">1</span>)) <span class="comment"># = 0x1 补码</span></span><br><span class="line">print(<span class="built_in">hex</span>(-<span class="number">1</span>)) <span class="comment"># = -0x1 负号 + 原码 （ Python 特色，Java 会直接输出补码）</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hex</span>(<span class="number">1</span> &amp; <span class="number">0xffffffff</span>)) <span class="comment"># = 0x1 正数补码</span></span><br><span class="line">print(<span class="built_in">hex</span>(-<span class="number">1</span> &amp; <span class="number">0xffffffff</span>)) <span class="comment"># = 0xffffffff 负数补码</span></span><br><span class="line"></span><br><span class="line">print(-<span class="number">1</span> &amp; <span class="number">0xffffffff</span>) <span class="comment"># = 4294967295 （ Python 将其认为正数）可以用 ~(num1 ^ mask)将负数还原。</span></span><br></pre></td></tr></table></figure><p>```</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
&lt;/code&gt;&lt;/pre&gt;&lt;</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="https://xxren8218.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四十七）：求1+2+3+…+n</title>
    <link href="https://xxren8218.github.io/20210511/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B1%821-2-3-%E2%80%A6-n.html"/>
    <id>https://xxren8218.github.io/20210511/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B1%821-2-3-%E2%80%A6-n.html</id>
    <published>2021-05-11T06:08:14.000Z</published>
    <updated>2021-05-18T09:58:37.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><pre><code>求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</code></pre><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><pre><code>这是一道超级无敌送分题，使用递归即可。</code></pre><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> n = <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            n += self.Sum_Solution(n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure><h2 id="上述代码不对，含有if判断语句"><a href="#上述代码不对，含有if判断语句" class="headerlink" title="上述代码不对，含有if判断语句."></a>上述代码不对，含有if判断语句.</h2><ul><li>可以用逻辑运算符的短路效应</li></ul><p>常见的逻辑运算符有三种，即 “与 &amp; ”，“或 || ”，“非 ! ” ；而其有重要的短路效应，如下所示：<br>if(A &amp;&amp; B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</p><p>if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</p><p>本题需要实现 “当 n = 0 时终止递归” 的需求，可通过短路效应实现。</p><p>n &amp;&amp; sumNums(n - 1) // 当 n = 0 时不成立 ，此时 “短路” ，终止后续递归</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNums</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        n &gt; <span class="number">1</span> <span class="keyword">and</span> self.sumNums(n - <span class="number">1</span>)   <span class="comment"># 用逻辑运算符来避免递归条件if的使用</span></span><br><span class="line">        self.res += n</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="递归" scheme="https://xxren8218.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四十六）：孩子们的游戏（圆圈中最后剩下的数）</title>
    <link href="https://xxren8218.github.io/20210510/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%EF%BC%88%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%EF%BC%89.html"/>
    <id>https://xxren8218.github.io/20210510/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%EF%BC%88%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%EF%BC%89.html</id>
    <published>2021-05-10T12:16:29.000Z</published>
    <updated>2021-05-18T09:50:10.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><pre><code>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</code></pre><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>可以按照题目进行分析:</p><ol><li>先建立一个孩子的列表[0,1,…n-1]共n个孩子</li><li>pop列表的元素（报数到m-1的人出去,这个人记为index），终止条件为列表中只剩一个元素</li><li>然后在循环内嵌套循环来找是第几个人pop出列表。<ul><li>需要一个计数变量count。因为每次进入这个循环的时候，已经有一个人出去了。所以count初始化为0</li><li>count和index同时加一。若index大于人数了,那么需要将其归零 —— 因为是个环，即从第一个人又开始。</li></ul></li></ol><ul><li>注意pop完一个元素（人）后，需要判断是否目前的index是否超出人数，若超出，则需要从第一个同学开始计数。<br>返回列表第一个元素即可。</li></ul><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span>(<span class="params">self, n, m</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        res = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 用来pop()人数</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(res) &gt; <span class="number">1</span>:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 用来判断达到count时,谁来pop</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; m-<span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 来判断越界</span></span><br><span class="line">                <span class="keyword">if</span> index == <span class="built_in">len</span>(res):</span><br><span class="line">                    index = <span class="number">0</span></span><br><span class="line">            res.pop(index)</span><br><span class="line">            <span class="comment"># 弹出后也需要看目前的index有没有越界。</span></span><br><span class="line">            <span class="comment"># 如n个人[0,1,...,n-1]，共n个数字。弹出了n-1,</span></span><br><span class="line">            <span class="comment"># 那么此时为[0,1,2,...n-1]共n-1个数字，那么这个index-&gt;n-1，不存在，应为第一个index-&gt;0</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(res):</span><br><span class="line">                index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="发现在牛客可以执行，但是到力扣超时，采用力扣的数学方法对其进行求解。原理如图所示："><a href="#发现在牛客可以执行，但是到力扣超时，采用力扣的数学方法对其进行求解。原理如图所示：" class="headerlink" title="发现在牛客可以执行，但是到力扣超时，采用力扣的数学方法对其进行求解。原理如图所示："></a>发现在牛客可以执行，但是到力扣超时，采用力扣的数学方法对其进行求解。原理如图所示：</h2><p><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210518174921.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210518174936.PNG" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xxren8218/blogimages/img/20210518174951.PNG" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span>(<span class="params">self, n, m</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            f = (f + m) % i</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数学" scheme="https://xxren8218.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="双指针" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四十五）：扑克牌顺子</title>
    <link href="https://xxren8218.github.io/20210510/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90.html"/>
    <id>https://xxren8218.github.io/20210510/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90.html</id>
    <published>2021-05-10T12:01:26.000Z</published>
    <updated>2021-05-18T09:51:17.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><pre><code>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</code></pre><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><pre><code>这道题可以用另外一种思路解决：无非两种特殊情况需要考虑：    1.因为有四个鬼，所以最多有四个0，遇到0直接跳过    2.若含有重复的数字，那肯定不能成为顺子。可以用python的set()得以解决。    3.要组成顺子，这几张牌的max(max-min)只能是5-1=4（1，2，3，4，5）        若有零，则肯定更小于4了。</code></pre><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        repeat = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> repeat:</span><br><span class="line">                repeat.add(i)  <span class="comment"># 注意为add()方法。</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(repeat) - <span class="built_in">min</span>(repeat) &lt;= <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张)...他随</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="其他" scheme="https://xxren8218.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（四十二）：和为S的两个数字</title>
    <link href="https://xxren8218.github.io/20210508/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.html"/>
    <id>https://xxren8218.github.io/20210508/%E5%89%91%E6%8C%87Offer%EF%BC%88%E5%9B%9B%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.html</id>
    <published>2021-05-08T10:27:38.000Z</published>
    <updated>2021-05-18T10:02:43.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><pre><code>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。输出描述：对应每个测试案例，输出两个数，小的先输出。</code></pre><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><pre><code>对于一个数组，我们可以定义两个指针，一个从左往右遍历（left），另一个从右往左遍历（right）。首先，我们比较第一个数字和最后一个数字的和cursum与给定数字tsum，如果cursum &lt; tsum，那么我们就要加大输入值，所以，left向右移动一位，重复之前的计算；如果cursum &gt; tsum，那么我们就要减小输入值，所以，right向左移动一位，重复之前的计算；如果相等，那么这两个数字就是我们要找的数字，直接输出即可。这么做的好处是，也保证了乘积最小。</code></pre><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span>(<span class="params">self, array, tsum</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(array)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> array[left] + array[right] == tsum:</span><br><span class="line">                res.append(array[left])</span><br><span class="line">                res.append(array[right])</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">elif</span> array[left] + array[right] &lt; tsum:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="可以进行扩展，找出和为目标函数，且乘积最小的组合"><a href="#可以进行扩展，找出和为目标函数，且乘积最小的组合" class="headerlink" title="可以进行扩展，找出和为目标函数，且乘积最小的组合"></a>可以进行扩展，找出和为目标函数，且乘积最小的组合</h1><h1 id="可以扩展，不给你排序。找出和为目标函数，且乘积最小的组合。如何做？"><a href="#可以扩展，不给你排序。找出和为目标函数，且乘积最小的组合。如何做？" class="headerlink" title="可以扩展，不给你排序。找出和为目标函数，且乘积最小的组合。如何做？"></a>可以扩展，不给你排序。找出和为目标函数，且乘积最小的组合。如何做？</h1><pre><code>- 先排序，再同样的套路。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出</summary>
      
    
    
    
    <category term="传统算法" scheme="https://xxren8218.github.io/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://xxren8218.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="双指针" scheme="https://xxren8218.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
