{"meta":{"title":"X.X.Ren","subtitle":"个人博客","description":"自学计算机的经历","author":"任晓雄","url":"https://xxren8218.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-02-28T16:13:27.840Z","updated":"2021-02-28T10:34:55.359Z","comments":false,"path":"/404.html","permalink":"https://xxren8218.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-02-28T16:13:27.852Z","updated":"2021-02-28T10:34:55.360Z","comments":false,"path":"books/index.html","permalink":"https://xxren8218.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-02-28T16:13:27.859Z","updated":"2021-02-28T10:34:55.361Z","comments":false,"path":"categories/index.html","permalink":"https://xxren8218.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-02-28T16:13:27.865Z","updated":"2021-02-28T10:34:55.361Z","comments":true,"path":"links/index.html","permalink":"https://xxren8218.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-02-28T16:13:27.871Z","updated":"2021-02-28T10:34:55.361Z","comments":false,"path":"repository/index.html","permalink":"https://xxren8218.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-28T16:13:27.877Z","updated":"2021-02-28T10:34:55.361Z","comments":false,"path":"tags/index.html","permalink":"https://xxren8218.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-01T16:55:45.748Z","updated":"2019-07-29T13:52:40.000Z","comments":true,"path":"about/502.html","permalink":"https://xxren8218.github.io/about/502.html","excerpt":"","text":"502 Bad Gateway html, body { padding: 0; margin: 0; width: 100%; height: 100%; } .icon { -webkit-user-select: none; user-select: none; display: inline-block; } .icon-offline { content: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABIAQMAAABvIyEEAAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAGxJREFUeF7tyMEJwkAQRuFf5ipMKxYQiJ3Z2nSwrWwBA0+DQZcdxEOueaePp9+dQZFB7GpUcURSVU66yVNFj6LFICatThZB6r/ko/pbRpUgilY0Cbw5sNmb9txGXUKyuH7eV25x39DtJXUNPQGJtWFV+BT/QAAAAABJRU5ErkJggg==\"); position: relative; } .hidden { display: none; } /* Offline page */ .offline .interstitial-wrapper { color: #2b2b2b; font-size: 1em; line-height: 1.55; margin: 0 auto; max-width: 600px; padding-top: 100px; width: 100%; } .offline .runner-container { height: 150px; max-width: 600px; overflow: hidden; position: absolute; top: 35px; width: 44px; } .offline .runner-canvas { height: 150px; max-width: 600px; opacity: 1; overflow: hidden; position: absolute; top: 0; z-index: 2; } .offline .controller { background: rgba(247, 247, 247, .1); height: 100vh; left: 0; position: absolute; top: 0; width: 100vw; z-index: 1; } #offline-resources { display: none; } #message h1 { font-size: 34px; color: #555; margin: 100px 0px 40px 0px; } #message p { color: #555; padding: 5px 0px; line-height: 36px; letter-spacing: 1px; font-size: 18px; } #message p a, p a:hover { color: #777; padding: 0px 8px; } #message p span { color: #777; margin: 0px 8px; padding: 1px 2px; background: #eee; border-radius: 0.3em; } #github { position: absolute; bottom: 0px; font-size: 12px !important; color: #aaa !important; } @media (max-width: 420px) { .suggested-left > #control-buttons, .suggested-right > #control-buttons { float: none; } .snackbar { left: 0; bottom: 0; width: 100%; border-radius: 0; } #message h1 { font-size: 22px; margin: 100px 20px 50px 20px; } #message p { padding: 20px; } } @media (max-height: 350px) { h1 { margin: 0 0 15px; } .icon-offline { margin: 0 0 10px; } .interstitial-wrapper { margin-top: 5%; } .nav-wrapper { margin-top: 30px; } } @media (min-width: 600px) and (max-width: 736px) and (orientation: landscape) { .offline .interstitial-wrapper { margin-left: 0; margin-right: 0; } } @media (min-width: 420px) and (max-width: 736px) and (min-height: 240px) and (max-height: 420px) and (orientation: landscape) { .interstitial-wrapper { margin-bottom: 100px; } } @media (min-height: 240px) and (orientation: landscape) { .offline .interstitial-wrapper { margin-bottom: 90px; } .icon-offline { margin-bottom: 20px; } } @media (max-height: 320px) and (orientation: landscape) { .icon-offline { margin-bottom: 0; } .offline .runner-container { top: 10px; } } @media (max-width: 240px) { .interstitial-wrapper { overflow: inherit; padding: 0 8px; } } eval(function(p,a,c,k,e,r){e=function(c){return(c35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('(j(){j c(a,b){V(c.4B)T c.4B;c.4B=i;i.1V=M.3t(a);i.8X=i.U=1t;i.6r=i.1V.3t(\"#8U-4v\");i.o=b||c.o;i.s=c.4p;i.1A=i.I=i.C=i.K=1t;i.28=i.1Q=i.2y=i.1N=0;i.1g=1F/60;i.1s=i.o.2M;i.1f=[];i.2l=i.2r=i.1a=i.1i=i.2s=!1;i.1M=0;i.2w=1t;i.3N=0;i.8T=1t;i.2j={};i.2K=1t;i.8R={};i.8Q=0;i.4L()?i.4M():i.4X()}j p(a,b){T N.2I(N.2C()*(b-a+1))+a}j z(a){B b=a.W/4*3;a=8P(a);B c=F 8M(b);c=F 8L(c);Y(B e=0;ei.s.A?(a=b*i.s.A/3A*i.o.6v,i.1s=a>b?b:a):a&&(i.1s=a)},1c:j(){M.3t(\".\"+c.1h.4V).1n.7b=\"5A\";i.43();i.3a();i.U=M.2D(\"48\");i.U.3s=c.1h.4P;B a=i.U,b=i.s.A,f=i.s.J,e=c.1h.7a,d=M.2D(\"K\");d.3s=e?c.1h.4d+\" \"+e:c.1h.4d;d.D=b;d.S=f;a.2A(d);i.K=d;i.C=i.K.1D(\"2d\");i.C.79=\"#77\";i.C.76();c.4a(i.K);i.2g=F u(i.K,i.2h,i.s,i.o.5M);i.1A=F k(i.K,i.2h.37,i.s.A);i.I=F g(i.K,i.2h.3R);i.1V.2A(i.U);r&&i.5I();i.5J();i.G();1k.Z(c.L.5y,i.5L.1v(i))},5I:j(){i.1U=M.2D(\"48\");i.1U.3s=c.1h.58;i.1V.2A(i.1U)},5L:j(){i.2w||(i.2w=74(i.43.1v(i),5O))},43:j(){6Y(i.2w);i.2w=1t;B a=1k.6X(i.1V);a=6O(a.5S.2X(0,a.5S.W-2));i.s.A=i.1V.6N-2*a;i.K&&(i.K.D=i.s.A,i.K.S=i.s.J,c.4a(i.K),i.1A.4e(i.s.A),i.3u(),i.2g.G(0,0,!0),i.I.G(0),i.1i||i.1a||i.2r?(i.U.1n.D=i.s.A+\"1z\",i.U.1n.S=i.s.J+\"1z\",i.1A.G(0,N.2c(i.1N)),i.3l()):i.I.Q(0,0),i.1a&&i.2a&&(i.2a.5Y(i.s.A),i.2a.Q()))},5Z:j(){V(i.2s||i.1a)i.1a&&i.3k();3h{i.1X=!0;i.I.1X=!0;B a=\"@-6L-6J 66 { 6I { D:\"+g.o.A+\"1z }6H { D: \"+i.s.A+\"1z }}\",b=M.2D(\"1n\");b.6G=a;M.6F.2A(b);i.U.Z(c.L.6n,i.6a.1v(i));i.U.1n.6b=\"66 .4s 6D-6C 1 6A\";i.U.1n.D=i.s.A+\"1z\";i.2s=i.1i=!0}},6a:j(){i.28=0;i.1X=!1;i.I.1X=!1;i.U.1n.6b=\"\";i.3N++;M.Z(c.L.4O,i.2N.1v(i));1k.Z(c.L.4Q,i.2N.1v(i));1k.Z(c.L.4S,i.2N.1v(i))},3u:j(){i.C.6y(0,0,i.s.A,i.s.J)},G:j(){i.4u=!1;B a=q(),b=a-(i.1Q||a);i.1Q=a;V(i.1i){i.3u();i.I.1H&&i.I.6i(b);i.28+=b;a=i.28>i.o.5D;1!=i.I.33||i.1X||i.5Z();i.1X?i.2g.G(0,i.1s,a):(b=i.2s?b:0,i.2g.G(b,i.1s,a,i.2l));V(a)a:{B f=i.2g.1f[0],e=i.I;a=F h(e.E+1,e.H+1,e.o.A-2,e.o.J-2);B d=F h(f.E+1,f.H+1,f.R.D*f.1r-2,f.R.S-2);V(y(a,d)){f=f.X;e=e.1u?g.X.1J:g.X.1I;Y(B w=0;w"},{"title":"关于","date":"2021-03-01T17:05:48.632Z","updated":"2021-03-01T17:05:48.632Z","comments":false,"path":"about/index.html","permalink":"https://xxren8218.github.io/about/index.html","excerpt":"","text":"个人简介： game html, body { padding: 0; margin: 0; width: 100%; height: 100%; } .icon { -webkit-user-select: none; user-select: none; display: inline-block; } .icon-offline { content: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABIAQMAAABvIyEEAAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAGxJREFUeF7tyMEJwkAQRuFf5ipMKxYQiJ3Z2nSwrWwBA0+DQZcdxEOueaePp9+dQZFB7GpUcURSVU66yVNFj6LFICatThZB6r/ko/pbRpUgilY0Cbw5sNmb9txGXUKyuH7eV25x39DtJXUNPQGJtWFV+BT/QAAAAABJRU5ErkJggg==\"); position: relative; } .hidden { display: none; } /* Offline page */ .offline .interstitial-wrapper { color: #2b2b2b; font-size: 1em; line-height: 1.55; margin: 0 auto; max-width: 600px; padding-top: 100px; width: 100%; } .offline .runner-container { height: 150px; max-width: 600px; overflow: hidden; position: absolute; top: 35px; width: 44px; } .offline .runner-canvas { height: 150px; max-width: 600px; opacity: 1; overflow: hidden; position: absolute; top: 0; z-index: 2; } .offline .controller { background: rgba(247, 247, 247, .1); height: 100vh; left: 0; position: absolute; top: 0; width: 100vw; z-index: 1; } #offline-resources { display: none; } #message h1 { font-size: 34px; color: #555; margin: 100px 0px 40px 0px; } #message p { color: #555; padding: 5px 0px; line-height: 36px; letter-spacing: 1px; font-size: 18px; } #message p a, p a:hover { color: #777; padding: 0px 8px; } #message p span { color: #777; margin: 0px 8px; padding: 1px 2px; background: #eee; border-radius: 0.3em; } #github { position: absolute; bottom: 0px; font-size: 12px !important; color: #aaa !important; } @media (max-width: 420px) { .suggested-left > #control-buttons, .suggested-right > #control-buttons { float: none; } .snackbar { left: 0; bottom: 0; width: 100%; border-radius: 0; } #message h1 { font-size: 22px; margin: 100px 20px 50px 20px; } #message p { padding: 20px; } } @media (max-height: 350px) { h1 { margin: 0 0 15px; } .icon-offline { margin: 0 0 10px; } .interstitial-wrapper { margin-top: 5%; } .nav-wrapper { margin-top: 30px; } } @media (min-width: 600px) and (max-width: 736px) and (orientation: landscape) { .offline .interstitial-wrapper { margin-left: 0; margin-right: 0; } } @media (min-width: 420px) and (max-width: 736px) and (min-height: 240px) and (max-height: 420px) and (orientation: landscape) { .interstitial-wrapper { margin-bottom: 100px; } } @media (min-height: 240px) and (orientation: landscape) { .offline .interstitial-wrapper { margin-bottom: 90px; } .icon-offline { margin-bottom: 20px; } } @media (max-height: 320px) and (orientation: landscape) { .icon-offline { margin-bottom: 0; } .offline .runner-container { top: 10px; } } @media (max-width: 240px) { .interstitial-wrapper { overflow: inherit; padding: 0 8px; } } eval(function(p,a,c,k,e,r){e=function(c){return(c35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('(j(){j c(a,b){V(c.4B)T c.4B;c.4B=i;i.1V=M.3t(a);i.8X=i.U=1t;i.6r=i.1V.3t(\"#8U-4v\");i.o=b||c.o;i.s=c.4p;i.1A=i.I=i.C=i.K=1t;i.28=i.1Q=i.2y=i.1N=0;i.1g=1F/60;i.1s=i.o.2M;i.1f=[];i.2l=i.2r=i.1a=i.1i=i.2s=!1;i.1M=0;i.2w=1t;i.3N=0;i.8T=1t;i.2j={};i.2K=1t;i.8R={};i.8Q=0;i.4L()?i.4M():i.4X()}j p(a,b){T N.2I(N.2C()*(b-a+1))+a}j z(a){B b=a.W/4*3;a=8P(a);B c=F 8M(b);c=F 8L(c);Y(B e=0;ei.s.A?(a=b*i.s.A/3A*i.o.6v,i.1s=a>b?b:a):a&&(i.1s=a)},1c:j(){M.3t(\".\"+c.1h.4V).1n.7b=\"5A\";i.43();i.3a();i.U=M.2D(\"48\");i.U.3s=c.1h.4P;B a=i.U,b=i.s.A,f=i.s.J,e=c.1h.7a,d=M.2D(\"K\");d.3s=e?c.1h.4d+\" \"+e:c.1h.4d;d.D=b;d.S=f;a.2A(d);i.K=d;i.C=i.K.1D(\"2d\");i.C.79=\"#77\";i.C.76();c.4a(i.K);i.2g=F u(i.K,i.2h,i.s,i.o.5M);i.1A=F k(i.K,i.2h.37,i.s.A);i.I=F g(i.K,i.2h.3R);i.1V.2A(i.U);r&&i.5I();i.5J();i.G();1k.Z(c.L.5y,i.5L.1v(i))},5I:j(){i.1U=M.2D(\"48\");i.1U.3s=c.1h.58;i.1V.2A(i.1U)},5L:j(){i.2w||(i.2w=74(i.43.1v(i),5O))},43:j(){6Y(i.2w);i.2w=1t;B a=1k.6X(i.1V);a=6O(a.5S.2X(0,a.5S.W-2));i.s.A=i.1V.6N-2*a;i.K&&(i.K.D=i.s.A,i.K.S=i.s.J,c.4a(i.K),i.1A.4e(i.s.A),i.3u(),i.2g.G(0,0,!0),i.I.G(0),i.1i||i.1a||i.2r?(i.U.1n.D=i.s.A+\"1z\",i.U.1n.S=i.s.J+\"1z\",i.1A.G(0,N.2c(i.1N)),i.3l()):i.I.Q(0,0),i.1a&&i.2a&&(i.2a.5Y(i.s.A),i.2a.Q()))},5Z:j(){V(i.2s||i.1a)i.1a&&i.3k();3h{i.1X=!0;i.I.1X=!0;B a=\"@-6L-6J 66 { 6I { D:\"+g.o.A+\"1z }6H { D: \"+i.s.A+\"1z }}\",b=M.2D(\"1n\");b.6G=a;M.6F.2A(b);i.U.Z(c.L.6n,i.6a.1v(i));i.U.1n.6b=\"66 .4s 6D-6C 1 6A\";i.U.1n.D=i.s.A+\"1z\";i.2s=i.1i=!0}},6a:j(){i.28=0;i.1X=!1;i.I.1X=!1;i.U.1n.6b=\"\";i.3N++;M.Z(c.L.4O,i.2N.1v(i));1k.Z(c.L.4Q,i.2N.1v(i));1k.Z(c.L.4S,i.2N.1v(i))},3u:j(){i.C.6y(0,0,i.s.A,i.s.J)},G:j(){i.4u=!1;B a=q(),b=a-(i.1Q||a);i.1Q=a;V(i.1i){i.3u();i.I.1H&&i.I.6i(b);i.28+=b;a=i.28>i.o.5D;1!=i.I.33||i.1X||i.5Z();i.1X?i.2g.G(0,i.1s,a):(b=i.2s?b:0,i.2g.G(b,i.1s,a,i.2l));V(a)a:{B f=i.2g.1f[0],e=i.I;a=F h(e.E+1,e.H+1,e.o.A-2,e.o.J-2);B d=F h(f.E+1,f.H+1,f.R.D*f.1r-2,f.R.S-2);V(y(a,d)){f=f.X;e=e.1u?g.X.1J:g.X.1I;Y(B w=0;w"}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-03-01T12:38:51.462Z","updated":"2021-03-01T12:38:51.462Z","comments":true,"path":"2021/03/01/hello-world/","link":"","permalink":"https://xxren8218.github.io/2021/03/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo server More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"个人博客搭建教程","slug":"搭建博客的缘由","date":"2021-02-28T17:07:56.037Z","updated":"2021-02-28T17:07:56.037Z","comments":true,"path":"2021/03/01/搭建博客的缘由/","link":"","permalink":"https://xxren8218.github.io/2021/03/01/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BC%98%E7%94%B1/","excerpt":"","text":"","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://xxren8218.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://xxren8218.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"Linux下shell脚本编程学习","slug":"learning-linux-shell-script","date":"2020-11-27T06:19:03.000Z","updated":"2020-12-09T11:14:50.000Z","comments":true,"path":"2020/11/27/learning-linux-shell-script/","link":"","permalink":"https://xxren8218.github.io/2020/11/27/learning-linux-shell-script/","excerpt":"摘要：从11月27日到12月9日，大概花了一个星期的时间，终于啃完了621页的《Linux命令行与shell脚本编程大全》。","text":"摘要：从11月27日到12月9日，大概花了一个星期的时间，终于啃完了621页的《Linux命令行与shell脚本编程大全》。 文章说明文章作者：鴻塵文章说明：学习shell过程中的记录，参考书籍主要有《Linux命令行与shell脚本编程大全（第3版）》，《鸟哥的Linux私房菜（第三版）》系列和《快乐的 Linux 命令行》，参考资料主要有Linux命令大全等。文章链接：https://hwame.top/20201127/learning-linux-shell-script.html 1.构建基本脚本1.1.创建shell脚本文件创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：1#!/bin/bash 4.处理用户输入4.1.命令行参数注意：利用$0读取脚本名时存在一个潜在的问题，即$0参数会同时包含路径和连在一起的命令，如下表所示。解决这个问题只需要使用basename命令，他会返回不包含路径的脚本名：basename $0，例如script=$(basename $0)。 执行命令 $0变量 备注 bash mz.sh mz.sh 没有问题 ./mz.sh ./mz.sh 包含命令 bash /home/hwame/mz.sh /home/hwame/mz.sh 包含路径 在shell脚本中使用命令行参数时要小心些。当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。通俗的说，当脚本中使用了变量$1、$2、$3时，如果允许脚本时没有给出对应的命令行参数则会报错。 因此在使用参数前一定要检查其中是否存在数据，一种方法是使用-n测试来检查命令行参数$1中是否有数据：if [ -n &quot;$1&quot;]; then。 12345#!/bin/bash# Grabbing the last parameterparams=$#echo The last parameter is $paramsecho The last parameter is $&#123;!#&#125; 上述示例中的两种方式都没问题。但要注意，当命令行上没有任何参数时，$#的值为0，params变量的值也一样，但$&#123;!#&#125;变量会返回命令行用到的脚本名。 123456789101112131415#!/bin/bashcount=1for param in &quot;$*&quot;do echo &quot;\\$* Parameter #$count = $param&quot; count=$[ $count + 1 ]doneechocount=1for param in &quot;$@&quot;do echo &quot;\\$@ Parameter #$count = $param&quot; count=$[ $count + 1 ]done 运行结果如图： 4.3.移动变量bash shell的shift命令能够用来操作命令行参数。顾名思义，他会根据它们的相对位置来移动命令行参数。默认情况下它会将每个参数变量向左移动一个位置。所以，变量$3的值会移到$2中，变量$2的值会移到$1中，而变量$1的值则会被删除（注意，变量$0的值即程序名不会改变）。也可以一次性移动多个位置，只需要给shift命令提供一个参数指明要移动的位置数就行了：shift n。注意：如果某个参数被移出，它的值就被丢弃了，无法再恢复。 这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数，例如：1234567#!/bin/bashcount=1while [ -n &quot;$1&quot; ]; do echo &quot;Parameter #$count = $1&quot; count=$[ $count + 1 ] shiftdone运行结果如图所示： 4.4.处理选项「选项」是跟在单破折线后面的单个字母，它能改变命令的行为，此处介绍3种在脚本中处理选项的方法。 (1)查找选项表面上看，命令行选项也没什么特殊的。在命令行上，它们紧跟在脚本名之后，就跟命令行参数一样。实际上，如果愿意，你可以像处理命令行参数一样处理命令行选项。 ①处理简单选项：可以用shift命令来处理脚本程序携带的命令行选项，用case语句来判断某个参数是否为选项。case语句会检查每个参数是不是有效选项，如果是就运行对应语句中的命令。不管选项按什么顺序出现在命令行上，这种方法都适用。示例如下：1234567891011#!/bin/bash# extracting command line options as parameterswhile [ -n &quot;$1&quot; ]; do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; ;; -b) echo &quot;Found the -b option&quot; ;; -c) echo &quot;Found the -c option&quot; ;; *) echo &quot;$1 is not an option&quot; ;; esac shiftdone ②分离参数和选项：对于在shell脚本中同时使用选项和参数的情况，标准方式是用特殊字符（双破折线--）来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。shell会用双破折线来表明选项列表结束。在双破折线之后，脚本就可以放心地将剩下的命令行参数当作参数，而不是选项来处理了。要检查双破折线，只要在case语句中加一项就行了，如下例所示：12345678910111213141516171819#!/bin/bash# extracting options and parameterswhile [ -n &quot;$1&quot; ]; do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; ;; -b) echo &quot;Found the -b option&quot; ;; -c) echo &quot;Found the -c option&quot; ;; --) shift break ;; *) echo &quot;$1 is not an option&quot; ;; esac shiftdonecount=1for param in $@; do echo &quot;Parameter #$count: $param&quot; count=$[ $count + 1 ]done 运行结果如图，可以看出，第一次未分离时脚本认为所有的命令行参数都是选项；第二次使用--分离后，当脚本遇到双破折线时，它会停止处理选项，并将剩下的参数都当作命令行参数。 ③处理带值的选项：有些选项会带上一个额外的参数值，例如：./mz.sh -a test1 -b -c -d test2。当命令行选项要求额外的参数时，脚本必须能检测到并正确处理，如下例：123456789101112131415161718192021#!/bin/bash# extracting command line options and valueswhile [ -n &quot;$1&quot; ]; do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot;;; -b) param=&quot;$2&quot; echo &quot;Found the -b option, with parameter value $param&quot; shift ;; -c) echo &quot;Found the -c option&quot;;; --) shift break ;; *) echo &quot;$1 is not an option&quot;;; esac shiftdonecount=1for param in &quot;$@&quot;; do echo &quot;Parameter #$count: $param&quot; count=$[ $count + 1 ]done 在这个例子中，case语句定义了三个它要处理的选项，其中-b选项还需要一个额外的参数值。由于要处理的参数是$1，额外的参数值就应该位于$2（因为所有的参数在处理完之后都会被移出）。只要将参数值从$2变量中提取出来就可以了。当然，因为这个选项占用了两个参数位，所以你还需要使用shift命令多移动一个位置。运行结果如图： 该方法会将原始脚本的命令行参数传给getopt命令，之后再将getopt命令的输出传给set命令，用getopt格式化后的命令行参数来替换原始的命令行参数，格式看起来如下所示：set -- $(getopt -q ab:cd &quot;$@&quot;)。现在原始的命令行参数变量的值会被getopt命令的输出替换，而getopt已经为我们格式化好了命令行参数。利用该方法就可以写出能帮我们处理命令行参数的脚本：123456789101112131415161718192021#!/bin/bashset -- $(getopt -q ab:cd &quot;$@&quot;)while [ -n &quot;$1&quot; ]; do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; ;; -b) param=&quot;$2&quot; echo &quot;Found the -b option, with parameter value $param&quot; shift ;; -c) echo &quot;Found the -c option&quot; ;; --) shift break ;; *) echo &quot;$1 is not an option&quot;;; esac shiftdonecount=1for param in &quot;$@&quot;; do echo &quot;Parameter #$count: $param&quot; count=$[ $count + 1 ]done注意到该例和上文查找选项中第三种情况「处理带值的选项」一样，唯一不同的是加入了getopt命令来帮助格式化命令行参数。并且可以运行带有复杂选项的脚本如合并的选项：./mz.sh -ac，同时之前的功能照样没有问题。 1234567891011#!/bin/bash# simple demonstration of the getopts commandwhile getopts :ab:c optdo case &quot;$opt&quot; in a) echo &quot;Found the -a option&quot; ;; b) echo &quot;Found the -b option, with value $OPTARG&quot;;; c) echo &quot;Found the -c option&quot; ;; *) echo &quot;Unknown option: $opt&quot;;; esacdone while语句定义了getopts命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（opt）。注意到在本例中case语句的用法有些不同：getopts命令解析命令行选项时会移除开头的单破折线，所以在case定义中不用单破折线。getopts命令有几个好用的功能：①可以在参数值中包含空格；②可以将选项字母和参数值放在一起使用，而不用加空格，getopts命令能够从选项中正确解析出参数值；③可以将命令行上所有未定义的选项统一输出成问号，以问号形式发送给代码。上述代码运行结果如图： getopts命令知道何时停止处理选项，并将参数留给你处理。在getopts处理每个选项时，它会将OPTIND环境变量值增一。在getopts完成处理时，你可以使用shift命令和OPTIND值来移动参数。如下例：12345678910111213141516171819#!/bin/bashwhile getopts :ab:cd optdo case &quot;$opt&quot; in a) echo &quot;Found the -a option&quot; ;; b) echo &quot;Found the -b option, with value $OPTARG&quot; ;; c) echo &quot;Found the -c option&quot; ;; d) echo &quot;Found the -d option&quot; ;; *) echo &quot;Unknown option: $opt&quot; ;; esacdoneshift $[ $OPTIND - 1 ]count=1for param in &quot;$@&quot;do echo &quot;Parameter $count: $param&quot; count=$[ $count + 1 ]done运行结果如图： 4.5.将选项标准化所谓选项标准化，就是尽量遵循某些字母选项在Linux世界里已经拥有的某种程度的标准含义，而不是随意决定用哪些字母选项以及它们的用法，将选项标准化使得脚本看起来能更友好一些。常用的Linux命令选项如下： 选项 含义 描述 -a all 显示所有对象 -c count 生成一个计数 -d directory 指定一个目录 -e extend 扩展一个对象 -f file 指定读入数据的文件 -h help 显示命令的帮助信息 -i ignorecase 忽略文本大小写 -l long 产生输出的长格式版本 -n non-interactive 使用非交互模式（批处理） -o output redirect 将所有输出重定向到指定的输出文件 -q-s quietsilent 以安静模式运行 -r recursive 递归地处理目录和文件 -v verbose 生成详细输出 -x exclude 排除某个对象 -y yes 对所有问题回答yes 4.6.获得用户输入尽管命令行选项和参数是从脚本用户处获得输入的一种重要方式，但有时脚本的交互性还需要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本的人来回答。bash shell为此提供了read命令。 (1)基本的读取read命令从标准输入（键盘）或另一个文件描述符中接受输入，在收到输入后会将数据放进一个指定的变量。例如：1234#!/bin/bashecho -n &quot;Enter your name: &quot;read nameecho &quot;Hello $name, welcome to my program. &quot;注意，上例中生成提示的echo命令使用了-n选项。该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。这让脚本看起来更像表单。实际上，read命令包含了-p选项，允许你直接在read命令行指定提示符。例如：1234#!/bin/bashread -p &quot;Please enter your age: &quot; agedays=$[ $age * 365 ]echo &quot;That makes you over $days days old! &quot;read命令也允许指定多个变量，输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量。是不是和Python中的*args和**kwargs有点像呢？也可以在read命令行中不指定变量，这样它收到的任何数据都会放进特殊环境变量REPLY中。REPLY环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用。 (2)超时如果不管是否有数据输入，脚本都必须继续执行，你可以用-t选项来指定一个计时器，他指定了read命令等待输入的秒数。当计时器过期后，read命令会返回一个非零退出状态码，可以使用if-then语句或while循环这种标准的结构化语句来理清所发生的具体情况。 也可以不对输入过程计时，而是让read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。可以将-n选项和值1一起使用，告诉read命令在接受单个字符后退出。只要按下单个字符回答后，read命令就会接受输入并将它传给变量，无需按回车键。12345678910#!/bin/bashread -n1 -p &quot;Do you want to continue [Y/N]? &quot; answercase $answer in Y | y) echo echo &quot;fine, continue on…&quot;;; N | n) echo echo OK, goodbye exit;;esacecho &quot;This is the end of the script&quot;运行结果如图： (3)隐藏方式读取当需要输入类似密码这种需要从脚本用户处得到输入，但又在屏幕上显示输入信息时，可以使用-s选项不回显终端的输入（实际上数据会被显示，只是read命令会将文本颜色设成跟背景色一样）。输入提示符输入的数据不会出现在屏幕上，但会赋给变量，以便在脚本中使用。例如：read -s -p &quot;Enter your password: &quot; password。 (4)从文件中读取可以用read命令来读取文件里的数据，每次调用read命令都会从文件中读取一行文本。当文件中再没有内容时，read命令会退出并返回非零退出状态码。如何将文件中的数据传给read命令呢？最常见的方法是对文件使用cat命令，将结果通过管道直接传给含有read命令的while命令。见下例：12345678#!/bin/bashcount=1cat textfile | while read linedo echo &quot;Line $count: $line&quot; count=$[ $count + 1]doneecho &quot;Finished processing the file&quot;文件textfile内容及运行结果如下： 5.创建函数5.1.基本脚本函数函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用，调用函数（在脚本中使用该代码块）时只要使用所起的函数名就行了。 创建函数的第一种格式是采用关键字function，后跟分配给该代码块的函数名：name属性定义了赋予函数的唯一名称，脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令，在调用该函数时会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。123function name &#123; commands&#125; 创建函数的第二种格式更接近于其他编程语言中定义函数的方式：函数名后的空括号表明正在定义的是一个函数，这种格式的命名规则和之前定义shell脚本函数的格式一样。123name() &#123; commands&#125; 至于使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。 注意①：函数定义不一定非得是shell脚本中首先要做的事，但必须在使用函数之前定义它，否则会收到一条command not found的错误消息。注意②：函数名必须是唯一的，如果你重定义了函数，新定义会覆盖原来函数的定义，这一切不会产生任何错误消息。 5.2.返回值bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码，生成退出状态码有以下3种不同的方法： 默认退出状态码：默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量$?来确定函数的退出状态码。注意：由于函数的默认退出状态码取决于函数体中最后一条命令的退出状态码，因此你无法知道函数中其他命令中是否成功运行，所以这种方法很危险。 使用return命令：使用return命令来退出函数并返回特定的退出状态码，它允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。注意：①函数一结束就取返回值，否则可能会丢失返回值。②退出状态码的范围是0~255，超出则会取余。 使用函数输出：正如可以将命令的输出保存到shell变量中一样，你也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中。见下例：1234567#!/bin/bashfunction myfunc &#123; read -p &quot;Enter a value: &quot; value echo $[ $value * 2 ]&#125;result=$(myfunc)echo &quot;The new value is $result&quot; 注意①：该函数实际上输出了两条消息，read命令输出了一条简短的消息来向用户询问输入值，但bash shell并不将其作为STDOUT输出的一部分，并且忽略掉它。如果你用echo语句生成这条消息来向用户查询，那么它会与输出值一起被读进shell变量中。注意②：这种方法还可以返回浮点值和字符串值，这使它成为一种获取函数返回值的强大方法。上例运行结果如图： 5.3.在函数中使用变量 在函数中使用变量时，你需要注意它们的定义方式以及处理方式——这是shell脚本中常见错误的根源。 向函数传递参数bash shell会将函数当作小型脚本来对待，这意味着你可以像普通脚本那样向函数传递参数。 函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在$0变量中定义，函数命令行上的任何参数都会通过$1、$2等定义。也可以用特殊变量$#来判断传给函数的参数数目。注意①：在脚本中指定函数时，必须将参数和函数放在同一行，例如func1 $value1 10，result=$(func1 $value1 10)；注意②：由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。尽管函数也使用了$1和$2变量，但它们和脚本主体中的$1和$2变量并不相同。要在函数中使用这些值，必须在调用函数时手动将它们传过去。12345678#!/bin/bashfunction myfunc &#123; echo $[ $1 * $2 ]&#125;value1=$(myfunc 10 20)value2=$(myfunc)value3=$(myfunc $1 $2)echo &quot;The result is $valuex&quot;如上例，value1是正常的函数调用方式，将参数和函数放在同一行。如果想让value2以这种方式直接获取命令行参数值将报错：syntax error: operand expected...，原因见上，解决办法就是按value3的方式。尽管在函数的定义和调用时都使用了$1和$2变量，但他们的区别就如同形参和实参。 在函数中处理变量变量的作用域也会经常带来麻烦，作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同，也就是说，对脚本的其他部分而言，它们是隐藏的。 函数使用两种类型的变量：全局变量和局部变量。 全局变量：在shell脚本中任何地方都有效的变量。如果你在脚本的主体部分定义了一个全局变量，那么可以在函数内读取它的值。类似地，如果你在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。默认情况下，在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问。注意：在使用全局变量时，如果变量被修改后新值将依然有效，这有时会产生难以预料的后果。它要求你清清楚楚地知道函数中具体使用了哪些变量，包括那些用来计算非返回值的变量。 局部变量：local关键字保证了变量只局限在该函数中，如果脚本中在该函数之外有同样名字的变量，那么shell将会保持这两个变量的值是分离的。如果要将函数内部使用的任何变量都声明成局部变量，只需要在变量声明的前面加上local关键字：local temp。也可以在变量赋值语句中使用local关键字：local temp=$[ $value + 5 ]。 5.4.数组变量和函数向函数传递数组参数向脚本函数传递数组变量的方法会有点不好理解。将数组变量当作单个参数传递的话，它不会起作用。见下例：1234567891011121314#!/bin/bashfunction testit &#123; echo &quot;The parameters are: $@&quot; thisarray=$1 echo &quot;The received array is $&#123;thisarray[*]&#125;&quot;&#125;myarray=(1 2 3 4 5)echo &quot;The original array is: $&#123;myarray[*]&#125;&quot;testit $myarray# 运行结果如下：# The original array is: 1 2 3 4 5# The parameters are: 1# The received array is 1如你所见，如果将该数组变量作为函数参数，函数只会取数组变量的第一个值。要解决这个问题，必须将该数组变量的值分解成单个值，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量。如下例所示，$myarray变量来保存所有的数组元素，然后将它们都放在函数的命令行上。该函数随后从命令行参数中重建数组变量。在函数内部，数组仍然可以像其他数组一样使用。12345678910111213#!/bin/bashfunction testit &#123; local newarray newarray=($(echo &quot;$@&quot;)) echo &quot;The new array value is: $&#123;newarray[*]&#125;&quot;&#125;myarray=(1 2 3 4 5)echo &quot;The original array is $&#123;myarray[*]&#125;&quot;testit $&#123;myarray[*]&#125;# 运行结果如下：# The original array is 1 2 3 4 5# The new array value is: 1 2 3 4 5下面是一个遍历数组并将所有元素累加的例子：12345678910111213141516#!/bin/bashfunction addarray &#123; local sum=0 local newarray newarray=($(echo &quot;$@&quot;)) for value in $&#123;newarray[*]&#125; do sum=$[ $sum + $value ] done echo $sum&#125;myarray=(1 2 3 4 5)echo &quot;The original array is: $&#123;myarray[*]&#125;&quot;arg1=$(echo $&#123;myarray[*]&#125;)result=$(addarray $arg1)echo &quot;The result is $result&quot;运行结果如图： 从函数返回数组从函数里向shell脚本传回数组变量也用类似的方法：函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。见下例：1234567891011121314151617181920#!/bin/bashfunction returnarray &#123; local oriarray local newarray local elements local i oriarray=($(echo &quot;$@&quot;)) newarray=($(echo &quot;$@&quot;)) elements=$[ $# - 1 ] for (( i = 0; i &lt;= $elements; i++ )) &#123; newarray[$i]=$[ $&#123;oriarray[$i]&#125; * 2 ] &#125; echo $&#123;newarray[*]&#125;&#125;myarray=(1 2 3 4 5)echo &quot;The original array is: $&#123;myarray[*]&#125;&quot;arg1=$(echo $&#123;myarray[*]&#125;)result=($(returnarray $arg1))echo &quot;The new array is: $&#123;result[*]&#125;&quot;该脚本用$arg1变量将数组值传给returnarray函数，函数将该数组重组到新的数组变量中，生成该输出数组变量的一个副本。然后对数据元素进行遍历，将每个元素值翻倍，并将结果存入函数中该数组变量的副本。returnarray函数使用echo语句来输出每个数组元素的值。脚本用returnarray函数的输出来重新生成一个新的数组变量。运行结果如图： 5.5.函数递归局部函数变量的一个特性是自成体系，除了从脚本命令行处获得的变量，自成体系的函数不需要使用任何外部资源。这个特性使得函数可以递归地调用，也就是说，函数可以调用自己来得到结果。通常递归函数都有一个最终可以迭代到的基准值。许多高级数学算法用递归对复杂的方程进行逐级规约，直到基准值定义的那级。递归算法的经典例子是计算阶乘：1234567891011121314#!/bin/bashfunction factorial &#123; if [ $1 -eq 1 ] then echo 1 else local temp=$[ $1 - 1 ] local result=$(factorial $temp) echo $[ $result * $1 ] fi&#125;read -p &quot;Enter value: &quot; valueresult=$(factorial $value)echo &quot;The factorial of $value is: $result&quot;运行结果如下： 5.6.创建库bash shell允许创建函数库文件，然后在多个脚本中引用该库文件。第一步需要创建一个包含脚本中所需函数的公用库文件，例如定义了3个简单的函数的库文件myfuncs。第二步就是在用到这些函数的脚本文件中包含该库文件，但是问题就来了。 和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs的shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。这同样适用于脚本：如果你尝试像普通脚本文件那样运行库文件，函数并不会出现在脚本中。例如运行下例将报错addem: command not found：12345#!/bin/bash./myfuncs# 库文件中的函数addem将两数相加result=$(addem 10 15)echo &quot;The result is $result&quot; 使用函数库的关键在于source命令。 source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。source命令有个快捷的别名.，称作点操作符（dot operator）。要在shell脚本中运行myfuncs库文件，只需添加：. ./myfuncs。如果库文件和shell脚本不是位于同一目录，则需要使用相应路径访问该库文件。 5.7.在命令行上使用函数和在shell脚本中将脚本函数当命令使用一样，在命令行界面的提示符下你也可以直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。重点在于让shell能够识别这些函数，有以下两种方法： 在命令行上创建函数； 在.bashrc文件中定义函数。 对于简单的函数，可以在命令行上直接定义一个函数，因为shell会解释用户输入的命令。如果采用单行方式定义函数，必须在每个命令后面加个分号，这样shell就能知道在哪里是命令的起止了；如果采用多行方式定义函数，则不需要添加分号，只需要回车即可。如图所示：注意：在命令行上创建函数时，如果你给函数起了个跟内建命令或另一个命令相同的名字，函数将会覆盖原来的命令。 在命令行上创建函数不仅输入不便，而且最主要的问题是退出shell时函数就消失了。最简单的解决办法就是将函数定义在.bashrc文件中，bash shell在每次启动时都会在主目录下查找这个文件，不管是交互式shell还是从现有shell中启动的新shell。 直接定义函数，可以直接在主目录下的.bashrc文件中定义函数。许多Linux发行版已经在.bashrc文件中定义了一些东西，所以注意不要误删了，把你写的函数放在文件末尾就行了。 读取函数文件，只要是在shell脚本中，都可以用source命令（或者它的别名.操作符）将库文件中的函数添加到.bashrc脚本中。 shell还会将定义好的函数传给子shell进程，这样一来，这些函数就自动能够用于该shell会话中的任何shell脚本了。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xxren8218.github.io/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://xxren8218.github.io/tags/shell/"}]},{"title":"Nginx配置与uWSGI配置详解","slug":"configuration-of-nginx-and-uwsgi","date":"2020-05-22T00:18:48.000Z","updated":"2020-07-02T09:29:09.000Z","comments":true,"path":"2020/05/22/configuration-of-nginx-and-uwsgi/","link":"","permalink":"https://xxren8218.github.io/2020/05/22/configuration-of-nginx-and-uwsgi/","excerpt":"摘要：文章介绍了Nginx与uWSGI的知识，并依具体的例子对Web应用进行详细配置。","text":"摘要：文章介绍了Nginx与uWSGI的知识，并依具体的例子对Web应用进行详细配置。 文章说明文章作者：鴻塵文章链接：https://hwame.top/20200522/configuration-of-nginx-and-uwsgi.html 一、Nginx配置文件1.指令Nginx配置文件包含指定指令控制的模块，指令分为 简单指令 和 块指令 ，如果块指令大括号内有其他指令，就被称为一个 上下文 ，比如events, http, server, location等。 简单指令：由名称和参数组成，以空格分隔，并以分号结尾；块指令：具有和简单指令相同的结构，以大括号包围的一堆附加指令结束。指令： nginx -t不运行，仅测试配置文件；nginx -c config_path从指定路径加载配置文件；nginx -t -c config_path测试指定配置文件。 2.控制命令启动Nginx：nginx [-c config_path]，默认配置目录为/etc/nginx/nginx.conf。查看信息：nginx -v，查看版本信息；nginx -V，查看详细信息。查看进程：ps -ef | grep nginx，利用管道命令查看进程，ps命令用法参见：【Linux命令大全】控制Nginx：nginx -s signal，参数signal有stop, quit, reload，分别表示快速关闭、优雅关闭、重载配置系统管理：systemctl option nginx，参数option有status, start, stop, enable, disable，分别表示查看状态、启动服务、关闭服务、设置开机自启、禁止开机自启 3.文件详情nginx.conf文件位置：默认位于/etc/nginx/nginx.conf，此乃默认配置文件，服务启动基于该文件。原文内容：12345678910111213141516171819202122232425262728user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker-connections 1024 ; &#125;http &#123; include /etc/nginx/mime.types; default_type appplication/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; &#125; 参数详解： main user：worker进程运行的用户和组 worker_processes：指定开启的子进程数，建议设置为与CPU数相等 error_log：用来定义全局错误日志文件，如原文中路径为/var/log/nginx/error.log，级别level有debug, info, notice, warn, error, crit pid：指定进程ID的存储文件位置 events use：指定Nginx工作模式，①epoll=高效工作模式，Linux，默认，②kqueue=高效工作模式，BSD，③poll=标准模式，④epoll=标准模式 worker_connections：每个进程的最大连接数，其中$正向代理=连接数×进程数$，$反向代理=\\frac{1}{4}\\times\\text{连接数}\\times\\text{进程数}$【Linux系统限制最多能同时打开$65535=2^{16}$个文件，亦即默认上限，能以ulimit -n 65535解除】 http最核心的模块，主要负责http服务器相关配置，包含server和upstream子模块，见后文 include：第12行include mime.types设置文件的mime类型为/etc/nginx/mime.types所定义的类型，第27行xxx.config包含其他配置文件（分开规划解耦作用）的server default_type：设置默认类型，当文件类型未知时将使用默认（注：octet-stream=八进制字节流） log_format：设置日志格式 access_log：访问日志，中间为日志路径，最后main为日志格式log_format中的main sendfile：设置高效文件传输模式 keepalive_timeout：设置客户端连接活跃超时 gzip：gzip压缩 核心模块http： upstream子模块，负载均衡，多服务器反向代理 server ip:port weight=1：指定反向代理服务器及分流权重 server子模块，用来指定虚拟主机 listen 80;：指定虚拟主机监听的端口，80端口表示http server_name localhost;：指定ip地址或域名，多个域名以空格分隔 charset utf-8：指定网页的默认编码格式 error_page 500 502 /50x.html;：指定错误页面，见/etc/nginx/conf.d/*.conf即default.conf access_log xxx main;：指定虚拟主机的访问日志存放路径 error_log xxx main;：指定虚拟主机的错误日志存放路径 root xxx;：指定虚拟主机的根目录 index xxx;：指定默认主页 location：核心【server】中的核心【location】，后面主要就是配置这里，支持正则匹配和条件，其主要功能是定位和解析URL、实现动静分离。语法格式：location [modifier] uri &#123;指令 xxx&#125;，可选修饰符modifier表示定位URL的方式：①=，使用精确匹配并且终止搜索②~，区分大小写的正则③~*，不区分大小写的正则④^~，最佳匹配通常用来匹配目录（非正则匹配）；常用指令为alias，alias定义了location的别名（需要在文件系统中能够找到），如果location指定了正则表达式，alias将会应用正则表达式中的捕获，alias替代location中匹配的部分，没有匹配的部分将在文件系统中搜索 default.conf文件位置：位于/etc/nginx/conf.d/nginx.conf，只包含一个server模块。Nginx服务启动时由nginx.conf通过include /etc/nginx/conf.d/*.conf;引用其内容（即server），从而实现解耦。原文内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;host.access.log main; location &#x2F; &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; index index.html index.htm; &#125; #error_page 404 &#x2F;404.html; # redirect server error pages to the static page &#x2F;50x.html # error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http:&#x2F;&#x2F;127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME &#x2F;scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ &#x2F;\\.ht &#123; # deny all; #&#125;&#125; 二、uwsgi配置文件1.命令启动：uwsgi --ini uwsgi.ini，当前目录（项目目录）下新建ini文件停止：uwsgi --stop uwsgi.pid，uWSGI服务器启动后在当前目录自动生成pid文件，无需新建 2.文件详情文件位置：位于[Project_Dir]/uwsgi.ini，此乃用户建立的配置文件，uwsgi服务启动基于该文件。文件内容：123456789101112131415161718192021222324252627[uwsgi]# 用于nginx与uwsgi对接时的uwsgi配置# (1)使用nginx连接时，使用socketsocket &#x3D; ip:port# (2)直接作为web服务器使用(相当于测试，(1)(2)二选一)#http &#x3D; ip:port# (3)配置工程目录，wsgi-file为入口文件，此用于Flaskchdir &#x3D; [Project_Absolute_dir]wsgi-file &#x3D; app.py# routercallable &#x3D; app_flask_instance# (4)配置项目的wsgi目录，相对于工程目录(3)，此用于Django#chdir &#x3D; [Project_Absolute_dir]#wsgi-file &#x3D; Project_name&#x2F;wsgi.py#Note: unlike Flask, wsgi.py generated by Django automaticly# (5)配置进程和线程信息processes &#x3D; 4threads &#x3D; 10enable-threads &#x3D; Truemaster &#x3D; Truepidfile &#x3D; uwsgi.piddaemonize &#x3D; uwsgi.log 三、项目部署1.项目描述项目位置：位于/usr/local/flask_covid/项目文件：主要包括app.py，spider.py，static/css+js/，templates/main.html，以及测试静态路由的文本文件static/mmdd.md。 2.配置准备 将Nginx默认的配置文件/etc/nginx/nginx.conf和/etc/nginx/conf.d/default.conf复制到项目根目录下，default.conf用处不大（只需用到少量内容） 编辑配置文件/usr/local/flask_covid/nginx.conf【若因非root用户修改而出现权限问题，则需修改文件权限】，将default.conf内容去注释后复制到nginx.conf中的include /etc/nginx/conf.d/*.conf;处【由于将default配置转移过来了，所以不需要include语句来引用，删除之】，nginx.conf内容为： 1234567891011121314151617···omit text above···#include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;#Copy &quot;server &#123;...&#125;&quot; from file&#x3D;&quot;default.conf&quot;server &#123; listen 80; server_name localhost; #charset koi8-r; location &#x2F; &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; index index.html index.htm; &#125; location &#x3D; &#x2F;50x.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; &#125; #Copy and replace over. 继续编辑配置文件/usr/local/flask_covid/nginx.conf，文件如上，修改如下： (1)修改字符集：charset utf-8; (2)将root移动到上一级server下，并修改路径为项目的绝对路径：root /usr/local/flask_covid; (3)修改URL静态路由的解析：首先将location / &#123;···&#125;修改为location /static &#123;···&#125;，以便于访问./static静态资源【注：ppt18，当client请求发出请求时，由Nginx直接提供静态资源，由uwsgi通过Nginx提供动态资源，后者才是真正意义上的代理】，然后为其内容设置别名alias [Project_Absolute_dir]/static; (4)由于默认用户为user nginx;时进程master_process = root, worker_process = nginx，为了避免请求静态资源时出现的因权限不够而请求失败的问题，故需修改用户：user root; 此时在项目目录下执行nginx -c /usr/local/flask_covid/nginx.conf启动Nginx服务器，于是可以在浏览器中输入http://ip/static/file_name（不加端口号）访问到静态资源，就如同操作文件夹一样【实测成功，直接下载到了./static/mmdd.md文件，并且./static文件夹下的所有资源皆可访问到】。修改后nginx.conf内容为： 123456789101112131415161718192021222324252627282930313233343536373839user root;worker_processes 1;error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;pid &#x2F;var&#x2F;run&#x2F;nginx.pid;events &#123; worker-connections 1024 ; &#125;http &#123; include &#x2F;etc&#x2F;nginx&#x2F;mime.types; default_type appplication&#x2F;octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; #include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; # ********** VERY IMPORTANT PARAGRAPH ********** #Copy &quot;server &#123;...&#125;&quot; from file&#x3D;&quot;default.conf&quot; server &#123; listen 80; server_name localhost; charset utf-8; root &#x2F;usr&#x2F;local&#x2F;flask_covid; location &#x2F;static &#123; alias &#x2F;usr&#x2F;local&#x2F;flask_covid&#x2F;static; &#125; error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; &#125; #Copy and replace over. &#125; 至此测试成功 3.uWSGI配置 安装uwsgi：pip install uwsgi 工程目录下创建uwsgi.ini配置文件并添加配置信息，见2.2 个性化修改如下： 部署时用(1)，测试时用(2)，ip设置为0.0.0.0保证所有人可以访问，端口号与app.py相同； Flask项目用(3)，Django项目用(4)，配置工程目录chdir为项目完整绝对路径，并与nginx.conf的server → root相同：chdir = /usr/local/flask_covid；wsgi-file为项目启动文件【注：Django项目会自动生成./[Project_Name/wsgi.py]】； 配置进程和线程，其中enable-threads表示线程可用 修改完成后uwsgi.ini内容为： 12345678910111213141516171819202122232425[uwsgi]# 用于nginx与uwsgi对接时的uwsgi配置# (1)使用nginx连接时，使用socketsocket &#x3D; 0.0.0.0:5000# (2)直接作为web服务器使用(相当于测试，部署时与(1)二选一)#http &#x3D; 0.0.0.0:5000# (3)配置工程目录，wsgi-file为入口文件，callable为flask实例，此用于Flaskchdir &#x3D; &#x2F;usr&#x2F;local&#x2F;flask_covidwsgi-file &#x3D; app.py# routercallable &#x3D; app# (4)配置项目的wsgi目录，相对于工程目录(3)，此用于Django#chdir &#x3D; &#x2F;usr&#x2F;local&#x2F;flask_covid#wsgi-file &#x3D; flask_covid&#x2F;wsgi.py#Note: unlike flask, wsgi.py generated by Django automaticly# (5)配置进程和线程信息processes &#x3D; 2threads &#x3D; 4enable-threads &#x3D; Truemaster &#x3D; Truepidfile &#x3D; uwsgi.piddaemonize &#x3D; uwsgi.log 使用uWSGI服务器： 启动：uwsgi --ini uwsgi.ini，不能加sudo 停止：uwsgi --stop uwsgi.pid，uWSGI服务器启动后在当前目录自动生成pid文件，无需新建 测试（打开(2)、关闭(1)）：启动 Nginx和uWSGI服务器，出现[uWSGI] getting INI configuration from /usr/local/flask_covid/uwsgi.ini的信息表明 uWSGI配置成功，此时可以在浏览器中输入http://ip:port（加端口号）访问 部署（打开(1)、关闭(2)）：见3.2 4.Nginx配置 首先停止3.3的测试：uwsgi --stop /usr/local/flask_covid/uwsgi.pid【注：如果无法停止并报错：signal_pidfile()/kill(): No such process [core/uwsgi.c line 1693]，首先利用ps -ef | grep uwsgi查询其进程号，然后将uwsgi.pid文件修改为相应进程号，最后执行停止命令】 部署时，uWSGI与 Nginx的对接依赖于/etc/nginx/uwsgi_params文件，该文件在安装uwsgi时自动生成，其定义了一系列的uwsgi参数 编辑配置文件/usr/local/flask_covid/nginx.conf，在原来配置好了的静态文件下配置首页目录，location定位和解析的URL/就表示首页，然后利用include去对接uwsgi_params文件，uwsgi_pass去关联localhost【因为uWSGI与 服务器同属一个地方】，端口号port必须与3.3uwsgi.ini的socket一致，如下所示： 1234567location &#x2F;static &#123; alias xxx&#x2F;static&#x2F;; &#125;location &#x2F; &#123; include &#x2F;etc&#x2F;nginx&#x2F;uwsgi_params; uwsgi_pass localhost:5000; &#125; 由于修改了Nginx配置，因此需要先关闭服务nginx -s quit，然后重新启动：nginx -c /usr/local/flask_covid/nginx.conf 启动uWSGI服务器：uwsgi --ini /usr/local/flask_covid/uwsgi.ini 此时nginx与uwsgi便对接成功，可以在浏览器中输入http://ip（不加端口号）进行访问【由于location /&#123;...&#125;下面有uwsgi_pass localhost:8000进行转发代理，自动加上port，因此不能加端口号】 四、总结建议不建议改变Nginx默认的配置文件/etc/nginx/nginx.conf的位置，当部署大型项目时，或有多个服务需要同时运行，则将导致配置文件的混乱，且难以使用系统服务管理工具systemctl，建议的做法是针对具体的项目，在/etc/nginx/conf.d/目录下创建具有标识性的独用于本项目的配置文件myproject.conf，便于维护。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xxren8218.github.io/categories/Linux/"}],"tags":[{"name":"Linux部署","slug":"Linux部署","permalink":"https://xxren8218.github.io/tags/Linux%E9%83%A8%E7%BD%B2/"}]}],"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://xxren8218.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"Linux","slug":"Linux","permalink":"https://xxren8218.github.io/categories/Linux/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://xxren8218.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"shell","slug":"shell","permalink":"https://xxren8218.github.io/tags/shell/"},{"name":"Linux部署","slug":"Linux部署","permalink":"https://xxren8218.github.io/tags/Linux%E9%83%A8%E7%BD%B2/"}]}